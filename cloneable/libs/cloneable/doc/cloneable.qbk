[article Cloneable
    [quickbook 1.4]
    [version 0.1]
    [authors [Schladetsch, Christian]]
    [copyright 2009 Christian Schladetsch]
    [purpose /WikiWiki/ Generalised cloning system for hierachical objects]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.4 ]
[/ Sept 24, 2002 ]
[/ Sept 2, 2004 ]
[/ Feb 14, 2005 ]
[/ Sept 13, 2005 ]

[/ Some links]

[def __note__       [$images/note.png]]
[def __alert__      [$images/alert.png]]
[def __tip__        [$images/tip.png]]
[def :-)            [$images/smiley.png]]
[def __spirit__     [@http://spirit.sourceforge.net Spirit]]
[def __boostbook__  [@http://www.boost.org/doc/html/boostbook.html BoostBook]]
[def __docbook__    [@http://www.docbook.org/ DocBook]]

[section:intro Introduction]

The [*Boost.Cloneable] library provides a means for creating, 
duplicating, and querying instances of object types that are specified 
in class hierarchies, and a set of containers[1] for those objects.

Cloneable objects can create clones of derived types from base types, 
can do so given any STL-compliant allocator, and support multiple clone type targets.

The user of the library is able to override the default cloning process, 
 and may supply custom allocators. Cloneable types can derive from other cloneable
types, in which case the user can specify which subobject type to duplicate or create when 
making a new clone or new object from an existing instance.

You can use [*Boost.Cloneable] with existing, external types without modification 
to those types by using the supplied ['adaptor] mechanism. [*Boost.Cloneable] also 
supports types that are not default-constructable.

There is a fundamental requirement that a common base class type is shared for 
each type in a given class hierarchy. The user can supply their own base classes, 
or sensible defaults are generated.

The complete source code for the library, with unit-tests, are available
in the Boost SVN respository [@http://svn.boost.org/svn/boost/sandbox/cloneable/ here].

[1] Cloneable objects can be used in containers-of-pointers (based on a modified [*Boost.PtrContainer] implementation), producing a 'heterogenous' container system with value semantics for comparison and copying, and emplace semantics for insertion. These containers are currently a part of the proposal as well, however it is intended that they eventually form a distinct library. This proposal will focus mostly on the single-object aspect of the system.

[endsect]

[section:change_log Change Log]

[h3 Version 0.1]

* Created

[endsect]

[section:tutorial Tutorial]

This tutorial progresses through the basic usage of the library, demonstrating how 
to make a new Cloneable type, how to make an exsiting, external type Cloneable, 
and how to deal with multiple inheritance in type hierarchies.

The following is a very quick introduction to [*Boost.Cloneable]:

``
#include <boost/cloneable.hpp>

using namespace boost;

class Foo : public cloneable::base<Foo> { };

int main()
{
     Foo *foo = new Foo();
     cloneable::base_type *cloned = foo->clone();
     assert(typeid(*cloned) == typeid(Foo));
     return 0;
}
``

Here we have made a class and derived from `cloneable::base`, passing the 
type of thing to clone as a parameter. 

Because we didn't supply a base
type to use, we were given `base_type`, which is the return type of the clone
method. 

Although it is fine to use 
this default base class, we shall see that in general it is better to provide 
our own base classes as this gives us much flexibility when it comes to 
associative containers and resource management. 
 
But we'll get to that later. For now, let's move on to some slightly less trivial examples.

[section Simple Hierarchical Cloning]

In the previous example, we did not supply a base class, so our Cloneable type
was given the `base_type`. Below, we prepare our own base type `Animal`,
which of course has a virtual destructor, as well as a means to get a member 
variable from a derived type:

``
#include <string>
#include <boost/cloneable.hpp>

using namespace boost;
using namespace std;

class Animal
{
    virtual ~Animal() { }
    virtual string get_name() const = 0;
};
``

Note that `Animal` doesn't have to derive from anything, or have any special members or methods. 
Now let's use our base class to create a simple type hierarchy:

``

class Cat : public cloneable::base<Cat, Animal>
{
    string name;
    
public:
    Cat() {}
    Cat(string n) : name(n) { }
    string get_name() const { return name; }
};
``

We derive our `Cat` class from `cloneable::base<Cat, Animal>`. The first type argument to `base<...>` is 
the derived type to use for cloning, and the second argument is the common base type of the hierarhcy. As
we saw in the first example, if you do not provide your own base type, your Cloneable type will use the
base `cloneable::base_type`.

Other than that, `Cat` implements the `get_name` pure virtual method derived in the base class `Animal`.

Now, let's use it:

``
int main()
{
    Cat *cat = new Cat("sam");

    // clone the cat. returns a pointer to the base class
    Animal *animal = cat->clone();
    assert(typeid(*animal) == typeid(Cat));

    // downcast to our derived type
    Cat *cloned = dynamic_cast<Cat *>(animal);
    assert(cloned->get_name() == "sam");

    return 0;
};
``

Note that the `clone()` method returns
a pointer to the base class of the type hierarchy - in this case, `Animal`. 
We had to use a dynamic cast to down-cast to our derived type.

If you know the derived type that you wish to be cloned, you can use the 
`clone_as<T>()` method instead and save some typing:

``
Cat *cloned = cat->clone_as<Cat>();
``

As we shall soon see, this is also handy when we have choices of which sub-object to clone.

We now add other animals to the hierachy, including one that uses multiple inheritance:

``
class Dog : public cloneable::base<Dog, Animal>
{
};

class Labrador : public Dog, public cloneable::base<Labrador, Animal>
{
};
``

`Dog` is just like a cat, but different. `Labrador` is the first example we have seen
that uses multiple inheritance. In this case, we are saying that a Labrador is-a Dog,
and is Cloneable as either a Dog or a Labrador. Using these types:

``
int main()
{
    Labrador *lab = new Labrador();
    Dog *dog = lab->clone_as<Dog>();
    Labrador *cloned_lab = lab->clone_as<Labrador>();
    
    assert(typeid(*dog) == typeid(Dog));
    assert(typeid(*cloned_lab) == typeid(Labrador));
    
    return 0;
}
``

When cloning the `Labrador` class, we must specify which sub-object we wish to duplicate using the
`clone_as<Ty>` method. 

It should be noted that when using `clone_as<Ty>`, we actually are making a type of `Ty`, rather than 
making another type and casting up.

We can also use the Cloneable library to make a new instance, with no duplication:

``
Animal *MakeNew(const cloneable::abstract_base<Animal> &animal)
{
    return animal.create_new();
}

int main()
{
    Cat *cat = new Cat();
    Animal *new_animal = MakeNew(*cat);
    assert(typeid(*new_animal) == typeid(Cat));
    return 0;
}
``

This will create a new derived animal type (not a new base), and return a pointer 
to the base. Here we used a free-function to make the new object, to show how 
to use the `abstract_base` template structure. We used `abstract_base<Animal>`, rather than 
just `Animal`, as the base type argument for the `MakeNew` function. This is because 
the base class we provided, `Animal`, does not derive from anything and does not 
have any clone-related methods. These methods are added by the `abstract_base<>` mix-in, 
which all derived `Animal`s are implicitly convertible to.

This is the basics of the cloneability side of the library. But there are a few more
details and use-cases to cover before we get to the containers. The first of which is
dealing with types that we can't change.

[endsect]

[section Controlling Construction]

We sometimes work with objects that cannot be default constructed. The Cloneable system
works with these types safely:

``
struct Base { virtual ~Base() {} };

struct T0 : cloneable::base<T0, Base, no_default_construction_tag>
{
    string &str;
    T0(string &s) : str(s) { }
};
``

`T0` has a member that is a reference and as such doesn't have a default constructor.
To avoid compile-time errors when using this type in the Cloneable libray, you must
indicate that it is not default-constructible by passing the `no_default_construction_tag`
type as a parameter to `cloneable::base<>`. The order that you give the base-type or tag-types
to `cloneable::base<>` is not important and is dealt with correctly by the library.

Putting this type to use:

``
int main()
{
    string str = "foo";
    T0 *p = new T0(str);
    T0 *q = p->clone_as<T0>();
    assert(&q->str == &str);
    
    // demonstrate that attempting to create
    // a new T0 instance without parameters
    // results in an exception of type no_default_construction
    bool caught = false;
    try
    {
        p->create_new();
    }
    catch (no_default_construction)
    {
        caught = true;
    }
    assert(caught);
    return 0;
}
``

A `no_default_construction` exception is thrown if you attempt to default-construct a 
type that has no default constructor.

[endsect]

[section Using External Types]

Quite often we find ourselves using classes that are defined in an external library. 
These are not open to be changed, but we would still like them to be Cloneable. 
To address this issue, we can use the `cloneable::adaptor<Type,Base>` structure:

``
class External { /* hidden impl */ }; // for whatever reason, this cannot be modified

class MyBase { virtual ~MyBase() { } };

typedef cloneable::adaptor<External, MyBase> MyExternal;

int main()
{
    MyExternal *ex = new MyExternal();
    MyExternal *cloned = ex->clone_as<MyExternal>();
    return 0;
}
``

By using the `cloneable::adaptor<Type, Base>` structure, we create a new type
that is cloneable and can be used correctly in heterogenous containers.

Alternatively of course, we could just make a new structure which either derives 
from or encapsulates the external class. This will be necessary if you wish to
pass construction arguments to the external type, or provide a custom clone 
method for it. For example:

``
class Wrapper : cloneable::base<Wrapper, Base>
{
    External *impl;
public:
    Wrapper() : impl(0) { }
    Wrapper(const Wrapper &other)
    {
        impl = new Wrapper(*other.impl);
    }
};
``

There are of course many ways to do this, and how you do it will depend on many factors. 
Just bear in mind that `cloneable::adaptor<>` is there if you need it.

Next, we look at how to customise the cloning operation itself, and how we can 
use our own or other allocators. This is important to understand before we
finally get to the heterogenous containers.

[endsect]

[section Dealing with Muliple Sub-Objects]

When working with types that have multiple cloneable sub-objects, we must use the 
`clone_as<T>` and `create_as<T>` methods to disambiguate which sub-type to clone
or create.

This is demonstrated below:

``
struct Base { virtual ~Base() { } };
struct T0 : base<T0, Base> { };
struct T1 : T0, base<T1, Base> { };
struct W : base<W, Base> { };
struct T2 : W, T1, base<T2, Base> { };

int main()
{
    T2 *t2 = new T2();
    
    // clone sub-objects
    W *t2_w = t2->clone_as<W>();
    T1 *t2_t1 = t2->clone_as<T1>();
    T0 *t2_t0 = t2->clone_as<T0>();
    
    // create sub-objects
    W *t2_w_new = t2->create_as<W>();
    T1 *t2_t1_new = t2->create_as<T1>();
    T0 *t2_t0_new = t2->create_as<T0>();
    
    
    return 0;
}
``

Note that if a sub-type S in type T is not default-constructabe, an exception of type
no_default_construction will be thrown if you attempt to default-create a new S instance
from a T instance. 

[endsect]

[section Customising the Cloning Process]

So far, we have been making clones using the default cloning process. 
This uses the copy-constructor of a given type T to generate the clone. 
However, quite often we will want to have greater control over this process, 
and sometimes we don't want to or cannot use a copy constructor at all.

Customising the cloning process is a simple matter of providing a `make_copy`
method overload in your derived class:

``
class Foo : public cloneable::base<Foo>
{
    // over-ride the make_copy method, providing our own means to make a clone
    Foo *make_copy() const
    {
        Foo *copy = new Foo();
        // TODO: write values to copy from this
        return copy;
    }
};
``

Please ensure that you override the `make_copy()` method correctly. It must return 
a type that is co-variant with the base you used for the derived type, and must be 
`const`. If you make a mistake on the return type, the compiler will complain. But
if you forget to make the method const, it will not be invoked when needed and there
will be no warning or error.

This example uses the heap to make clones; we will next see how to make 
clones using any standard-compliant allocator type.

[endsect]

[section Using Custom Allocators]

The entire Cloneable system was designed to support general allocators. This provides 
more fine-tuned control over cloning and creation operations, and ensures Cloneable 
types work well in containers. 

When making a new object, sub-object, clone or sub-clone, the underlying `abstract_base` 
is given a reference to an `abstract_allocator`. This is 
an interface (containing only pure virtual methods) that is used to expose a specialised 
`allocator<T>` to the non-specific `abstract_base`. This process is easy to understand with some examples:

``
int main()
{
    std::allocator<int> alloc;
    Cat *cat = cloneable::create<Cat>(alloc);   // create a Cat using the allocator
    Cat *dupe = cat->clone_as<Cat>(alloc);      // clone using the same allocator
    
    my_allocator<int> my_alloc;
    Cat *dup2 = cat->clone_as<Cat>(my_alloc);   // clone using another allocator
    return 0;
}
``

As you can see, most of the internals can be safely ignored. From this, it becomes clear 
that if you write a clone override, you should do so for the method that takes an `abstract_allocator &`, 
rather than just always use the heap:

``
class Foo : public cloneable::base<Foo>
{
    // over-ride the make_copy method, providing our own means to make a clone
    Foo *make_copy(cloneable::abstract_allocator &amp;alloc) const
    {
        Foo *copy = cloneable::create<Foo>(alloc);
        
        // write values to copy from this; use alloc for any further required allocations
        
        return copy;
    }
};
``

Recall that if your class can be correctly copy-constructed, you do not need to 
provide a custom clone override at all. If your class only members that have value 
semantics and can in turn be copy-constructed (including `std::containers`, and heterogenous::containers), 
then you do not need to provide any customisation. 

However, if your class contains pointers of any description, or references, 
then you will in general have to provide a sensible copy-constructor, or provide a custom clone override.

In summary, there are three stages of customisation:

* If your class has types with value semantics, the compiler-generated default copy constructor will suffice.
* If your class has types that need explicit construction, making a copy-constructor for your class will suffice to make clones.
* If your class has members that contain references, or require allocation, then you should override `make_copy` and construct the members in the copy instance, using the supplied abstract_allocator.

[endsect]

[section Cloneable Traits]

This is mostly relevant to library maintainers and is not important otherwise.

To assist with dealing with cloneable objects in other systems, the following
traits are provided:

``
class Base { virtual ~Base() { } };
struct T : base<T, Base> { };
struct U : base<T, Base, no_default_construction> { };
struct V { };

BOOST_STATIC_ASSERT(cloneable::is_cloneable<T>::value);
BOOST_STATIC_ASSERT(cloneable::is_cloneable<U>::value);
BOOST_STATIC_ASSERT(!cloneable::is_cloneable<V>::value);
BOOST_STATIC_ASSERT(cloneable::has_base<T,Base>::value);

//BOOST_STATIC_ASSERT(cloneable::is_default_constructable<V>::value); compile-time error: no traits
BOOST_STATIC_ASSERT(cloneable::is_default_constructable<T>::value);
BOOST_STATIC_ASSERT(!cloneable::is_default_constructable<T>::value);
``

More details are in the `clonable::traits<T>` structure.

[endsect]


[endsect]

[section Heterogenous Containers]

This section of the tutorial presents the first glimpse of the so-called ['heterogenous containers] 
provided by the Cloneable library. These are:

* `list<Base, Allocator>`
* `vector<Base, Allocator>`
* `deque<Base, Allocator>`
* `chain<Base, LinkLength, Allocator>`
* `map<Base, Predicate, Allocator>`
* `set<Base, Predicate, Allocator>`
* `multimap<Base, Pred, Alloc>`
* `multiset<Base, Pred, Alloc>`
* `hash_map<Base, Predicate, Hash, Allocator>`
* `hash_set<Base, Predicate, Hash, Allocator>`
* `hash_multimap<Base, Pred, Hash, Alloc>`.
* `hash_multiset<Base, Pred, Hash, Alloc>`

All of these containers store pointers to objects. However, they each expose their contained objects using value semantics.
If this seems similar to [*Boost.PtrContainer], that is not coincidental, as these containers are based on a modified implementation
of that library.

You will have noted that each container is specialised over a `Base` type, rather than a concrete derived type. This is 
because they are intended to store base pointers. 

It may be surprising that `map<>` takes only one type - the `Base` type - of
objects to store, rather than the more familiar ['key] and ['mapped] types. This is because a heterogenous map provides
an association between objects with the same base type.

All heterogenous containers create objects to be added 'in place', in storage created by the containers allocator. 
As such, to add a new object to a heterogenous container, you provide the type and the construction arguments. Allocation
and construction is dealt with by the container, and, importantly, ['objects are not copied into the container]:

``
container.add_method<Type>(construction args..);
``

This means, for instance, that you can use non-default-constructable objects in heterogenous vectors. 

It also means that you can use objects that do not or cannot have assignment defined. 

Basically, as long as you can construct the object at all, you can use it in a heterogenous container. 

Importantly, clones are guaranteed to be created using the same allocator as that used to make the original objects.

This is why it is
important that you overload `make_copy(abstract_allocator &) const`, rather than the `make_copy() const` method that
does not take an allocator. (['Indeed, there is a good case to be made for removing this second method from the library
completely - CJS]).

These containers will be presented in order, with some motivational examples which combines them. First, we shall
extend our little Animal hierarchy to include an age member, and comparison operators.

[section Extended Object Hierarhcy]

This is the definitions we will use in the following examples. First, let's look at a slightly
extended base type for our Animal hierarchy:

``
struct Animal
{
	double age;
	string name;
	
	Animal(double years_old = 0) : age(years_old) { }
	Animal(string n, double years_old = 0) : age(years_old), name(n) { }
	
	friend bool operator==(const Animal &left, const Animal &right) const
	{
		return left.age == right.age;
	}
	friend bool operator<(const Animal &left, const Animal &right) const
	{
		return left.age < right.age;
	}
	struct CompareNames
	{
		friend bool operator<(const Animal &left, const Animal &right) const
		{
			return left.name < right.name;
		}
	};
};
``

This is just a little more elaborate than the previous example hierarchy we used earlier in the tutorial.
We have added an `age` field for all animals, indicating how old it is in years. Animals have relational
operators for testing equivalence and sorting. Another functor named `CompareNames` is provided, which
sorts by the name field of animals rather than age.

You are aware that getting your base class right is very important to the strength and efficacy of the 
hierarchy as a whole. At a minimum, you must of course use a virtual destructor. Getting the comparison
operators right is very important as well, but of course we can always add more sorting predicates such
as `CompareNames` as needed.

What we would like to avoid is having a so-called ['fat interface] as the base class, which 
has a lot of extra information that is only relevant to one or more derived types. Some of these issues
can be addressed with further use of interfaces and virtual methods to obtain sorting criteria.

A full discussion on object-oriented design is beyond the scope of this brief tutorial - and I'm sure you're
very aware of the issues in any case. Suffice to say 
that you should pay attention to how you design your base types. Always use a virtual
destructor, try to keep state to a minimum, and bear in mind how you will want to compare objects.

Moving on, we define our derived types:

``
struct Cat : cloneable::base<Cat, Animal>
{
	Cat(string name, double age = 10) : Animal(name, age) { }
};

struct Dog : cloneable::base<Dog, Animal>
{
	Dog(string name, double age = 0) : Animal(name, age) { }
};

struct Labrador : Dog, cloneable::base<Labrador, Animal>
{
	bool is_guide_dog;
	Labrador(string name, bool can_lead, double age = 0) : Dog(name, age), is_guide_dog(can_lead) { }
};
``

Labradors now have an extra field indicating that a given instance has been trained as a guide dog, and each Animal
type can be constructed by passing its name and age. Note that there are no default constructors for 
any of the Animal types.

Feel free to return to this page to refresh your memory as we walk through some
examples that use these definitions.

First, a preamble on names and semantics.

[endsect]

[section Container Method Names]

To add an element of type `Ty` to any heterogenous
container such as a `list`, `vector` or `set` we use the following syntax:

``
container.add_method_name<Ty>(a0, a1,..., an);
``

Specifically, we do not directly add an object to a heterogenous container. Rather, we specify the type of thing
to add, and provide any construction arguments. This is true as well for specifying
objects to search for in associative containers:

``
container.find<Ty>(a0, a1,..., an);
``

This creates a new object of type `Ty`, constructed with the provided arguments, searches for it
in the container, then destroys it. This means that you can store, and search for objects that are not
default constructable and/or do not have an assignment operator. But, I'm getting a little ahead of ourselves here - 
more on associative containers later.

[:[*['["Aside: The name for the method to add new objects to heterogenous sequence containers has gone from 
being called `push_back` to `emplace_back` to `push_emplace_back`
and back to `push_back`. Similarly for associative containers the names have varied
from `insert` to `emplace` to `emplace_insert` and back to `insert`.
The C++0x containers have emplace methods that insert a new object after a given iterator
location, by passing construction arguments. These are called `emplace` methods.
This is similar to the way that objects are added to heterogenous containers, but not 
the same. For all heterogenous containers, the process is to specify the type of thing
and any creation arguments. There is no need to specify an iterator, but there
is a need to specify the type explicitly. This is different to the C++0x containers, which
do not require the type.
For this reason the names have changed and are yet to be settled. All suggestions
for the names of the methods, or namespaces, are welcome. I am sure they'll end up being
called something like `emplace_back` rather than `push_back`; but the difference is that
there is no `push_back` in a heterogenous container: everything is always emplaced,
so this is one reason why I've been vasilating over the naming conventions to use]]]

-- CJS
]

With this in mind, let's visit the first container: the faithful list.

[endsect]

[section List]

The first heterogenous container we'll look at is the `list`. It is very much like a standard `list<T>`.
But it is also very different:

``
typedef heterogenous::list<Animal> List;

List list;
list.push_back<Cat>("sam", 12);
list.push_back<Dog>("spot", 8);
list.push_back<Labrador>("max", 14);

List copy = list;

const Labrador &lab = list.back_as<Labrador>();
assert(lab.name == "max" && lab.age == 14);
``

The first thing you may notice is the strange way we add new items to a list. All heterogenous containers use ['emplace] 
semantics for searching for existing objects or adding new objects.

For now, it will be enough to absorb the ['emplacement syntax] for adding new elements, and to note that the cloned list called `copy` made
a deep copy of the list; the underlying base pointers were not just copied - they were cloned.

[endsect]

[section Vector]

The vector gets the same treatment as lists, with the same syntax for adding new elements, but also some
extra methods for random access of specifically typed contained objects:

``
typedef heterogenous::vector<Animal> Vector;
Vector vector;
vector.push_back<Cat>("sam");
vector.push_back<Dog>("spot");
vector.push_back<Labrador>("max", 14);

Vector copy = vector;

Labrador &lab = vector.as<Labrador>(2);
Dog &labs_dog = vector.as<Dog>(2);
Dog &spot = vector.as<Dog>(1);

const Dog *maybe_dog = vector.cast<Dog>(0);
``

['Again, the names here have undergone a number of changes and remain in flux. Suggestions welcome!]

`push_back` works just like with `list` and is not surprising. But the `as` and `cast` methods are new.

`vector::as` is the same as `vector::at` except that it requires a type to convert to. `at` will return 
a base reference. `as` returns a derived-type reference, or throws `std::bad_cast`.

`vector::cast` (['another name in need of a better name]) returns a pointer of the given type to 
the specified element, or returns the null pointer if conversion was not possible or ambiguous.

The other members in `vector` are largely what you would expect with no real surprises. See the reference for complete details.

[endsect]

[section Set]

So far we have been intoduced to the two basic heterogenous sequence containers, `list` and `vector`. The main
difference over the standard containers is how you add new objects to them, and that they are, well, heterogenous.
You can store any type of object in them that derives from the base type that you used to define the list or vector.

Things start to get interesting with the associative containers `set` and `map`. Here we take a quick look
at how we might use a heterogenous set to store a collection of animals.

``
int main()
{
	typedef heterogenous::set<Animal> Set;
	Set set;
	
	const Cat &sam = set.emplace<Cat>("sam", 1.5).deref();
	const Dog &spot = set.emplace<Dog>("spot", 3).deref();
	const Labrador &max = set.emplace<Labrador>("max", 14).deref();

	Set copy = set;

	Set::iterator dog = copy.find<Dog>(14);		// find a dog aged 14
	Set::iterator any = copy.find<Animal>(1.5);	// find any animal aged 1.5
	Set::iterator cat = copy.find<Cat>(3);		// find a cat aged 3

	assert(&*dog == &max);
	assert(&*any == &sam);
	assert(cat == set.end());
	
	return 0;
}
``

[endsect]

[section Map]

TODO

``
int main()
{
	typedef heterogenous::map<Animal> Map;
	Map map;
	Map::value_type &pair0 = map.key<Dog>("spot", 12).value<Dog>("rover", 8);
	Map::value_type &pair1 = map.key<Cat>("sam", 6).value<Cat>("sooty", 10);
	Map::value_type &pair2 = map.key<Cat>("fluffy", 10).value<Cat>("tigger", 14);
	Map::value_type &pair3 = map.key<Labrador>("max", 12).value<Cat>("sooty", 3);
	
	Map copy = map;
	
	Map::iterator found_pair0 = map.find<Cat>("sam", 6);
	
	assert(&found_pair0->first == pair1.first);
	
	return 0;
}
``
[endsect]

[section HashMap and HashSet]

These share the same interface as `map` and `set`, but are based on hash tables rather than a tree.

[endsect]

[endsect]

