[article Cloneable
    [quickbook 1.4]
    [version 0.1]
    [authors [Schladetsch, Christian]]
    [copyright 2009 Christian Schladetsch]
    [purpose /WikiWiki/ Generalised cloning system for hierachical objects]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.4 ]
[/ Sept 24, 2002 ]
[/ Sept 2, 2004 ]
[/ Feb 14, 2005 ]
[/ Sept 13, 2005 ]

[/ Some links]

[def __note__       [$images/note.png]]
[def __alert__      [$images/alert.png]]
[def __tip__        [$images/tip.png]]
[def :-)            [$images/smiley.png]]
[def __spirit__     [@http://spirit.sourceforge.net Spirit]]
[def __boostbook__  [@http://www.boost.org/doc/html/boostbook.html BoostBook]]
[def __docbook__    [@http://www.docbook.org/ DocBook]]

[section:intro Introduction]

The [*Boost.Cloneable] library provides a means for creating, 
duplicating, and querying instances of object types that are specified 
in class hierarchies, and a set of containers[1] for those objects.

Cloneable objects can create clones of derived types from base types, 
can do so given any STL-compliant allocator, and support multiple clone type targets.

The user of the library is able to override the default cloning process, 
 and may supply custom allocators. Cloneable types can derive from other cloneable
types, in which case the user can specify which subobject type to duplicate or create when 
making a new clone or new object from an existing instance.

You can use [*Boost.Cloneable] with existing, external types without modification 
to those types by using the supplied ['adaptor] mechanism. [*Boost.Cloneable] also 
supports types that are not default-constructable.

There is a fundamental requirement that a common base class type is shared for 
each type in a given class hierarchy. The user can supply their own base classes, 
or sensible defaults are generated.

[1] Cloneable objects can be used in containers-of-pointers (based on a modified [*Boost.PtrContainer] implementation), producing a 'heterogenous' container system with value semantics for comparison and copying, and emplace semantics for insertion. These containers are currently a part of the proposal as well, however it is intended that they eventually form a distinct library. This proposal will focus mostly on the single-object aspect of the system.

[endsect]

[section:change_log Change Log]

[h3 Version 0.1]

* Created

[endsect]

[section:tutorial Tutorial]

This tutorial progresses through the basic usage of the library, demonstrating how 
to make a new Cloneable type, how to make an exsiting, external type Cloneable, 
and how to deal with multiple inheritance in type hierarchies.

The following is a very quick introduction to [*Boost.Cloneable]:

``
#include <boost/cloneable.hpp>

using namespace boost;

class Foo : public cloneable::base<Foo> { };

int main()
{
     Foo *foo = new Foo();
     cloneable::base_type *cloned = foo->clone();
     assert(typeid(*cloned) == typeid(Foo));
     return 0;
}
``

Here we have made a class and derived from `cloneable::base`, passing the 
type of thing to clone as a parameter. 

Because we didn't supply a base
type to use, we were given `base_type`, which is the return type of the clone
method. 

Although it is fine to use 
this default base class, we shall see that in general it is better to provide 
our own base classes as this gives us much flexibility when it comes to 
associative containers and resource management. 
 
But we'll get to that later. For now, let's move on to some slightly less trivial examples.

[section Simple Hierarchical Cloning]

In the previous example, we did not supply a base class, so our Cloneable type
was given the `base_type`. Below, we prepare our own base type `Animal`,
which of course has a virtual destructor, as well as a means to get a member 
variable from a derived type:

``
#include <string>
#include <boost/cloneable.hpp>

using namespace boost;
using namespace std;

class Animal
{
    virtual ~Animal() { }
    virtual string get_name() const = 0;
};

class Cat : public cloneable::base<Cat, Animal>
{
    string name;
    
public:
    Cat() {}
    Cat(string n) : name(n) { }
    string get_name() const { return name; }
};

int main()
{
    Cat *cat = new Cat("sam");

    // clone the cat. returns a pointer to the base class
    Animal *animal = cat->clone();
    assert(typeid(*animal) == typeid(Cat));

    // downcast to our derived type
    Cat *cloned = dynamic_cast<Cat *>(animal);
    assert(cloned->get_name() == "sam");

    return 0;
};
``

In this example, we note that the `clone()` method returns
a pointer to the base class of the type hierarchy - in this case, `Animal`. 
We had to use a dynamic cast to down-cast to our derived type.

If you know the derived type that you wish to be cloned, you can use the 
`clone_as<T>()` method instead and save some typing:

``
Cat *cloned = cat->clone_as<Cat>();
``

As we shall soon see, this is also handy when we have choices of which sub-object to clone.

We now add other animals to the hierachy, including one that uses multiple inheritance:

``
class Dog : public cloneable::base<Dog, Animal>
{
};

class Labrador : public Dog, public cloneable::base<Labrador, Animal>
{
};

int main()
{
    Labrador *lab = new Labrador();
    Dog *dog = lab->clone_as<Dog>();
    Labrador *cloned_lab = lab->clone_as<Labrador>();
    
    assert(typeid(*dog) == typeid(Dog));
    assert(typeid(*cloned_lab) == typeid(Labrador));
    
    return 0;
}
``

Here we see that class Labrador is-a Dog, and is also cloneable as a Labrador. 
When cloning this class, we specify which sub-object we wish to duplicate. Note that 
when using `clone_as<T>`, we actually are making a type of T, rather than making another type and casting up.

We can also use the Cloneable library to make a new instance, with no duplication:

``
Animal *MakeNew(const cloneable::abstract_base<Animal> &animal)
{
    return animal.create_new();
}

int main()
{
    Cat *cat = new Cat();
    Animal *new_animal = MakeNew(*cat);
    assert(typeid(*new_animal) == typeid(Cat));
    return 0;
}
``

This will create a new derived animal type (not a new base), and return a pointer 
to the base. Here we used a free-function to make the new object, to show how 
to use the `abstract_base` template structure. We used `abstract_base<Animal>`, rather than 
just `Animal`, as the base type argument for the `MakeNew` function. This is because 
the base class we provided, `Animal`, does not derive from anything and does not 
have any clone-related methods. These methods are added by the `abstract_base<>` mix-in, 
which all derived `Animal`s are implicitly convertible to.

This is the basics of the cloneability side of the library. But there are a few more
details and use-cases to cover before we get to the containers. The first of which is
dealing with types that we can't change.

[endsect]

[section Controlling Construction]

We sometimes work with objects that cannot be default constructed. The Cloneable system
works with these types safely:

``
struct Base { virtual ~Base() {} };

struct T0 : cloneable::base<T0, Base, no_default_construction>
{
    string &str;
    T0(string &s) : str(s) { }
};

int main()
{
    string str = "foo";
    T0 *p = new T0(str);
    T0 *q = p->clone_as<T0>();
    assert(&q->str == &str);
    
    // demonstrate that attempting to create
    // a new T0 instance without parameters
    // results in an exception of type no_default_construction
    bool caught = false;
    try
    {
        p->create_new();
    }
    catch (no_default_construction)
    {
        caught = true;
    }
    assert(caught);
    return 0;
}
``

Note that we had to pass the `no_default_construction` tag-type to `cloneable::base<>` in
the definition of T0. Without this, an error would occur when compiling the `create_new()` line.

The `no_default_construction` tag is thrown if you attempt to default-construct a 
type that has no default constructor.

[endsect]

[section Using External Types]

Quite often we find ourselves using classes that are defined in an external library. 
These are not open to be changed, but we would still like them to be Cloneable. 
To address this issue, we can use the `cloneable::adaptor<Type,Base>` structure:

``
class External { /* hidden impl */ }; // for whatever reason, this cannot be modified

class MyBase { virtual ~MyBase() { } };

typedef cloneable::adaptor<External, MyBase> MyExternal;

int main()
{
    MyExternal *ex = new MyExternal();
    MyExternal *cloned = ex->clone_as<MyExternal>();
    return 0;
}
``

By using the `cloneable::adaptor<Type, Base>` structure, we create a new type
that is cloneable and can be used correctly in heterogenous containers.

Alternatively of course, we could just make a new structure which either derives 
from or encapsulates the external class. This will be necessary if you wish to
pass construction arguments to the external type, or provide a custom clone 
method for it. For example:

``
class Wrapper : cloneable::base<Wrapper, Base>
{
    External *impl;
public:
    Wrapper() : impl(0) { }
    Wrapper(const Wrapper &other)
    {
        impl = new Wrapper(*other.impl);
    }
};
``

There are of course many ways to do this, and how you do it will depend on many factors. 
Just bear in mind that `cloneable::adaptor<>` is there if you need it.

Next, we look at how to customise the cloning operation itself, and how we can 
use our own or other allocators. This is important to understand before we
finally get to the heterogenous containers.

[endsect]

[section Dealing with Muliple SubObjects]

When dealing with types that have multiple cloneable sub-objects, we must use the 
`clone_as<T>` and `create_as<T>` methods to disambiguate which sub-type to clone
or create.

This is demonstrated below:

``
struct Base { virtual ~Base() { } };
struct T0 : base<T0, Base> { };
struct T1 : T0, base<T1, Base> { };
struct W : base<W, Base> { };
struct T2 : W, T1, base<T2, Base> { };

int main()
{
    T2 *t2 = new T2();
    
    // clone sub-objects
    W *t2_w = t2->clone_as<W>();
    T1 *t2_t1 = t2->clone_as<T1>();
    T0 *t2_t0 = t2->clone_as<T0>();
    
    // create sub-objects
    W *t2_w_new = t2->create_as<W>();
    T1 *t2_t1_new = t2->create_as<T1>();
    T0 *t2_t0_new = t2->create_as<T0>();
    
    
    return 0;
}
``

Note that if a sub-type S in type T is not default-constructabe, an exception of type
no_default_construction will be thrown if you attempt to default-create a new S instance
from a T instance. 

However, it is always safe to clone types that are not default constructable. 

[endsect]

[section Customising the Cloning Process]

So far, we have been making clones using the default cloning process. 
This uses the copy-constructor of a given type T to generate the clone. 
However, quite often we will want to have greater control over this process, 
and sometimes we don't want to or cannot use a copy constructor at all.

Customising the cloning process is a simple matter of providing a `make_copy`
method overload in your derived class:

``
class Foo : public cloneable::base<Foo>
{
    // over-ride the make_copy method, providing our own means to make a clone
    Foo *make_copy() const
    {
        Foo *copy = new Foo();
        // TODO: write values to copy from this
        return copy;
    }
};
``

Please ensure that you override the `make_copy()` method correctly. It must return 
a type that is co-variant with the base you used for the derived type, and must be 
`const`. If you make a mistake on the return type, the compiler will complain. But
if you forget to make the method const, it will not be invoked when needed and there
will be no warning or error.

This example uses the heap to make clones; we will next see how to make 
clones using any standard-compliant allocator type.

[endsect]

[section Cloneable Traits]

This is mostly relevant to library maintainers and is not important otherwise.

To assist with dealing with cloneable objects in other systems, the following
traits are provided:

``
class Base { virtual ~Base() { } };
struct T : base<T, Base> { };
struct U : base<T, Base, no_default_construction> { };
struct V { };

BOOST_STATIC_ASSERT(cloneable::is_cloneable<T>::value);
BOOST_STATIC_ASSERT(cloneable::is_cloneable<U>::value);
BOOST_STATIC_ASSERT(!cloneable::is_cloneable<V>::value);
BOOST_STATIC_ASSERT(cloneable::has_base<T,Base>::value);

//BOOST_STATIC_ASSERT(cloneable::is_default_constructable<V>::value); compile-time error: no traits
BOOST_STATIC_ASSERT(cloneable::is_default_constructable<T>::value);
BOOST_STATIC_ASSERT(!cloneable::is_default_constructable<T>::value);
``

More details are in the `clonable::traits<T>` structure.

[endsect]

[section Using Custom Allocators]

The entire Cloneable system was designed to support general allocators. This provides 
more fine-tuned control over cloning and creation operations, and ensures Cloneable 
types work well in containers. 

When making a new object, sub-object, clone or sub-clone, the underlying `abstract_base` 
is given a reference to an `abstract_allocator`. This is 
an interface (containing only pure virtual methods) that is used to expose a specialised 
`allocator<T>` to the non-specific `abstract_base`. This process is easy to understand with some examples:

``
int main()
{
    std::allocator<int> alloc;
    Cat *cat = cloneable::create<Cat>(alloc);   // create a Cat using the allocator
    Cat *dupe = cat->clone_as<Cat>(alloc);      // clone using the same allocator
    
    my_allocator<int> my_alloc;
    Cat *dup2 = cat->clone_as<Cat>(my_alloc);   // clone using another allocator
    return 0;
}
``

As you can see, most of the internals can be safely ignored. From this, it becomes clear 
that if you write a clone override, you should do so for the method that takes an `abstract_allocator &`, 
rather than just always use the heap:

``
class Foo : public cloneable::base<Foo>
{
    // over-ride the make_copy method, providing our own means to make a clone
    Foo *make_copy(cloneable::abstract_allocator &amp;alloc) const
    {
        Foo *copy = cloneable::create<Foo>(alloc);
        
        // write values to copy from this; use alloc for any further required allocations
        
        return copy;
    }
};
``

Recall that if your class can be correctly copy-constructed, you do not need to 
provide a custom clone override at all. If your class only members that have value 
semantics and can in turn be copy-constructed (including `std::containers`, and heterogenous::containers), 
then you do not need to provide any customisation. 

However, if your class contains pointers of any description, or references, 
then you will in general have to provide a sensible copy-constructor, or provide a custom clone override.

In summary, there are three stages of customisation:

* If your class has types with value semantics, the compiler-generated default copy constructor will suffice.
* If your class has types that need explicit construction, making a copy-constructor for your class will suffice to make clones.
* If your class has members that contain references, or require allocation, then you should override `make_copy` and construct the members in the copy instance, using the supplied abstract_allocator.

[endsect]


[endsect]

[section Containers]

This section of the tutorial presents the first glimpse of the so-called ['heterogenous containers] 
provided by the Cloneable library. These are:

* `list<Base, Allocator>`
* `vector<Base, Allocator>`
* `map<Base, Predicate, Allocator>`
* `set<Base, Predicate, Allocator>`
* `hash_map<Base, Predicate, Hash, Allocator>`
* `hash_set<Base, Predicate, Hash, Allocator>`

All of these containers store pointers to objects. However, they each expose their contained objects using value semantics.
If this seems similar to Boost.PtrContainer, that is not coincidental, as these containers are based on a modified implementation
of that library.

You will have noted that each container is specialised over a Base type, rather than a concrete derived type. This is 
because they are intended to store base pointers. It may be surprising that `map<>` takes only one type - the Base type - of
object to store, rather than the more familiar key and mapped types. This is because a heterogenous map provides
an association between objects with the same base type.

These containers will be presented in order, with some motivational examples which combines them. First, we shall
extend our little Animal hierarchy to include an age member, and a comparison operator:

``
struct Animal
{
	double age;
	Animal(double years_old = 0) : age(years_old) { }
	
	bool operator<(const Animal &other) const
	{
		return age < other.age;
	}
};

struct Cat : cloneable::base<Cat, Animal>
{
	Cat(double age = 0) : base_type(age) { }
};

struct Dog : cloneable::base<Dog, Animal>
{
	Dog(double age = 0) : base_type(age) { }
};

struct Labrador : Dog, cloneable::base<Labrador, Animal>
{
	Labrador(double age = 0) : base_type(age) { }
};

``

With this in mind, let's visit the first container: the faithful list.

[section List]

TODO

``
typedef heterogenous::list<Animal> List;

List list;
list.emplace_back<Cat>("sam", 12);
list.emplace_back<Dog>("spot", 8);
list.emplace_back<Labrador>("max", 14);

List copy = list;

const Labrador &lab = list.back_as<Labrador>();
assert(lab.name == "max" && lab.age == 14);
``

The first thing you may notice is the strange way we add new items to a list. All heterogenous containers use ['emplace] 
semantics for adding or querying objects.

This means that the container creates the objects 'in place', in storage created by the containers allocator. 
As such, to add a new object to a heterogenous container, you provide the type and the construction arguments.

Clones are created using the same allocator as that used to make the original objects; this is why it is
important that you overload `make_copy(abstract_allocator &) const`, rather than the `make_copy` method that
does not take an allocator. Indeed, there is a good case to be made for removing this second method from the library
completely.

For now, it will be enough to absorb the emplace syntax, and to note that the cloned list called `copy` made
a deep copy of the list; the underlying base pointers were not just copied - they were cloned.

[endsect]

[section Vector]

TODO

``
typedef heterogenous::vector<Animal> Vector;
Vector vector;
vector.emplace_back<Cat>("sam");
vector.emplace_back<Dog>("spot");
vector.emplace_back<Labrador>("max", 14);

Vector copy = vector;

Labrador &lab = vector.as<Labrador>(2);
Dog &labs_dog = vector.as<Dog>(2);
Dog &spot = vector.as<Dog>(1);

``

[endsect]

[section Set]

TODO

``
int main()
{
	typedef heterogenous::set<Animal> Set;
	Set set;
	
	Cat &sam = set.emplace<Cat>("sam", 1.5);
	Dog &spot = set.emplace<Dog>("spot", 3);
	Labrador &max = set.emplace<Labrador>("max", 14);

	Set copy = set;

	Set::iterator dog = copy.find<Dog>(14);
	Set::iterator any = copy.find<Animal>(1.5);

	assert(&*dog == &max);
	assert(&*any == &sam);
	
	return 0;
}

``

[endsect]

[section Map]

TODO

``
int main()
{
	typedef heterogenous::map<Animal> Map;
	Map map;
	Map::value_type &pair0 = map.key<Dog>("spot", 12).value<Dog>("rover", 8);
	Map::value_type &pair1 = map.key<Cat>("sam", 6).value<Cat>("sooty", 10);
	Map::value_type &pair2 = map.key<Cat>("fluffy", 10).value<Cat>("tigger", 14);
	Map::value_type &pair3 = map.key<Labrador>("max", 12).value<Cat>("sooty", 3);
	
	Map copy = map;
	
	Map::iterator found_pair0 = map.find<Cat>("sam", 6);
	
	assert(&found_pair0->first == pair1.first);
	
	return 0;
}
``
[endsect]

[section HashMap and HashSet]

These share the same interface as `map` and `set`, but are based on hash tables rather than a tree.

[endsect]

[endsect]

