<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Tutorial</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="../index.html" title="Cloneable 0.1">
<link rel="up" href="../index.html" title="Cloneable 0.1">
<link rel="prev" href="../index.html" title="Cloneable 0.1">
<link rel="next" href="heterogenous_containers.html" title="Heterogenous Containers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../libraries.html">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="heterogenous_containers.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" title="Tutorial">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="cloneable.tutorial"></a><a class="link" href="tutorial.html" title="Tutorial"> Tutorial</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#cloneable.tutorial.simple_hierarchical_cloning">Simple
      Hierarchical Cloning</a></span></dt>
<dt><span class="section"><a href="tutorial.html#cloneable.tutorial.controlling_construction">Controlling
      Construction</a></span></dt>
<dt><span class="section"><a href="tutorial.html#cloneable.tutorial.using_external_types">Using External
      Types</a></span></dt>
<dt><span class="section"><a href="tutorial.html#cloneable.tutorial.dealing_with_muliple_sub_objects">Dealing
      with Muliple Sub-Objects</a></span></dt>
<dt><span class="section"><a href="tutorial.html#cloneable.tutorial.customising_the_cloning_process">Customising
      the Cloning Process</a></span></dt>
<dt><span class="section"><a href="tutorial.html#cloneable.tutorial.using_custom_allocators">Using Custom
      Allocators</a></span></dt>
<dt><span class="section"><a href="tutorial.html#cloneable.tutorial.cloneable_instance">Cloneable Instance</a></span></dt>
<dt><span class="section"><a href="tutorial.html#cloneable.tutorial.cloneable_traits">Cloneable Traits</a></span></dt>
</dl></div>
<p>
      This tutorial progresses through the basic usage of the library, demonstrating
      how to make a new Cloneable type, how to make an exsiting, external type Cloneable,
      and how to deal with multiple inheritance in type hierarchies.
    </p>
<p>
      The following is a quick introduction to <span class="bold"><strong>Boost.Cloneable</strong></span>:
    </p>
<p>
      
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">cloneable</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span>

<span class="keyword">class</span> <span class="identifier">Foo</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Foo</span><span class="special">&gt;</span> <span class="special">{</span> <span class="special">};</span>
</pre>
<p>
    </p>
<p>
      Here we have included the main <span class="bold"><strong>Boost.Cloneable</strong></span>
      header, made a class and derived from <code class="computeroutput"><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span></code>, passing
      the type of thing to clone as the first type parameter. Now we can use it to
      make a clone:
    </p>
<p>
      
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
     <span class="identifier">Foo</span> <span class="special">*</span><span class="identifier">foo</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Foo</span><span class="special">();</span>
     <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base_type</span> <span class="special">*</span><span class="identifier">cloned</span> <span class="special">=</span> <span class="identifier">foo</span><span class="special">-&gt;</span><span class="identifier">clone</span><span class="special">();</span>
     <span class="identifier">assert</span><span class="special">(</span><span class="keyword">typeid</span><span class="special">(*</span><span class="identifier">cloned</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">typeid</span><span class="special">(</span><span class="identifier">Foo</span><span class="special">));</span>
     <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
    </p>
<p>
      Because we didn't supply a base type to use, the default base type named <code class="computeroutput"><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base_type</span></code> is used. This is the return-type
      of the <code class="computeroutput"><span class="identifier">clone</span></code> method added to
      the <code class="computeroutput"><span class="identifier">Foo</span></code> type.
    </p>
<p>
      An equivalent way of making the clone is to use a free-function:
    </p>
<p>
      
</p>
<pre class="programlisting"><span class="identifier">Foo</span> <span class="special">*</span><span class="identifier">clone</span> <span class="special">=</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">clone</span><span class="special">(*</span><span class="identifier">foo</span><span class="special">);</span> <span class="comment">// note: clone() takes a const reference, not a pointer
</span></pre>
<p>
    </p>
<p>
      This allows us to work with types that may or may not be <span class="emphasis"><em>Cloneable</em></span>
      in the sense of this library. If the given type is not <span class="emphasis"><em>Cloneable</em></span>,
      then the default way of making a clone using <code class="computeroutput"><span class="keyword">new</span>
      <span class="identifier">Type</span><span class="special">(</span><span class="identifier">original</span><span class="special">)</span></code>
      is used. (<span class="emphasis"><em>is defaulting to <code class="computeroutput"><span class="keyword">new</span>
      <span class="identifier">T</span><span class="special">(</span><span class="identifier">orig</span><span class="special">)</span></code> too
      dangerous? --CJS</em></span>)
    </p>
<p>
      To clone from a base class, which generally doesn't have any clone-related
      methods, we use the free-functions <code class="computeroutput"><span class="identifier">clone</span></code>,
      <code class="computeroutput"><span class="identifier">can_clone_as</span></code> and <code class="computeroutput"><span class="identifier">clone_as</span></code>:
    </p>
<p>
      
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">cloneable</span><span class="special">;</span>
	
	<span class="identifier">base_type</span> <span class="special">*</span><span class="identifier">foo_base</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Foo</span><span class="special">();</span>
	<span class="identifier">assert</span><span class="special">(</span><span class="identifier">can_clone_as</span><span class="special">&lt;</span><span class="identifier">Foo</span><span class="special">&gt;(*</span><span class="identifier">foo_base</span><span class="special">));</span>
	
	<span class="identifier">Foo</span> <span class="special">*</span><span class="identifier">foo_clone</span> <span class="special">=</span> <span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">Foo</span><span class="special">&gt;(*</span><span class="identifier">foo_base</span><span class="special">);</span>
	<span class="identifier">assert</span><span class="special">(</span><span class="identifier">foo_clone</span> <span class="special">!=</span> <span class="number">0</span><span class="special">);</span>
	
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
    </p>
<div class="note" title="Note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        we pass references to these functions rather than pointers, and these functions
        work for <span class="emphasis"><em>Cloneable</em></span> types and generally. We can also
        pass an allocator to these functions, but more on custom allocation later.
      </p></td></tr>
</table></div>
<p>
      Although it is fine to use the default base class in this example and other
      similar cases, we shall see that in general it is better to provide our own
      base classes. This gives us flexibility and space for customisation, allows
      us to use the types in associative containers, and to control resource management.
    </p>
<p>
      But we'll get to that later. For now, let's move on to some slightly less trivial
      examples.
    </p>
<div class="section" title="Simple Hierarchical Cloning">
<div class="titlepage"><div><div><h3 class="title">
<a name="cloneable.tutorial.simple_hierarchical_cloning"></a><a class="link" href="tutorial.html#cloneable.tutorial.simple_hierarchical_cloning" title="Simple Hierarchical Cloning">Simple
      Hierarchical Cloning</a>
</h3></div></div></div>
<p>
        In the previous example, we did not supply a base class, so our Cloneable
        type was given the default <code class="computeroutput"><span class="identifier">base_type</span></code>.
        Below, we prepare our own base type <code class="computeroutput"><span class="identifier">Animal</span></code>,
        which of course has a virtual destructor, as well as a means to get a member
        variable from a derived type:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">cloneable</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">;</span>

<span class="keyword">class</span> <span class="identifier">Animal</span>
<span class="special">{</span>
    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">Animal</span><span class="special">()</span> <span class="special">{</span> <span class="special">}</span>
    <span class="keyword">virtual</span> <span class="identifier">string</span> <span class="identifier">get_name</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">Animal</span></code> doesn't have to derive
        from anything, or have any special members or methods.
      </p>
<p>
        Now let's use our base class to create a simple type hierarchy:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Cat</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Cat</span><span class="special">,</span> <span class="identifier">Animal</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">string</span> <span class="identifier">name</span><span class="special">;</span>
    
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">Cat</span><span class="special">()</span> <span class="special">{}</span>
    <span class="identifier">Cat</span><span class="special">(</span><span class="identifier">string</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">name</span><span class="special">(</span><span class="identifier">n</span><span class="special">)</span> <span class="special">{</span> <span class="special">}</span>
    <span class="identifier">string</span> <span class="identifier">get_name</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">name</span><span class="special">;</span> <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        We derive our <code class="computeroutput"><span class="identifier">Cat</span></code> class from
        <code class="computeroutput"><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Cat</span><span class="special">,</span> <span class="identifier">Animal</span><span class="special">&gt;</span></code>. The first type argument to <code class="computeroutput"><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Cat</span><span class="special">,</span> <span class="identifier">Animal</span><span class="special">&gt;</span></code> is the derived type to use for cloning,
        and the second argument is the common base type of the hierarhcy. As we saw
        in the first example, if you do not provide your own base type, your Cloneable
        type will use the base <code class="computeroutput"><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base_type</span></code>.
      </p>
<p>
        Other than that, <code class="computeroutput"><span class="identifier">Cat</span></code> implements
        the <code class="computeroutput"><span class="identifier">get_name</span></code> pure virtual
        method derived from the base class <code class="computeroutput"><span class="identifier">Animal</span></code>.
      </p>
<p>
        Now, let's use it:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">Cat</span> <span class="special">*</span><span class="identifier">cat</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Cat</span><span class="special">(</span><span class="string">"sam"</span><span class="special">);</span>

    <span class="comment">// clone the cat. returns a pointer to the base class
</span>    <span class="identifier">Animal</span> <span class="special">*</span><span class="identifier">animal</span> <span class="special">=</span> <span class="identifier">cat</span><span class="special">-&gt;</span><span class="identifier">clone</span><span class="special">();</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="keyword">typeid</span><span class="special">(*</span><span class="identifier">animal</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">typeid</span><span class="special">(</span><span class="identifier">Cat</span><span class="special">));</span>

    <span class="comment">// downcast to our derived type
</span>    <span class="identifier">Cat</span> <span class="special">*</span><span class="identifier">cloned</span> <span class="special">=</span> <span class="keyword">dynamic_cast</span><span class="special">&lt;</span><span class="identifier">Cat</span> <span class="special">*&gt;(</span><span class="identifier">animal</span><span class="special">);</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">cloned</span><span class="special">-&gt;</span><span class="identifier">get_name</span><span class="special">()</span> <span class="special">==</span> <span class="string">"sam"</span><span class="special">);</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<div class="note" title="Note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          the <code class="computeroutput"><span class="identifier">clone</span><span class="special">()</span></code>
          method returns a pointer to the base class of the type hierarchy - in this
          case, <code class="computeroutput"><span class="identifier">Animal</span></code>.
        </p></td></tr>
</table></div>
<p>
        We had to use a dynamic cast to down-cast to our derived type. If you know
        the derived type that you wish to be cloned, you can use the <code class="computeroutput"><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;()</span></code>
        method instead and save some typing:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">Cat</span> <span class="special">*</span><span class="identifier">cloned</span> <span class="special">=</span> <span class="identifier">cat</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">Cat</span><span class="special">&gt;();</span>
</pre>
<p>
      </p>
<p>
        As we shall soon see, this is also handy when we have choices of which sub-object
        to clone. Of course, we could also use the free-function <code class="computeroutput"><span class="identifier">clone</span></code>:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">cloneable</span><span class="special">;</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">can_clone_as</span><span class="special">&lt;</span><span class="identifier">Cat</span><span class="special">&gt;(*</span><span class="identifier">cat</span><span class="special">));</span>
<span class="identifier">Cat</span> <span class="special">*</span><span class="identifier">cloned</span> <span class="special">=</span> <span class="identifier">clone</span><span class="special">(*</span><span class="identifier">cat</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        We now add other animals to the hierachy, including one that uses multiple
        inheritance:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Dog</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Dog</span><span class="special">,</span> <span class="identifier">Animal</span><span class="special">&gt;</span>
<span class="special">{</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">Labrador</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">Dog</span><span class="special">,</span> <span class="keyword">public</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Labrador</span><span class="special">,</span> <span class="identifier">Animal</span><span class="special">&gt;</span>
<span class="special">{</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">Dog</span></code> is just like a cat, but
        different <span class="inlinemediaobject"><img src="../images/smiley.png" alt="smiley"></span>. <code class="computeroutput"><span class="identifier">Labrador</span></code>
        is the first example we have seen that uses multiple inheritance. In this
        case, we are saying that a Labrador is-a Dog, and is Cloneable as either
        a Dog or a Labrador. Using these types:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">Animal</span> <span class="special">*</span><span class="identifier">lab</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Labrador</span><span class="special">();</span>
    <span class="identifier">Animal</span> <span class="special">*</span><span class="identifier">lab_as_dog</span> <span class="special">=</span> <span class="identifier">lab</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">Dog</span><span class="special">&gt;();</span>
    <span class="identifier">Animal</span> <span class="special">*</span><span class="identifier">lab_clone</span> <span class="special">=</span> <span class="identifier">lab</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">Labrador</span><span class="special">&gt;();</span>
    
    <span class="identifier">assert</span><span class="special">(</span><span class="keyword">typeid</span><span class="special">(*</span><span class="identifier">lab_as_dog</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">typeid</span><span class="special">(</span><span class="identifier">Dog</span><span class="special">));</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="keyword">typeid</span><span class="special">(*</span><span class="identifier">lab_clone</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">typeid</span><span class="special">(</span><span class="identifier">Labrador</span><span class="special">));</span>
    
    <span class="identifier">assert</span><span class="special">(!</span><span class="identifier">can_clone_as</span><span class="special">&lt;</span><span class="identifier">Labrador</span><span class="special">&gt;(</span><span class="identifier">lab_as_dog</span><span class="special">));</span>
    
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        When cloning the <code class="computeroutput"><span class="identifier">Labrador</span></code>
        class, we must specify which sub-object we wish to duplicate using the <code class="computeroutput"><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">Ty</span><span class="special">&gt;</span></code>
        method.
      </p>
<p>
        It should be noted that when using <code class="computeroutput"><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">Ty</span><span class="special">&gt;</span></code>, we actually are making an instance of
        type <code class="computeroutput"><span class="identifier">Ty</span></code>, rather than making
        another type and casting up.
      </p>
<p>
        We can also use the Cloneable library to make a new derived instance from
        a base type:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">Animal</span> <span class="special">*</span><span class="identifier">cat</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Cat</span><span class="special">();</span>
    <span class="identifier">Animal</span> <span class="special">*</span><span class="identifier">new_animal</span> <span class="special">=</span> <span class="identifier">create_new</span><span class="special">(*</span><span class="identifier">cat</span><span class="special">);</span>
    
    <span class="identifier">assert</span><span class="special">(</span><span class="keyword">typeid</span><span class="special">(*</span><span class="identifier">new_animal</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">typeid</span><span class="special">(</span><span class="identifier">Cat</span><span class="special">));</span>
    
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        This will create a new derived animal type (not a new base), and return a
        pointer to the base.
      </p>
<p>
        This is the basics of the cloneability side of the library. But there are
        a few more details and use-cases to cover before we get to the containers.
        The first of these details is dealing with types that are not default-constructable.
        This is a very useful part of the library, as it allows for containers with
        elements that are not default constructable and do not have assignment operations.
        We'll get to that in the containers tutorial, but for now let's quickly cover
        the basics in the next section.
      </p>
</div>
<div class="section" title="Controlling Construction">
<div class="titlepage"><div><div><h3 class="title">
<a name="cloneable.tutorial.controlling_construction"></a><a class="link" href="tutorial.html#cloneable.tutorial.controlling_construction" title="Controlling Construction">Controlling
      Construction</a>
</h3></div></div></div>
<p>
        We sometimes work with objects that cannot be default constructed. The Cloneable
        system works with these types safely:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Base</span> <span class="special">{</span> <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">Base</span><span class="special">()</span> <span class="special">{}</span> <span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">T0</span> <span class="special">:</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">,</span> <span class="identifier">no_default_construction_tag</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">string</span> <span class="special">&amp;</span><span class="identifier">str</span><span class="special">;</span>
    <span class="identifier">T0</span><span class="special">(</span><span class="identifier">string</span> <span class="special">&amp;</span><span class="identifier">s</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">str</span><span class="special">(</span><span class="identifier">s</span><span class="special">)</span> <span class="special">{</span> <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">T0</span></code> has a member that is a
        reference and as such doesn't have a default constructor. To avoid compile-time
        errors when using this type in the Cloneable libray, you must indicate that
        it is not default-constructible by passing the <code class="computeroutput"><span class="identifier">no_default_construction_tag</span></code>
        type as a parameter to <code class="computeroutput"><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;&gt;</span></code>. The order that you give the base-type
        or tag-types to <code class="computeroutput"><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;&gt;</span></code> is not important.
      </p>
<p>
        Putting this type to use:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">string</span> <span class="identifier">str</span> <span class="special">=</span> <span class="string">"foo"</span><span class="special">;</span>
    <span class="identifier">T0</span> <span class="special">*</span><span class="identifier">p</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">T0</span><span class="special">(</span><span class="identifier">str</span><span class="special">);</span>
    <span class="identifier">T0</span> <span class="special">*</span><span class="identifier">q</span> <span class="special">=</span> <span class="identifier">clone</span><span class="special">(*</span><span class="identifier">p</span><span class="special">);</span> <span class="comment">// or, p-&gt;clone_as&lt;T0&gt;();
</span>    <span class="identifier">assert</span><span class="special">(&amp;</span><span class="identifier">q</span><span class="special">-&gt;</span><span class="identifier">str</span> <span class="special">==</span> <span class="special">&amp;</span><span class="identifier">str</span><span class="special">);</span>
    
    <span class="comment">// demonstrate that attempting to create
</span>    <span class="comment">// a new T0 instance without parameters
</span>    <span class="comment">// results in an exception of type no_default_construction
</span>    <span class="keyword">bool</span> <span class="identifier">caught</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="keyword">try</span>
    <span class="special">{</span>
        <span class="identifier">p</span><span class="special">-&gt;</span><span class="identifier">create_new</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">catch</span> <span class="special">(</span><span class="identifier">no_default_construction</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">caught</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">caught</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        A <code class="computeroutput"><span class="identifier">no_default_construction</span></code>
        exception is thrown if you attempt to default-construct a type that has no
        default constructor. As you would expect, if a Cloneable Q type derives from
        a non-default-constructable type, then Q is also not default-constructable.
      </p>
<p>
        Next, we'll look at how to use existing types that we can't change.
      </p>
</div>
<div class="section" title="Using External Types">
<div class="titlepage"><div><div><h3 class="title">
<a name="cloneable.tutorial.using_external_types"></a><a class="link" href="tutorial.html#cloneable.tutorial.using_external_types" title="Using External Types">Using External
      Types</a>
</h3></div></div></div>
<p>
        Quite often we find ourselves using classes that are defined in an external
        library. These are not open to be changed, but we would still like them to
        be Cloneable. To address this issue, we can use the <code class="computeroutput"><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">adaptor</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">,</span><span class="identifier">Base</span><span class="special">&gt;</span></code>
        structure:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">External</span> <span class="special">{</span> <span class="comment">/* hidden impl */</span> <span class="special">};</span> <span class="comment">// for whatever reason, this cannot be modified
</span>
<span class="keyword">class</span> <span class="identifier">MyBase</span> <span class="special">{</span> <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">MyBase</span><span class="special">()</span> <span class="special">{</span> <span class="special">}</span> <span class="special">};</span>

<span class="keyword">typedef</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">adaptor</span><span class="special">&lt;</span><span class="identifier">External</span><span class="special">,</span> <span class="identifier">MyBase</span><span class="special">&gt;</span> <span class="identifier">MyExternal</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">MyExternal</span> <span class="special">*</span><span class="identifier">ex</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">MyExternal</span><span class="special">();</span>
    <span class="identifier">MyExternal</span> <span class="special">*</span><span class="identifier">cloned</span> <span class="special">=</span> <span class="identifier">ex</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">MyExternal</span><span class="special">&gt;();</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        By using the <code class="computeroutput"><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">adaptor</span><span class="special">&lt;</span><span class="identifier">Type</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">&gt;</span></code>
        structure, we create a new type that is cloneable and can be used correctly
        in heterogenous containers.
      </p>
<p>
        Alternatively of course, we could just make a new structure which either
        derives from or encapsulates the external class. This will be necessary if
        you wish to pass construction arguments to the external type, or provide
        a custom clone method for it. For example:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Wrapper</span> <span class="special">:</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Wrapper</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">External</span> <span class="special">*</span><span class="identifier">impl</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">Wrapper</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">impl</span><span class="special">(</span><span class="number">0</span><span class="special">)</span> <span class="special">{</span> <span class="special">}</span>
    <span class="identifier">Wrapper</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Wrapper</span> <span class="special">&amp;</span><span class="identifier">other</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">impl</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Wrapper</span><span class="special">(*</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">impl</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        There are of course many ways to do this, and how you do it will depend on
        many factors. Just bear in mind that <code class="computeroutput"><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">adaptor</span><span class="special">&lt;&gt;</span></code> is there if you need it.
      </p>
<p>
        Next, we look at how to customise the cloning operation itself, and how we
        can use our own or other allocators. This is important to understand before
        we finally get to the heterogenous containers.
      </p>
</div>
<div class="section" title="Dealing with Muliple Sub-Objects">
<div class="titlepage"><div><div><h3 class="title">
<a name="cloneable.tutorial.dealing_with_muliple_sub_objects"></a><a class="link" href="tutorial.html#cloneable.tutorial.dealing_with_muliple_sub_objects" title="Dealing with Muliple Sub-Objects">Dealing
      with Muliple Sub-Objects</a>
</h3></div></div></div>
<p>
        When working with types that have multiple cloneable sub-objects, we must
        use the <code class="computeroutput"><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> and
        <code class="computeroutput"><span class="identifier">create_as</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> methods
        or functions to disambiguate which sub-type to clone or create.
      </p>
<p>
        This is demonstrated below:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Base</span> <span class="special">{</span> <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">Base</span><span class="special">()</span> <span class="special">{</span> <span class="special">}</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">T0</span> <span class="special">:</span> <span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">&gt;</span> <span class="special">{</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">T1</span> <span class="special">:</span> <span class="identifier">T0</span><span class="special">,</span> <span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">&gt;</span> <span class="special">{</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">W</span> <span class="special">:</span> <span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">W</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">&gt;</span> <span class="special">{</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">T2</span> <span class="special">:</span> <span class="identifier">W</span><span class="special">,</span> <span class="identifier">T1</span><span class="special">,</span> <span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">&gt;</span> <span class="special">{</span> <span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">T2</span> <span class="special">*</span><span class="identifier">t2</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">T2</span><span class="special">();</span>
    
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">can_clone_as</span><span class="special">&lt;</span><span class="identifier">W</span><span class="special">&gt;());</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">can_clone_as</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">&gt;());</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">can_clone_as</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">&gt;());</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">can_clone_as</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">&gt;());</span>
    
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">can_create_as</span><span class="special">&lt;</span><span class="identifier">W</span><span class="special">&gt;());</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">can_create_as</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">&gt;());</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">can_create_as</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">&gt;());</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">can_create_as</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">&gt;());</span>
    
    <span class="comment">// clone sub-objects
</span>    <span class="identifier">W</span> <span class="special">*</span><span class="identifier">t2_w</span> <span class="special">=</span> <span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">W</span><span class="special">&gt;();</span>
    <span class="identifier">T0</span> <span class="special">*</span><span class="identifier">t2_t0</span> <span class="special">=</span> <span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">&gt;();</span>
    <span class="identifier">T1</span> <span class="special">*</span><span class="identifier">t2_t1</span> <span class="special">=</span> <span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">&gt;();</span>
    <span class="identifier">T1</span> <span class="special">*</span><span class="identifier">t2_t2</span> <span class="special">=</span> <span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">&gt;();</span>
    
    <span class="comment">// create sub-objects
</span>    <span class="identifier">W</span> <span class="special">*</span><span class="identifier">t2_w_new</span> <span class="special">=</span> <span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">create_as</span><span class="special">&lt;</span><span class="identifier">W</span><span class="special">&gt;();</span>
    <span class="identifier">T0</span> <span class="special">*</span><span class="identifier">t2_t0_new</span> <span class="special">=</span> <span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">create_as</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">&gt;();</span>
    <span class="identifier">T1</span> <span class="special">*</span><span class="identifier">t2_t1_new</span> <span class="special">=</span> <span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">create_as</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">&gt;();</span>
    <span class="identifier">T2</span> <span class="special">*</span><span class="identifier">t2_t2_new</span> <span class="special">=</span> <span class="identifier">t2</span><span class="special">-&gt;</span><span class="identifier">create_as</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">&gt;();</span>
    
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<div class="warning" title="Warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/html/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          If a sub-type <code class="computeroutput"><span class="identifier">S</span></code> in type
          <code class="computeroutput"><span class="identifier">T</span></code> is not default-constructabe,
          an exception of type <code class="computeroutput"><span class="identifier">no_default_construction</span></code>
          will be thrown if you attempt to default-create a new <code class="computeroutput"><span class="identifier">S</span></code>
          instance from a <code class="computeroutput"><span class="identifier">T</span></code> instance.
        </p></td></tr>
</table></div>
</div>
<div class="section" title="Customising the Cloning Process">
<div class="titlepage"><div><div><h3 class="title">
<a name="cloneable.tutorial.customising_the_cloning_process"></a><a class="link" href="tutorial.html#cloneable.tutorial.customising_the_cloning_process" title="Customising the Cloning Process">Customising
      the Cloning Process</a>
</h3></div></div></div>
<p>
        So far, we have been making clones using the default cloning process. This
        uses the copy-constructor of a given type T to generate the clone. However,
        quite often we will want to have greater control over this process, and sometimes
        we don't want to or cannot use a copy constructor at all.
      </p>
<p>
        Customising the cloning process is a simple matter of providing a <code class="computeroutput"><span class="identifier">make_copy</span></code> method overload in your derived
        class:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Foo</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Foo</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// over-ride the make_copy method, providing our own means to make a clone
</span>    <span class="identifier">Foo</span> <span class="special">*</span><span class="identifier">make_copy</span><span class="special">()</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">Foo</span> <span class="special">*</span><span class="identifier">copy</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Foo</span><span class="special">();</span>
        <span class="comment">// TODO: write values to copy from this
</span>        <span class="keyword">return</span> <span class="identifier">copy</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        Please ensure that you override the <code class="computeroutput"><span class="identifier">make_copy</span><span class="special">()</span> <span class="keyword">const</span></code> method
        correctly. It must return a type that is co-variant with the base you used
        for the derived type, and should be <code class="computeroutput"><span class="keyword">const</span></code>.
        If you make a mistake on the return type, the compiler will complain. There
        is a non-const <code class="computeroutput"><span class="identifier">make_copy</span><span class="special">()</span></code> method as well. This will be invoked on
        a non-const original, then the const <code class="computeroutput"><span class="identifier">make_copy</span><span class="special">()</span> <span class="keyword">const</span></code> will
        be attempted before finally using the <code class="computeroutput"><span class="identifier">copy_construct</span><span class="special">()</span> <span class="keyword">const</span></code> method.
        To summarise:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          Attempting to make a copy of a non-const original will invoke <code class="computeroutput"><span class="identifier">make_copy</span><span class="special">()</span></code>
</li>
<li class="listitem">
          If this fails or is not over-ridden, then the <code class="computeroutput"><span class="identifier">make_copy</span><span class="special">()</span> <span class="keyword">const</span></code>
          method is invoked.
        </li>
<li class="listitem">
          If this fails is or not over-ridden, then <code class="computeroutput"><span class="identifier">copy_construct</span><span class="special">()</span> <span class="keyword">const</span></code>
          is invoked.
        </li>
</ul></div>
<p>
        This provides a means for clones to be made that alter the original, if you
        need to do that. For <code class="computeroutput"><span class="keyword">const</span></code> originals,
        the process starts from step 2. All of these methods are over-loaded with
        a similar method that takes an <code class="computeroutput"><span class="identifier">abstract_allocator</span></code>
        argument.
      </p>
<p>
        Which is a nice segue into the next section. This example used the heap to
        make clones; we will next see how to make clones using any standard-compliant
        allocator type.
      </p>
</div>
<div class="section" title="Using Custom Allocators">
<div class="titlepage"><div><div><h3 class="title">
<a name="cloneable.tutorial.using_custom_allocators"></a><a class="link" href="tutorial.html#cloneable.tutorial.using_custom_allocators" title="Using Custom Allocators">Using Custom
      Allocators</a>
</h3></div></div></div>
<p>
        The entire Cloneable system was designed to support general allocators. This
        provides more fine-tuned control over cloning and creation operations, and
        ensures Cloneable types work well in containers.
      </p>
<p>
        When making a new object, sub-object, clone or sub-clone, the underlying
        <code class="computeroutput"><span class="identifier">abstract_base</span></code> is given a
        reference to an <code class="computeroutput"><span class="identifier">abstract_allocator</span></code>.
        This is an interface used to expose a specialised <code class="computeroutput"><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        to the non-specific <code class="computeroutput"><span class="identifier">abstract_base</span></code>.
        This process is easy to understand with some examples:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">alloc</span><span class="special">;</span>
    <span class="identifier">Cat</span> <span class="special">*</span><span class="identifier">cat</span> <span class="special">=</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">create</span><span class="special">&lt;</span><span class="identifier">Cat</span><span class="special">&gt;(</span><span class="identifier">alloc</span><span class="special">);</span>   <span class="comment">// create a Cat using the allocator
</span>    <span class="identifier">Cat</span> <span class="special">*</span><span class="identifier">dupe</span> <span class="special">=</span> <span class="identifier">cat</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">Cat</span><span class="special">&gt;(</span><span class="identifier">alloc</span><span class="special">);</span>      <span class="comment">// clone using the same allocator
</span>    
    <span class="identifier">my_allocator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">my_alloc</span><span class="special">;</span>
    <span class="identifier">Cat</span> <span class="special">*</span><span class="identifier">dup2</span> <span class="special">=</span> <span class="identifier">cat</span><span class="special">-&gt;</span><span class="identifier">clone_as</span><span class="special">&lt;</span><span class="identifier">Cat</span><span class="special">&gt;(</span><span class="identifier">my_alloc</span><span class="special">);</span>   <span class="comment">// clone using another allocator
</span>    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        As you can see, most of the internals can be safely ignored. From this, it
        becomes clear that if you write a clone override, you should do so for the
        method that takes an <code class="computeroutput"><span class="identifier">abstract_allocator</span>
        <span class="special">&amp;</span></code>, rather than just always use
        the heap:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Foo</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Foo</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// over-ride the make_copy method, providing our own means to make a clone
</span>    <span class="identifier">Foo</span> <span class="special">*</span><span class="identifier">make_copy</span><span class="special">(</span><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">abstract_allocator</span> <span class="special">&amp;</span><span class="identifier">alloc</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">Foo</span> <span class="special">*</span><span class="identifier">copy</span> <span class="special">=</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">create</span><span class="special">&lt;</span><span class="identifier">Foo</span><span class="special">&gt;(</span><span class="identifier">alloc</span><span class="special">);</span>
        
        <span class="comment">// write values to copy from this; use alloc for any further required allocations
</span>        
        <span class="keyword">return</span> <span class="identifier">copy</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        Recall that if your class can be correctly copy-constructed, you do not need
        to provide a custom clone override at all. If your class only members that
        have value semantics and can in turn be copy-constructed (including <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">containers</span></code>,
        and heterogenous::containers), then you do not need to provide any customisation.
        So don't start by making a custom clone override method. First, check your
        class to see if it is actually needed. Introducing a <code class="computeroutput"><span class="identifier">make_copy</span><span class="special">()</span></code> method too early or when not needed can
        create maintenance problems.
      </p>
<div class="note" title="Note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          if your class contains pointers of any description, or references, then
          you will in general have to at least provide a sensible copy-constructor,
          or provide a custom clone override.
        </p></td></tr>
</table></div>
<p>
        In summary, there are three stages of customisation:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          If your class has types with value semantics, the compiler-generated default
          copy constructor will suffice.
        </li>
<li class="listitem">
          If your class has types that need explicit construction, making a copy-constructor
          for your class will suffice to make clones.
        </li>
<li class="listitem">
          If your class has members that contain references, or require allocation,
          then you should override <code class="computeroutput"><span class="identifier">make_copy</span></code>
          and construct the members in the copy instance, using the supplied abstract_allocator.
        </li>
</ul></div>
</div>
<div class="section" title="Cloneable Instance">
<div class="titlepage"><div><div><h3 class="title">
<a name="cloneable.tutorial.cloneable_instance"></a><a class="link" href="tutorial.html#cloneable.tutorial.cloneable_instance" title="Cloneable Instance">Cloneable Instance</a>
</h3></div></div></div>
<p>
        <span class="inlinemediaobject"><img src="../images/alert.png" alt="alert"></span> <span class="emphasis"><em>subject to change -- CJS</em></span>
      </p>
<p>
        A structure named <code class="computeroutput"><span class="identifier">instance</span><span class="special">&lt;&gt;</span></code> is available within the library for
        storing instances of cloneable objects.
      </p>
<p>
        This is used by the library to store a pointer to Cloneable objects, along
        with the allocator that made it. It can be used, for example, to assign from
        a generalised base to an <code class="computeroutput"><span class="identifier">instance</span><span class="special">&lt;&gt;</span></code> without the user needing to manually
        cast.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Base</span> <span class="special">{</span> <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">Base</span><span class="special">()</span> <span class="special">{</span> <span class="special">}</span> <span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">Foo</span> <span class="special">:</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">Foo</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">&gt;</span> <span class="special">{</span> <span class="special">};</span>

<span class="keyword">void</span> <span class="identifier">test</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">Base</span><span class="special">&gt;</span> <span class="identifier">List</span><span class="special">;</span>
    <span class="identifier">list</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">&lt;</span><span class="identifier">Foo</span><span class="special">&gt;(</span><span class="number">1</span><span class="special">);</span>
    <span class="identifier">List</span><span class="special">::</span><span class="identifier">instance</span><span class="special">&lt;</span><span class="identifier">Foo</span><span class="special">&gt;</span> <span class="identifier">foo</span> <span class="special">=</span> <span class="identifier">list</span><span class="special">.</span><span class="identifier">front</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        The full signature of this type is:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span>
	<span class="keyword">class</span> <span class="identifier">Derived</span> <span class="special">=</span> <span class="identifier">any_derived_tag</span>
	<span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Base</span> <span class="special">=</span> <span class="identifier">any_base_tag</span>
	<span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Alloc</span> <span class="special">=</span> <span class="identifier">default_clone_allocator</span>
	<span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Ctor</span> <span class="special">=</span> <span class="identifier">default_construction_tag</span>
	<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">instance</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        But you will rarely need that when used as shown in the example.
      </p>
<p>
        The next section cleans up some housework required for library maintainers,
        then we finally get to the fun stuff with the containers.
      </p>
</div>
<div class="section" title="Cloneable Traits">
<div class="titlepage"><div><div><h3 class="title">
<a name="cloneable.tutorial.cloneable_traits"></a><a class="link" href="tutorial.html#cloneable.tutorial.cloneable_traits" title="Cloneable Traits">Cloneable Traits</a>
</h3></div></div></div>
<p>
        This is mostly relevant to library maintainers and is not important otherwise.
      </p>
<p>
        To assist with dealing with cloneable objects in other systems, the following
        traits are provided:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Base</span> <span class="special">{</span> <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">Base</span><span class="special">()</span> <span class="special">{</span> <span class="special">}</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">T</span> <span class="special">:</span> <span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">&gt;</span> <span class="special">{</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">U</span> <span class="special">:</span> <span class="identifier">base</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">Base</span><span class="special">,</span> <span class="identifier">no_default_construction</span><span class="special">&gt;</span> <span class="special">{</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">V</span> <span class="special">{</span> <span class="special">};</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">(</span><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">is_cloneable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">);</span>
<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">(</span><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">is_cloneable</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">);</span>
<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">(!</span><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">is_cloneable</span><span class="special">&lt;</span><span class="identifier">V</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">);</span>
<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">(</span><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">has_base</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier">Base</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">);</span>

<span class="comment">//BOOST_STATIC_ASSERT(cloneable::is_default_constructable&lt;V&gt;::value); compile-time error: no traits
</span><span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">(</span><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">is_default_constructable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">);</span>
<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">(!</span><span class="identifier">cloneable</span><span class="special">::</span><span class="identifier">is_default_constructable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Full details are in <a href="../../../boost/cloneable/traits.hpp" target="_top">traits.hpp</a>.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright  2009 Christian Schladetsch<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="heterogenous_containers.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
