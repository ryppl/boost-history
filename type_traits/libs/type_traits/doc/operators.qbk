[/
  Copyright 2011 Frédéric Bron
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]
[c++]
[def __binary_temp `< class LHS, class RHS=LHS, class RET=void >`]
[def __prefix_temp `< class RHS, class RET=void >`]
[def __postfix_temp `< class LHS, class RET=void >`]

[section:operators Operator Type Traits]

[heading Introduction]

These traits are all /value traits/ inheriting from __integral_constant
and providing a simple `true` or `false` boolean value which reflects the fact
that given types can or not be used with given operators.

For example, `has_operator_plus<int, double>::value` is a `bool`
which value is `true` because it is possible to add a `double` to an `int` like
in the following code:
``
int i;
double d;
d+i;
``
It is also possible to know if the result of the operator is convertible or not
to a given type:
``
has_operator_plus<int, double, double>::value; // true: int+double is convertible to double
has_operator_plus<int, double, char*>::value; // false: int+double is not convertible to char*
has_operator_less<int, double, bool>::value; // true: int<double is convertible to bool
``

The syntax for binary operators is the following:
``
template __binary_temp has_operator_op;
``
where:

* `LHS` is the type used at the left hand side of `operator op`,
* `RHS` is the type used at the right hand side of `operator op`,
* `RET` is the type for which we want to know if the result of `operator op` can
  be converted to.

The default behaviour (`RET=void`) is to not check for the return value of the
operator. Be careful that it does not mean that the operator must return `void`
to have the trait value to be `true`.
If `RET` is different from the default `void`, the return value is checked to be
convertible to `RET`. Convertible to `RET` means that the return value can be
used as argument to a function expecting `RET`:
``
void f(RET);
LHS lhs;
RHS rhs;
f(lhs+rhs); // is valid if has_operator_plus<LHS, RHS, RET>::value==true
``

Similarly, the syntax for postfix and prefix operators is the following:
``
template __prefix_temp has_operator_prefixop;
template __postfix_temp has_operator_postfixop;
``

The following tables give the list of supported binary, prefix and postfix
operators.

[table Supported binary operators
   [[operator]                   [trait name]]

   [[`==`]    [[link boost_typetraits.reference.has_operator_equal_to `has_operator_equal_to __binary_temp`]]]
   [[`!=`]    [[link boost_typetraits.reference.has_operator_not_equal_to `has_operator_not_equal_to __binary_temp`]]]
   [[`<`]     [[link boost_typetraits.reference.has_operator_less `has_operator_less __binary_temp`]]]
   [[`<=`]    [[link boost_typetraits.reference.has_operator_less_equal `has_operator_less_equal __binary_temp`]]]
   [[`>`]     [[link boost_typetraits.reference.has_operator_greater `has_operator_greater __binary_temp`]]]
   [[`>=`]    [[link boost_typetraits.reference.has_operator_greater_equal `has_operator_greater_equal __binary_temp`]]]

   [[`+`]     [[link boost_typetraits.reference.has_operator_plus `has_operator_plus __binary_temp`]]]
   [[`-`]     [[link boost_typetraits.reference.has_operator_minus `has_operator_minus __binary_temp`]]]
   [[`*`]     [[link boost_typetraits.reference.has_operator_multiplies `has_operator_multiplies __binary_temp`]]]
   [[`/`]     [[link boost_typetraits.reference.has_operator_divides `has_operator_divides __binary_temp`]]]
   [[`%`]     [[link boost_typetraits.reference.has_operator_modulus `has_operator_modulus __binary_temp`]]]
   [[`+=`]    [[link boost_typetraits.reference.has_operator_plus_equal `has_operator_plus_equal __binary_temp`]]]
   [[`-=`]    [[link boost_typetraits.reference.has_operator_minus_equal `has_operator_minus_equal __binary_temp`]]]
   [[`*=`]    [[link boost_typetraits.reference.has_operator_multiplies_equal `has_operator_multiplies_equal __binary_temp`]]]
   [[`/=`]    [[link boost_typetraits.reference.has_operator_divides_equal `has_operator_divides_equal __binary_temp`]]]
   [[`%=`]    [[link boost_typetraits.reference.has_operator_modulus_equal `has_operator_modulus_equal __binary_temp`]]]

   [[`&&`]    [[link boost_typetraits.reference.has_operator_logical_and `has_operator_logical_and __binary_temp`]]]
   [[`||`]    [[link boost_typetraits.reference.has_operator_logical_or `has_operator_logical_or __binary_temp`]]]

   [[`&`]     [[link boost_typetraits.reference.has_operator_bit_and `has_operator_bit_and __binary_temp`]]]
   [[`|`]     [[link boost_typetraits.reference.has_operator_bit_or `has_operator_bit_or __binary_temp`]]]
   [[`^`]     [[link boost_typetraits.reference.has_operator_bit_xor `has_operator_bit_xor __binary_temp`]]]
   [[`<<`]    [[link boost_typetraits.reference.has_operator_left_shift `has_operator_left_shift __binary_temp`]]]
   [[`>>`]    [[link boost_typetraits.reference.has_operator_right_shift `has_operator_right_shift __binary_temp`]]]
   [[`&=`]    [[link boost_typetraits.reference.has_operator_bit_and_equal `has_operator_bit_and_equal __binary_temp`]]]
   [[`|=`]    [[link boost_typetraits.reference.has_operator_bit_or_equal `has_operator_bit_or_equal __binary_temp`]]]
   [[`^=`]    [[link boost_typetraits.reference.has_operator_bit_xor_equal `has_operator_bit_xor_equal __binary_temp`]]]
   [[`<<=`]   [[link boost_typetraits.reference.has_operator_left_shift_equal `has_operator_left_shift_equal __binary_temp`]]]
   [[`>>=`]   [[link boost_typetraits.reference.has_operator_right_shift_equal `has_operator_right_shift_equal __binary_temp`]]]
]

[table Supported prefix operators
   [[operator]                   [trait name]]
   [[`++`]   [[link boost_typetraits.reference.has_operator_prefix_increment `has_operator_prefix_increment __prefix_temp`]]]
   [[`--`]   [[link boost_typetraits.reference.has_operator_prefix_decrement `has_operator_prefix_decrement __prefix_temp`]]]
   [[`+`]   [[link boost_typetraits.reference.has_operator_unary_plus `has_operator_unary_plus __prefix_temp`]]]
   [[`-`]   [[link boost_typetraits.reference.has_operator_unary_minus `has_operator_unary_minus __prefix_temp`]]]
   [[`!`]   [[link boost_typetraits.reference.has_operator_logical_not `has_operator_logical_not __prefix_temp`]]]
   [[`~`]   [[link boost_typetraits.reference.has_operator_complement `has_operator_complement __prefix_temp`]]]
   [[`*`]   [[link boost_typetraits.reference.has_operator_dereference `has_operator_dereference __prefix_temp`]]]
]

[table Supported postfix operators
   [[operator]                   [trait name]]
   [[`++`]   [[link boost_typetraits.reference.has_operator_postfix_increment `has_operator_postfix_increment __postfix_temp`]]]
   [[`--`]   [[link boost_typetraits.reference.has_operator_postfix_decrement `has_operator_postfix_decrement __postfix_temp`]]]
]


The choice of trait names may seem unconsistent but it has not been possible to propose a more consistent naming convention because the standard is itself inconsistent.
The following table shows the names found in the standard for each operator and the corresponding trait name.

[table Operator names in the standard
[[operator] [alternative token (__std_ref 2.5)] [name in `<functionnal>` or `<iterator>` (__std_ref 20.3 and 24.2)] [trait name]]
[[binary]]
[[`==`]     [\u00F8]                      [`equal_to`]                                 [[link boost_typetraits.reference.has_operator_equal_to          `has_operator_equal_to`]]]
[[`!=`]     [`not_eq`]                    [`not_equal_to`]                             [[link boost_typetraits.reference.has_operator_not_equal_to      `has_operator_not_equal_to`]]]
[[`<`]      [\u00F8]                      [`less`]                                     [[link boost_typetraits.reference.has_operator_less              `has_operator_less`]]]
[[`<=`]     [\u00F8]                      [`less_equal`]                               [[link boost_typetraits.reference.has_operator_less_equal        `has_operator_less_equal`]]]
[[`>`]      [\u00F8]                      [`greater`]                                  [[link boost_typetraits.reference.has_operator_greater           `has_operator_greater`]]]
[[`>=`]     [\u00F8]                      [`greater_equal`]                            [[link boost_typetraits.reference.has_operator_greater_equal     `has_operator_greater_equal`]]]
[[ ]]
[[`+`]      [\u00F8]                      [`plus`]                                     [[link boost_typetraits.reference.has_operator_plus              `has_operator_plus`]]]
[[`-`]      [\u00F8]                      [`minus`]                                    [[link boost_typetraits.reference.has_operator_minus             `has_operator_minus`]]]
[[`*`]      [\u00F8]                      [`multiplies`]                               [[link boost_typetraits.reference.has_operator_multiplies        `has_operator_multiplies`]]]
[[`/`]      [\u00F8]                      [`divides`]                                  [[link boost_typetraits.reference.has_operator_divides           `has_operator_divides`]]]
[[`%`]      [\u00F8]                      [`modulus`]                                  [[link boost_typetraits.reference.has_operator_modulus           `has_operator_modulus`]]]
[[`+=`]     [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_plus_equal        `has_operator_plus_equal`]]]
[[`-=`]     [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_minus_equal       `has_operator_minus_equal`]]]
[[`*=`]     [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_multiplies_equal  `has_operator_multiplies_equal`]]]
[[`/=`]     [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_divides_equal     `has_operator_divides_equal`]]]
[[`%=`]     [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_modulus_equal     `has_operator_modulus_equal`]]]
[[ ]]
[[`&&`]     [`and`]                       [`logical_and`]                              [[link boost_typetraits.reference.has_operator_logical_and       `has_operator_logical_and`]]]
[[`||`]     [`or`]                        [`logical_or`]                               [[link boost_typetraits.reference.has_operator_logical_or        `has_operator_logical_or`]]]
[[ ]]
[[`&`]      [`bitand`]                    [`bit_and`]                                  [[link boost_typetraits.reference.has_operator_bit_and           `has_operator_bit_and`]]]
[[`|`]      [`bitor`]                     [`bit_or`]                                   [[link boost_typetraits.reference.has_operator_bit_or            `has_operator_bit_or`]]]
[[`^`]      [`xor`]                       [`bit_xor`]                                  [[link boost_typetraits.reference.has_operator_bit_xor           `has_operator_bit_xor`]]]
[[`<<`]     [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_left_shift        `has_operator_left_shift`]]]
[[`>>`]     [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_right_shift       `has_operator_right_shift`]]]
[[`&=`]     [`and_eq`]                    [\u00F8]                                     [[link boost_typetraits.reference.has_operator_bit_and_equal     `has_operator_bit_and_equal`]]]
[[`|=`]     [`or_eq`]                     [\u00F8]                                     [[link boost_typetraits.reference.has_operator_bit_or_equal      `has_operator_bit_or_equal`]]]
[[`^=`]     [`xor_eq`]                    [\u00F8]                                     [[link boost_typetraits.reference.has_operator_bit_xor_equal     `has_operator_bit_xor_equal`]]]
[[`<<=`]    [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_left_shift_equal  `has_operator_left_shift_equal`]]]
[[`>>=`]    [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_right_shift_equal `has_operator_right_shift_equal`]]]
[[prefix]]
[[`++`]     [\u00F8]                      [`advance`]                                  [[link boost_typetraits.reference.has_operator_prefix_increment  `has_operator_prefix_increment`]]]
[[`--`]     [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_prefix_decrement  `has_operator_prefix_decrement`]]]
[[`+`]      [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_unary_plus        `has_operator_unary_plus`]]]
[[`-`]      [\u00F8]                      [`negate`]                                   [[link boost_typetraits.reference.has_operator_unary_minus       `has_operator_unary_minus`]]]
[[`!`]      [`not`]                       [`logical_not`]                              [[link boost_typetraits.reference.has_operator_logical_not       `has_operator_logical_not`]]]
[[`~`]      [`compl`]                     [\u00F8]                                     [[link boost_typetraits.reference.has_operator_complement        `has_operator_complement`]]]
[[`*`]      [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_dereference       `has_operator_dereference`]]]
[[postfix]]
[[`++`]     [\u00F8]                      [`advance`]                                  [[link boost_typetraits.reference.has_operator_postfix_increment `has_operator_postfix_increment`]]]
[[`--`]     [\u00F8]                      [\u00F8]                                     [[link boost_typetraits.reference.has_operator_postfix_decrement `has_operator_postfix_decrement`]]]
]

[heading Implementation]

The implementation consists in only header files. The following headers should
included first:
``#include <boost/type_traits/operators.hpp>``
or
``#include <boost/type_traits/has_operator_name.hpp>``
where [^name] is the textual name chosen for the wanted operator. The first
method includes all operator traits.

All traits are implemented the same way using preprocessor macros to avoid code
duplication.
The main files are in [^boost/type_traits/detail]: [^has_binary_operator.hpp],
[^has_prefix_operator.hpp] and [^has_postfix_operator.hpp].
The example of prefix `operator-` is presented below:

``
namespace boost {
namespace detail {
namespace has_operator_unary_minus_impl {

// 1. a function to have an instance of type T without requiring T to be default
// constructible
namespace {
   template <typename T> T &make();
}

// 2. we provide operator- for types that do not have one already

// a type returned from operator- when no such operator is found in the type's
// own namespace so that we have a means to know that our operator was used
struct tag { };

// this class allows implicit conversions and makes the following operator
// definition less-preferred than any other such operators that might be found
// via argument-dependent name lookup
struct any { template <class T> any(T const&); };

// when operator- is not available, this one is used
tag operator-(const any&);

// 3. if the return type has to be checked, we need to determine if operator-
// returns void or not

// we first redefine "operator," so that we have no compilation error if
// operator- returns void and we can use the return type of
// (-rhs, returns_void_t()) to deduce if operator- returns void or not:
// - operator- returns void   -> (-rhs, returns_void_t()) returns returns_void_t
// - operator- returns !=void -> (-rhs, returns_void_t()) returns int
struct returns_void_t {};
template <typename T> int operator,(T const &, returns_void_t);

// this intermediate trait has member value of type bool:
// - value==true -> operator- returns void
// - value==false -> operator- does not return void
template < typename RHS >
struct operator_unary_minus_returns_void {
   // overloads of function returns_void make the difference
   // yes_type and no_type have different size by construction
   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value=(sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((-make<RHS>(),returns_void_t()))));
};

// 4. check for return type when RET is non void

// this class is used only when RET is non void, therefore it is specialized to
// have its value==false when the operator returns void
template < typename RHS, typename RET, typename RETURNS_VOID >
struct has_operator_unary_minus_impl2;

// operator- does not return void, checks if it is convertible to RET using the
// sizeof trick based on overload resolution
template < typename RHS, typename RET >
struct has_operator_unary_minus_impl2< RHS, RET, ::boost::false_type > {
   static ::boost::type_traits::yes_type is_convertible_to_RET(RET);
   static ::boost::type_traits::no_type is_convertible_to_RET(...);
   static const bool value=(sizeof(is_convertible_to_RET(- make<RHS>()))==sizeof(::boost::type_traits::yes_type));
};

// operator- returns void!=RET -> specialization to return value==false
template < typename RHS, typename RET >
struct has_operator_unary_minus_impl2< RHS, RET, ::boost::true_type > {
   static const bool value=false;
};

// 5. main struct: to avoid any compilation error, this struct behaves
// differently when:
// - RET is void or non void
// - operator-(RHS) is forbidden by the standard
// forbidden_if is a bool that is:
// - true when the operator-(RHS) is forbidden by the standard (would yield
//   compilation error if used)
// - false otherwise
template < typename RHS, typename RET, bool forbidden_if >
struct has_operator_unary_minus_impl1;

// specialization to avoid compilation error when forbidden by the standard
template < typename RHS, typename RET >
struct has_operator_unary_minus_impl1 < RHS, RET, true > {
   static const bool value=false;
};

// checks for return type if template parameter RET is non void: use previously
// defined struct
template < typename RHS, typename RET >
struct has_operator_unary_minus_impl1 < RHS, RET, false > {
   static const bool value=(has_operator_unary_minus_impl2< RHS, RET, typename ::boost::integral_constant< bool, operator_unary_minus_returns_void< RHS >::value > >::value);
};

// in case we do not want to check for return type, we still need to know if our
// definition of operator BOOST_TT_TRAIT_OP is used or an other existing one;
// this is done with redefinition of "operator," that returns tag or tag2
struct tag2 { };
tag operator,(tag, tag2);

// do not check for return type if 2nd template parameter RET is void
template < typename RHS >
struct has_operator_unary_minus_impl1< RHS, void, false > {
   static ::boost::type_traits::yes_type check(tag2); // this version is preferred when operator exists
   static ::boost::type_traits::no_type check(tag); // this version is used otherwise

   static const bool value=(sizeof(check(((-make<RHS>()),make<tag2>())))==sizeof(::boost::type_traits::yes_type));
};

// some specializations needs to be declared for the special void case
template < typename RET >
struct has_operator_unary_minus_impl1< void, RET, false > {
   static const bool value=false;
};

template <>
struct has_operator_unary_minus_impl1< void, void, false > {
   static const bool value=false;
};

// defines some typedef for convenience
template < typename RHS, typename RET >
struct has_operator_unary_minus_impl {
   // shortcuts for writing forbidden_if
   typedef typename ::boost::remove_reference<RHS>::type rhs_noref;
   typedef typename ::boost::remove_cv<rhs_noref>::type rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<rhs_noref>::type >::type >::type rhs_noptr;
   static const bool value=(has_operator_unary_minus_impl1 < rhs_noref, RET, ::boost::is_pointer< rhs_noref >::value >::value);
};
} // namespace has_operator_unary_minus_impl
} // namespace detail

// this is the accessible definition of the trait to end user
template < typename RHS, typename RET=void >
struct has_operator_unary_minus : ::boost::integral_constant< bool, (::boost::detail::has_operator_unary_minus_impl::has_operator_unary_minus_impl< RHS, RET >::value)> {
};
} // namespace boost
``

[heading Known issues]

* These traits cannot detect whether the operators are public or not:
if an operator is defined as a private member of type `T` then
the instantiation of the corresponding trait will produce a compiler error.
For this reason these traits cannot be used to determine whether a type has a
public operator or not.

``
struct A { private: A operator-(); };
boost::has_operator_unary_minus<A>::value; // error: A::operator-() is private
``

* There is an issue if the operator exists only for type `A` and `B` is
convertible to `A`. In this case, the compiler will report an ambigous overload
because both the existing operator and the one we provide (with argument of type
`any`) need type conversion, so that none is preferred.

``
struct A { };
void operator-(const A&);
struct B { operator A(); };
boost::has_operator_unary_minus<A>::value; // this is fine
boost::has_operator_unary_minus<B>::value; // error: ambigous overload between
                                           // operator-(const any&) and
                                           // operator-(const A&)
                                           // both need type conversion
``
``
struct B { };
struct A { A(const B&) { } };
void operator-(const A&);
boost::has_operator_unary_minus<A>::value; // this is fine
boost::has_operator_unary_minus<B>::value; // error: ambigous overload between
                                           // operator-(const any&) and
                                           // operator-(const A&)
                                           // both need type conversion
``

[heading Acknowledgments]

Frédéric Bron is very thankful to numerous people from the boost mailing list for their kind help and patience.
In particular, the following persons have been very helpful for the implementation: Edward Diener, Eric Niebler, Jeffrey Lee Hellrung (Jr.), Robert Stewart, Roman Perepelitsa, Steven Watanabe, Vicente Botet.

[endsect]
