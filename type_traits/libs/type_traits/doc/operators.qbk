[/
  (C) Copyright 2011 Frederic Bron.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]
[c++]
[def __binary_temp `< class Lhs, class Rhs=Lhs, class Ret=dont_care >`]
[def __prefix_temp `< class Rhs, class Ret=dont_care >`]
[def __postfix_temp `< class Lhs, class Ret=dont_care >`]

[section:operators Operator Type Traits]

[heading Introduction]

These traits are all /value traits/ inheriting from __integral_constant
and providing a simple `true` or `false` boolean value which reflects the fact
that given types can or not be used with given operators.

For example, `can_call_addition<int, double>::value` is a `bool`
which value is `true` because it is possible to add a `double` to an `int` like
in the following code:
``
int i;
double d;
d+i;
``
It is also possible to know if the result of the operator is convertible or not
to a given type:
``
can_call_addition<int, double, double>::value; // true: int+double is convertible to double
can_call_addition<int, double, char*>::value; // false: int+double is not convertible to char*
can_call_subtraction<int, double, bool>::value; // true: int<double is convertible to bool
``

The syntax for binary operators is the following:
``
template __binary_temp can_call_op;
``
where:

* `Lhs` is the type used at the left hand side of `operator op`,
* `Rhs` is the type used at the right hand side of `operator op`,
* `Ret` is the type for which we want to know if the result of `operator op` can
  be converted to.

The default behaviour (`Ret=dont_care`) is to not check for the return value of the
operator.
If `Ret` is different from the default `dont_care`, the return value is checked to be
convertible to `Ret`. Convertible to `Ret` means that the return value can be
used as argument to a function expecting `Ret`:
``
void f(Ret);
Lhs lhs;
Rhs rhs;
f(lhs+rhs); // is valid if can_call_addition<Lhs, Rhs, Ret>::value==true
``
If `Ret=void`, the return type is checked to be exactly `void`.

Similarly, the syntax for postfix and prefix operators is the following:
``
template __prefix_temp can_call_prefixop;
template __postfix_temp can_call_postfixop;
``

The following tables give the list of supported binary, prefix and postfix
operators.

[table Supported binary operators
   [[operator] [trait name]]
   [[`+`]      [[link boost_typetraits.reference.can_call_addition `can_call_addition __binary_temp`]]]
   [[`-`]      [[link boost_typetraits.reference.can_call_subtraction `can_call_subtraction __binary_temp`]]]
   [[`*`]      [[link boost_typetraits.reference.can_call_multiplication `can_call_multiplication __binary_temp`]]]
   [[`/`]      [[link boost_typetraits.reference.can_call_division `can_call_division __binary_temp`]]]
   [[`%`]      [[link boost_typetraits.reference.can_call_modulus `can_call_modulus __binary_temp`]]]
   [[`+=`]     [[link boost_typetraits.reference.can_call_addition_assignment `can_call_addition_assignment __binary_temp`]]]
   [[`-=`]     [[link boost_typetraits.reference.can_call_subtraction_assignment `can_call_subtraction_assignment __binary_temp`]]]
   [[`*=`]     [[link boost_typetraits.reference.can_call_multiplication_assignment `can_call_multiplication_assignment __binary_temp`]]]
   [[`/=`]     [[link boost_typetraits.reference.can_call_division_assignment `can_call_division_assignment __binary_temp`]]]
   [[`%=`]     [[link boost_typetraits.reference.can_call_modulus_assignment `can_call_modulus_assignment __binary_temp`]]]
   [[`&`]      [[link boost_typetraits.reference.can_call_bitwise_and `can_call_bitwise_and __binary_temp`]]]
   [[`|`]      [[link boost_typetraits.reference.can_call_bitwise_or `can_call_bitwise_or __binary_temp`]]]
   [[`^`]      [[link boost_typetraits.reference.can_call_bitwise_xor `can_call_bitwise_xor __binary_temp`]]]
   [[`&=`]     [[link boost_typetraits.reference.can_call_bitwise_and_assignment `can_call_bitwise_and_assignment __binary_temp`]]]
   [[`|=`]     [[link boost_typetraits.reference.can_call_bitwise_or_assignment `can_call_bitwise_or_assignment __binary_temp`]]]
   [[`^=`]     [[link boost_typetraits.reference.can_call_bitwise_xor_assignment `can_call_bitwise_xor_assignment __binary_temp`]]]
   [[`<<`]     [[link boost_typetraits.reference.can_call_left_shift `can_call_left_shift __binary_temp`]]]
   [[`>>`]     [[link boost_typetraits.reference.can_call_right_shift `can_call_right_shift __binary_temp`]]]
   [[`<<=`]    [[link boost_typetraits.reference.can_call_left_shift_assignment `can_call_left_shift_assignment __binary_temp`]]]
   [[`>>=`]    [[link boost_typetraits.reference.can_call_right_shift_assignment `can_call_right_shift_assignment __binary_temp`]]]
   [[`==`]     [[link boost_typetraits.reference.can_call_equal `can_call_equal __binary_temp`]]]
   [[`!=`]     [[link boost_typetraits.reference.can_call_not_equal `can_call_not_equal __binary_temp`]]]
   [[`<`]      [[link boost_typetraits.reference.can_call_less `can_call_less __binary_temp`]]]
   [[`<=`]     [[link boost_typetraits.reference.can_call_less_equal `can_call_less_equal __binary_temp`]]]
   [[`>`]      [[link boost_typetraits.reference.can_call_greater `can_call_greater __binary_temp`]]]
   [[`>=`]     [[link boost_typetraits.reference.can_call_greater_equal `can_call_greater_equal __binary_temp`]]]
   [[`&&`]     [[link boost_typetraits.reference.can_call_and `can_call_and __binary_temp`]]]
   [[`||`]     [[link boost_typetraits.reference.can_call_or `can_call_or __binary_temp`]]]
]

[table Supported prefix operators
   [[operator] [trait name]]
   [[`!`]      [[link boost_typetraits.reference.can_call_not `can_call_not __prefix_temp`]]]
   [[`+`]      [[link boost_typetraits.reference.can_call_unary_plus `can_call_unary_plus __prefix_temp`]]]
   [[`-`]      [[link boost_typetraits.reference.can_call_unary_minus `can_call_unary_minus __prefix_temp`]]]
   [[`~`]      [[link boost_typetraits.reference.can_call_complement `can_call_complement __prefix_temp`]]]
   [[`*`]      [[link boost_typetraits.reference.can_call_dereference `can_call_dereference __prefix_temp`]]]
   [[`++`]     [[link boost_typetraits.reference.can_call_pre_increment `can_call_pre_increment __prefix_temp`]]]
   [[`--`]     [[link boost_typetraits.reference.can_call_pre_decrement `can_call_pre_decrement __prefix_temp`]]]
]

[table Supported postfix operators
   [[operator] [trait name]]
   [[`++`]     [[link boost_typetraits.reference.can_call_post_increment `can_call_post_increment __postfix_temp`]]]
   [[`--`]     [[link boost_typetraits.reference.can_call_post_decrement `can_call_post_decrement __postfix_temp`]]]
]

[heading Implementation]

The implementation consists in only header files. The following headers should
included first:
``#include <boost/type_traits/can_call.hpp>``
or
``#include <boost/type_traits/can_call_name.hpp>``
where [^name] is the textual name chosen for the wanted operator. The first
method includes all operator traits.

All traits are implemented the same way using preprocessor macros to avoid code
duplication.
The main files are in [^boost/type_traits/detail]: [^can_call_binary_operator.hpp],
[^can_call_prefix_operator.hpp] and [^can_call_postfix_operator.hpp].
The example of prefix `operator-` is presented below:

``
namespace boost {
namespace detail {

// This namespace ensures that ADL does not mess things up.
namespace can_call_unary_minus_impl {

// 1. a function to have an instance of type T without requiring T to be default
// constructible
template <typename T> T &make();


// 2. checks if operator- returns void or not
// conditions: Rhs!=void

// we first redefine "operator," so that we have no compilation error if
// operator- returns void and we can use the return type of
// (-rhs, returns_void_t()) to deduce if
// operator- returns void or not:
// - operator- returns void   -> (-rhs, returns_void_t()) returns returns_void_t
// - operator- returns !=void -> (-rhs, returns_void_t()) returns int
struct returns_void_t {};
template <typename T> int operator,(T const &, returns_void_t);

// this intermediate trait has member value of type bool:
// - value==true -> operator- returns void
// - value==false -> operator- does not return void
template < typename Rhs >
struct operator_returns_void {
   // overloads of function returns_void make the difference
   // yes_type and no_type have different size by construction
   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((- make<Rhs>(),returns_void_t()))));
};


// 3. check for return type if Ret!=dont_care
// conditions: Rhs!=void

struct dont_care { };

template < typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, false > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, true > {
   static const bool value = false;
};

// when Ret!=void, checks if it is convertible to Ret using the sizeof trick
// based on overload resolution
template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret); // this version is preferred for types convertible to Ret
   static ::boost::type_traits::no_type is_convertible_to_Ret(...); // this version is used otherwise

   static const bool value = (sizeof(is_convertible_to_Ret(- make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};


// 4. we provide our operator definition for types that do not have one already

// a type returned from operator- when no such operator is
// found in the type's own namespace so that we have a means to know that our
// operator was used
struct tag { };

// this class allows implicit conversions and makes the following operator
// definition less-preferred than any other such operators that might be found
// via argument-dependent name lookup
struct any { template <class T> any(T const&); };

// when operator- is not available, this one is used
tag operator - (const any&);


// 5. check for operator existence
// condition: Rhs!=void

// check if our definition of operator- is used or an other
// existing one;
// this is done with redefinition of "operator," that returns tag or tag2
struct tag2 { };
tag operator,(tag, tag2);

template < typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(tag2); // this version is preferred when operator exists
   static ::boost::type_traits::no_type check(tag); // this version is used otherwise

   static const bool value = (sizeof(check(((- make<Rhs>()),make<tag2>())))==sizeof(::boost::type_traits::yes_type));
};


// 5. main trait: to avoid any compilation error, this struct behaves
// differently when:
// - operator-(Rhs) is forbidden by the standard
// Forbidden_if is a bool that is:
// - true when the operator-(Rhs) is forbidden by the standard
//   (would yield compilation error if used)
// - false otherwise
template < typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, false > {
   static const bool
      value = (
         ::boost::type_traits::ice_and<
            operator_exists < Rhs >::value,
            operator_returns_Ret < Rhs, Ret, operator_returns_void < Rhs >::value >::value
         >::value
      );
};

// specialization needs to be declared for the special void case
template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};

// defines some typedef for convenience
template < typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   static const bool value = (trait_impl1 < Rhs_noref, Ret, ::boost::is_pointer< Rhs_noref >::value >::value);
};

} // namespace can_call_unary_minus_impl
} // namespace detail

// this is the accessible definition of the trait to end user
template < typename Rhs, typename Ret=::boost::detail::can_call_unary_minus_impl::dont_care >
struct can_call_unary_minus : ::boost::integral_constant<bool,(::boost::detail::can_call_unary_minus_impl::trait_impl < Rhs, Ret >::value)> { };

} // namespace boost
``

[heading Known issues]

* These traits cannot detect whether the operators are public or not:
if an operator is defined as a private member of type `T` then
the instantiation of the corresponding trait will produce a compiler error.
For this reason these traits cannot be used to determine whether a type has a
public operator or not.

``
struct A { private: A operator-(); };
boost::can_call_unary_minus<A>::value; // error: A::operator-() is private
``

* There is an issue if the operator exists only for type `A` and `B` is
convertible to `A`. In this case, the compiler will report an ambiguous overload
because both the existing operator and the one we provide (with argument of type
`any`) need type conversion, so that none is preferred.

``
struct A { };
void operator-(const A&);
struct B { operator A(); };
boost::can_call_unary_minus<A>::value; // this is fine
boost::can_call_unary_minus<B>::value; // error: ambiguous overload between
                                           // operator-(const any&) and
                                           // operator-(const A&)
                                           // both need type conversion
``
``
struct B { };
struct A { A(const B&) { } };
void operator-(const A&);
boost::can_call_unary_minus<A>::value; // this is fine
boost::can_call_unary_minus<B>::value; // error: ambiguous overload between
                                           // operator-(const any&) and
                                           // operator-(const A&)
                                           // both need type conversion
``

[heading Acknowledgments]

Frédéric Bron is very thankful to numerous people from the boost mailing list for their kind help and patience.
In particular, the following persons have been very helpful for the implementation: Edward Diener, Eric Niebler, Jeffrey Lee Hellrung (Jr.), Robert Stewart, Roman Perepelitsa, Steven Watanabe, Vicente Botet.

[endsect]
