[/
  Copyright 2009-2011  Frédéric Bron.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:has_operator_unary_plus has_operator_unary_plus]
   template <class RHS, class RET=void>
   struct has_operator_unary_plus : public __tof {};

__inherit
If (i) `rhs` of type `RHS` can be used in expression `+rhs`,
and (ii) `RET=void` or the result of expression `+rhs` is convertible to `RET`
then inherits from __true_type,
otherwise inherits from __false_type.

The default behaviour (`RET=void`) is to not check for the return value of `operator+`.
If `RET` is different from the default `void` type, the return value is checked to be convertible to `RET`.

This trait can not detect whether `operator+` is public or not: if `operator+` is defined as a private member of `RHS` then
instantiating `has_operator_unary_plus<RHS>` will produce a compiler error.
For this reason `has_operator_unary_plus` can not be used to determine whether a type has a public `operator+` or not.

__header `#include <boost/type_traits/has_operator_unary_plus.hpp>` or `#include <boost/type_traits.hpp>`

__examples

[:`has_operator_unary_plus<RHS, RET>::value_type` is the type `bool`.]

[:`has_operator_unary_plus<int>` inherits from `__true_type`.]

[:`has_operator_unary_plus<int, int>` inherits from `__true_type`.]

[:`has_operator_unary_plus<int, long>` inherits from `__true_type`.]

[:`has_operator_unary_plus<double, double>` inherits from `__true_type`.]

[:`has_operator_unary_plus<double, int>` inherits from `__true_type`.]

[:`has_operator_unary_plus<int, std::string>` inherits from `__false_type`.]

[:`has_operator_unary_plus<long>::value` is a `bool` integral constant
expression that evaluates to /true/.]

[endsect]

