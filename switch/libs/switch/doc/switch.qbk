[library Boost.Switch
  [quickbook 1.4]
  [version 2.0]
  [authors [Watanabe, Steven]]
  [copyright 2007 Steven Watanabe]
  [license
      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      <ulink href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
  ]
  [purpose generates a switch statement]
]

[def __CaseConcept [link boost_switch.reference.Concepts.CaseConcept Case Concept]]

[section:introduction Introduction]

The built in C/C++ switch statement is very efficient.
Unfortunately, unlike a chained if/else construct there
is no easy way to use it when the number of cases depends
on a template parameter.  Such uses are important for
code generation using template metaprogramming.  This
library attempts to provide for these use cases.

[endsect]

[section:Examples Examples]

Here is an example of using Switch to implement the apply_visitor
function from Boost.Variant.  The implementation is fairly straghtforward,
albeit containing a lot of boilerplate.

[import ../example/apply_visitor.cpp]

[apply_visitor_implementation]

Now, it can be used exactly like the original `boost::apply_visitor`

[apply_visitor_usage]

[endsect]

[section:reference Reference]

[section:Concepts Concepts]

[section:CaseConcept Case Concept]

[table Notation
    [[Symbol] [Meaning]]
    [[c] [A Case object]]
    [[C] [A case type]]
    [[I] [An MPL Integral Constant type]]
    [[i] [An MPL Integral Constant object]]
]

[table Valid Expressions
    [[Expression] [Semantics]]
    [[C::labels] [An MPL Forward Sequence of MPL Integral Constants]]
    [[c.apply<R>(i)] [Returns type R.  The type of i must be a member of the sequence C::labels]]
]

[endsect]

[section:SingleCase Single Case]

[table Notation
    [[Symbol] [Meaning]]
    [[c] [A Case object]]
    [[C] [A case type]]
    [[I] [An MPL Integral Constant type]]
    [[i] [An MPL Integral Constant object]]
]

[table Valid Expressions
    [[Expression] [Semantics]]
    [[C::label] [An MPL Integral Constant]]
    [[c()] [Function application.]]
    [[C::fallthrough()] [Returns a bool indicating whether this case should fall through.]]
]

[endsect]

[endsect]

[section:switch_ switch_]

    namespace boost {
    namespace control {

        template<class Result, class Int, class Case>
        Result switch_(Int n, Case case);

        template<class Result, class Int, class Case, class Default>
        Result switch_(Int n, Case case, Default default_);

    }
    }

[*Header]

    #include <boost/control/switch.hpp>

[variablelist Parameters
    [[[^Result]][The type to return.]]
    [[[^n]][Must be of a built-in integal or enumeration type.]]
    [[[^case]][Model of the __CaseConcept.]]
    [[[^default_]][Unary function object such that default_(n) returns a type convertible to the result type]]
]

Generates a switch statement. If the nested ::value of one
of the elements of `Case::labels` is equal to `n`, then this function
will return the result of calling `case.apply<Result>` with a default constructed
parameter of that type.  Otherwise it will pass `n` to `default_`.
If no default was specified, a default constructed instance of Result
will be returned.

Thus, `switch_<R>(n, case, default_)` is equivalent to

    switch(n) {
        typedef typename mpl::at_c<Case::labels, 0>::type case0;
        case case0::value: return(case.apply<R>(case0()));

        typedef typename mpl::at_c<Case::labels, 1>::type case1;
        case case1::value: return(case.apply<R>(case1()));

        typedef typename mpl::at_c<Case::labels, 2>::type case2;
        case case2::value: return(case.apply<R>(case2()));

        ...

        typedef typename mpl::at_c<Case::labels, N>::type caseN;
        case caseN::value: return(case.apply<R>(caseN()));

        default: return(default_(n));
    }

[endsect]

[section:case Case Generators]

    namespace boost {
    namespace control {

        template<class S, class F>
        ``/unspecified/`` case_(F f);

        template<int N0, int N1, int N2, ..., int NN, class F>
        ``/unspecified/`` case_c(F f);

        template<int Low, int High>
        ``/unspecified/`` case_range_c(F f);

    }
    }

[*Header]

    #include <boost/control/case.hpp>

Each of these functions takes a unary function object, `f`.
The return type models the __CaseConcept.  The first form, `case_`,
take an MPL Forward Sequence of MPL Integral constants, `S`, as
an explicit template parameter.  The resulting Case object
has `S` as its labels.  The result of applying the Case object
is to forward the MPL Integral Constant parameter to f.
Thus, it must be possible to apply f to any of the elements
of `S`.

The second, `case_c`, is a shortcut for `case_<mpl::vector_c<int, N0, N1, N2, ..., NN> >(f)`.
The form `case_range_c` is a shortcut for `case_<mpl::range_c<int, Low, High> >`.
[note The return types are not guaranteed to be the same.  However, whatever
the exact type is, it should have equivalent semantics to the long form.]

Cases can be combined together using `operator,`.
The result is the union of the individual cases.
The expression

    case_c<0>(f0), case_c<1>(f1), ... case_c<N>(fN)

For example is a Case which executes `f0(mpl::int_<0>())`
if it is given the parameter `0`, `f1(mpl::int_<1>())`
if given a parameter of `1` and so on.

A plain case can be adapted to make it usable in this
expression template framework, by the function make_case.

    template<class Case>
    ``/unspecified/`` make_case(Case case_);

[endsect]

[section:BOOST_SWITCH_LIMIT BOOST_SWITCH_LIMIT]

    #define BOOST_SWITCH_LIMIT 50

[*Header]

    #include <boost/control/switch.hpp>

Specifies the maximum number of cases supported.
The default value of 50 can be overridden as long
as it is the same in every translation unit.

[endsect]

[endsect]

[section:Alternatives Alternatives]

[section:Map Map]

Another way to achieve similar functionality is to use a map to
function pointers or Boost.Functions.  The advantages of this
approach are

* The number of cases is only limited by memory contraints.
* The key can be any type, not just built-in integers

The disadvantages are:

* The extra indirection makes it harder for the
  compiler to optimize.
* The table needs to be initialized somehow.  The
  easy method of using a local static variable is not
  thread-safe.  Making it thread-safe adds more overhead.

[endsect]

[section:IfElse If/Else]

Another alternative is a chained if/else statement.
The advantages are:

* easy to implement
* no limit to the mumber of cases
* fast for small numbers of cases
* can handle other types besides builtin integers

The disadvantages are:
* slow for a large number of cases

[endsect]

[section:BinarySearch Binary Search]

One final alternative is to use a binary search.
The advantages of this approach are:

* fast for any size table (As fast as a jump table)
* no limit to the number of cases

The disadvantages are:

* compilation will be /sloooooow/ if the cases
  are not already sorted. 

[endsect]

[table Possible Implementations
    [[] [`switch`] [`std::map`] [if/else] [binary search]]
    [[initialization required?]        [no] [yes] [no] [no]]
    [[dispatch speed] [fast] [slow] [slow for large numbers of cases] [fast]]
    [[easy to implement by hand] [no] [yes] [yes] [no]]
    [[limited number of cases?] [yes] [no] [no] [no]]
    [[compilation time] [fast] [fast] [fast] [slow if the cases are not sorted]]
    [[can handle any type?] [no] [yes] [yes] [yes but need to be able to sort at compile time]]
    [[fallthrough?] [yes] [no] [no] [no]]
]

[section:benchmarks Benchmarks]

[table Runtime Benchmark on msvc 9.0 (seconds)
    [[] [consecutive] [spread out]]
    [[switch] [2.953] [3.047]]
    [[if/else] [14.093] [14.563]]
    [[binary_search] [2.922] [2.828]]
    [[std::map] [9.907] [9.953]]
    [[sorted_array] [9.625] [9.89]]
]

[table Runtime Benchmark on g++ 3.4.4 (seconds)
    [[] [consecutive] [spread out]]
    [[switch] [2.656] [2.922]]
    [[if/else] [7.047] [6.984]]
    [[binary_search] [3] [3.031]]
    [[std::map] [50.719] [51.125]]
    [[sorted_array] [9.109] [9.313]]
]

[table Compile Time Benchmark on g++ 3.4.4 for 50 cases (seconds)
    [[] [sorted] [reverse sorted]]
    [[switch] [7.14] [9.50]]
    [[if/else] [5.81] [9.48]]
    [[binary_search] [5.83] [11.98]]
    [[std::map] [10.53] [14.30]]
    [[sorted_array] [10.92] [13.27]]
]

[table Compile Time Benchmark on g++ 3.4.4 for 250 cases (seconds)
    [[] [sorted] [reverse sorted]]
    [[switch] [] [270.61]]
    [[if/else] [] [174.72]]
    [[binary_search] [] [killed after 40 minutes]]
    [[std::map] [] []]
    [[sorted_array] [] []]
]

[endsect]

[endsect]
