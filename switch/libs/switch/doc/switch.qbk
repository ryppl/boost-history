[library Boost.Switch
  [version 1.0]
  [authors [Watanabe, Steven]]
  [copyright 2007 Steven Watanabe]
  [license
      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      <ulink href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
  ]
  [purpose generates a switch statement]
]

[section:introduction Introduction]

The built in C/C++ switch statement is very efficient.
Unfortunately, unlike a chained if/else construct there
is no easy way to use it when the number of cases depends
on a template parameter.  This library attempts to provide
for such usage.

[endsect]

[section:Concepts Concepts]

[section:CaseConcept Case Concept]

[table Notation
    [[Symbol] [Meaning]]
    [[c] [A Case object]]
    [[C] [A case type]]
    [[I] [An MPL Integral Constant type]]
    [[i] [An MPL Integral Constant object]]
]

[table Valid Expressions
    [[Expression] [Semantics]]
    [[C::labels] [An MPL Forward Sequence of MPL Integral Constants]]
    [[c.apply<R>(i)] [Returns type R.  The type of i must be a member of the sequence C::labels]]
]

[endsect]

[section:SingleCase Single Case]

[table Notation
    [[Symbol] [Meaning]]
    [[c] [A Case object]]
    [[C] [A case type]]
    [[I] [An MPL Integral Constant type]]
    [[i] [An MPL Integral Constant object]]
]

[table Valid Expressions
    [[Expression] [Semantics]]
    [[C::label] [An MPL Integral Constant]]
    [[c()] [Function application.]]
    [[C::fallthrough()] [Returns a bool indicating whether this case should fall through.]]
]

[endsect]

[endsect]

[section:switch_ switch_]

    namespace boost {

    template<class Result, class Int, class Case>
    Result switch_(Int n, Case case);

    template<class Result, class Int, class Case, class Default>
    Result switch_(Int n, Case f, Default default_);

    }

[*Header]

    #include <boost/switch.hpp>

[variablelist Parameters
    [[[^Result]][The type to return.]]
    [[[^n]][Must be of a built-in integal or enumeration type.  Statements of the
           form switch(n) {} must be legal.]]
    [[[^case]][Model of the Case concept.]]
    [[[^default_]][Unary function object such that default_(n) returns a type convertible to the result type]]
]

Generates a switch statement. If the nested ::value of one
of the elements of `Cases` is equal to `n`, then this function
will call `f` with a default constructed parameter of that type.
Otherwise it will either pass `n` to `default_` or throw an exception
depending on whether `default_` was specified.

Thus, `switch<R>(n, case, default_)` is equivalent to

    switch(n) {
        case mpl::at_c<Case::labels, 0>::type::value: return(case.apply<R>(mpl::at_c<Case::labels, 0>::type()));
        case mpl::at_c<Case::labels, 1>::type::value: return(case.apply<R>(mpl::at_c<Case::labels, 1>::type()));
        case mpl::at_c<Case::labels, 2>::type::value: return(case.apply<R>(mpl::at_c<Case::labels, 2>::type()));
        ...
        case mpl::at_c<Case::labels, N>::type::value: return(case.apply<R>(mpl::at_c<Case::labels, N>::type()));
        default: return(default_(n));
    }

For example

    template<class FusionSequence>
    struct print_nth_function {
        typedef void result_type;
        template<class Case>
        void operator()(Case) const {
            std::cout << fusion::at<Case>(sequence) << std::endl;
        }
        print_nth(const FusionSequence& s) : sequence(s) {}
        const FusionSequence& sequence;
    };

    struct throw_out_of_range {
        template<class Int>
        void operator()(Int) const {
            throw(std::out_of_range());
        }
    };

    template<class FusionSequence>
    void print_nth(const FusionSequence& s, std::size_t n) {
        typedef typename fusion::result_of::size<FusionSequence>::type size;
        typedef mpl::range_c<std::size_t, 0, size::value> range;
        switch_<void>(n, case<range>(print_nth_function(s)), throw_out_of_range());
    }

prints the nth element of a fusion sequence.

Here is an example of using Switch to implement the apply_visitor
function from Boost.Variant.

    template<class Variant, class Visitor>
    struct apply_visitor_function {
    public:
        apply_visitor_function(Variant& variant, Visitor& visitor) : variant_(variant), visitor_(visitor) {}
        template<int N>
        typedef Visitor::result_type operator()(N) {
            return(visitor_(boost::get<typename mpl::at<typename Variant::type, N> >(variant_)));
        }
    private:
        Variant variant_;
        Visitor visitor_;
    };

    template<class R>
    struct never_called {
        template<class Int>
        R operator()(Int) {
            BOOST_ASSERT(!"this function should never be called.");
        }
    };

    template<class Variant, class Visitor>
    typename Visitor::result_type apply_visitor(Variant& variant, Visitor visitor) {
        apply_visitor_function<Variant, Visitor> f(variant, visitor);
        never_called<typename Visitor::result_type> default_;
        return(switch_<typename Visitor::result_type>(variant.which(), case_<mpl::range_c<int, 0, mpl::size<Variant::types>::value> >, default_));
    }

[endsect]

[section:BOOST_SWITCH_LIMIT BOOST_SWITCH_LIMIT]

    #define BOOST_SWITCH_LIMIT 50

[*Header]

    #include <boost/switch.hpp>

Specifies the maximum number of cases supported.
The default value of 50 can be overridden as long
as it is the same in every translation unit.

[endsect]

[section:Alternatives Alternatives]

[section:Map Map]

Another way to achieve similar functionality is to use a map to
function pointers or Boost.Functions.  The advantages of this
approach are

* The number of cases is only limited by memory contraints.
* The key can be any type, not just built-in integers

The disadvantages are:

* The extra indirection makes it harder for the
  compiler to optimize.
* The table needs to be initialized somehow.  The
  easy method of using a local static variable is not
  thread-safe.  Making it thread-safe adds more overhead.

[endsect]

[section:IfElse If/Else]

Another alternative is a chained if/else statement.
The advantages are:

* easy to implement
* no limit to the mumber of cases
* fast for small numbers of cases
* can handle other types besides builtin integers

The disadvantages are:
* slow for a large number of cases

[endsect]

[section:BinarySearch Binary Search]

One final alternative is to use a binary search.
The advantages of this approach are:

* fast for any size table (As fast as a jump table)
* no limit to the number of cases

The disadvantages are:

* compilation will be /sloooooow/ if the cases
  are not already sorted. 

[endsect]

[table Possible Implementations
    [[] [`switch`] [`std::map`] [if/else] [binary search]]
    [[initialization required?]        [no] [yes] [no] [no]]
    [[dispatch speed] [fast] [slow] [slow for large numbers of cases] [fast]]
    [[easy to implement by hand] [no] [yes] [yes] [no]]
    [[limited number of cases?] [yes] [no] [no] [no]]
    [[compilation time] [fast] [fast] [fast] [slow if the cases are not sorted]]
    [[can handle any type?] [no] [yes] [yes] [yes but need to be able to sort at compile time]]
    [[fallthrough?] [yes] [no] [no] [no]]
]

[section:benchmarks Benchmarks]

[table Runtime Benchmark on msvc 9.0 (seconds)
    [[] [consecutive] [spread out]]
    [[switch] [2.953] [3.047]]
    [[if/else] [14.093] [14.563]]
    [[binary_search] [2.922] [2.828]]
    [[std::map] [9.907] [9.953]]
    [[sorted_array] [9.625] [9.89]]
]

[table Runtime Benchmark on g++ 3.4.4 (seconds)
    [[] [consecutive] [spread out]]
    [[switch] [2.656] [2.922]]
    [[if/else] [7.047] [6.984]]
    [[binary_search] [3] [3.031]]
    [[std::map] [50.719] [51.125]]
    [[sorted_array] [9.109] [9.313]]
]

[table Compile Time Benchmark on g++ 3.4.4 for 50 cases (seconds)
    [[] [sorted] [reverse sorted]]
    [[switch] [7.14] [9.50]]
    [[if/else] [5.81] [9.48]]
    [[binary_search] [5.83] [11.98]]
    [[std::map] [10.53] [14.30]]
    [[sorted_array] [10.92] [13.27]]
]

[table Compile Time Benchmark on g++ 3.4.4 for 250 cases (seconds)
    [[] [sorted] [reverse sorted]]
    [[switch] [] [270.61]]
    [[if/else] [] [174.72]]
    [[binary_search] [] [killed after 40 minutes]]
    [[std::map] [] []]
    [[sorted_array] [] []]
]

[endsect]

[endsect]
