[library Boost.Switch
  [version 1.0]
  [authors [Watanabe, Steven]]
  [copyright 2007 Steven Watanabe]
  [license
      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      <ulink href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
  ]
  [purpose generates a switch statement]
]

[section:introduction Introduction]

The built in C/C++ switch statement is very efficient.
Unfortunately, unlike a chained if/else construct there
is no easy way to use it when the number of cases depends
on a template parameter.  This library attempts to provide
for such usage.

[endsect]

[section:Concepts Concepts]

[section:CaseConcept Case Concept]

[table Notation
    [[Symbol] [Meaning]]
    [[c] [A Case object]]
    [[C] [A case type]]
    [[I] [An MPL Integral Constant type]]
    [[i] [An MPL Integral Constant object]]
]

[table Valid Expressions
    [[Expression] [Semantics]]
    [[C::labels] [An MPL Forward Sequence of MPL Integral Constants]]
    [[c.apply<R>(i)] [Returns type R.  The type of i must be in C::labels]]
]

[endsect]

[section:SingleCase Single Case]

[table Notation
    [[Symbol] [Meaning]]
    [[c] [A Case object]]
    [[C] [A case type]]
    [[I] [An MPL Integral Constant type]]
    [[i] [An MPL Integral Constant object]]
]

[table Valid Expressions
    [[Expression] [Semantics]]
    [[C::label] [An MPL Integral Constant]]
    [[c()] [Function application.]]
    [[C::fallthrough()] [Returns a bool indicating whether this case should fall through.]]
]

[endsect]

[endsect]

[section:switch_ switch_]

    namespace boost {

    template<class Cases, class Int, class F>
    typename F::result_type switch_(Int n, F f);

    template<class Cases, class Int, class F, class Default>
    typename F::result_type switch_(Int n, F f, Default default_);

    }

[*Header]

    #include <boost/switch.hpp>

[variablelist Parameters
    [[[^Cases]][MPL Forward Sequence.  Each of the elements must have a nested integral
        constant ::value suitable for use in a case statement]]
    [[[^n]][Must be of a built-in integal type]]
    [[[^f]][Unary function object.  f(T()) must be defined for every T in Cases and must
        return a type convertible to F::result_type]]
    [[[^default_]][Unary function object such that default_(n) returns a type convertible to the result type]]
]

Generates a switch statement. If the nested ::value of one
of the elements of `Cases` is equal to `n`, then this function
will call `f` with a default constructed parameter of that type.
Otherwise it will either pass `n` to `default_` or throw an exception
depending on whether `default_` was specified.

Thus, `switch<Cases>(n, f, default_)` is equivalent to

    switch(n) {
        case mpl::at_c<Cases, 0>::type::value: return(f(mpl::at_c<Cases, 0>::type()));
        case mpl::at_c<Cases, 1>::type::value: return(f(mpl::at_c<Cases, 1>::type()));
        case mpl::at_c<Cases, 2>::type::value: return(f(mpl::at_c<Cases, 2>::type()));
        ...
        case mpl::at_c<Cases, N>::type::value: return(f(mpl::at_c<Cases, N>::type()));
        default: return(default_(n));
    }

For example

    template<class FusionSequence>
    struct print_nth_function {
        typedef void result_type;
        template<class Case>
        void operator()(Case) const {
            std::cout << fusion::at<Case>(sequence) << std::endl;
        }
        print_nth(const FusionSequence& s) : sequence(s) {}
        const FusionSequence& sequence;
    };

    struct throw_out_of_range {
        template<class Int>
        void operator()(Int) const {
            throw(std::out_of_range());
        }
    };

    template<class FusionSequence>
    void print_nth(const FusionSequence& s, std::size_t n) {
        typedef typename fusion::result_of::size<FusionSequence>::type size;
        typedef mpl::range_c<std::size_t, 0, size::value> range;
        switch_<range>(n, print_nth_function(s), throw_out_of_range());
    }

prints the nth element of a fusion sequence.

[endsect]

[section:BOOST_SWITCH_LIMIT BOOST_SWITCH_LIMIT]

    #define BOOST_SWITCH_LIMIT 50

[*Header]

    #include <boost/switch.hpp>

Specifies the maximum number of cases supported.
The default value of 50 can be overridden as long
as it is the same in every translation unit.

[endsect]

[section:Alternatives Alternatives]

[section:Map Map]

Another way to achieve similar functionality is to use a map to
function pointers or Boost.Functions.  The advantages of this
approach are

* The number of cases is only limited by memory contraints.
* The key can be any type, not just built-in integers

The disadvantages are:

* The extra indirection makes it harder for the
  compiler to optimize.
* The table needs to be initialized somehow.  The
  easy method of using a local static variable is not
  thread-safe.  Making it thread-safe adds more overhead.

[endsect]

[section:IfElse If/Else]

Another alternative is a chained if/else statement.
The advantages are:

* easy to implement
* no limit to the mumber of cases
* fast for small numbers of cases
* can handle other types besides builtin integers

The disadvantages are:
* slow for a large number of cases

[endsect]

[section:BinarySearch Binary Search]

One final alternative is to use a binary search.
The advantages of this approach are:

* fast for any size table (As fast as a jump table)
* no limit to the number of cases

The disadvantages are:

* compilation will be /sloooooow/ if the cases
  are not already sorted. 

[endsect]

[table Possible Implementations
    [[] [`switch`] [`std::map`] [if/else] [binary search]]
    [[initialization required?]        [no] [yes] [no] [no]]
    [[dispatch speed] [fast] [slow] [slow for large numbers of cases] [fast]]
    [[easy to implement by hand] [no] [yes] [yes] [no]]
    [[limited number of cases?] [yes] [no] [no] [no]]
    [[compilation time] [fast] [fast] [fast] [slow if the cases are not sorted]]
    [[can handle any type?] [no] [yes] [yes] [yes but need to be able to sort at compile time]]
]

[section:benchmarks Benchmarks]

[table Runtime Benchmark on msvc 9.0 (seconds)
    [[] [consecutive] [spread out]]
    [[switch] [2.953] [3.047]]
    [[if/else] [14.093] [14.563]]
    [[binary_search] [2.922] [2.828]]
    [[std::map] [9.907] [9.953]]
    [[sorted_array] [9.625] [9.89]]
]

[table Runtime Benchmark on g++ 3.4.4
    [[] [consecutive] [spread out]]
    [[switch] [2.656] [2.922]]
    [[if/else] [7.047] [6.984]]
    [[binary_search] [3] [3.031]]
    [[std::map] [50.719] [51.125]]
    [[sorted_array] [9.109] [9.313]]
]

[endsect]

[endsect]
