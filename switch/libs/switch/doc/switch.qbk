[library Boost.Switch
  [version 1.0]
  [authors [Watanabe, Steven]]
  [copyright 2007 Steven Watanabe]
  [license
      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      <ulink href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
  ]
  [purpose generates a switch statement]
]

[section:introduction Introduction]

The built in C/C++ switch statement is very efficient.
Unfortunately, unlike a chained if/else construct there
is no easy way to use it when the number of cases depends
on a template parameter.  This library attempts to provide
for such usage.

[endsect]

[section:switch_ switch_]

    namespace boost {

    template<class Cases, class Int, class F>
    typename F::result_type switch_(Int n, F f);

    template<class Cases, class Int, class F, class Default>
    typename F::result_type switch_(Int n, F f, Default default_);

    }

[*Header]

    #include <boost/switch.hpp>

[variablelist Parameters
    [[[^Cases]][MPL Forward Sequence.  Each of the elements must have a nested integral
        constant ::value suitable for use in a case statement]]
    [[[^n]][Must be of a built-in integal type]]
    [[[^f]][Unary function object.  f(T()) must be defined for every T in Cases and must
        return a type convertible to F::result_type]]
    [[[^default_]][Unary function object such that default_(n) returns a type convertible to the result type]]
]

Generates a switch statement. If the nested ::value of one
of the elements of `Cases` is equal to `n`, then this function
will call `f` with a default constructed parameter of that type.
Otherwise it will either pass `n` to `default_` or throw an exception
depending on whether `default_` was specified.

Thus, `switch<Cases>(n, f, default_)` is equivalent to

    switch(n) {
        case mpl::at_c<Cases, 0>::type::value: return(f(mpl::at_c<Cases, 0>::type()));
        case mpl::at_c<Cases, 1>::type::value: return(f(mpl::at_c<Cases, 1>::type()));
        case mpl::at_c<Cases, 2>::type::value: return(f(mpl::at_c<Cases, 2>::type()));
        ...
        case mpl::at_c<Cases, N>::type::value: return(f(mpl::at_c<Cases, N>::type()));
        default: return(default_(n));
    }

For example

    template<class FusionSequence>
    struct print_nth_function {
        typedef void result_type;
        template<class Case>
        void operator()(Case) const {
            std::cout << fusion::at<Case>(sequence) << std::endl;
        }
        print_nth(const FusionSequence& s) : sequence(s) {}
        const FusionSequence& sequence;
    };

    struct throw_out_of_range {
        template<class Int>
        void operator()(Int) const {
            throw(std::out_of_range());
        }
    };

    template<class FusionSequence>
    void print_nth(const FusionSequence& s, std::size_t n) {
        typedef typename fusion::result_of::size<FusionSequence>::type size;
        typedef mpl::range_c<std::size_t, 0, size::value> range;
        switch_<range>(n, print_nth_function(s), throw_out_of_range());
    }

prints the nth element of a fusion sequence.

[endsect]

[section:bad_switch bad_switch]

    namespace boost {

    class bad_switch : public std::runtime_error {};

    }

[*Header]

    #include <boost/switch.hpp>

Thrown when the default case is executed
and no default was provided.

[endsect]

[section:BOOST_SWITCH_LIMIT BOOST_SWITCH_LIMIT]

    #define BOOST_SWITCH_LIMIT 50

[*Header]

    #include <boost/switch.hpp>

Specifies the maximum number of cases supported.
The default value of 50 can be overridden as long
as it is the same in every translation unit.

[endsect]

[section:Alternatives Alternatives]

Another way to achieve similar functionality is to use a map to
function pointers or Boost.Functions.  The advantages of this
approach are

* The number of cases is only limited by memory contraints.
* The key can be any type, not just built-in integers

The disadvantages are:

* The extra indirection makes it harder for the
  compiler to optimize.
* The table needs to be initialized somehow.  The
  easy method of using a local static variable is not
  thread-safe.  Making it thread-safe adds more overhead.

[endsect]
