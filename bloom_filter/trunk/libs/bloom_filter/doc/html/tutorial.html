<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" 
	  href="../../../../doc/src/boostbook.css"/>
    <link rel="stylesheet" type="text/css" href="style/my.css"/>

    <title>Boost.BloomFilter</title>  
  </head>

  <body>
    <header>
      <img src="../../../../boost.png" width="277" height="86" 
	   alt="Boost C++ Libraries"/>
      <p>
	<a href="../../../../index.html">Home</a>
	<a href="../../../../libs/libraries.htm">Libraries</a> 
	<a href="http://www.boost.org/users/people.html">People</a> 
	<a href="http://www.boost.org/users/faq.html">FAQ</a> 
	<a href="../../../../more/index.htm">More</a> 
      </p>
    </header>

    <hr/>

    <h2 class="title">Tutorial</h2>

    <p>
      To use this Bloom filter, there are two template parameters to be aware of and two functions to utilize:
    </p>

    <ul>
      <li>Template parameters:
      <ul>
	<li>Type: the type of elements this Bloom filter will store</li>
	<li>Size: the number of bits used to store the Bloom filter state</li>
      </ul>
      </li>
      <li>Basic functions:
      <ul>
	<li><code>void insert(const T&amp;);</code></li>
	<li><code>bool contains(const T&amp;);</code></li>
      </ul>
      </li>
    </ul>

    <p>
      With that out of the way, let's jump into a minimal example.
    </p>

    <div class="listing">
      <code class="c_comment">// introductory Boost.BloomFilter program</code>
      <code class="c_keyword">#include</code> <code class="c_include">&lt;boost/bloom_filter/bloom.hpp&gt;</code>
      <code class="c_keyword">#include</code> <code class="c_include">&lt;iostream&gt;</code>
      <code class="c_keyword">using namespace</code> <code class="c_namespace">boost::bloom_filter</code>;
      <code class="c_keyword">using namespace</code> <code class="c_namespace">std</code>;
	
      <code class="c_type">int</code> <code class="c_func">main</code>() {
        <code class="c_keyword">static const</code> <code class="c_type">size_t</code> <code class="c_id">INSERT_MAX</code> = 5000;
        <code class="c_keyword">static const</code> <code class="c_type">size_t</code> <code class="c_id">CONTAINS_MAX</code> = 10000;
        <code class="c_keyword">static const</code> <code class="c_type">size_t</code> <code class="c_id">NUM_BITS</code> = 512;

        <code class="c_type">bloom_filter</code>&lt;int, NUM_BITS&gt; <code class="c_id">bloom</code>;
	<code class="c_type">size_t</code><code class="c_id"> collisions</code> = 0;

	<code class="c_keyword">for</code> (<code class="c_type">int</code><code class="c_id"> i</code> = 0; i &lt; INSERT_MAX; ++i) {
	  bloom.insert(i);
	}

	<code class="c_keyword">for</code> (<code class="c_type">int</code><code class="c_id"> i</code> = INSERT_MAX; i &lt; CONTAINS_MAX; ++i) {
	  <code class="c_keyword">if</code> (bloom.contains(i)) cout &lt;&lt; "collision" &lt;&lt; endl;
	}

	cout &lt;&lt; <code class="c_str">"collisions: "</code> 
	     &lt;&lt; collisions  
	     &lt;&lt; endl;

	<code class="c_keyword">return</code> 0;
      }
    </div>

    <p>
      Above, we see a simple example that instantiates the default Bloom filter, inserts integers
      0 - 4999, and then queries the existence of those integers. That's all it takes to use
      this Bloom filter!
    </p>
    <p>
      In practice, where false positive rates matter a great deal, care must be taken to choose not
      only the right bitset Size, but also the right number (and implementation) of hash functions.
      This is where the last template parameter comes in, as well as the remaining member functions.
      To use the Bloom filter to its maximum potential, you must understand how to customize
      these remaining parameters.
    </p>
    <ul>
      <li>Advanced template parameters:
      <ul>
	<li><code>HashFunctions</code>:
	a boost::mpl::vector of Hasher objects.</li>
      </ul>
      </li>
      <li>Advanced state monitoring functions:
      <ul>
	<li><code>size_t size() const</code>: returns the value of the template parameter Size</li>
	<li><code>size_t num_hash_functions() const</code>: returns the number of hash functions used to define this Bloom filter.</li>
	<li><code>double false_positive_rate() const </code>: returns the current false positive rate</li>
      </ul>
      </li>
    </ul>

    <p>
      A Hasher is a function object that overloads operator() such that the following interface is satisfied:
    </p>

    <div class="listing">
      <code class="c_keyword">template</code> &lt;<code class="c_keyword">typename</code> <code class="c_id">T, Seed</code>&gt;
      <code class="c_keyword">struct</code> <code class="c_id">ExampleHasher</code> {
        <code class="c_type">size_t</code> <code class="c_func">operator</code>()(<code class="c_keyword">const</code> <code class="c_type">T</code>&) <code class="c_keyword">const</code>;
      };
    </div>
    <p>
      Note that the template parameter Seed isn't strictly required, as 
      long as some form of seeding is present in the Hasher object. By 
      default, boost_hash is defined for users in 
      boost/bloom_filter/hash/default.hpp. This can be used to define 
      Bloom filters with additonal hashing functions easily, as demonstrated below:
    </p>

    <div class="listing">
      <code class="c_comment">// advanced Boost.BloomFilter program</code>
      <code class="c_keyword">#include</code> <code class="c_include">&lt;boost/bloom_filter/bloom.hpp&gt;</code>
      <code class="c_keyword">#include</code> <code class="c_include">&lt;iostream&gt;</code>
      <code class="c_keyword">using namespace</code> <code class="c_namespace">boost::bloom_filter</code>;
      <code class="c_keyword">using namespace</code> <code class="c_namespace">std</code>;
	
      <code class="c_type">int</code> <code class="c_func">main</code>() {
        <code class="c_keyword">typedef</code> <code class="c_namespace">boost::mpl::vector</code>&lt;<code class="c_type">boost_hash</code>&lt;<code class="c_id">int, 1</code>&gt;, 
	                           <code class="c_type">boost_hash</code>&lt;<code class="c_id">int, 2</code>&gt;, 
				   <code class="c_type">boost_hash</code>&lt;<code class="c_id">int, 3</code>&gt; &gt; <code class="c_type">HashFns</code>;

        <code class="c_keyword">static const</code> <code class="c_type">size_t</code> <code class="c_id">INSERT_MAX</code> = 5000;
        <code class="c_keyword">static const</code> <code class="c_type">size_t</code> <code class="c_id">CONTAINS_MAX</code> = 10000;
        <code class="c_keyword">static const</code> <code class="c_type">size_t</code> <code class="c_id">NUM_BITS</code> = 1024;

        <code class="c_type">bloom_filter</code>&lt;int, NUM_BITS, HashFns&gt; <code class="c_id">bloom</code>;
        <code class="c_type">size_t</code><code class="c_id"> collisions</code> = 0;

	cout &lt;&lt; <code class="c_str">"false positive rate: "</code> 
	     &lt;&lt; bloom.false_positive_rate()
	     &lt;&lt; endl;

	<code class="c_keyword">for</code> (<code class="c_type">int</code><code class="c_id"> i</code> = 0; i &lt; INSERT_MAX; ++i) {
	  bloom.insert(i);
	}

	<code class="c_keyword">for</code> (<code class="c_type">int</code><code class="c_id"> i</code> = INSERT_MAX; i &lt; CONTAINS_MAX; ++i) {
	    <code class="c_keyword">if</code> (bloom.contains(i)) ++collisions;
	}

	cout &lt;&lt; <code class="c_str">"false positive rate: "</code> 
	     &lt;&lt; bloom.false_positive_rate()
	     &lt;&lt; endl;

	cout &lt;&lt; <code class="c_str">"collisions: "</code>
	     &lt;&lt; collisions
	     &lt;&lt; endl;

	<code class="c_keyword">return</code> 0;
      }
    </div>

    <p>
      All the details of insertion and querying the Bloom filter are handled
      transparently by the insert() and contains() functions, regardless
      of the type, bit size, and hash functions used. This makes it very
      convenient to experiment with different Bloom filter parameters in
      projects you commit to.
    </p>

    <hr/>

    <footer>
      <p>
	Last revised: <time datetime="2011-06-06">June 6, 2011</time>.
      </p>

      <p class="copyright">
	Copyright &#169; 2011 
	<a href="mailto:cpp.cabrera@gmail.com">Alejandro Cabrera</a>
      </p>
      
      <p class="copyright">
	Distributed under the Boost Software License, Version 1.0. (See
	accompanying file 
	<a href="../../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or
	copy at 
	<a href="http://www.boost.org/LICENSE_1_0.txt">
	  http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
    </footer>

  </body>
</html>
