<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" 
	  href="../../../../doc/src/boostbook.css"/>
    <link rel="stylesheet" type="text/css" href="style/my.css"/>

    <title>Boost.BloomFilter</title>  
  </head>

  <body>
    <header>
      <img src="../../../../boost.png" width="277" height="86" 
	   alt="Boost C++ Libraries"/>
      <p>
	<a href="../../../../index.html">Home</a>
	<a href="../../../../libs/libraries.htm">Libraries</a> 
	<a href="http://www.boost.org/users/people.html">People</a> 
	<a href="http://www.boost.org/users/faq.html">FAQ</a> 
	<a href="../../../../more/index.htm">More</a> 
      </p>
    </header>

    <hr/>

    <h2 class="title">Design</h2>
    
    <div class="toc">
      <ul>
	<li><a href="#overview">Overview</a></li>
	<li><a href="#default_hash">Default Hash Functions</a></li>
	<li><a href="#c++0x">C++0x Considerations</a></li>
	<li><a href="#future">Future Directions</a></li>
      </ul>
    </div>

    <h4>Overview</h4>
    <a name="overview"></a>
    <p>
      This Bloom filter implementation is designed to allow compile-time determination of storage space(in bits), insertion/query type, and hash functions. The design goals were:
    </p>
    <ul>
      <li>Easy to use correctly</li>
      <li>Not difficult to customize regarding use of hash functions</li>
      <li>Fast</li>
      <li>Compact - the amount of space used by the Bloom filter is capped by the size of the underlying std::bitset</li>
      <li>Type-safe - its impossible to insert an element of the wrong type into the Bloom filter.</li>
      <li>Type-safe - its impossible to perform a union or intersect operation between incompatible Bloom filters.</li>
    </ul>
    <p>
      To meet these design goals, the Bloom filter is implemented using template parameters. There are three templates:
    </p>
    <ul>
      <li>Size - number of bits to use for state representation</li>
      <li>Type - type of elements to hash</li>
      <li>HashFunctions - a boost::mpl::vector of hash functions objects</li>
    </ul>
    <p>
      Currently, the Bloom filter executes the hash functions one at a time. It is not hard to imagine an implementation that dispatches lightweight threads to perform each of the k hash functions. 
    </p>

    <h4>Default Hash Functions</h4>
    <a name="default_hash"></a>
    <p>
      To make the Bloom filter easy to use, the HashFunctions template partameter has a default value. This way, if the user wishes to use a Bloom filter for a quick, non-critical task, the user has the ability to just declare and use.
    </p>
    <p>
      The default hash function set consists of three boost_hash function objects seeded with the values 3, 5, and 7. These are implemented using Boost.Functional hash_range. The boost_hash function object is made available in the file boost/bloom_filter/hash/default.hpp for users that wish to use more or fewer hash functions to use their Bloom filter without having to create their own hash function object.
    </p>

    <h4>C++0x Considerations</h4>
    <a name="c++0x"></a>
    <p>
      Currently, this implementation uses boost::mpl::vector, boost::mpl::size, and boost::mpl::at_c for managing the hash function set. When C++0x is widely implemented, it may be beneficial to implement hash function set management in terms of std::tuple, std::tuple_size, and std::tuple_element. This will have to be investigated.
    </p>
    <p>
      Alternatively, it may be possible to use a custom, minimal data structure for storing hash functions based on variadic template expansion. This may yield faster compile times. However, this may be entirely unnecessary since, to the best of my knowledge, std::tuple in (at least) GCC is implemented using variadic templates.
    </p>
    <p>
      C++0x also introduces lambdas. It may be possible to define hash function objects in terms of lambdas for small, localized uses of the Bloom filter class. Testing needs to be done to verify that lambdas can be safely used.
    </p>

    <h4>Future Directions</h4>
    <a name="future"></a>
    <p>
      There are a few planned features that have not yet made it to the Bloom filter package:
    </p>
    <ul>
      <li>[De]Compression policy support via template policy class</li>
      <li>Bloom filter variations implemented as separate classes:
      <ul>
	<li>Counting Bloom filter (deletion support)</li>
	<li>Scaling Bloom filter (constant false positive rate)</li>
	<li>Two-hash Bloom filter (uses two-hash functions to generate k hash values)</li>
	<li>Bloomier filters (?)</li>
      </ul>
      </li>
      <li>Union/intersection of Bloom filters of the same size and same number/type of hash functions differing only by type (types must be convertible).</li>
      <li>Parallel execution of hashing, especially useful for large (>1MB, >32 hash functions) Bloom filters. Such a feature should have a smart, defaulting mechanism that enables parallelism once Size/HashFunction parameters exceed a certain threshold, if parallelism is available on the given platform.</li>
    </ul>
    <p>
      The design space for Bloom filter-like data structures is immense. Given feedback in the future, this section is likely to grow. Please send suggestions to <a href="mailto:cpp.cabrera@gmail.com">Alejandro Cabrera</a>
    </p>
    <hr/>

    <footer>
      <p>
	Last revised: <time datetime="2011-06-06">June 6, 2011</time>.
      </p>

      <p class="copyright">
	Copyright &#169; 2011 
	<a href="mailto:cpp.cabrera@gmail.com">Alejandro Cabrera</a>
      </p>
      
      <p class="copyright">
	Distributed under the Boost Software License, Version 1.0. (See
	accompanying file 
	<a href="../../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or
	copy at 
	<a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
    </footer>

  </body>
</html>
