<?xml version = "1.0" encoding = "UTF-8"?>
<!--
(C) Copyright 2003-2004: Reece H. Dunn 
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-->

<section id = "outfmt.fmtobj"><title>Format Objects</title>
   <para>
      Examples of using format objects can be found in the following files:
      <ulink url = "../../example/pair_output.cpp">libs/outfmt/example/pair_output.cpp</ulink>,
      <ulink url = "../../example/output-2D.cpp">libs/outfmt/example/output-2D.cpp</ulink>,
      <ulink url = "../../example/output-3D.cpp">libs/outfmt/example/output-3D.cpp</ulink> and
      <ulink url = "../../example/john-torjo.cpp">libs/outfmt/example/john-torjo.cpp</ulink>.
   </para>
   <section id = "outfmr.fmtobj-out"><title>Output Facilities</title>
      <para>
         When writing an object to a stream using <code>boost::io::formatob( ex )</code>,
         a <code>FormatObject</code> is created. This <code>FormatObject</code> orchestrates
         how each element in the sequence (array, container or n-ary type) is to be written.
         For non-sequential types, the <code>FormatObject</code> uses operator&lt;&lt;.
         Nested sequential types will be mapped apropriately using automatic type deduction.
         You can customize this writing behavior by specifying a second parameter to
         <code>boost::io::formatob</code>.
      </para><para>
         The <code>FormatObject</code> class has to provide a write function having this
         syntax:
      </para>
      <programlisting>   FormatObject::write( os, fo.ob );</programlisting>
      <para>
         where <code>FormatObject</code> is the format object responsible for
         rendering the type to a stream, <code>os</code> is the output stream,
         <code>fo</code> is the <code>boost::io::formatob_t</code> object and
         <code>ob</code> is the object passed to the manipulator for formatting.
         The <code>write</code> function has the form:
      </para>
      <programlisting>
   template&lt; typename T, class OutputStream &gt;
   inline OutputStream &amp; write( OutputStream &amp; os, const T &amp; value ) const
   (
      // ...
      return( os );
   );</programlisting>
      <para>
         It is possible for <code>T</code> to be a more specialized type (like
         <code>std::pair</code>) in order to perform specialist formatting. Also,
         the <code>FormatObject</code> may divert processing to a nested
         <code>FormatObject</code> making it possible to format complex nested
         constructs.
      </para><para>
         When outputting a sequential type, the format object accesses the delimeter
         values, for example:
      </para>
      <programlisting>
      os &lt;&lt; open()      &lt;&lt; p.first
         &lt;&lt; separator() &lt;&lt; p.second
         &lt;&lt; close();</programlisting>
   </section><section id = "outfmr.fmtobj-in"><title>Input Facilities</title>
      <para>
         When reading an object from a stream using <code>boost::io::formatob( ex )</code>,
         a <code>FormatObject</code> is created. This <code>FormatObject</code> orchestrates
         how each element in the sequence (array, container or n-ary type) is to be read.
         Nested sequential types will be mapped apropriately using automatic type deduction.
         You can customize this writing behavior by specifying a second parameter to
         <code>boost::io::formatob</code>.
      </para><para>
         The <code>FormatObject</code> class has to provide a read function having this
         syntax:
      </para>
      <programlisting>   FormatObject::read( is, fo.ob );</programlisting>
      <para>
         where <code>FormatObject</code> is the format object responsible for
         reading the type from a stream, <code>is</code> is the input stream,
         <code>fo</code> is the <code>boost::io::formatob_t</code> object and
         <code>ob</code> is the object passed to the manipulator for formatting.
         The <code>read</code> function has the form:
      </para>
      <programlisting>
   template&lt; typename T, class InputStream &gt;
   inline bool read( InputStream &amp; is, T &amp; value ) const
   (
      // ...
      return( true );
   );</programlisting>
      <para>
         This function is responsible for reading the data from the stream, placing
         it in the <code>value</code> object. If there is an error during the read
         operation (e.g. the delimeters are incorrect), the function returns
         <code>false</code>.
      </para><para>
         Note that here <code>is</code> will be a <code>boost::io::detail::input_helper</code>
         object that wraps around the calling input stream, accommodating implementation
         differences and providing extra functionality such as <code>match</code> for
         matching character or string types.
      </para><para>
         When reading in an object, the format object uses <code>is.match</code> to check
         a string, for example:
      </para>
      <programlisting>   if( !is.match( open())) return false;</programlisting>
   </section><section id = "outfmr.fmtobj-creating"><title>Creating A Format Object</title>
      <para>
         Format objects are responsible for rendering a sequence to/from a stream. In
         the case of a std::pair, it will have the following format:
      </para>
      <programlisting>   open() &lt;&lt; first &lt;&lt; separator() &lt;&lt; second &lt;&lt; close()</programlisting>
      <para>
         Where <code>open()</code>, <code>close()</code> and <code>separator()</code> are
         the delimeter values taken from either <code>boost::io::openclose_formatter_t</code>
         or <code>boost::io::formatter_t</code>. Therefore, a format object will derive
         from one of these unless it does not specifically process sequence constructs
         (for example, an XML character escaper would not derive from these classes).
         Format objects usually have the following form:
      </para>
      <programlisting>
   template&lt; typename DelimeterType, class FormatObject &gt;
   class fmt_object: public formatter_t
                            &lt;
                               DelimeterType,
                               fmt_object&lt; DelimeterType, FormatObject &gt;,
                               FormatTraits
                            &gt;
   {
      private:
         FormatObject fo;
      public:
         typedef DelimeterType format_type;
         // read and write functions; constructors
   };</programlisting>
      <para>
         where <code>FormatTraits</code> is a class denoting the default delimeter values
         (for example <code>boost::io::detail::default_nary_traits</code>), and
         <code>format_type</code> is the delimeter type (needed for nested format object
         constructs).
      </para><para>
         Here <code>fmt_object</code> is the outer format object, used to render a specific
         sequence type (e.g. arrays). It applies the inner format object (<code>fo</code>)
         to the elements within the sequence instead of formatting them directly. This
         allows nested types to be properly formatted.
      </para><para>
         The example file
         <ulink url = "../../example/john-torjo.cpp">libs/outfmt/example/john-torjo.cpp</ulink>
         creates a custom format object for rendering the following:
      </para>
      <programlisting>   [position] object</programlisting>
      <para>
         where <code>position</code> is the current index within the sequence, starting at
         <code>0</code> and <code>object</code> is the value of the element in the sequence
         at that index.
      </para><para>
         You may also want to provide creator functions to allow the format object to be
         constructed from within the input/output statement. For example, using the XML
         character escaper:
      </para>
      <programlisting>
   std::cout &lt;&lt; boost::io::formatob( str,
                   boost::io::containerfmt( xml::char_escaper())
                ).format( "", "", "" );</programlisting>
   </section><section id = "outfmr.fmtobj-simple"><title>Simple Types</title>
      <section id = "outfmr.fmtobj-basic"><title>boost::io::basicfmt_t</title>
         <programlisting>   class boost::io::basicfmt_t</programlisting>
         <para>
            This is a generic format object that defaults to using the I/O stream
            <code>&lt;&lt;</code> operator for writing and <code>&gt;&gt;</code>
            for reading. (This behaviour is actually implemented by
            <code>boost::io::detail::simple_object</code>).
         </para>
         <section><title>boost::io::basicfmt</title>
            <programlisting>   boost::io::basicfmt();</programlisting>
            <para>
               This creates an object of type <code>boost::io::basicfmt_t</code>. You
               will not generally use this function as all formatting objects default
               to using <code>boost::io::basicfmt_t</code> as the nested format object.
               It is required, however, if you want to default the first argument of a
               pair type, but provide customization of the second. For example:
            </para>
            <programlisting>
   boost::io::pairfmt( boost::io::basicfmt(), boost::io::pairfmt());
   // type: std::pair&lt; int, std::pair&lt; char, float &gt; &gt;</programlisting>
         </section>
      </section><section id = "outfmr.fmtobj-wrapped"><title>boost::io::wrappedfmt_t</title>
         <programlisting>
   template&lt; typename DelimeterType, class FormatObject &gt;
   class boost::io::wrappedfmt_t;</programlisting>
         <para>
            <code>boost::io::wrappedfmt_t</code> inherits its formatting from
            <code>boost::io::openclose_formatter_t</code>, allowing specific formatting
            to be added around a type, for example, adding <code>'</code> around
            characters. This would also be useful for things like formatting a
            complex type as XML data.
         </para>
         <section><title>boost::io::wrappedfmt</title>
            <programlisting>   boost::io::wrappedfmt();</programlisting>
            <para>
               This creates an object of type <code>boost::io::wrappedfmt_t</code>
               using the default format type and format object.
            </para>
            <programlisting>   boost::io::wrappedfmtex&lt; DelimeterType &gt;();</programlisting>
            <para>
               This creates an object of type <code>boost::io::wrappedfmt_t</code>
               using a custom format type.
            </para>
            <programlisting>   boost::io::wrappedfmt( const FormatObject &amp; fo );</programlisting>
            <para>
               This creates an object of type <code>boost::io::wrappedfmt_t</code>
               using a custom format object, inheriting the format type from that
               format object.
            </para>
         </section>
      </section>
   </section><section id = "outfmr.fmtobj-narytype"><title>N-Ary Types</title>
      <para>
         An n-ary type is an object, such as a quaternion, that has a fixed number of
         elements.
      </para>
      <section id = "outfmr.fmtobj-pair"><title>boost::io::pairfmt_t</title>
         <programlisting>
   template&lt; typename DelimeterType, class FormatObject1, class FormatObject2 &gt;
   class boost::io::pairfmt_t;</programlisting>
         <para>
            <code>boost::io::pairfmt_t</code> inherits its formatting from
            <code>boost::io::formatter_t</code>, allowing specific formatting
            to be added around the pair type (<code>std::pair</code>,
            <code>std::complex</code>, <code>boost::rational</code>,
            <code>boost::compressed_pair</code> and <code>boost::numeric::interval</code>).
            This is a special case of static n-ary where each element can have a
            different formatting, allowing constructs like:
         </para>
         <programlisting>
   std::pair&lt; float, std::list&lt; char &gt; &gt;</programlisting>
         <section><title>boost::io::pairfmt</title>
            <programlisting>   boost::io::pairfmt();</programlisting>
            <para>
               This creates an object of type <code>boost::io::pairfmt_t</code>
               using the default format type and format object.
            </para>
            <programlisting>   boost::io::pairfmtex&lt; DelimeterType &gt;();</programlisting>
            <para>
               This creates an object of type <code>boost::io::pairfmt_t</code>
               using a custom format type.
            </para>
            <programlisting>   boost::io::pairfmt( const FormatObject &amp; fo );</programlisting>
            <para>
               This creates an object of type <code>boost::io::pairfmt_t</code>
               using a custom format object for <code>FormatObject1</code>, inheriting
               the format type from that format object.
            </para>
            <programlisting>   boost::io::pairfmt( const FO1 &amp; fo1, const FO2 &amp; fo2 );</programlisting>
            <para>
               This creates an object of type <code>boost::io::pairfmt_t</code>
               using <code>fo1</code> for the <code>FormatObject1</code> format object and
               <code>fo2</code> for <code>FormatObject2</code>, inheriting the format type
               from <code>FO1</code>. If hte format objects have a different format type
               a compilation error will result.
            </para>
         </section>
      </section><section id = "outfmr.fmtobj-nary"><title>boost::io::naryfmt_t</title>
         <programlisting>
   template&lt; typename DelimeterType, class FormatObject &gt;
   class boost::io::naryfmt_t;</programlisting>
         <para>
            <code>boost::io::naryfmt_t</code> inherits its formatting from
            <code>boost::io::formatter_t</code>, allowing specific formatting
            to be added around a 4-ary (<code>boost::math::quaternion</code>) or 8-ary
            (<code>boost::math::octonion</code>) type.
         </para>
      </section>
         <section><title>boost::io::naryfmt</title>
            <programlisting>   boost::io::naryfmt();</programlisting>
            <para>
               This creates an object of type <code>boost::io::naryfmt_t</code>
               using the default format type and format object.
            </para>
            <programlisting>   boost::io::naryfmtex&lt; DelimeterType &gt;();</programlisting>
            <para>
               This creates an object of type <code>boost::io::naryfmt_t</code>
               using a custom format type.
            </para>
            <programlisting>   boost::io::naryfmt( const FormatObject &amp; fo );</programlisting>
            <para>
               This creates an object of type <code>boost::io::naryfmt_t</code>
               using a custom format object, inheriting the format type from that
               format object.
            </para>
         </section>
   </section><section id = "outfmr.fmtobj-seq"><title>Sequences</title>
      <section id = "outfmr.fmtobj-array"><title>boost::io::arrayfmt_t</title>
         <programlisting>
   template&lt; typename DelimeterType, class FormatObject &gt;
   class boost::io::arrayfmt_t;</programlisting>
         <para>
            <code>boost::io::arrayfmt_t</code> inherits its formatting from
            <code>boost::io::formatter_t</code>, allowing specific formatting
            to be added around an array construct. It allows you to specify an
            offset and length in order to create sub-ranges.
         </para>
         <section><title>boost::io::arrayfmt</title>
            <programlisting>
   boost::io::arrayfmt( long len );
   boost::io::arrayfmt( long off, long len );</programlisting>
            <para>
               This creates an object of type <code>boost::io::arrayfmt_t</code>
               using the default format type and format object, where <code>len</code>
               is the number of elements within the array to be processed and
               <code>off</code> is the offset from the first element within the array.
            </para>
            <programlisting>
   boost::io::arrayfmtex&lt; DelimeterType &gt;( long len );
   boost::io::arrayfmtex&lt; DelimeterType &gt;( long off, long len );</programlisting>
            <para>
               This creates an object of type <code>boost::io::arrayfmt_t</code>
               using a custom format type, where <code>len</code> is the number of
               elements within the array to be processed and <code>off</code> is the
               offset from the first element within the array.
            </para>
            <programlisting>
   boost::io::arrayfmtout( const FormatObject &amp; fo, long len );
   boost::io::arrayfmtout( const FormatObject &amp; fo, long off, long len );</programlisting>
            <para>
               This creates an object of type <code>boost::io::arrayfmt_t</code>
               using a custom format object, inheriting the format type from that
               format object, where <code>len</code> is the number of elements
               within the array to be processed and <code>off</code> is the offset
               from the first element within the array.
            </para>
         </section>
      </section><section id = "outfmr.fmtobj-container"><title>boost::io::containerfmt_t</title>
         <programlisting>
   template&lt; typename DelimeterType, class FormatObject &gt;
   class boost::io::containerfmt_t;</programlisting>
         <para>
            <code>boost::io::containerfmt_t</code> inherits its formatting from
            <code>boost::io::formatter_t</code>, allowing specific formatting
            to be added around an STL container type.
         </para>
         <section><title>boost::io::containerfmt</title>
            <programlisting>   boost::io::containerfmt();</programlisting>
            <para>
               This creates an object of type <code>boost::io::containerfmt_t</code>
               using the default format type and format object.
            </para>
            <programlisting>   boost::io::containerfmtex&lt; DelimeterType &gt;();</programlisting>
            <para>
               This creates an object of type <code>boost::io::containerfmt_t</code>
               using a custom format type.
            </para>
            <programlisting>   boost::io::containerfmt( const FormatObject &amp; fo );</programlisting>
            <para>
               This creates an object of type <code>boost::io::containerfmt_t</code>
               using a custom format object, inheriting the format type from that
               format object.
            </para>
         </section>
      </section><section id = "outfmr.fmtobj-range"><title>boost::io::rangefmt_t</title>
         <programlisting>
   template&lt; typename DelimeterType, class FormatObject &gt;
   class boost::io::rangefmt_t;</programlisting>
         <para>
            <code>boost::io::rangefmt_t</code> inherits its formatting from
            <code>boost::io::formatter_t</code>, allowing specific formatting
            to be added around an object created by <code>boost::io::range</code>.
         </para>
         <section><title>boost::io::rangefmt</title>
            <programlisting>   boost::io::rangefmt();</programlisting>
            <para>
               This creates an object of type <code>boost::io::rangefmt_t</code>
               using the default format type and format object.
            </para>
            <programlisting>   boost::io::rangefmtex&lt; DelimeterType &gt;();</programlisting>
            <para>
               This creates an object of type <code>boost::io::rangefmt_t</code>
               using a custom format type.
            </para>
            <programlisting>   boost::io::rangefmt( const FormatObject &amp; fo );</programlisting>
            <para>
               This creates an object of type <code>boost::io::rangefmt_t</code>
               using a custom format object, inheriting the format type from that
               format object.
            </para>
         </section>
      </section>
   </section><section id = "outfmr.fmtobj-fmtob"><title>boost::io::formatob_t</title>
      <programlisting>
   template&lt; typename T, typename DelimeterType, class FormatObject >
   class boost::io::formatob_t;</programlisting>
      <para>
         This is the class that is created using the <code>boost::io::formatob</code>
         manipulator. It behaves like the <code>boost::io::formatter_t</code> class,
         redirecting the calls to <code>FormatObject</code>. See
         <link linkend = "outfmt.manip">boost::io::formatob</link> for a discussion on
         creating a <code>boost::io::formatob_t</code> object.
      </para>
   </section><section id = "outfmr.fmtobj-state"><title>boost::io::statefmt_t</title>
      <programlisting>
   template&lt; typename DelimeterType, class StateObject, bool pre, class FormatObject &gt;
   class boost::io::statefmt_t;</programlisting>
      <para>
         <code>boost::io::statefmt_t</code> does not inherit any formatting because
         it only renders a state object to the stream, paired with a format object
         for the type it surrounds. If <code>pre</code> is <code>true</code>, it will
         render:
      </para>
      <programlisting>   [StateObject][FormatObject]</programlisting>
      <para>
         to the stream, where <code>[StateObject]</code> is the output generated by the
         state object and <code>[FormatObject]</code> is the output generated by the
         format object. If <code>pre</code> is <code>false</code>, it will render:
      </para>
      <programlisting>   [FormatObject][StateObject]</programlisting>
      <para>
         to the stream.
      </para>

      <section id = "outfmr.fmtobj-stateob"><title>State Objects</title>
         <para>A state object is a type of function object that has the form:</para>
         <programlisting>
   template&lt; class OutputStream &gt;
   inline OutputStream &amp; operator()
   (
      OutputStream &amp; os
   );</programlisting>
         <para>A state object should only output state information to the stream.</para>
      </section><section><title>boost::io::statefmt</title>
         <programlisting>   boost::io::statefmt&lt; StateObject, pre &gt;();</programlisting>
         <para>
            This creates an object of type <code>boost::io::statefmt_t</code>
            using the default format type and format object, where
            <code>StateObject</code> is the state object class to be used
            and <code>pre</code> is an indicator whether the state object is
            rendered before or after the element <code>boost::io::statefmt_t</code>
            surrounds.
         </para>
         <programlisting>   boost::io::statefmtex&lt; DelimeterType, StateObject, pre &gt;();</programlisting>
         <para>
            This creates an object of type <code>boost::io::statefmt_t</code>
            using a custom format type, where <code>StateObject</code> is the
            state object class to be used and <code>pre</code> is an indicator
            whether the state object is rendered before or after the element
            <code>boost::io::statefmt_t</code> surrounds.
         </para>
         <programlisting>   boost::io::statefmt&lt; StateObject, pre &gt;( const FormatObject &amp; fo );</programlisting>
         <para>
            This creates an object of type <code>boost::io::statefmt_t</code>
            using a custom format object, inheriting the format type from that
            format object, where <code>StateObject</code> is the state object
            class to be used and <code>pre</code> is an indicator whether the
            state object is rendered before or after the element
            <code>boost::io::statefmt_t</code> surrounds.
         </para>
      </section>
   </section><section id = "outfmr.fmtobj-errormsg"><title>I Get Long Error Messages When I Try To Compile</title>
      <para>
         This is due to the template-based nature of the library. Locate the
         <code>boost::io::formatob</code> call where the errors originate and
         check to see if the format object construct matches with the type
         of the object you are formatting.
      </para>
   </section>
</section>
