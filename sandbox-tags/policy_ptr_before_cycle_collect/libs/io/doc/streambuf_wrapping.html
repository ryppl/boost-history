<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>I/O Stream-buffer-wrapping Stream Base Library</title>
</head>
<body text="black" bgcolor="white" link="blue" vlink="purple" alink="red">
<h1><img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="middle" width="277" height="86">Stream-buffer-wrapping Streams</h1>

<p>The header <cite><a
href="../../../boost/io/streambuf_wrapping.hpp">boost/io/
streambuf_wrapping.hpp</a></cite> covers base class templates for easily
wrapping new stream-buffer classes in streams.</p>

<h2><a name="contents">Contents</a></h2>

<ol>
	<li><a href="#contents">Contents</a></li>
	<li><a href="#rationale">Rationale</a></li>
	<li><a href="#header">Header Synopsis</a></li>
	<li><a href="#common">Common Interface</a>
		<ul>
			<li><a href="#m_types">Member Types</a></li>
			<li><a href="#m_ctr">Constructors</a></li>
			<li><a href="#m_observe">Observer Member Functions</a></li>
		</ul></li>
	<li><a href="#example">Example</a></li>
	<li><a href="#refer">References</a></li>
	<li><a href="#credits">Credits</a>
		<ul>
			<li><a href="#contributors">Contributors</a></li>
			<li><a href="#history">History</a></li>
		</ul></li>
</ol>

<h2><a name="rationale">Rationale</a></h2>

<p>To extend the C++ IOStream system with a new character sink and/or
source, a stream-buffer class (template) is defined with the appropriate
transfer (and buffering) properties.  The actual I/O is done with a
stream object, that sends/receives characters via a stream-buffer
object.  The Standard stream base class templates are designed to use
stream buffers with an independent lifetime, and include functionality
for switching what stream buffer is used.  The specialized Standard
stream class templates can include a special stream buffer within the
stream.</p>

<p>All the Standard specialized stream class templates use customized
code to connect with their internal stream buffer.  This library
provides base class templates that provide standard ways of using an
internal stream buffer, accessing that stream buffer, and checking if
the stream buffer's stream switched to an external stream buffer.
Streams built around combining custom stream buffers with these
wrappers can enrich an I/O library, since the developer doesn't have
to worry about all the issues of creating matching stream classes for
a stream buffer class.</p>

<h2><a name="header">Header Synopsis</a></h2>

<blockquote><pre>
namespace boost
{
namespace io
{

template &lt; class StreamBuf &gt;
    class basic_wrapping_istream;

template &lt; class StreamBuf &gt;
    class basic_wrapping_ostream;

template &lt; class StreamBuf &gt;
    class basic_wrapping_iostream;

}
}
</pre></blockquote>

<h2><a name="common">Common Interface</a></h2>

<p>The three base class templates have the following public (and
protected) interface.  Just substitute &quot;<code>istream</code>,&quot;
&quot;<code>ostream</code>,&quot; or &quot;<code>iostream</code>&quot;
for <var>stream</var>.</p>

<blockquote><pre>
#include &lt;istream&gt;  <i>// for std::basic_istream, std::basic_iostream</i>
#include &lt;ostream&gt;  <i>// for std::basic_ostream</i>

template &lt; class StreamBuf &gt;
class boost::io::basic_wrapping_<var>stream</var>
    : public std::basic_<var>stream</var>&lt; typename StreamBuf::char_type,
       typename StreamBuf::traits_type &gt;
{
public:
    // Types
    typedef StreamBuf  streambuf_type;

    typedef typename StreamBuf::char_type    char_type;
    typedef typename StreamBuf::traits_type  traits_type;

    typedef typename StreamBuf::int_type  int_type;
    typedef typename StreamBuf::pos_type  pos_type;
    typedef typename StreamBuf::off_type  off_type;

    // Accessors
    streambuf_type *  rdbuf();

    streambuf_type const *  rdbuf() const;

    bool  is_using_internal_streambuf() const;

protected:
    // Constructors
    explicit  basic_wrapping_<var>stream</var>( streambuf_type const &amp;s );

    basic_wrapping_<var>stream</var>();

    template &lt; typename T1 &gt;
    explicit  basic_wrapping_<var>stream</var>( T1 x1 );

    template &lt; typename T1, typename T2 &gt;
    basic_wrapping_<var>stream</var>( T1 x1, T2 x2 );

    template &lt; typename T1, typename T2, typename T3 &gt;
    basic_wrapping_<var>stream</var>( T1 x1, T2 x2, T3 x3 );

};
</pre></blockquote>

<p>The template argument <var>StreamBuf</var> should represent a
stream-buffer class.  The class must have member types
<code>char_type</code>, <code>traits_type</code>, <code>int_type</code>,
<code>pos_type</code>, and <code>off_type</code>.  The class must
(publically) derive from <code>std::basic_streambuf&lt;char_type,
traits_type&gt;</code>.</p>

<p>These class templates are only meant for (direct) derivation.  A
derived class is a stream class (template) that should support the
public (and protected) member interface of its internal stream buffer. 
The <code>rdbuf</code> member functions can be used for
forwarding to the stream buffer's interface.</p>

<h3><a name="m_types">Member Types</a></h3>

<dl>
	<dt><code>streambuf_type</code>
	<dd>a synonym for the stream buffer type used as the template parameter

	<dt><code>char_type</code>
	<dd>a synonym for the stream buffer's character type

	<dt><code>traits_type</code>
	<dd>a synonym for the stream buffer's character-traits type

	<dt><code>int_type</code>
	<dd>a synonym for the stream buffer's character with end-of-file type

	<dt><code>pos_type</code>
	<dd>a synonym for the stream buffer's position type

	<dt><code>off_type</code>
	<dd>a synonym for the stream buffer's offset type
</dl>

<h3><a name="m_ctr">Constructors</a></h3>

<p><strong>Note:</strong> the automatically-defined destructor is used.</p>

<dl>
	<dt><code>explicit  basic_wrapping_<var>stream</var>( streambuf_type
		const &amp;s );</code>
	<dd>
		<strong>Requires:</strong> <code>streambuf_type</code>
			support copy construction (via a constant reference)<br>
		<strong>Effects:</strong> initializes the internal stream
			buffer to a copy of <var>s</var>

	<dt><code>basic_wrapping_<var>stream</var>();</code>
	<dd>
		<strong>Requires:</strong> the stream buffer support default
			construction<br>
		<strong>Effects:</strong> initializes the internal stream
			buffer to a default state

	<dt><code>template &lt; typename T1 &gt;  explicit 
		basic_wrapping_<var>stream</var>( T1 x1 );</code>
	<dd>
		<strong>Requires:</strong> the stream buffer support
			construction with a single argument of the type
			<code>T1</code><br>
		<strong>Effects:</strong> initializes the internal stream
			buffer with <var>x1</var>

	<dt><code>template &lt; typename T1, typename T2 &gt; 
		basic_wrapping_<var>stream</var>( T1 x1, T2 x2 );</code>
	<dd>
		<strong>Requires:</strong> the stream buffer support
			construction with two arguments of types <code>T1</code> and
			<code>T2</code>, respectively<br>
		<strong>Effects:</strong> initializes the internal stream
			buffer with <var>x1</var> and <var>x2</var>

	<dt><code>template &lt; typename T1, typename T2, typename T3 &gt; 
		basic_wrapping_<var>stream</var>( T1 x1, T2 x2, T3 x3 );</code>
	<dd>
		<strong>Requires:</strong> the stream buffer support
			construction with three arguments of types <code>T1</code>,
			<code>T2</code> and <code>T3</code>, respectively<br>
		<strong>Effects:</strong> initializes the internal stream
			buffer with <var>x1</var>, <var>x2</var> and
			<var>x3</var>
</dl>

<h3><a name="m_observe">Observer Member Functions</a></h3>

<dl>
	<dt><code>streambuf_type *  rdbuf();</code>
	<dd>
		<strong>Returns:</strong> a pointer to the internal stream
			buffer<br>
		<strong>Rationale:</strong> gives access to the stream's
			internal stream buffer, no matter what stream buffer the
			stream is currently using; helps forward function calls to
			the internal stream buffer

	<dt><code>streambuf_type const *  rdbuf()
		const;</code>
	<dd>
		<strong>Returns:</strong> a pointer to the internal stream
			buffer<br>
		<strong>Rationale:</strong> same as the
			non-<code>const</code> version

	<dt><code>bool  is_using_internal_streambuf() const;</code>
	<dd>
		<strong>Returns:</strong> <code>this-&gt;rdbuf() ==
			this-&gt;std::basic_ios&lt;char_type,
                        traits_type&gt;::rdbuf()</code><br>
		<strong>Rationale:</strong> the only reliable way to check if
			a stream is using its internal stream buffer; if
			<code>false</code> is returned, then no modifying operations
			applied to the internal stream buffer could affect the
			containing stream's processing
</dl>

<h2><a name="example">Example</a></h2>

<p>Let's take a stream-buffer class (template) that acts as a null-source/sink:</p>

<blockquote><pre>
#include &lt;ios&gt;        <i>// for std::streamsize</i>
#include &lt;streambuf&gt;  <i>// for std::basic_streambuf</i>
#include &lt;string&gt;     <i>// for std::char_traits</i>

template &lt; typename Ch, class Tr = std::char_traits&lt;Ch&gt; &gt;
class basic_nulbuf
    : public std::basic_streambuf&lt; Ch, Tr &gt;
{
public:
    typedef Ch  char_type;
    typedef Tr  traits_type;

    typedef typename Tr::int_type  int_type;
    typedef typename Tr::pos_type  pos_type;
    typedef typename Tr::off_type  off_type;

    basic_nulbuf() {}  // Ensure a public constructor

protected:
    // The default versions work except for these two methods:

    virtual  std::streamsize
    xsputn( char_type const *, std::streamsize n )
    { return n; }

    virtual  int_type
    overflow( int_type c = traits_type::eof() )
    { return traits_type::not_eof( c ); }
};

typedef basic_nulbuf&lt;char&gt;      nulbuf;
typedef basic_nulbuf&lt;wchar_t&gt;  wnulbuf;
</pre></blockquote>

<p>It can be simply used like:</p>

<blockquote><pre>
#include &quot;nulbuf.hpp&quot;   <i>// for nulbuf</i>
#include &lt;ostream&gt;      <i>// for std::ostream</i>

int main()
{
    nulbuf        nb;
    std::ostream  n( &amp;nb );

    n &lt;&lt; &quot;whatever&quot;;
}
</pre></blockquote>

<p>Instead of attaching this stream buffer with a stream right before printing,
a class combining the stream buffer and the stream can be used:</p>

<blockquote><pre>
#include &lt;cstddef&gt;     <i>// for NULL</i>
#include &quot;nulbuf.hpp&quot;  <i>// for basic_nulbuf</i>
#include &lt;ostream&gt;     <i>// for std::basic_ostream</i>
#include &lt;string&gt;      <i>// for std::char_traits</i>

template &lt; typename Ch, class Tr = std::char_traits&lt;Ch&gt; &gt;
class basic_nulostream
    : public std::basic_ostream&lt; Ch, Tr &gt;
{
    typedef std::basic_ostream&lt;Ch, Tr&gt;  base_type;

    basic_nulbuf&lt;Ch, Tr&gt;  buf_;

public:
    basic_nulostream()
        : base_type( NULL )
    {
        this-&gt;init( &amp;buf_ );
    }
};

typedef basic_nulostream&lt;char&gt;      nulostream;
typedef basic_nulostream&lt;wchar_t&gt;  wnulostream;
</pre></blockquote>

<p>The above technique can work because, for streams, calling the <code>init</code>
member function after construction is equivalent to calling the constructor with
the proper stream buffer pointer directly.  For those who are strict about proper
construction, an equivalent solution is:</p>

<blockquote><pre>
#include &quot;nulbuf.hpp&quot;  <i>// for basic_nulbuf</i>
#include &lt;ostream&gt;     <i>// for std::basic_ostream</i>
#include &lt;string&gt;      <i>// for std::char_traits</i>

// Check out &lt;boost/utility/base_from_member.hpp&gt;
// to generalize this technique
template &lt; typename Ch, class Tr &gt;
struct my_wrapper
{
    basic_nulbuf&lt;Ch, Tr&gt;  buf_;
};

template &lt; typename Ch, class Tr = std::char_traits&lt;Ch&gt; &gt;
class basic_nulostream
    : private my_wrapper&lt; Ch, Tr &gt;
    , public std::basic_ostream&lt; Ch, Tr &gt;
{
    typedef std::basic_ostream&lt;Ch, Tr&gt;  base_type;

public:
    basic_nulostream()
        : base_type( &amp;buf_ )  // The inheritance order matters!
    {}
};

typedef basic_nulostream&lt;char&gt;      nulostream;
typedef basic_nulostream&lt;wchar_t&gt;  wnulostream;
</pre></blockquote>

<p>Either technique can compact the final code to:</p>

<blockquote><pre>
#include &quot;nulstream.hpp&quot;  <i>// for nulostream </i>

int main()
{
    nulostream  nos;

    nos &lt;&lt; &quot;whatever&quot;;
}
</pre></blockquote>

<p>The code in this library just generalizes the second technique:</p>

<blockquote><pre>
#include &quot;nulbuf.hpp&quot;                       <i>// for basic_nulbuf</i>
#include &lt;boost/io/streambuf_wrapping.hpp&gt;  <i>// for boost::io::basic_wrapping_ostream</i>
#include &lt;string&gt;                           <i>// for std::char_traits</i>


template &lt; typename Ch, class Tr = std::char_traits&lt;Ch&gt; &gt;
class basic_nulostream
    : public boost::io::basic_wrapping_ostream&lt; basic_nulbuf&lt;Ch, Tr&gt; &gt;
{
public:
    basic_nulostream() {}
};

typedef basic_nulostream&lt;char&gt;      nulostream;
typedef basic_nulostream&lt;wchar_t&gt;  wnulostream;
</pre></blockquote>

<h2><a name="refer">References</a></h2>

<ul>
	<li>The streambuf-wrapping streams library header itself: <cite><a
		href="../../../boost/io/streambuf_wrapping.hpp">boost/io/
		streambuf_wrapping.hpp</a></cite></li>
	<li>Tests and examples can be seen in the stream libraries that use
		this library, like <a href="array_stream.html">array-based
		streams</a>.</li>
</ul>

<h2><a name="credits">Credits</a></h2>

<h3><a name="contributors">Contributors</a></h3>

<dl>
	<dt><a href="../../../people/daryle_walker.html">Daryle Walker</a>
	<dd>Started the library.  Contributed the initial versions of the
		streambuf-wrapping stream base class templates.
</dl>

<h3><a name="history">History</a></h3>

<dl>
	<dt>11 Nov 2002, Daryle Walker
	<dd>Initial version
</dl>

<hr>

<p>Revised: 7 June 2003</p>

<p>Copyright 2003 Daryle Walker.  Use, modification, and distribution
are subject to the Boost Software License, Version 1.0.  (See accompanying
file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or a copy at
&lt;<a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>&gt;.</p>
</body>
</html>
