<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Boost.Move Library</title>
<meta content="Eric Friedman, mailto:ebf@users.sourceforge.net" name="author">
</head>

<body text="#000000" bgColor="#ffffff">

<h1>
    <img height="86" src="../../c++boost.gif" width="277" align="center" border="0">
    Boost.Move Library
</h1>
<h2>Overview</h2>
<ul>
  <li><a href="#motivation">Motivation</a></li>
  <li><a href="#examples">Examples</a></li>
  <li>Header <code>&quot;boost/move.hpp&quot;</code></li><ul>
    <li><a href="#move-synopsis">Synopsis</a></li>
  </ul>
  <li>Header <code>&quot;boost/move/move.hpp&quot;</code></li><ul>
    <li><a href="move.html#synopsis">Synopsis</a></li>
    <li><code><a href="move.html#move">move</a></code></li>
    <li><code><a href="move.html#return_t">return_t</a></code></li>
    <li><code><a href="move.html#algorithm-move_swap">move_swap</a></code> algorithm</li>
    <li><code><a href="move.html#algorithm-move">move</a></code> algorithm</li>
    <li><code><a href="move.html#algorithm-move_backwards">move_backwards</a></code> algorithm</li>
    <li><code><a href="move.html#algorithm-move_backwards">move_backwards</a></code> algorithm</li>
  </ul>
  <li>Header <code>&quot;boost/move/moveable.hpp&quot;</code></li><ul>
    <li><a href="moveable.html#synopsis">Synopsis</a></li>
    <li><code><a href="moveable.html#moveable">moveable</a></code></li>
    <li><code><a href="moveable.html#move_source">move_source</a></code></li>
    <li><code><a href="moveable.html#move_return">move_return</a></code></li>
  </ul>
  <li><a href="#portability">Portability</a></li>
  <li>Credits<ul>
      <li><a href="#acknowledgments">Acknowledgments</a></li>
      <li><a href="#bibliography">Bibliography</a></li>
    </ul>
  </li>
  </ul>
<hr>
<h2><a name="motivation">Motivation</a></h2>
<p>Given a source object and destination storage, there are two kinds of 
relocation operations: <i>copy</i> and <i>move</i>. The <i>copy</i> operation is well known to every C++ programmer; indeed, C++ 
features explicit language support for the operation in the form of copy 
constructors. On the other hand, the <i>move </i>operation is less common in C++; often a 
C++ programmer's only 
experience with the move operation is from the <code>auto_ptr</code> class template 
in the Standard Library, whose &quot;copy&quot; constructors' behavior is relatively unusual. The 
behavior of <code>auto_ptr</code>'s constructors is most commonly termed &quot;destructive copy.&quot; As we will see, the move operation is often quite similar to this &quot;destructive copy&quot; behavior.</p>
<p>Now let's define the two operations more precisely.</p>
<p><i>Copying</i> results in the construction of an object in the 
destination storage that is equal to the source object's given state. Note, however, that copying 
does not alter the source object's state in any way. This, of course, is what allows a <code>const</code> arguments for copy construction and assignment.</p>
<p><i>Moving</i>, like copying, results in the construction of an object in the 
destination storage that is equal to the source object's given state. In this regard, 
moving is a subset of copying. Unlike copying, however, moving may alter the state of the source object unpredictably provided the object's type invariants are maintained. Thus, because a move may alter the source object, move construction and assignment operate only on non-<code>const</code> arguments.</p>
<p>Why, then, is the move operation important? If the functional behavior of the move 
operation is a subset of the copy operation's behavior, why not simply always 
use the copy operation, which, moreover, does not require non-<code>const</code> source 
objects?</p>
<p>The answer lies in two parts: efficiency and exception-safety.</p>
<p>The move operation often improves program efficiency and may prove essential in meeting certain complexity requirements. Copy operations are often used when move operations would work equally well -- such as when returning the result of a function. Moving an object is often more efficient (and otherwise <i>no less 
efficient</i>) than copying: dynamically-allocated content can often be moved by simply copying its pointer, 
whereas <i>copying</i> the content requires both new storage allocation and a copy of the content's data -- in sum, a vastly more complex operation.</p>
<p>The move operation is also often safer than copying. Indeed, the move operation on most types can provide a no-throw guarantee or Abraham's strong guarantee of <a href="../../more/generic_exception_safety.html">exception-safety</a> without a compromise in efficiency. 
For example, objects with dynamically-allocated contents cannot provide a copy operation with a no-throw guarantee because it relies on the dynamic allocation of the destination storage, and dynamic allocation of memory does not satisfy the 
no-throw guarantee. On the other hand, since the move operation is not required to maintain the state of the source object, its implementation for such objects is straightforward, simply shallow-copying the <i>pointer</i> rather than deep-copying the content.</p>
<p>Additionally, the move operation is useful in allowing the 
relocation of statically-allocated objects whose types otherwise do not 
logically support the copy operation; common examples of such types are a 
variety of system-level classes such as threads, files, and sockets. Also, the 
ability to guarantee the success of an object's relocation in memory 
is important in the implementation of some efficient garbage collectors [<a href="#bib-sut02">Sut02</a>].</p>
<p>The <b>Boost.Move</b> library provides solutions to address the problems described 
above:</p>
<ul>
  <li>The <code><a href="moveable.html#moveable">moveable</a></code> class template, from which a user type derives to enable support for move operations on that type.</li>
  <li>The <code><a href="moveable.html#move_source">move_source</a></code> class template, which receives an object to be moved. For example, a constructor receiving a <code>move_source</code> constructs a new object by moving the source object.</li>
  <li>The <code><a href="move.html#move">move</a></code> function template, which, given an object of type <code>T</code>, returns a <code><a href="moveable.html#move_source">move_source&lt;T&gt;</a></code> if <code>T</code> derives <a href="moveable.html#moveable"><code>moveable&lt;T&gt;</code></a>, or a <code>T&amp;</code> otherwise. Thus, <code>move</code> triggers a move operation when supported but otherwise falls back upon a copy operation.</li>
  <li>The <code><a href="move.html#return_t">return_t</a></code> class template, which faciltates returning the result of a function to the caller by a move operation if supported, or by copy otherwise.</li>
  <li>Algorithms that leverage the move operation, such as <a href="move.html#algorithm-move_swap"><code>move_swap</code></a> and the range algorithms <a href="move.html#algorithm-move"><code>move</code></a>, <a href="move.html#algorithm-move_backwards"><code>move_backwards</code></a>, and <a href="move.html#algorithm-unitialized_move"><code>unitialized_move</code></a>.</li>
</ul>
<hr>
<h2><a name="examples">Examples</a></h2>
<p>[TODO]</p>
<hr>
<h2><a name="header-move">Header <code>&quot;boost/move.hpp&quot;</code></a></h2>
<p>Includes <code>&quot;boost/move/move.hpp&quot;</code> and <code>&quot;boost/move/moveable.hpp&quot;</code> headers.</p>
<p><strong>Rationale:</strong> The two headers &quot;move/move.hpp&quot; and &quot;move/moveable.hpp&quot; are logically independent and are therefore provided separately. They are often used together, however, so &quot;move.hpp&quot; includes them both as a convenience to the user.</p>
<hr>
<h2><a name="header-move-move">Header <code>&quot;boost/move/move.hpp&quot;</code></a></h2>
<p>See <a href="move.html"><code>&quot;boost/move/move.hpp&quot;</code> documentation</a>.</p>
<hr>
<h2><a name="header-move-moveable">Header <code>&quot;boost/move/moveable.hpp&quot;</code></a></h2>
<p>See <a href="moveable.html"><code>&quot;boost/move/moveable.hpp&quot;</code> documentation</a>.</p>
<hr>
<h2><a name="portability">Portability</a></h2>
<p>To date the code and test harnesses have been compiled and tested successfully 
using and GNU g++, versions 2.9.5 and 3.2. </p>
<hr>
<h2>Credits</h2>
<h3><a name="acknowledgments">Acknowledgments</a></h3>
<p>Eric Friedman designed and implemented the initial submission.</p>
<p>Andrei Alexandrescu's work on his MOJO library [<a href="#bib-ale03">Ale03</a>] influenced the evolution and greatly improved the final design of the library.</p>
<p>Howard Hinnant, Peter Dimov, and Dave Abrahams further influenced the design of the library in their paper proposing core-language support for move semantics [<a href="#bib-hda02">HDA02</a>].</p>
<h3><a name="bibliography">Bibliography</a></h3>
<p><a name="bib-abr">[Abr]</a> Dave Abrahams. 
&quot;Exception-Safety in Generic Components: Lessons Learned from Specifying 
Exception-Safety for the C++ Standard Library," Boost.org. n.d. See <a href="http://www.boost.org/more/generic_exception_safety.html">&lt;http://www.boost.org/more/generic_exception_safety.html&gt;</a>.</p>
<p><a name="bib-abr02">[Abr02]</a> Dave Abrahams. &quot;Addressing the variant issue,&quot; Boost Mailing List. 10 August 2002. Available at <a href="http://aspn.activestate.com/ASPN/Mail/Message/1316073">&lt;http://aspn.activestate.com/ASPN/Mail/Message/1316073&gt;</a>.
<p><a name="bib-ale03">[Ale03]</a> Andrei Alexandrescu. &quot;Generic&lt;Programming&gt;: Move Constructors,&quot; <i>C/C++ Users Journal</i> Experts Forum. February 2003. See <a href="http://www.cuj.com/experts/2102/alexandr.htm">&lt;http://www.cuj.com/experts/2102/alexandr.htm&gt;</a>.</p>
<p><a name="bib-fri02">[Fri02]</a> Eric Friedman. &quot;boost::move and boost::auto_mover in sandbox,&quot; Boost Mailing List. 15 August 2002. Available at <a href="http://aspn.activestate.com/ASPN/Mail/Message/1323099">&lt;http://aspn.activestate.com/ASPN/Mail/Message/1323099&gt;</a>.
<p><a name="bib-hda02">[HDA02]</a> Howard E. Hinnant, Peter Dimov, and Dave Abrahams. "A Proposal to Add Move Semantics Support to the C++ Language." <i>ISO/IEC JTC1/SC22/WG21</i>, doc. N1377=02-0035. 10 September 2002. Available at <a href="http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">&lt;http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2002/n1377.htm&gt;</a>.
<p><a name="bib-sut02">[Sut02]</a> Herb Sutter. &quot;Standard C++ Meets Managed C++,&quot; <i>C/C++ Users Journal</i>. 
September 2002. Available at <a href="http://www.cuj.com/articles/2002/0209/0209i/0209i.htm">&lt;http://www.cuj.com/articles/2002/0209/0209i/0209i.htm&gt;</a>.</p>
<hr>
<div align="right">
  <small><i>&copy; Copyright Eric Friedman, 2002-2003</i></small>
</div>

</body>

</html>