<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <title>Boost Named Template Parameters</title>
  </head>

  <body bgcolor="#FFFFFF" text="#000000">
  <img SRC="../../../c++boost.gif" ALT="C++ Boost" width="277" height="86">
  </img>

<h1>
Named Template Parameters
</h1>


<h2>Table of contents</h2>

<ul>
  <li><a href="../../../boost/named_template_parameters.hpp">
  boost/named_template_parameters.hpp</a> header.</li>
  <li><a href="#introduction">Introduction</a></li>

  <li><a href="#using_named_template_parameters">Using named template parameters</a>

  <ul>
    <li><a href="#defining_parameter_names">Defining the parameter names</a></li>
     <li><a href="#default_values">Default values</a></li>
     <li><a href="#class_that_supports_NTP">The class that needs to support NTPs</a></li>
  </ul>

  </li>

  <li><a href="#advanced_topics">Advanced topics</a>

    <ul>
      <li><a href="#unnamed_named_coexistence">Mixing named and unnamed template parameters</a></li>
      <li><a href="#nontrivial_defaults">Nontrivial default values</a></li>
       <li><a href="#avoiding_pitfalls">Avoiding some pitfalls</a></li>
    </ul>

  </li>

  <li><a href="#how_it_works">How it works</a></li>

  <li><a href="#references">References</a></li>

</ul>

<h2 id="introduction">Introduction</h2>

<p>
The mapping between the <i>actual</i> template arguments and the <i>formal</i> 
template parameters in C++ is defined by the ordering of the parameters.

For example, consider the template definition:
</p>


<pre>
template&lt;class T1, class T2, class T3&gt; class A { ... };
</pre>
The mapping defined, say, by the instantiation:
<pre>
A&lt;int, char, float&gt;
</pre>


<p>is</p>

<p>
<code>T1 = int, T2 = char, T3 = float</code>
</p>


<p>When there are a large number of template parameters, the order based
mapping is seldom ideal.

First, it is easy to get the order of the parameters wrong, which can lead to 
hard to find errors. 

Second, many of the template parameters can have default values. 
Whether one can take advantage of the default value for a particular 
template argument or not, is dependent on the relative position of 
the parameter in the template parameter list.

Consider the following example:
</p>

<pre>template &lt;class Model = basic, class Color = black, 
          class Seats = no_leather, class Transmission = automatic&gt;
class car { ... }; 
</pre>

<p>

Suppose we make two instantiations of the <code>car</code> template: 

In the first one, we want to change the <code>Model</code> from <code>basic</code> to <code>limited_edition</code>, but otherwise the defaults are fine.

In the second one, we want <code>Transmission</code> to be <code>manual</code>
and, again, apply the default values for other parameters.

The two instantiations are:
</p>

<pre>
car&lt;limited_edition&gt; 
car&lt;basic, black, no_leather, manual&gt; 
</pre>

<p>
In the second instantiation all template arguments have to be written explicitly,
even though we only wanted to change one parameter.

This is because the <i>n</i> template arguments given in a template 
instantiation are always mapped to be the
<i>n</i> leftmost template parameters in the template definition.
</p>

<p>
In situations such as this, instead of defining the <i>actual argument &rarr; 
formal parameter</i> mapping
by the ordering of the parameter list, it would be preferable 
to use <i>names</i> for template parameters. 
The syntax for this could be like:
</p>

<pre>
car&lt;Transmission = manual&gt;
</pre>

<p>
This is pseudo-code and there is no direct support for this in C++, 
but one can mimic the behavior.
This technique is known as <i>Named Template Parameters</i> (NTP).
</p>

<p>
The Boost Named Template Parameter library provides support for NTPs
with the following syntax:
</p>

<pre>
car&lt;Transmission_is&lt;manual&gt; &gt;
</pre>

<p>
The implementation is a modified version of the solution presented in 
the forthcoming (at the time of writing this) book by 
<i>Daveed Vandevoorde</i> and <i>Nicolas Josuttis</i>.
</p>


<h2 id = "using_named_template_parameters">Using named template parameters</h2>

<p>Making your template class support named template parameters requires 
some work.
The feature cannot be encapsulated in a black box, but 
rather an interplay of
templates defined in the Named Template Parameter 
library and user defined templates is required.
The coarse steps that need to be taken are:
</p>

<ol>
<li><code>#include "boost/named_template_parameters.hpp"</code></li>
<li>Define templates that give names for the parameters.</li>
<li>Define a classes that give default values to the parameters.</li>
<li>Define the class that needs to support named template parameters.</li>
</ol>

<p>
The next three sections describe the steps 2, 3 and 4 in more detail.
Our starting point is the original definition of the <code>car</code> 
template we gave
in the introduction:
</p>

<pre>template &lt;class Model = basic, class Color = black, 
          class Seats = no_leather, class Transmission = automatic&gt;
class car { ... }; 
</pre>

<p>
The goal is to make this template accept any number (up to four) of the types 
<code>Model_is&lt;A&gt;</code>,
<code>Color_is&lt;B&gt;</code>,
<code>Seats_is&lt;C&gt;</code> or
<code>Transmission_is&lt;D&gt;</code> as its arguments, in arbitrary order. 

The types <code>A</code>, <code>B</code>,
<code>C</code> and <code>D</code> are the types for 
<code>Model</code>, <code>Color</code>,
<code>Seats</code> and <code>Transmission</code>.
Furthermore, for all arguments that are not defined, default value should 
be applied.
Note that even though we discuss about default <i>values</i>, the values
themselves are <i>types</i>.
</p>

<h3 id="defining_parameter_names">Defining the parameter names</h3>

<p>
We have used the convention <code><i>name</i>_is</code> in our named template 
parameters.
The named template parameters are template classes themselves and can thus be 
named freely, but it is advisable to use consistent naming convention.
The original template parameters in the <code>car</code> template are named
as <code>Model</code>, <code>Color</code>, <code>Seats</code> and 
<code>Transmission</code>.
This suggests the names <code>Model_is</code>, <code>Color_is</code>, 
<code>Seats_is</code> and <code>Transmission_is</code>.

Whatever the naming convention, here is what a <i>named template parameter
template</i> needs to be like. 
We use <code>Model_is</code> as an example:
</p>

<pre>
template &lt;class T&gt struct Model_is : virtual public car_defaults
{ 
  typedef T Model; 
};
</pre>


<p>
The class contains one typedef <code>Model</code> which is the name of the
<i>feature</i> that it encapsulates. 
We have chosen to name the features with the names of the original template
arguments.
Again, consistent naming is advisable.
</p>

<p>
Each named template parameter template must inherit
form a <i>default value class</i> using virtual inheritance (strictly speaking
no inheritance is necessary if the feature does not have a default value).
In our example, the default value class is <code>car_defaults</code>, 
described in the next section.
</p>


<h3 id="default_values">Default values</h3>

<p>In the simplest form, just one class containing a typedef for 
each feature is what is needed for defining the defaults values:</p>

<pre>
struct car_defaults : 
  virtual public boost::ntp::named_parameter_tag {

  typedef basic Model;
  typedef black Color;
  typedef boost::ntp::unspecified Seats;
  typedef automatic Transmission;
};
</pre>

<p>
This class expresses that the default values are <code>basic</code> for 
<code>Model</code>, <code>black</code> for <code>Color</code>, etc.

Note the default value for <code>Seats</code>, which is
<code>boost:::ntp::unspecified</code>.

This means that there is no default value, or that there is, but it may 
depend on the values of other features, which has to be dealt with another
mechanism. 
We explain this mechanism in section 
<a href="#nontrivial_defaults">Nontrivial default values</a>.
</p>

<h3 id = "class_that_supports_NTP">The class that needs to support NTPs</h3>

<p>
Having defined the named template parameter templates and the default value class, we are ready to rewrite the <code>car</code> template itself.
Our original template definition without NTPs was:
</p>

<pre>template &lt;class Model = basic, class Color = black, 
          class Seats = no_leather, class Transmission = automatic&gt;
class car { ... }; 
</pre>

<p>
This changes to:
</p>

<pre>
template &lt;class Model = car_defaults, 
          class Color = car_defaults,
          class Seats = car_defaults, 
          class Transmission = car_defaults&gt;
class car {

  typedef boost::tuple&lt;Model, Color, Seats, Transmission&gt; argument_tuple;

  typedef boost::ntp::named_parameter_extractor&lt;argument_tuple&gt; features;

public:

  typedef typename features::Model model;
  typedef typename features::Color color;
  typedef typename features::Seats seats;
  typedef typename features::Transmission transmission;

  ...
};
</pre>

<p>
The first thing to notice is that the default value class, 
<code>car_defaults</code>,
is used as the default for all parameters.
</p>

<p>
Second, the template parameter names <code>Model</code>, <code>Color</code> 
etc. do not make much sense anymore, as say <code>Model</code> could be
carrying the type <code>Color_is&lt;red&gt;</code> etc.
<a href="#footnote1"><sup>1</sup></a>

As we do not know which template parameter contains information about which
feature, our task is to extract the values (types) of different features 
from the set of template parameters. 

To accomplish this, we first group all template parameters 
into a 
<a href="http://www.boost.org/libs/tuple/doc/tuple_users_guide.html"><code>tuple</code></a> type:
</p>

<pre>
typedef boost::tuple&lt;Model, Color, Seats, Transmission&gt; argument_tuple;
</pre>

<p>
The order of the elements can be arbitrary.

Next, the <code>argument_tuple</code> type is passed to 
<code>named_parameter_extractor</code> metafunction:
</p>

<pre>
typedef boost::ntp::named_parameter_extractor&lt;argument_tuple&gt; features;
</pre>

<p>
Now, the <code>features</code> type contains our four features as 
nested types. 
The typedefs we define make the features 
<code>model</code>, <code>color</code>, <code>seats</code> 
and <code>transmission</code> conveniently available as 
'first class citizens' of the <code>car</code> template class.
</p>


<p>
We have now covered the basic mechanism.
There are a few cases that this basic mechanism cannot cover.
We have already alluded to the coexistence of unnamed and named 
template parameters being possible, as well as having default values that 
are dependent on the values of other features. 
These are the topics of the next section.
</p>

<h2 id = "advanced_topics">Advanced topics</h2>

<h3 id = "unnamed_named_coexistence">Mixing named and unnamed template parameters</h3>

<p>
Named template parameters and normal unnamed parameters can coexist.
The same argument slot can be made to accept either a named or 
unnamed template argument. 

Let us choose to provide this functionality for the first two 
argument positions in the <code>car</code> template, 
that is, for <code>Model</code> and <code>Color</code>.
Concretely, we want to allow instantiations like:
</p>
<pre>
car&lt;limited_edition, black, Seats_is&lt;no_leather&gt; &gt;
car&lt;basic, Seats_is&lt;no_leather&gt;, Color_is&lt;black&gt; &gt;
</pre>

<p>
To give this dual behavior to a template parameter slot,
one wraps the template parameter with the <code>as_named</code> 
metafunction in the argument tuple type.
The argument tuple in our example becomes:
</p>
<pre>
typedef boost::tuple&lt;
  typename boost::ntp::as_named&lt;Model, Model_is&gt;::type, 
  typename boost::ntp::as_named&lt;Color, Color_is&gt;::type, 
  Seats, 
  Transmission    
&gt; argument_tuple;
</pre>

<p>
The first parameter to <code>as_named</code> is the template parameter, 
that can either be unnamed or named.
The second parameter is the named template parameter template.
The <code>as_named</code> metafunction simply examines the first parameter,
and converts it to a NTP (using the second parameter) if it is not one already.
</p>

<!--Note, that using in our design goals we decided to 
allow instantiations where the first argument, 
or the first and the second arguments are unnamed template arguments.
In such instantiations <code>Model</code> really contains information about 
the model of the car etc.-->


<h3 id="nontrivial_defaults">Nontrivial default values</h3>

<p>
Suppose we want to implement some logic to the default values for features
in the <code>car</code> template,
namely we want to make the value of <code>Model</code> imply the default value 
of <code>Seats</code>.
Concretely, if <code>Model == limited_edition</code>, the default value for 
<code>Seats</code> should be <code>leather</code>, 
otherwise it should be <code>no_leather</code>.
Our simple <code>car_defaults</code> class cannot handle this
situation as it can only provide a fixed type for each typedef.
In general, 
if there are default values that are dependent on the values of other features,
we need a metafunction to compute the default value.
</p>

<p>
To build such a metafunction we define another
default value class, or actually a class template.
This template takes one template parameter, from which it inherits
using public inheritance.

Once the template is instantiated, the template parameter will contain 
the inputs to the metafunction, that
is, the features after the <em>trivial defaults</em> have been applied.
By trivial defaults we refer to the typedefs defined in the 
<code>car_defaults</code> class.
Hence, the second default value class defines defaults for all features
that do not have trivial defaults.
Naturally, if a feature intentionally does not have a default value,
one does not need to define a typedef for it in neither class.

Here is our default value template:
</p>

<pre>
using namespace boost;

template &lt;class Features&gt; struct nontrivial_car_defaults : public Features {
    typedef typename
      mpl::if_c&lt;is_same&lt;typename Features::Seats, ntp::unspecified&gt;::value,
        typename mpl::if_c&lt;is_same&lt;typename Features::Model, limited_edition&gt;::value,
          leather,
          no_leather
        &gt;::type,
      typename Features::Seats  
    &gt;::type Seats;
};
</pre>				    

<p>
The code of the metafunction is somewhat hard to read:
<code>is_same</code> comes from the Boost type_traits library and test the 
equality of two types, <code>if_c</code> is a compile time if construct and is
defined in the Boost Metaprogramming Library.
The following pseudo code expresses the logic of the metafunction:
</p>

<pre>
if (Features::Seats is unspecified) {
  if (Features::Model is limited_edition) Seats = leather;
  else Seats = no_leather;
}
else Seats = Features::Seats;
</pre>

<p>
Note that the trivial default value we gave for <code>Seats</code> was 
<code>ntp::unspecified</code>, a fact that we rely on here.
</p>

<p>To apply the nontrivial defaults we need to do some changes in
the <code>car</code> template.
Basically, the <code>features</code> type contains an intermediate feature set, and needs to be routed via the metafunction we just defined:
</p>
<pre>
typedef nontrivial_car_defaults&lt;features&gt; final_features;
</pre>
<p>
Hence, the input to this metafunction is the features we had before.
As the result we get the same features with the nontrivial default 
values applied.
</p>

<p>
Below is the definition of the entire <code>car</code> template after
the changes we have introduced in the Advanced topics section:
</p>

<pre>
template &lt;class Model = car_defaults, 
          class Color = car_defaults,
          class Seats = car_defaults, 
          class Transmission = car_defaults&gt;
class car {

  typedef boost::tuple&lt;
    typename boost::ntp::as_named&lt;Model, Model_is&gt;::type, 
    typename boost::ntp::as_named&lt;Color, Color_is&gt;::type, 
    Seats, 
    Transmission    
  &gt; argument_tuple;

  typedef boost::ntp::named_parameter_extractor&lt;argument_tuple&gt; features;

  typedef nontrivial_car_defaults&lt;features&gt; final_features;

public:

  typedef typename final_features::Model model;
  typedef typename final_features::Color color;
  typedef typename final_features::Seats seats;
  typedef typename final_features::Transmission transmission;

  ...
};
</pre>

<h3 id = "avoiding_pitfalls">Avoiding some pitfalls</h3>

<h4 id ="name_clashes">Name clashes</h4>

<p>
The named template parameter templates must be defined in some namespace and you may
end up wanting to use the same template name for two different classes that
use the NTP scheme.
For example, a <code>bicycle</code> class could very well have a 
<code>Model</code> feature and thus <code>Model_is</code> would be a 
natural choice for the name of the named template parameter template.

Also, most likely <code>car</code> and <code>bicycle</code> models do
not share the same default value.
</p>

<p>
The easiest way to solve this is to come up with different names for the
two features (e.g. car_model and bicycle_model).
Another possibility is to define a common default class for the feature.
Other features can still be kept in separate classes by building a hierarchy 
of default value classes:
</p>

<pre>
struct common_features {
  typedef boost::ntp::unspecified Model;
};

struct car_defaults : virtual public common_features { ... };
struct bicycle_defaults : virtual public common_features { ... };
</pre>

<p>
The common named template parameter template <code>Model_is</code> 
then inherits from 
<code>common_features</code>, instead of car or bicycle defaults.
The default value is set <code>unspecified</code> and the real 
default values for car and bicycle are then defined in the nontrivial
default classes for <code>car</code> and <code>bicycle</code>
templates.
</p>

<h4 id="nontype_parameters">Nontype template parameters</h4>

<p>The Boost NTP library supports nontype template parameters with little
extra difficulty.
Instead of typedefs, you just define static constants in the default value
classes and in the named template parameter templates. 

For example, to add the feature <i>Number_of_wheels</i> to the <code>car</code>
template we would add the line:
<pre>
static const int Number_of_wheels = 4;
</pre>
<p>
into the <code>car_defaults</code> class.
The named template parameter template for this feature would be:
</p>
<pre>
template &lt;int N&gt; Number_of_wheels_is { static const int Number_of_wheels = N };
</pre>
<p>
Finally, to access the feature in the <code>car</code> class we would write:
</p>
<pre>
static const int number_of_wheels = final_features::Number_of_wheels;
</pre>
<p>
However, the case where one wants to have a nontype template parameter 
that can either be provided as a named or as an unnamed template parameter, 
is not supported.

If this kind of behaviour is desired, 
the simplest solution is to wrap the compile time constants into wrapper 
templates which can be used as type template parameters.
For example:
</p>

<pre>
template&lt;int N&gt; struct int_wrapper {
  static const int value = N; 
};
</pre>

<p>
defines a wrapper that can carry an integral constant.
Note that for better portability you may want to use the 
<code>BOOST_STATIC_CONSTANT</code> macro to define the static constants.
</p>



<h2 id="how_it_works">How it works</h2>

<p>Do we need this?</p>

<h2 id = "references">References</h2>

<p>
Vandevoorde, Josuttis: C++ Template Book.
</p>

<fn id="footnote1"><sup>1</sup> 
We continue to use these names, however, as we later show how to allow
the coexistence of normal unnamed template parameters an NTPs (see section
<a href = "#unnamed_named_coexistence">Mixing named and unnamed template parameters</a>).</fn>

<hr></hr>

<p>
&copy; Copyright Jaakko Järvi and Jeremy Siek 2002. 
Permission to copy, use, modify, sell and distribute this document is 
granted provided this copyright notice appears in all copies. 
This document is provided "as is" without express or implied warranty, 
and with no claim as to its suitability for any purpose. 
</p>


</body>




</html>




<!-- (cf. <code>transmission_is</code> in the example in <i>Introduction</i>).

selitä, että kaikilla ei välttämättä ole oletusarvoa
-->

<!--

  typedef car_default_value_2&lt;
    intermediate_feature_list
  &gt; features;
  ...



    typename boost::ntp::as_named&lt;Model, Model_is&gt;::type, 
    typename boost::ntp::as_named&lt;Color, Color_is&gt;::type, 




<p>
Note that in the case where some named template parameter does not have 
a default value, 
there is no need to specify a typedef for that feature.
Alternatively, a typedef with a value like <code>boost::ntp::unspecified</code> 
can be used. This latter method may lead to more readable error messages, if
the user fails to provide the named template argument in question.
</p>


-->
