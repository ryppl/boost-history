[library Boost.Units
  [quickbook 1.3]
  [version 0.7.1]
  [authors [Schabel, Matthias C.]]
  [authors [Watanabe, Steven]]
  [copyright 2003-2007 Matthias Christian Schabel, 2007 Steven Watanabe]
  [license
      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      [@http://www.boost.org/LICENSE_1_0.txt])
  ]
  [purpose zero-overhead compile-time dimensional analysis and unit computations]
]

[def __boost_mpl [@http://www.boost.org/libs/mpl/doc/index.html Boost Metaprogramming Library]]

[def __mpl_forward_sequence [@http://www.boost.org/libs/mpl/doc/refmanual/forward-sequence.html MPL Forward Sequence]]

[def __ordinal [classref boost::units::ordinal ordinal]]
[def __dim [classref boost::units::dim dim]]
[def __static_rational [classref boost::units::static_rational static_rational]]
[def __make_dimension_list [classref boost::units::make_dimension_list make_dimension_list]]
[def __unit [classref boost::units::unit unit]]
[def __unit_info [classref boost::units::unit_info unit_info]]
[def __quantity [classref boost::units::quantity quantity]]

[def __unary_plus_typeof_helper [classref boost::units::unary_plus_typeof_helper unary_plus_typeof_helper]]
[def __unary_minus_typeof_helper [classref boost::units::unary_minus_typeof_helper unary_minus_typeof_helper]]
[def __add_typeof_helper [classref boost::units::add_typeof_helper add_typeof_helper]]
[def __subtract_typeof_helper [classref boost::units::subtract_typeof_helper subtract_typeof_helper]]
[def __multiply_typeof_helper [classref boost::units::multiply_typeof_helper multiply_typeof_helper]]
[def __divide_typeof_helper [classref boost::units::divide_typeof_helper divide_typeof_helper]]
[def __power_typeof_helper [classref boost::units::power_typeof_helper power_typeof_helper]]
[def __root_typeof_helper [classref boost::units::root_typeof_helper root_typeof_helper]]

[def __static_negate [classref boost::units::static_negate static_negate]]
[def __static_add [classref boost::units::static_add static_add]]
[def __static_subtract [classref boost::units::static_subtract static_subtract]]
[def __static_multiply [classref boost::units::static_multiply static_multiply]]
[def __static_divide [classref boost::units::static_divide static_divide]]
[def __static_power [classref boost::units::static_power static_power]]
[def __static_root [classref boost::units::static_root static_root]]

[def __get_dimension [classref boost::units::get_dimension get_dimension]]
[def __get_system [classref boost::units::get_system get_system]]

[def __pow [funcref boost::units::pow pow]]
[def __root [funcref boost::units::root root]]
[def __quantity_cast [funcref boost::units::quantity_cast quantity_cast]]

[def __from_value [memberref boost::units::quantity::from_value from_value]]
[def __value [memberref boost::units::quantity::value value]]

[def __BOOST_UNITS_STATIC_CONSTANT [macroref BOOST_UNITS_STATIC_CONSTANT]]
[def __BOOST_UNITS_ENABLE_IMPLICIT_UNIT_CONVERSIONS [macroref BOOST_UNITS_ENABLE_IMPLICIT_UNIT_CONVERSIONS]]

[section:Introduction Introduction]

The Boost.Units library is a C++ implementation of zero runtime overhead compile-time dimensional analysis in a general 
and extensible manner, treating it as a generic metaprogramming problem. Support for units
and quantities (defined as a unit and associated value) for arbitrary unit system models and arbitrary  
value types is provided, as is a general facility for unit conversions enabling fine-grained control over
conversion. Complete SI and CGS unit system models are provided, along with systems for 
angles measured in degrees, gradians, and radians. A small subset of the SI system including only length, mass, 
and time is developed in the examples as a demonstration of the relative ease of adding new unit systems and 
the extensibility of the library architecture. 

In order to enable complex compile-time dimensional analysis calculations with no runtime overhead,
Boost.Units relies heavily on the [___boost_mpl] (MPL) and on template metaprogramming techniques, and is, as a consequence, 
fairly demanding of compiler compliance to ISO standards. At present, it has been successfully
compiled and tested on the following compilers/platforms :

# g++ 4.0.1 on Mac OSX 10.4
# g++ 3.4.4 on Windows XP
# Microsoft Visual C++ 7.1 on Windows XP
# Microsoft Visual C++ 8.0 on Windows XP
# Metrowerks CodeWarrior 9.2 on Windows XP.  

The following compilers/platforms are known *not* to work :

# Microsoft Visual C++ 6.0 on Windows XP
# Microsoft Visual C++ 7.0 on Windows XP
# Metrowerks CodeWarrior 8.0 on Windows XP.

[endsect]

[section:Quick_Start Quick Start]

Before discussing the basics of the library, we first define a few terms that will be used frequently
in the following :

*  *Fundamental dimension* : A fundamental dimension is a type of measurement that forms the basis
   of a unit system. The SI unit system defines seven fundamental dimensions : length \[L\], mass \[M\], time \[T\], 
   current \[C\], temperature \[K\], amount \[A\], and luminous intensity \[I\].
*  *Dimension* : A dimension represents the signature of a collection of fundamental dimensions, each
   potentially raised to a different rational power. For example, area = \[L\]^2, velocity = \[L\]/\[T\], 
   energy = \[M\] \[L\]^2/\[T\]^2.
*  *Unit* : Units are a specific measure of a dimension. While length is an abstract measure of
   distance, the meter is the concrete unit of distance in the SI system. Units represent a reference 
   measure of some dimension (fundamental or otherwise).
*  *Quantity* : Quantities represent a concrete amount of some unit. Thus, while the meter is a unit of length in the SI system,
   5.5 meters is a quantity of length in that system. 

To begin, we present a short [@../example/tutorial.cpp tutorial] that demonstrates the use of 
[@http://en.wikipedia.org/wiki/SI_units SI] units. After including the appropriate system headers 
and the headers for the various SI units we will need (all SI units can be included with  
[headerref boost/units/systems/si.hpp]) and for quantity I/O ([headerref boost/units/io.hpp]), we define 
a function that computes the work, in joules, done by exerting a force in newtons over a specified distance in meters 
and outputs the result to `std::cout`. The [___quantity] class accepts a second template parameter as its value type; 
this parameter defaults to
`double` if not otherwise specified. To demonstrate the ease of using user-defined types in dimensional
calcuations, we also present code for computing the complex impedance using `std::complex<double>`
as the value type :

[import ../example/tutorial.cpp]

[tutorial_code]

The intent and function of the above code should be obvious; the output produced is :

[tutorial_output]

While this library attempts to make simple dimensionsional computations easy to code, it is in no way
tied to any particular unit system (SI or otherwise). Instead, it provides a highly flexible compile-time
system for dimensional analysis, supporting arbitrary collections of fundamental dimensions, rational 
powers of units, and both explicit and implicit quantity conversions, controllable on a per fundamental
dimension basis. In addition, it accomplishes all of this via template metaprogramming techniques. With 
modern optimizing compilers, this results in zero runtime overhead for quantity computations relative to the 
same code without unit checking.

[endsect]

[section:Dimensional_Analysis Dimensional Analysis]

The concept of 
[@http://en.wikipedia.org/wiki/Dimensional_analysis dimensional analysis] 
is normally presented early on in introductory physics and engineering classes as a means of determining the  
correctness of an equation or computation by propagating the physical measurement
[@http://en.wikipedia.org/wiki/Units_of_measurement units]
of various quantities through the equation along with their numerical values. There are a number of standard 
unit systems in common use, the most prominent of which is the 
[@http://en.wikipedia.org/wiki/SI_units Systeme International] 
(also known as SI or MKS, for meter-kilogram-second, three of the fundamental dimensions on which the system is based), 
which is the international standard unit system and is widely utilized in science and engineering. 
Other common systems include the [@http://en.wikipedia.org/wiki/Cgs_units CGS]
(centimeter-gram-second) system and the 
[@http://en.wikipedia.org/wiki/English_units English]
system still in use in some problem domains in the United States and elsewhere. In physics, 
there also exist a number of other systems that are in common use in specialized subdisciplines. These are 
collectively referred to as [@http://en.wikipedia.org/wiki/Natural_units natural units]. When 
quantities representing different physical quantities are combined, dimensional analysis provides the means of 
assessing the consistency of the resulting calculation. For example, the sum of two lengths is also a length, 
while the product of two lengths is an area, and the sum of a length and an area is undefined. Similarly, the 
arguments to many functions (such as exp, log, etc...) must be dimensionless quantities, as can be easily seen by 
examining their series expansions. This requirement can also be enforced in code involving dimensioned quantities
where appropriate.

In the following, we view dimensional analysis as an abstraction in which an arbitrary set of 
[@http://en.wikipedia.org/wiki/Fundamental_units units] obey the rules of a specific algebra. 
We will refer to a pair of a fundamental unit and a rational exponent as a *fundamental dimension*, 
and a list composed of an arbitrary number of fundamental dimensions as a *composite dimension* or, simply,
*dimension*. In particular, given a set of [$form_0.png] fundamental dimensions denoted by [$form_1.png] and
a set of [$form_0.png] rational exponents [$form_2.png], any possible (composite) dimension can be written
as [$form_3.png].  

Composite dimensions obey the algebraic rules for dimensional analysis. In particular, for any scalar value, [$form_4.png], 
and composite dimensions [$form_5.png]
and [$form_6.png], where 
[$form_7.png], we have:

[$form_8.png]

Users of a dimensional analysis library should be able to specify an arbitrary list of fundamental dimensions to 
produce a composite dimension. This potentially includes both repeated tags and dimensionless tags. For example, 
it should be possible to express energy as [$form_9.png], [$form_10.png], 
[$form_11.png], or any other permutation of mass, length, and time having aggregate exponents of 
1, 2, and -2, respectively. In addition, in some cases, multiple fundamental dimensions representing the same dimension 
measured in different unit systems may appear. In order to be able to perform computations on arbitrary sets of dimensions, 
all composite dimensions must be reducible to an unambiguous final composite dimension, which we will refer to as a 
*reduced dimension*, for which

# fundamental dimensions are consistently ordered
# dimensions with zero exponent are elided. Note that reduced dimensions are never composed of more than 
  [$form_0.png] dimension tags, one for each distinct fundamental dimension, but may have fewer.

In our implementation, fundamental dimensions are associated with arbitrary tag types. As we will ultimately 
represent composite dimensions as typelists, we must provide some mechanism for 
sorting dimension tags in order to make it possible to convert an arbitrary composite dimension into a reduced
dimension. A template class is provided for this purpose for convenience (found in [headerref boost/units/dimension_tag.hpp]), 
or the tags themselves can provide an appropriate `typedef` for `value`:

    template<std::size_t N> struct ordinal { typedef typename boost::mpl::int_<N> value; };

With this, we can define the fundamental types for length, mass, and time as (noting the the specific ordering
is not important, only the uniqueness of the ordinal values) :

[import ../example/test_system.hpp]
[test_system_snippet_1]

It is important to note that the choice of order is completely arbitrary as long as each tag has a unique enumerable
value. To define the fundamental dimensions themselves, we simply create MPL-conformant typelists having unit 
exponents by using the [___dim] class to encapsulate the fundamental dimension tag with a [___static_rational] exponent. 
The [___make_dimension_list] class acts as a wrapper to ensure that the resulting type is in the form of a reduced dimension:

[test_system_snippet_2]

To facilitate definition of fundamental dimensions, a convenience class is provided:

[test_system_snippet_3]

so that the above code is identical to the full typelist definition.

We require that fundamental dimensions be represented by orthonormal basis vectors in the space of dimensions; this
requirement is not strictly necessary, as any set of basis vectors that span the vector space of dimensions can be used 
as fundamental units. However, while it is conceptually interesting, allowing for non-orthonormal basis vectors adds 
a tremendous amount of additional complexity (essentially it would require an implementation of basic compile-time 
linear algebra) with little clear benefit for practical applications. 

Naturally, we also define composite dimensions via a typelist:

[test_system_snippet_4]

A convenience class for composite dimensions with integer powers is also provided:

[test_system_snippet_5]

[endsect]

[section:Units Units]

We define a *unit* as a composite dimension expressed in some *unit system*, where the latter is a self-consistent 
set of reference measures corresponding to the fundamental dimensions comprising the unit system. For example,
length is an abstract concept that can be made concrete by associating it with a unit system. Thus, the meter is a unit
of length in the SI system. Units are, like composite dimensions, purely compile-time variables with no associated value.
Units obey the same algebra as dimensions do; the presence of the unit system serves to ensure that units having identical
reduced dimension in different systems (like feet and meters) cannot be inadvertently mixed in computations.

There are three distinct types of unit system that can be envisioned:

* *Homogeneous systems* : Systems in which each fundamental dimension is measured in the same unit system (all SI, for 
 example). 
* *Mixed systems* : Systems in which each fundamental dimension is measured in one unit system, but the 
 systems for different fundamental systems may come from different unit systems. For example, centimeter-kilogram-second
 units in which lengths are measured in the CGS system and masses and times are measured in the SI system. These
 systems can be treated in the same way as homogeneous systems for the most part.
* *Heterogeneous systems* : Mixed systems in which each fundamental dimension may be represented by two or more
 fundamental units. For example, an empirical equation for radar beam height (in feet) is H = (r/C)^2 where r is the
 radar range in nautical miles. In order for this equation to be dimensionally correct, the constant, C, must be expressed in 
 nautical miles per foot^(1/2), which mixes two distinct fundamental length dimensions in a single unit.

Units are implemented by the [___unit] template class defined in [headerref boost/units/unit.hpp] :

    template<class Dim,class System> class unit;

In addition to supporting the compile-time dimensional analysis operations, the +, -, *, and / runtime operators are provided
for [___unit] variables. Because the dimension associated with powers and roots must be computed at compile-time, it is not 
possible to provide overloads for `std::pow` that function correctly for [___unit]s. These operations are supported through 
free functions [___pow] and [___root] that are templated on integer and [___static_rational] values and can take as an argument 
any type for which the utility classes [___power_typeof_helper] and [___root_typeof_helper] have been defined.

As an example, in the following we will implement a subset of the SI unit system based on the fundamental dimensions 
given above, demonstrating all steps necessary for a completely functional system. First, we simply define a unit system
class that includes type definitions for commonly used units:

[test_system_snippet_6]

If the units in a given system are to be used as a part of a heterogeneous unit system, the system tag must have a 
unique (among system tags) enumerable value. We reuse the [___ordinal] template for this application here.  
System ordinal values up to 100 are reserved for library use; user-defined systems should use ordinal values greater
than 100. The macro [___BOOST_UNITS_STATIC_CONSTANT] is provided in [headerref boost/units/static_constant.hpp] 
to facilitate ODR- and thread-safe constant definition in header files. We then define some constants for the supported units 
to simplify variable definitions:

[test_system_snippet_7]

We also specialize the [___unit_info] class for each fundamental 
dimension tag to provide information needed for I/O:

[test_system_snippet_8]

and similarly for `mass_tag` and `time_tag`. A future version of the library will provide a more flexible system
allowing for internationalization through a facet/locale-type mechanism. 
The `name()` and `symbol()` methods of [___unit_info] provide full and short names for the base unit. With these definitions, 
we have the rudimentary beginnings of our unit system, which can be used to determine reduced dimensions for arbitrary 
unit calculations.

[endsect]

[section:Quantities Quantities]

A *quantity* is defined as a value of an arbitrary value type that is associated with a specific unit. For example,
while meter is a unit, 3.0 meters is a quantity. Quantities obey two separate algebras: the native algebra for their 
value type, and the dimensional analysis algebra for the associated unit. In addition, algebraic operations are defined
between units and quantities to simplify the definition of quantities; it is effectively equivalent to algebra with
a unit-valued quantity.

Quantities are implemented by the [___quantity] template class defined in [headerref boost/units/quantity.hpp] :

    template<class Unit,class Y = double> class quantity;

This class is templated on both unit type (`Unit`) and value type (`Y`), with the latter defaulting to double-precision
floating point if not otherwise specified. Operators +, -, *, and / are provided for algebraic operations between 
scalars and units, scalars and quantities, units and quantities, and between quantities. In addition, integral and
rational powers and roots can be computed using the [___pow]<R> and [___root]<R> functions. Finally,  
the standard set of boolean comparison operators ( `==, !=,  <, <=, >, and >=` ) are provided to allow 
comparison of quantities from the same unit system.

[section:Quantity_Construction_and_Conversion Construction and Conversion of Quantities]

By default, this library is designed to emphasize safety above convenience when performing operations with dimensioned quantities.
Specifically, construction of quantities is required to fully specify both value and unit. Direct construction from a scalar value
is prohibited (though the static member function [___from_value] and the free function [___quantity_cast] are provided to enable 
this functionality where it is necessary. In addition, the mutating [___value] member function allows direct access to the 
underlying value of a [___quantity] variable. An explicit
constructor is provided to enable conversion between dimensionally compatible quantities in different unit systems. 
Implicit conversions between unit systems are allowed only when every fundamental dimension present is convertible between the 
starting and ending unit systems. This provides fine-grained control over implicit unit system conversions, allowing, for example,
trivial conversions between equivalent units in different systems (such as SI seconds and CGS seconds) while simultaneoulsy
enabling unintentional unit system mismatches to be caught 
at compile time and preventing precision loss and performance overhead from unintended conversions.
An exception is made for quantities for which the unit reduces to dimensionless; in this case, implicit conversion
to the underlying value type is allowed via class template specialization. Quantities of different value types are implicitly 
convertible if the value types are themselves implicitly convertible. The [___quantity] class also defines mutating and 
non-mutating `value()` members for directly accessing and/or setting the underlying value. Clearly, use of the mutating form
is to be reserved for cases where it is absolutely necessary as doing so voids the guarantee of dimensional correctness.

To summarize, conversions are allowed under the following conditions :

* implicit conversion of `quantity<Unit,Y>` to `quantity<Unit,Z>` is allowed if `Y` and `Z` are convertible.
* implicit assignment between `quantity<Unit,Y>` and `quantity<Unit,Z>` is allowed if `Y` and `Z` are convertible.
* explicit conversion between `quantity<Unit1,Y>` and `quantity<Unit2,Z>` is allowed if `Unit1` and `Unit2` are convertible
    and if `Y` and `Z` are convertible.
* implicit conversion between `quantity<Unit1,Y>` and `quantity<Unit2,Z>` is allowed if every fundamental dimension of `Unit1` 
    is implicitly convertible to the corresponding fundamental dimension in `Unit2` and if `Y` and `Z` are convertible.
* implicit assignment between `quantity<Unit1,Y>` and `quantity<Unit2,Z>` is allowed if every fundamental dimension of `Unit1` 
    is implicitly convertible to the corresponding fundamental dimension in `Unit2` and if `Y` and `Z` are convertible.
* `quantity<Unit,Y>` can be directly constructed from a value of type `Y` using the static member function [___from_value].
* `quantity<Unit,Y>` can be directly constructed from a value of type `Y` using the `quantity_cast< quantity<Unit,Y> >` function.
* `quantity<Unit,Y>` can be directly constructed from `quantity<Unit,X>` using the `quantity_cast<Y>` function.
* `quantity<Unit1,Y>` can be directly constructed from `quantity<Unit2,X>` using the `quantity_cast<Unit1>` function.

Because dimensionless quantities have no associated units, they behave as normal scalars, and allow implicit conversion to and from 
the underlying value type.

[endsect]

[section:Heterogeneous_Operators Heterogeneous Operators]

For most common value types, the result type of arithmetic operators is the same as the value type itself. For example, 
the sum of two double precision floating point numbers is another double precision floating point number. However, there 
are instances where this is not the case. A simple example is given by the [@http://en.wikipedia.org/wiki/Natural_number 
natural numbers] where the operator arithmetic obeys the following rules (using the standard notation for 
[@http://en.wikipedia.org/wiki/Number number systems]):

* [$form_12.png]
* [$form_13.png]
* [$form_14.png]
* [$form_15.png]

This library is designed to support arbitrary value type algebra for addition, subtraction, multiplication, division, and 
rational powers and roots. For compilers that support `typeof`, the appropriate value type will be automatically deduced. 
For compilers that do not provide language support for `typeof`, it is necessary to specialize the desired operator helper
template classes to define the algebra. For the case of natural numbers, this would amount to something like the following 
pseudocode:

    template<> struct add_typeof_helper<natural,natural>        { typedef natural type; };
    template<> struct subtract_typeof_helper<natural,natural>   { typedef integer type; };
    template<> struct multiply_typeof_helper<natural,natural>   { typedef natural type; };
    template<> struct divide_typeof_helper<natural,natural>     { typedef rational type; };

    typename add_typeof_helper<natural,natural>::type           operator+(natural x,natural y);
    typename subtract_typeof_helper<natural,natural>::type      operator-(natural x,natural y);
    typename multiply_typeof_helper<natural,natural>::type      operator*(natural x,natural y);
    typename divide_typeof_helper<natural,natural>::type        operator/(natural x,natural y);

Naturally, it is also possible to define heterogeneous operators between different value types:

    template<> struct add_typeof_helper<natural,integer>        { typedef integer   type; };
    template<> struct add_typeof_helper<integer,natural>        { typedef integer   type; };

[endsect]

[endsect]

[section:Examples Examples]

[section:Example_1 Example 1]

([@../examples/unit_example_1.cpp unit_example_1.cpp])

By using the template specializations for operations on composite dimensions defined in [headerref boost/units/dimension.hpp],
it is possible to perform compile time arithmetic according to the dimensional analysis rules described above
to produce new composite dimensions :

[import ../example/unit_example_1.cpp]

[unit_example_1_snippet_1]

    typedef static_multiply<length_type,mass_type>::type                                       LM_type;
    typedef static_divide<length_type,time_type>::type                                         L_T_type;
    typedef static_root<static_divide<energy_type,mass_type>::type,static_rational<2> >::type  V_type;

outputting (with symbol demangling, implemented in [headerref boost/units/detail/utility.hpp])

[unit_example_1_output]

[endsect]

[section:Example_2 Example 2]

([@../examples/unit_example_2.cpp unit_example_2.cpp])

This example demonstrates the use of the simple but functional unit system implemented in 
[headerref libs/units/example/test_system.hpp] :

[import ../example/unit_example_2.cpp]

[unit_example_2_snippet_1]

We can perform various algebraic operations on these units, resulting in the following output:

[unit_example_2_output]

[endsect]

[section:Example_3 Example 3]

([@../examples/unit_example_3.cpp unit_example_3.cpp])

This example demonstrates how to use quantities of our toy unit system :

[import ../example/unit_example_3.cpp]

[unit_example_3_snippet_1]

giving us the basic quantity functionality :

[unit_example_3_output_double]

As a further demonstration of the flexibility of the system, we replace the `double` value type 
with a `std::complex<double>` value type (ignoring the question of the meaningfulness of
complex lengths and energies) :

[unit_example_3_snippet_2]

and find that the code functions exactly as expected with no additional work, delegating operations 
to `std::complex<double>` and performing the appropriate dimensional analysis :

[unit_example_3_output_complex]

[endsect]

[section:Example_4 Example 4]

([@../examples/unit_example_4.cpp unit_example_4.cpp])

This example provides a fairly extensive set of tests covering most of the [___quantity] functionality.
It uses the SI unit system defined in [headerref boost/units/systems/si.hpp].

If we define a few units and associated quantities,

[import ../example/unit_example_4.cpp]

[unit_example_4_snippet_1]

the various algebraic operations between scalars, units, and quantities give 

[unit_example_4_output_1]

Scalar/unit operations :

[unit_example_4_output_2]

Unit/unit operations and integral/rational powers of units :

[unit_example_4_output_3]

Scalar/quantity operations :

[unit_example_4_output_4]

Unit/quantity operations :

[unit_example_4_output_5]

Quantity/quantity operations and integral/rational powers of quantities :

[unit_example_4_output_6]

Logical comparison operators are also defined between quantities :

[unit_example_4_snippet_2]

giving

[unit_example_4_output_7]

Implicit conversion is allowed between dimensionless quantities and their corresponding value types :

[unit_example_4_snippet_3]

A generic function for computing mechanical work can be defined that takes force and distance arguments
in an arbitrary unit system and returns energy in the same system:

[unit_example_4_function_snippet_3]

[unit_example_4_snippet_4]

which functions as expected for SI quantities :

[unit_example_4_output_9]

The ideal gas law can also be implemented in SI units :

[unit_example_4_function_snippet_4]

[unit_example_4_snippet_5]

with the resulting output :

[unit_example_4_output_10]

Trigonometric and inverse trigonometric functions can be implemented for any unit system
that provides an angular fundamental dimension. These behave as one expects, with trigonometric functions
taking an angular quantity and returning a dimensionless quantity, while the inverse trigonometric functions
take a dimensionless quantity and return an angular quantity :

[unit_example_4_function_snippet_1]

[unit_example_4_function_snippet_2]

Defining a few angular quantities,

[unit_example_4_snippet_6]

yields

[unit_example_4_output_11]

Dealing with complex quantities is trivial. Here is the calculation of complex impedance :

[unit_example_4_snippet_7]

giving

[unit_example_4_output_12]

[section:UDT_Quantities User-defined value types]

User-defined value types that support the appropriate arithmetic operations are automatically supported
as quantity value types. The operators that are supported by default for quantity value types are unary plus, unary minus,
addition, subtraction, multiplication, division, equal-to, not-equal-to, less-than, less-or-equal-to, 
greater-than, and greater-or-equal-to. Support for rational powers and roots can be added by overloading
the [___power_typeof_helper] and [___root_typeof_helper] classes. Here we implement a user-defined `measurement`
class that models a numerical measurement with an associated measurement error and the appropriate algebra and
demonstrate it's use as a quantity value type; the full code is found in [@../examples/measurement.hpp measurement.hpp]:

[import ../example/measurement.hpp]

[measurement_snippet_1]

Then, defining some `measurement` [___quantity] variables

[unit_example_4_snippet_8]

gives

[unit_example_4_output_13]

If we implement the overloaded helper classes for rational powers and roots :

[measurement_snippet_2]

then we can also compute rational powers of measurement quantities :

[unit_example_4_output_14]

[endsect]

[endsect]

[section:Example_5 Example 5]

([@../examples/unit_example_5.cpp unit_example_5.cpp])

This example demonstrates [___quantity_cast] and the various allowed conversions between SI and CGS units. Defining some
quantities

[import ../example/unit_example_5.cpp]

[unit_example_5_snippet_1]

illustrates implicit conversion of quantities of different value types where implicit conversion 
of the value types themselves is allowed. [___quantity_cast] allows explicit conversions for three cases:

* construction of a quantity from a raw value :

[unit_example_5_snippet_2]

* explicit casting of a [___quantity] to a different `value_type` :

[unit_example_5_snippet_3]

* and explicit casting of a [___quantity] to a different unit :

[unit_example_5_snippet_4]

giving the following output :

[unit_example_5_output_1]

Explicit unit system conversion is allowed in the [___quantity] constructor :

[unit_example_5_snippet_5]

which produces the following output:

[unit_example_5_output_2]

While the library default is to enable only those unit conversions for which the conversion of every
fundamental dimension present in a quantity is specifically enabled as implicit, it is possible to 
supersede this behavior and enable all implicit conversions by defining the preprocessor 
constant [___BOOST_UNITS_ENABLE_IMPLICIT_UNIT_CONVERSIONS]. This allows us to do things like the following:

[unit_example_5_snippet_3]

which produces the following output:

[unit_example_5_output_3]

Of course, blindly enabling implicit conversions entails some risk of unnecessary conversions being done
in the background, with the potential for loss of precision and other related concerns. These issues should
be seriously considered, and, if possible, implicit conversions limited to cases where it is expressly 
allowed such as in the conversion between two identical units in different unit systems (e.g. seconds in
SI and CGS systems).

[endsect]

[section:Example_6 Example 6]

([@../examples/unit_example_6.cpp unit_example_6.cpp])

This example demonstrates use of a user-defined `scaled_value` value type that carries with it
a base and exponent as a compile-time prefactor and has a heterogenous algebra. That is, the result of the product
of two scaled values is not normally the same scaled value as either of the arguments. This class can be 
used, for example, to represent numbers in scientific notation over a dramatically larger range than even
double precision floating point variables. For example,

[import ../example/unit_example_6.cpp]

[unit_example_6_snippet_1]

defines the variable `length` as `4.0 * 10^3` meters and `time` as `10.0 * 10^{-2}` seconds.
Performing various operations on these variables correctly handles the heterogeneous algebra both for the value
type and for the dimensional analysis:

[unit_example_6_output_1]

[endsect]

[section:Example_7 Example 7]

([@../examples/unit_example7.cpp unit_example_7.cpp])

This example integrates Boost.Units into an N-dimensional array class, again demonstrating the ability 
to propagate quantities seamlessly through calculations. It is worthwhile noting that the `Array` class itself has no
knowledge of quantities, other than carefully implementing the various operators necessary. Because the associated 
array code is extensive, the array headers are not included (a similar example using built in C++ arrays is also
found in the source code to this example). This code

[import ../example/unit_example_7.cpp]

[unit_example_7_snippet_1]

[unit_example_7_snippet_2]

gives the following:

[unit_example_7_output_1]

[endsect]

[section:Example_8 Example 8]

([@../examples/unit_example_8.cpp unit_example_8.cpp])

This example demonstrates the use of `boost::math::quaternion` as a value type for  [___quantity] and the converse.
For the first case, we first define specializations of [___power_typeof_helper] and [___root_typeof_helper] for 
powers and roots, respectively:

[import ../example/unit_example_8.cpp]

[unit_example_8_class_snippet_1]

We can now declare a [___quantity] of a `quaternion` :

[unit_example_8_snippet_1]

so that all operations that are defined in the `quaternion` class behave correctly. If rational
powers were defined for this class, it would be possible to compute rational powers and roots with
no additional changes. 

[unit_example_8_output_1]

Now, if for some reason we preferred the [___quantity] to be the value type of the `quaternion` class we would have :

[unit_example_8_snippet_2]

Here, the unary plus and minus and addition and subtraction operators function correctly. Unfortunately, 
the multiplication and division operations fail because `quaternion` implements them in terms of the `*=` and 
`/=` operators, respectively, which are incapable of representing the heterogenous unit algebra needed for 
quantities (an identical problem 
occurs with `std::complex<T>`, for the same reason). In order to compute rational powers and roots, we need to 
specialize [___power_typeof_helper] and [___root_typeof_helper] as follows:

[unit_example_8_class_snippet_2]

giving:

[unit_example_8_output_2]

[endsect]

[section:Example_9 Example 9]

([@../examples/unit_example_9.cpp unit_example_9.cpp])

This example demonstrates how to implement a replacement `complex` class that functions correctly both as a 
quantity value type and as a quantity container class, including heterogeneous multiplication and division 
operations and rational powers and roots. Naturally, heterogeneous operations are only supported on
compilers that implement `typeof`. The primary differences are that binary operations are not implemented
using the `op=` operators and use the utility classes [___add_typeof_helper], [___subtract_typeof_helper], 
[___multiply_typeof_helper], and [___divide_typeof_helper]. In addition, [___power_typeof_helper] and
[___root_typeof_helper] are defined for both cases :

[import ../example/unit_example_9.cpp]

[unit_example_9_class_snippet_1]

With this replacement `complex` class, we can declare a complex variable :

[unit_example_9_snippet_1]   

to get the correct behavior for all cases supported by [___quantity] with a `complex` value type :

[unit_example_9_output_1]

and, similarly, `complex` with a [___quantity] value type 

[unit_example_9_snippet_2]

gives

[unit_example_9_output_2]

[endsect]

[section:Example_10 Example 10]

([@../examples/unit_example_10.cpp unit_example_10.cpp])

This is an extended example of use of quantities with trigonometric functions. Angle representations in
degrees, radians, and gradians are implemented in [headerref boost/units/systems/trig.hpp]. Defining angles
in each system as :

[import ../example/unit_example_10.cpp]

[unit_example_10_snippet_1]

we can use them as arguments to the trigonometric functions to obtain :

[unit_example_10_output]

[endsect]

[section:Example_11 Example 11]

([@../examples/unit_example_11.cpp unit_example_11.cpp])

This example demonstrates overloaded `cmath` functions from [headerref boost/units/cmath.hpp]. The support
for C99 standard functions in <cmath> is variable between compilers, so some functions may not be provided.

[import ../example/unit_example_11.cpp]

[unit_example_11_output]

[endsect]

[section:Example_12 Example 12]

([@../examples/unit_example_12.cpp unit_example_12.cpp])

This example demonstrates interoperability with `boost::numeric::interval`, with

[import ../example/unit_example_12.cpp]

[unit_example_12_snippet_1]

giving

[unit_example_12_output_1]

[endsect]

[section:Example_13 Example 13]

([@../example/unit_example_13.cpp unit_example_13.cpp])

This example demonstrates Boost.Serialization support, provided for units and quantities, with

[import ../example/unit_example_13.cpp]

[unit_example_13_snippet_1]

giving

[unit_example_13_output]

[endsect]

[section:Example_14 Example 14]

([@../example/unit_example_14.cpp unit_example_14.cpp])

This example provides an ad hoc performance test to verify that zero runtime overhead 
is incurred when using [___quantity] in place of `double`. 

[endsect]

[section:Example_15 Example 15]

([@../example/unit_example_15.cpp unit_example_15.cpp])

This example demonstrates use of Boost.Units to differentiate coordinate systems. 
Conversions between unit systems (either explicit or implicit) could also be added,
if desired.

[endsect]

[section:Example_16 Example 16]

([@../example/unit_example_16.cpp unit_example_16.cpp])

[import ../example/unit_example_16.cpp]

This example demonstrates the implementation of two non-SI units of length, the 
nautical mile :

[unit_example_16_class_snippet_1]

and the imperial foot :

[unit_example_16_class_snippet_2]

These units include conversions between themselves and the meter. Three functions
for computing radar beam height from radar range and the local earth radius are 
defined. The first takes arguments in one system and returns a value in the same 
system :

[unit_example_16_function_snippet_1]

The second is similar, but is templated on return type, so that the arguments are
converted to the return unit system internally :

[unit_example_16_function_snippet_2]

Finally, the third function is an empirical approximation that is only valid for
radar ranges specified in nautical miles, returning beam height in feet. This 
function uses the heterogeneous unit of nautical miles per square root of feet to
ensure dimensional correctness :

[unit_example_16_function_snippet_3]

With these, we can compute radar beam height in various unit systems :

[unit_example_16_snippet_1]

giving

[unit_example_16_output]

[endsect]

[section:Example_17 Example 17]

([@../example/unit_example_17.cpp unit_example_17.cpp])

This example demonstrates the abstract physical unit system provided for strictly
dimensional analysis calculations. This system explicitly prohibits quantity 
conversions of any sort to ensure that it cannot be mixed with other unit systems.

[import ../example/unit_example_17.cpp]

[unit_example_17_snippet_1]

gives

[unit_example_17_output]

[endsect]

[section:Example_18 Example 18]

([@../example/unit_example_18.cpp unit_example_18.cpp])

Mixed units and mixed unit conversions.

[endsect]

[section:Example_19 Example 19]

([@../example/unit_example_19.cpp unit_example_19.cpp])

This example demonstrates the fairly complete subset of the [@http://physics.nist.gov/cuu/Constants/index.html CODATA physical 
constants] in SI units provided in [headerref boost/units/systems/si/codata_constants.hpp]. At present, these constants are
only available for compilers that support `typeof`. 

[import ../example/unit_example_19.cpp]

[unit_example_19_output]

[endsect]

[section:Example_20 Example 20]

([@../example/unit_example_20.cpp unit_example_20.cpp])

Absolute and relative temperatures in Fahrenheit and conversions to Kelvin.

[endsect]

[endsect]

[section:Utilities Utilities]

Relatively complete SI and CGS unit systems are provided in [headerref boost/units/systems/si.hpp] and
[headerref boost/units/systems/cgs.hpp], respectively. 

[section:Metaprogramming_Classes Metaprogramming Classes]

    template<long N> struct ordinal<N>;

    template<typename T,typename V> struct get_tag< dim<T,V> >;
    template<typename T,typename V> struct get_value< dim<T,V> >;
    template<class S,class DT> struct get_system_tag_of_dim<S,DT>;
    template<typename Seq> struct make_dimension_list<Seq>;
    template<class DT> struct fundamental_dimension<DT>;
    template<class DT1,int E1,...> struct composite_dimension<DT1,E1,...>;

    template<class Dim,class System> struct get_dimension< unit<Dim,System> >;
    template<class Unit,class Y> struct get_dimension< quantity<Unit,Y> >;
    template<class Dim,class System> struct get_system< unit<Dim,System> >;
    template<class Unit,class Y> struct get_system quantity<Unit,Y> >;

    struct dimensionless_type;
    template<class System> struct dimensionless_unit<System>;
    template<class System,class Y> struct dimensionless_quantity<System,Y>;

    struct implicitly_convertible;
    struct trivial_conversion;
    template<class T,class S1,class S2> struct base_unit_converter<T,S1,S2>;

    template<class Q1,class Q2> class conversion_helper<Q1,Q2>;

[endsect]

[section:Metaprogramming_Predicates Metaprogramming Predicates]

    template<typename T,typename V> struct is_dim< dim<T,V> >;
    template<typename T,typename V> struct is_empty_dim< dim<T,V> >;

    template<typename Seq> struct is_dimension_list<Seq>;

    template<class S> struct is_system< homogeneous_system<S> >;
    template<class S> struct is_system< heterogeneous_system<S> >;
    template<class S> struct is_homogeneous_system< homogeneous_system<S> >;
    template<class S> struct is_heterogeneous_system< heterogeneous_system<S> >;

    template<class Dim,class System> struct is_unit< unit<Dim,System> >;
    template<class Dim,class System> struct is_unit_of_system< unit<Dim,System>,System >;
    template<class Dim,class System> struct is_unit_of_dimension< unit<Dim,System>,Dim >;
    template<class Tag,class System1,class System2> struct base_unit_is_implicitly_convertible;
    template<class S1,class D1,class S2,class D2> struct is_implicitly_convertible< unit<D1,S1>,unit<D2,S2> >;

    template<class Unit,class Y> struct is_quantity< quantity<Unit,Y> >;
    template<class Dim,class System,class Y> struct is_quantity_of_system< quantity<unit<Dim,System>,Y>,System >;
    template<class Dim,class System,class Y> struct is_quantity_of_dimension< quantity<unit<Dim,System>,Y>,Dim >;

    template<class System> struct is_dimensionless< unit<dimensionless_type,System> >;
    template<class System> struct is_dimensionless_unit< unit<dimensionless_type,System> >;
    template<class System,class Y> struct is_dimensionless< quantity<unit<dimensionless_type,System>,Y> >;
    template<class System,class Y> struct is_dimensionless_quantity< quantity<unit<dimensionless_type,System>,Y> >; 

[endsect]

[endsect]

[section:Reference Reference]

[xinclude units_reference.boostbook]

[xinclude si_reference.boostbook]

[xinclude cgs_reference.boostbook]

[xinclude trig_reference.boostbook]

[xinclude abstract_reference.boostbook]

[xinclude temperature_reference.boostbook]

[endsect]

[section:Installation Installation]

The core header files are located in `boost/units`. Unit system headers are 
located in `<boost/units/systems>`. There are no source files for the library
itself; example programs demonstrating various aspects of the library can be found in 
`boost/libs/units/example`. Programs for unit testing are provided in 
`boost/libs/units/test`.

[endsect]

[section:FAQ FAQ]

[section:Distinguishing_Quantities_With_Same_Units
How does one distinguish between quantities that are physically different but have the same units (such as 
energy and torque)?]

In cases such as this, the proper way to treat this difference is to recognize that the
underlying value types are distinct. For the particular case of energy vs. torque,
energy is a true
[@http://mathworld.wolfram.com/Scalar.html scalar] quantity, while torque, despite
having the same units as energy, is in fact a 
[@http://mathworld.wolfram.com/Pseudovector.html pseudovector]. Thus, to properly
treat torque quantities, a value type representing pseudovectors and encapsulating their 
algebra would have to be implemented. Then, one would write something like this:

    quantity<energy,double>          E;
    quantity<energy,pseudovector>    tau;

naturally, a typedef for torque could also be added to make the intent more transparent.

[endsect]

[section:Namespace_Boost Why is everything in the boost namespace?]

Boost.Units (formerly `mcs::units`) was originally written as an example of generic programming for dimensional analysis for the
Boost mailing list. There is also significant interest in development of a Boost Units library,
and this library represents my vision for how it could be done cleanly. Andrew Little has an extensive
project that was recently reviewed and rejected by Boost that demonstrates his (very different) 
take on the idea 
[@http://quan.sourceforge.net here]. There are also a number of additional units projects 
of varying degrees of completion in the 
[@http://boost-consulting.com/vault/index.php?&direction=0&order=&directory=Units Boost Vault]
and the
[@http://boost-consulting.com/vault/index.php?&direction=0&order=&directory=Units Boost Files] 
page on Yahoo! Groups (accessing the latter may require registration). As of February 6, 2007, `mcs::units`
has been officially submitted for public review for inclusion into Boost.

[endsect]

[section:Angle_Are_Units Angles are treated as units]

If you don't like this, you can just ignore the angle units and 
go on your merry way (periodically screwing up when a routine wants degrees and you give it 
radians instead...)

[endsect]

[endsect]

[section:Acknowledgements Acknowledgements]

Thanks to David Walthall for his assistance in debugging and
testing on a variety of platforms.

Thanks to:

* Paul Bristow, 
* Michael Fawcett, 
* Ben FrantzDale, 
* Ron Garcia,
* David Greene,
* Peder Holt,
* Janek Kozicki, 
* Andy Little,
* Kevin Lynch,
* Noah Roberts,
* Andrey Semashev,
* David Walthall,
* Deane Yang, 

and all the members of the Boost mailing list who provided their input into 
the design and implementation of this library.

[endsect]

[section:HelpWanted Help Wanted]

 Any help in the following areas would be much appreciated:

* testing on compilers other than gcc 4.0.1 under Mac OSX, and 
  MSVC 8.0, Metrowerks CodeWarrior 9.2, MSVC 7.1, and gcc 3.4.4 under Windows
* performance testing on various architectures
* tutorials on getting started and implementing new unit systems

[endsect]

[section:ReleaseNotes Release Notes]

0.7.1 (February 14, 2007) :

* Boost.Typeof emulation support
* attempting to rebind a heterogeneous_system to a different set of dimensions now fails.
* cmath.hpp now works with como-win32
* minor changes to the tests and examples to make msvc 7.1 happy

 0.7.0 (March 13, 2007) :

* heterogeneous and mixed system functionality added
* added fine-grained implicit unit conversion on a per fundamental dimension basis
* added a number of utility metafunction classes and predicates
* [headerref boost/units/operators.hpp] now uses `BOOST_TYPEOF` when possible
* angular units added in [headerref boost/units/systems/trig.hpp] - implicit conversion
    of radians between trigonometric, SI, and CGS systems allowed
* a variety of [___unit] and [___quantity] tests added
* examples now provide self-tests

0.6.2 (February 22, 2007) :

*  changed template order in `unit` so dimension precedes unit system
*  added `homogeneous_system<S>` for unit systems
*  incorporated changes to [headerref boost/units/dimension.hpp] (compile-time sorting by predicate), 
   [headerref boost/units/conversion.hpp] (thread-safe implementation of quantity conversions), 
   and [headerref boost/units/io.hpp] (now works with any `std::basic_ostream`) by SW
* added abstract units in [headerref boost/units/systems/abstract.hpp] to allow abstract dimensional
  analysis
* new example demonstrating implementation of code based on requirements from 
  Michael Fawcett ([@../examples/unit_example_16.hpp unit_example_16.cpp])

0.6.1 (February 13, 2007) :

* added metafunctions to test if a type is 
    * a valid dimension list (`is_dimension_list<D>`)
    * a unit (`is_unit<T>` and `is_unit_of_system<U,System>`)
    * a quantity (`is_quantity<T>` and `is_quantity_of_system<Q,System>`) 
* quantity conversion factor is now computed at compile time 
* static constants now avoid ODR problems
* unit_example_14.cpp now uses Boost.Timer
* numerous minor fixes suggested by SW

0.6.0 (February 8, 2007) :

* incorporated Steven Watanabe's optimized code for dimension.hpp, leading to *dramatic*
  decreases in compilation time (nearly a factor of 10 for unit_example_4.cpp in my tests).

0.5.8 (February 7, 2007) :

* fixed `#include` in [headerref boost/units/systems/si/base.hpp] (thanks to Michael Fawcett and 
  Steven Watanabe)
* removed references to obsolete `base_type` in [___unit_info] (thanks to Michael Fawcett)
* moved functions in [headerref boost/units/cmath.hpp] into `boost::units` namespace 
  (thanks to Steven Watanabe)
* fixed `#include` guards to be consistently named `BOOST_UNITS_XXX` (thanks to Steven 
  Watanabe)

0.5.7 (February 5, 2007) :

* changed quantity conversion helper to increase flexibility
* minor documentation changes
* submitted for formal review as a Boost library

0.5.6 (January 22, 2007) :

* added IEEE 1541 standard binary prefixes along with SI prefixes to and extended algebra of
  `scale` and `scaled_value` classes (thanks to Kevin Lynch)
* split SI units into separate header files to minimize the "kitchen sink" include problem
  (thanks to Janek Kozicki)
* added convenience classes for declaring fundamental dimensions and composite dimensions 
   with integral powers (`fundamental_dimension` and `composite_dimension` respectively)

0.5.5 (January 18, 2007) :

* template parameter order in `quantity` switched and default `value_type` of `double` added
  (thanks to Andrey Semashev and Paul Bristow)
* added implicit `value_type` conversion where allowed (thanks to Andrey Semashev)
* added `quantity_cast` for three cases (thanks to Andrey Semashev):
    * constructing `quantity` from raw `value_type`
    * casting from one `value_type` to another
    * casting from one `unit` to another (where conversion is allowed) 
* added` metre` and `metres` and related constants to the SI system for the convenience of
  our Commonwealth friends...

0.5.4 (January 12, 2007) :

* completely reimplemented unit conversion to allow for arbitrary unit conversions
  between systems
* strict quantity construction is default; quantities can be constructed from bare values 
  by using static member `from_value`

0.5.3 (December 12, 2006) :

* added Boost.Serialization support to `unit` and `quantity` classes
* added option to enforce strict construction of quantities (only constructible
  by multiplication of scalar by unit or quantity by unit) by preprocessor
  `MCS_STRICT_QUANTITY_CONSTRUCTION` switch

0.5.2 (December 4, 2006) :

* added `<cmath>` wrappers in the `std` namespace for functions that can support quantities 

0.5.1 (November 3, 2006) :

* converted to Boost Software License
* boostified directory structure and file paths

0.5 (November 2, 2006) :

* completely reimplemented SI and CGS unit systems and changed syntax for quantities
* significantly streamlined `pow` and `root` so for most applications it is only
  necessary to define `power_typeof_helper` and `root_typeof_helper` to gain this
  functionality
* added a selection of physical constants from the CODATA tables
* added a skeleton `complex` class that correctly supports both `complex<quantity<Y,Unit> >`
  and `quantity<complex<Y>,Unit>` as an example
* investigate using Boost.Typeof for compilers that do not support `typeof`

0.4 (October 13, 2006) : 

* `pow<R>` and `root<R>` improved for user-defined types
* added unary + and unary - operators
* added new example of interfacing with `boost::math::quaternion`
* added optional preprocessor switch to enable implicit unit conversions
  (`BOOST_UNITS_ENABLE_IMPLICIT_UNIT_CONVERSIONS`) 

0.3 (September 6, 2006) :

* Support for `op(X x,Y y)` for g++ added. This is automatically
  active when compiling with gcc and can be optionally enabled by defining the preprocessor
  constant `BOOST_UNITS_HAS_TYPEOF`

0.2 (September 4, 2006) : Second alpha release based on slightly modified code from 0.1 release

0.1 (December 13, 2003)  : written as a Boost demonstration of MPL-based dimensional analysis
in 2003.

[endsect]

[section:TODO TODO]

* Document concepts
* Implementation of I/O is rudimentary; consider methods of i18n using facets
* Consider runtime variant, perhaps using overload like `quantity<runtime,Y>`

[endsect]
