<HTML>
<HEAD>
<META NAME="GENERATOR" Content="Microsoft Visual Studio 10.0">
<TITLE></TITLE>
</HEAD>
<BODY>



    <div class="document">
        <table class="docinfo" frame="void" rules="none">
            <colgroup>
                <col class="docinfo-name" />
                <col class="docinfo-content" />
            </colgroup>
            <tbody valign="top">
                <tr>
                    <th class="docinfo-name">
                        Authors:</th>
                    <td>
                        Christian Schladetsch (christian.schladetsch@gmail.com)</td>
                </tr>
                <tr>
                    <th class="docinfo-name">
                        Version:</th>
                    <td>
                        0.1a</td>
                </tr>
                <tr class="field">
                    <th class="docinfo-name">
                        License:</th>
                    <td class="field-body">
                        Distributed under the Boost Software License, Version 1.0.</td>
                </tr>
            </tbody>
        </table>
        <div id="boost-bloom-filter" class="section">
            <h1>
                Boost.Monotonic</h1>
            <p>
                This proposal uses std::allocators and a common storage concept to provide 
                correctly-aligned allocation of objects of different types from the same buffer. 
                This buffer can be on the heap or on the stack. The allocation model is designed 
                to be optimal in time with also zero space overhead per allocation made.</p>
            <p>
                The name &#39;monotonic&#39; has been criticised as being too general and not really 
                indicative of the scope and purpose of the library. All alternative suggestions 
                gratefully considered!</p>
            <h2 id="Motivation">
                Motivation
            </h2>
            <p>
                We would sometimes like to use the various STL containers and use the stack for 
                their storage. In 
                this way, for example, a map&lt;K, list&lt; vector&lt;T&gt; &gt; &gt; can use storage from the stack 
                for the map, the list and the vector, rather than 
                fragmenting the heap.             </p>
            <p>
                Also, it would be great if the same storage 
                could be used by different containers, and even better if we could choose to use 
                the stack or the heap, and better still if there was zero overhead for the 
                memory allocations.</p>
            <p>
                There are many uses for such a system, including very fast and very small data 
                structures, per-frame containers, 
                efficient use containers for use in recursion, and reducing or removing heap 
                fragmentation.             </p>
            <p>
                This is what this library does, by collaborating multiple instances of the same 
                type of allocator with a 
                common shared storage.
                It is a fast allocation system, O(1) to allocate and zero-cost to deallocate; hence the proposed name of a 
                &quot;monotonic&quot; allocator.             </p>
            <h2 id="Proposal">
                Quick Example</h2>
            <p>
                The following example uses std::containers with the allocator in this library by 
                explicitly declaring the allocator type. An optional and debatable extension to 
                the library includes some basic wrapper types around the std::containers that 
                simplifies the syntax somewhat.</p>
                <pre>void shared()<br />{
	// declare the storage that will be shared by the various containers.
	// storage is on the stack here, but can be put on the heap with `new`
	boost::monotonic::inline_storage&lt;10000&gt; storage;<br />	{		
		std::map&lt;int, int, std::less&lt;int&gt;, boost::monotonic::allocator&lt;int&gt; &gt; map(storage);
		map[1] = 2;
		map[2] = 4;

		std::vector&lt;char, boost::monotonic::allocator&lt;char&gt; &gt; vec(storage);
		vec.assign(&#39;x&#39;, 4);

		std::list&lt;char, boost::monotonic::allocator&lt;char&gt; &gt; list(storage);
		std::copy(vec.begin(), vec.end(), std::back_inserter(list));

		typedef std::pair&lt;int, int&gt; pair;
		std::set&lt;pair, std::less&lt;pair&gt;, boost::monotonic::allocator&lt;pair&gt; &gt; set(storage);
		std::copy(map.begin(), map.end(), std::inserter(set));
	}
}</pre>
            <h2>
                Proposal
            </h2>
            <p>
                                The <a href="https://svn.boost.org/svn/boost/sandbox/monotonic">source code</a> resides in the boost sandbox.</p>
            <p>
                This is a constant-time, STL-compliant[1] allocator and storage 
                system with the following 
                properties:             </p>
            <ul>
                <li>Space for objects is pre-allocated. This can be on the heap <strong>or</strong> 
                    on the stack. </li>
                <li>Objects are initialised only as required. </li>
                <li>De-allocating an object calls its destructor iff it has one.</li>
                <li>Object storage is not reclaimed until the underlying storage goes out of scope.
                </li>
                <li>Multiple different containers of any type can share the same storage via 
                    different allocators.</li>
            </ul>
            <p>
                The benefits of using a monotonic::allocator over other allocators are:
                      <ul>
                <li>All storage is pre-allocated, similar to a pool </li>
                <li>Storage can be on the stack:                     <ul>
                        <li>Heap is not even used, let alone fragmented </li>
                        <li>Cache coherency is high </li>
                    </ul>
                </li>
                <li>Allocation is lightening-fast as it only involves advancing a pointer and 
                    possible alignment.</li>
                <li>Deallocation is even faster as it does absolutely nothing </li>
                <li>Different containers can share the same storage </li>
            </ul>
            <p>
                There are also limitations:             </p>
            <ul>
                <li>Containers must be constructed with either an allocator or storage. There are no 
                    default allocators, and hence no default container constructors. </li>
                <li>Storage grows monotonically: removing objects from a container does not 
                    de-allocate memory </li>
                <li>Stackspace is limited and putting large containers on the stack may exhaust 
                    stack space
                    <ul>
                        <li>This can be addressed on a per-compiler basis </li>
                        <li>The system can be used with the storage on the heap </li>
                    </ul>
                </li>
            </ul>
            <p>
                TODO:
            </p>
            <ul>
                <li>provide details on default stack-sizes on each target platform </li>
                <li>provide details as details on how to increase this. </li>
                <lprovide guidance on &#39;good&#39; sizes for containers that are stored on the stack
                </li>
            </ul>
            <h2 id="Architecture">
                Architecture
            </h2>
            <p>
                The architecture is quite simple. There are three main components: the storage, 
                the allocator and the container. The storage is based on boost::array&lt;char,N&gt; 
                and is on the stack or the heap. The allocator is stored in the container, which 
                is initialised with either an allocator or storage.<h3 id="Containers">
                Storage</h3>
            <p>
                The storage is provided via boost::monotonic::storage&lt;size_t num_bytes&gt;</p>
            <p>
                Put it on the stack to use storage on the stack, or put it on the heap to use 
                storage on the heap.</p>
            <h3>
              Allocator</h3>
            <p>
                boost::monotonic::allocator&lt;T&gt; provides a means for a set of containers to share 
                monotonic::storage.</p>
            <p>
                Allocations performed 
                by this allocator are correctly aligned for each container independantly (thanks 
                Artyom, Thorsten!); de-allocations 
                requested by this allocator do nothing.</p>
            <p>
                Allocators are initialised with storage. There is no overhead added to any 
                memory allocation; the only bytes used are the number of bytes required, plus 
                whatever is required by the platform for correct alignment.</p>
            <h3>
                Containers
            </h3>
            <p>
                The following container wrappers are, currently and precipitously, part of this proposal:             </p>
            <ul>
                <li>bboost::monotonic::list&lt;T&gt;</li>
                <li>boost::monotonic::vector&lt;T&gt; /li>
                <li>boost::monotonic::map&lt;K,T&gt; </li>
                <li>boost::monotonic::multi_map&lt;K,T&gt; </li>
                <li>boost::monotonic::set&lt;T&gt; </li>
                <li>boost::monotonic::multi_set&lt;T&gt; </li>
                <li>boost::monotonic::ptr_list&lt;T&gt; </li>
                <li>boost::monotonic::ptr_vector&lt;T&gt; </li>
                <li>boost::monotonic::ptr_map&lt;K,T&gt; </li>
                <lboost::monotonic::ptr_set&lt;T&gt; </li>
            </ul>
            <p>
                boost::unordered can have a similar treatment.</p>
            <p>
                Each of these are just the underlying container, which defaults to using 
                boost::monotonic::allocator&lt;T&gt;.</p>
            <p>
                It has been strongly suggested that these convenience structures be removed from 
                the proposal. For comparison, in the following Vector and Map are two exactly equivalent types:</p>
            <pre>ttypedef boost::monotonic::vector&lt;int&gt; Vector;
typedef std::vector&lt;int, boost::monotonic::allocator&lt;int&gt; &gt; Vector;</pre>
            <pre>typedef boost::monotonic::map&lt;int, boost::monotonic::list&lt;int&gt; &gt; Map;
typedef std::map&lt;int, std::list&lt;int, boost::monotonic::allocator&lt;int&gt; &gt;, std::less&lt;int&gt;, boost::monotonic::allocator&lt;int&gt; &gt; Map;</pre>
            <p>
                The container-wrappers currently remain part of the proposal, but this may well 
                change. In the meantime, the user is quite capable of using either method.</p>
            <h2 id="ExampleUsage">
                Memory Fragmentation</h2>
            <p>
                The proposed system can be used to reduce memory fragmentation, or remove it 
                completely. For example:</p>
                <pre>void Mainloop()()
{
	boost::monotonic::storage&lt;100000&gt; storage;
	for (;;)
	{
		DoStuff(storage);
		storage.reset();
	}
}</pre>
            <h2>
                Performance</h2>
            <p>
                This is still under investigation. Results to follow. The code in the sandbox 
                gives a favorable indication, but far more exhaustive testing is required before 
                any claims can be confidently made.</p>
            <h2>
                Example Usage
            </h2>
            <p>
                Quite often, we need to create a temporary collection of objects which will 
                exist only for the duration of a code block. A common pattern for this is to 
                collect a set of objects from a container to do some work on:           </p>
            <div class="code">
                <pre><b><span class="code-type">void</span></b> <b><span class="code-func">MainLoop</span></b>()
{
    boost::monotonic::inline_storage&lt;100*<span class="code-lang"><b>sizeof</b>(Object)&gt; storage;   <i><span 
                    class="code-comment">// create local storage on the stack
</span></i>    boost::monotonic::list&lt;Object&gt; deathrow(storage);   <i><span 
                    class="code-comment">// create a std::list that uses this storage</span></i></span></pre>
                <pre><span class="code-lang"><span 
                    class="code-comment">    foreach (object in world)
    {
         <b><span class="code-lang">if</span></b> (IsDead(object))
              deathrow.push_back(object);           <i><span class="code-comment">// allocation is just advancing a pointer
</span></i>    }
    foreach (object in deathrow)
    {
        world.Remove(object);
        object.Delete();
    }
    <span class="code-comment"><i>// storage is removed from stack; the heap is not touched
</i></span>}
</pre>
            </div>
            <p>
                The same system can be used to store very large containers on the heap but still 
                using a monotonic allocator:
            </p>
            <div class="code">
                <pre><b><span class="code-type">void</span></b> <b><span class="code-func">InlineHeapStorage</span></b>()
{
     <i><span class="code-comment">// create inline storage on the heap
</span></i>     <b><span class="code-keyword">std</span></b>::auto_ptr&lt;boost::monotonic::storage&lt;1000*1000*1000&gt; &gt; storage = <b><span 
                    class="code-lang">new </b>boost::monotonic::storage&lt;1000*1000*1000&gt;();

     <i><span class="code-comment">// create a hash-table-based mapping of ints to ints using a monotonic allocator
</span></i>     boost::monotonic::unsorted_map&lt;<b><span class="code-type">int</b>, <b><span 
                    class="code-type">int</span></b>&gt; table(*storage);

     <i><span class="code-comment">// populate the container; no new heap allocations are performed
</span></i>     <b><span class="code-lang">for</span></b> (<b><span class="code-type">int</span></b> n = 0; n &lt; 1000*1000; ++n)
     {
         <i><span class="code-comment">// storage created for the hash-table (including the lists) is pre-allocated
</span></i>         <i><span class="code-comment">// and each allocation requires only a pointer advance
</span></i>         table[rand()] = n;            
     }
}
</pre>
            </div>
            <p>
                Also, the stack-based allocation model can be used for per-frame allocation for 
                temporary storage. By passing the storage down the call-stack (either explicitly 
                as a parameter, or by storing within a visible member field), per-frame 
                containers and other storage can be used without resorting to the heap. At the 
                end of the frame, the storage is automatically released.
            </p>
            <div class="code">
                <pre><b><span class="code-type">void</span></b> <b><span class="code-func">DoSomething</span></b>(boost::monotonic::storage_base &amp;storage)
{      
    boost::monotonic::list&lt;Object&gt; vector(storage);
    <span class="code-comment"><i>// populate and use vector</i>
    DoSomethingElse(storage);
}

<b><span class="code-type">void</span></b> <b><span class="code-func">DoSDoSomethingElse</span></b>(boost::monotonic::storage_base &amp;storage)
{
    boost::monotonic::map&lt;<span class="code-type"><b>int</b>, Object&gt; map(storage);
    <i><span class="code-comment">// populate and use map
</span></i>}

<b><span class="code-type">void</span></b> <b><span class="code-func">MainLoop</span></b>()
{
    <b><span class="code-lang">while</span></b> (!Finished())
    {
         boost::monotonic::inline_storage&lt;10*1000&gt; storage;
         DoSomething(storage);
         <span class="code-comment"><i>// storage is released, ready for next loop</i>
    </span>}
}
</pre>
            </div>
            <p>
                Recursion also benefits from using the stack to store containers. For example, 
                assuming a cyclic graph of objects, we can avoid infinite recursion by using a 
                stack-based set:
            </p>
            <div class="code">
                <pre><b><span class="code-type">void</span></b> <b><span class="code-func">Object::Recurse</span></b>()
{
    boost::monotonic::inline_storage&lt;5000&gt; storage;    <i><span class="code-comment">// create storage on the stack for a set
</span></i>    Recurse(boost::monotonic::set&lt;<b><span class="code-type">int</b>&gt;(storage));      <i><span 
                    class="code-comment">// recurse, passing the set
</span></i>}

<b><span class="code-type">void</span></b> <b><span class="code-func">Object::Recurse</span></b>(boost::monotonic::set&lt;<b><span 
                    class="code-type">int</b>&gt; &amp;set)
{
     <b><span class="code-lang">if</span></b> (set.find(handle) != set.end()) <b><span 
                    class="code-lang">return</span></b>;  <i><span class="code-comment">// avoid infinite recursion
</span></i>     set.insert(handle);                         <i><span class="code-comment">// add handle to set for testing later
</span></i>     DoSomething();                              <i><span class="code-comment">// do something to this object
</span></i>     foreach (child object in <b><span class="code-lang">this</span></b>)              <i><span 
                    class="code-comment">// visit all child objects
</span></i>         Recurse(set);
}
</pre>
            </div>
            <div id="reference" class="section">
                <h2>
                    Notes</h2>
                <p>
                    [1] It can be argued that the proposed allocator is not in fact &quot;STL-compliant&quot;, 
                    as it includes a pointer to storage used by the allocator. In truth, the 
                    Standard doesn&#39;t state that allocators may not have any local data, only that 
                    STL implementations are free to treat allocators of the same type as having the 
                    same behavior. In practise, the distinction is largely academic and has had no 
                    seen impact on this library. All modern STL implementation check for allocators 
                    to do things like speed up swap methods etc. These all work with monotonic 
                    allocator as well.</p>
                <h2>
                    References</h2>
                    <li>Boost.AlignedMemory</li>
                    <li>Boost.AutoBuffer. A related service. Attempts to integrate this with STL has so 
                        far been unsuccessful. See libs/monotonic/test/main.cpp#test_auto_buffer</li>
                    <li>Boost.IntrusiveContainer, for an alternative means of creating efficient 
                        containers.</li>
                </ul>
            </div>
        </div>
    </div>



</BODY>
</HTML>
