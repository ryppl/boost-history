<HTML>
<HEAD>
<META NAME="GENERATOR" Content="Microsoft Visual Studio 10.0">
<TITLE></TITLE>
</HEAD>
<BODY>



    <div class="document">
        <table class="docinfo" frame="void" rules="none">
            <colgroup>
                <col class="docinfo-name" />
                <col class="docinfo-content" />
            </colgroup>
            <tbody valign="top">
                <tr>
                    <th class="docinfo-name">
                        Authors:</th>
                    <td>
                        Christian Schladetsch (christian.schladetsch@gmail.com)</td>
                </tr>
                <tr>
                    <th class="docinfo-name">
                        Version:</th>
                    <td>
                        0.1a</td>
                </tr>
                <tr class="field">
                    <th class="docinfo-name">
                        License:</th>
                    <td class="field-body">
                        Distributed under the Boost Software License, Version 1.0.</td>
                </tr>
            </tbody>
        </table>
        <div id="boost-bloom-filter" class="section">
            <h1>
                Boost.Monotonic</h1>
            <p>
                Boost.Monotonic is an implementation of an allocator that use a given, 
                fixed-size storage buffer. This buffer can be on the heap, or the stack, and may 
                be shared by multiple containers.</p>
            <h2 id="Motivation">
                Motivation
            </h2>
            <p>
                We would like to use STL containers which take their storage from the stack. In 
                this way, for example a std::map&lt;K,T&gt; can use storage from the stack rather than 
                fragmenting the heap.             </p>
            <p>
                There are many uses for such a system, including per-frame containers, 
                efficient use containers for use in recursion, and reducing or removing heap 
                fragmentation.             </p>
            <p>
                It is a fast allocation system, with the downside 
                that the resident set size can only grow in size. Hence the proposed name of a 
                &quot;monotonic&quot; allocator.
            </p>
            <h2 id="Proposal">
                Proposal
            </h2>
            <p>
                The <a href="https://svn.boost.org/svn/boost/sandbox/monotonic">source code</a> resides in the boost sandbox.</p>
            <p>
                This is a constant-time, stack-based STL-compliant[1] allocator with the following 
                properties:             </p>
            <ul>
                <li>Space for objects is pre-allocated. This can be on the heap <strong>or</strong> 
                    on the stack. </li>
                <li>Objects are initialised only as required. </li>
                <li>De-allocating an object calls its destructor. </li>
                <li>Object storage is not reclaimed until the underlying storage goes out of scope.
                </li>
            </ul>
            <p>
                The benefits of using a monotonic::allocator over other allocators are:
            </p>
            <ul>
                <li>All storage is pre-allocated, similar to a pool </li>
                <li>Storage can be on the stack:                     <ul>
                        <li>Heap is not even used, let alone fragmented </li>
                        <li>Cache coherency is high </li>
                    </ul>
                </li>
                <li>Allocation is lightening-fast as it only involves advancing a pointer and 
                    possible alignment.</li>
                <li>Deallocation is even faster as it does absolutely nothing </li>
                <li>Different containers can share the same storage </li>
            </ul>
            <p>
                There are also limitations:             </p>
            <ul>
                <li>Containers must be constructed with either an allocator or storage. There are no 
                    default allocators, and hence no default container constructors. </li>
                <li>Storage grows monotonically: removing objects from a container does not 
                    de-allocate memory </li>
                <li>Stackspace is limited and putting large containers on the stack may exhaust 
                    stack space
                    <ul>
                        <li>This can be addressed on a per-compiler basis </li>
                        <li>The system can be used with the storage on the heap </li>
                    </ul>
                </li>
            </ul>
            <p>
                TODO:
            </p>
            <ul>
                <li>provide details on default stack-sizes on each target platform </li>
                <li>provide details as details on how to increase this. </li>
                <li>provide guidance on &#39;good&#39; sizes for containers that are stored on the stack
                </li>
            </ul>
            <h3 id="Containers">
                Allocator</h3>
            <p>
                boost::monotonic::allocator&lt;T&gt; provides a means for a set of containers to share 
                a memory buffer that may be on the stack or on the heap. Allocations performed 
                by this allocator are aligned (thanks Artyom, Thorsten!); de-allocations 
                requested by this allocator do nothing.</p>
            <h3>
                Containers
            </h3>
            <p>
                The following container wrappers are part of this proposal:             </p>
            <ul>
                <li>boost::monotonic::list&lt;T&gt; </li>
                <li>boost::monotonic::vector&lt;T&gt; </li>
                <li>boost::monotonic::map&lt;K,T&gt; </li>
                <li>boost::monotonic::multi_map&lt;K,T&gt; </li>
                <li>boost::monotonic::set&lt;T&gt; </li>
                <li>boost::monotonic::multi_set&lt;T&gt; </li>
                <li>boost::monotonic::ptr_list&lt;T&gt; </li>
                <li>boost::monotonic::ptr_vector&lt;T&gt; </li>
                <li>boost::monotonic::ptr_map&lt;K,T&gt; </li>
                <li>boost::monotonic::ptr_set&lt;T&gt; </li>
            </ul>
            <p>
                boost::unordered can have a similar treatment.</p>
            <p>
                It has been strongly suggested that these convenience structures be removed from 
                the proposal. For comparison, the following are two exactly equivalent types:</p>
            <pre>typedef boost::monotonic::map&lt;int, boost::monotonic::list&lt;int&gt; &gt; Map;
typedef std::map&lt;int, std::list&lt;int, boost::monotonic::allocator&lt;int&gt; &gt;, std::less, boost::monotonic::allocator&lt;int&gt; &gt; Map;</pre>
            &gt;<p>
                The matter can be argued either way. The container-wrappers currently remain 
                part of the proposal, but this may change.</p>
            <h2 id="Architecture">
                Architecture
            </h2>
            <p>
                The architecture is quite simple. There are three main components: the storage, 
                the allocator and the container. The storage is based on boost::array&lt;char,N&gt; 
                and is on the stack or the heap. The allocator is stored in the 
                container, which is initialised with either an allocator or storage, as shown 
                for example with monotonic::map:
            </p>
            <div class="code">
                <pre>/// A std::map&lt;K,T,P&gt; that uses a monotonic allocator 
template &lt;class K, class T, class P = std::less&lt;K&gt; &gt; 
struct map : std::map&lt;K,T,P, allocator&lt;K&gt; &gt; 
{ 
	typedef allocator&lt;K&gt; Allocator; 
	typedef std::map&lt;K,T,P,Allocator &gt; Map; 
	typedef P Predicate; 
	map() { } 
	map(storage_base &amp;S) : Map(Predicate(), Allocator(S)) { } 
	map(Allocator const &amp;A) : Map(Predicate(), A) { } 
	map(Predicate P, Allocator const &amp;A) : Map(P, A) { } 
	// other parameter-forwarding ctors elided for brevity
}; </pre>
            </div>
            <h2 id="ExampleUsage">
                Memory Fragmentation</h2>
            <p>
                The proposed system can be used to reduce memory fragmentation, or remove it 
                completely. For example:</p>
                <pre>void Mainloop()
{
	boost::monotonic::storage&lt;100000&gt; storage;
	for (;;)
	{
		DoStuff(storage);
		storage.reset();
	}
}</pre>
            <h2>
                Performance</h2>
            <p>
                This is still under investigation. Results to follow. The code in the sandbox 
                gives a favorable indication, but far more exhaustive testing is required before 
                any claims can be confidently made.</p>
            <h2>
                Example Usage
            </h2>
            <p>
                Quite often, we need to create a temporary collection of objects which will 
                exist only for the duration of a code block. A common pattern for this is to 
                collect a set of objects from a container to do some work on:           </p>
            <div class="code">
                <pre><b><span class="code-type">void</span></b> <b><span class="code-func">MainLoop</span></b>()
{
    boost::monotonic::inline_storage&lt;100*<span class="code-lang"><b>sizeof</b>(Object)&gt; storage;   <i><span 
                    class="code-comment">// create local storage on the stack
</span></i>    boost::monotonic::list&lt;Object&gt; deathrow(storage);   <i><span 
                    class="code-comment">// create a std::list that uses this storage</span></i></span></pre>
                <pre><span class="code-lang"><span 
                    class="code-comment">    foreach (object in world)
    {
         <b><span class="code-lang">if</span></b> (IsDead(object))
              deathrow.push_back(object);           <i><span class="code-comment">// allocation is just advancing a pointer
</span></i>    }
    foreach (object in deathrow)
    {
        world.Remove(object);
        object.Delete();
    }
    <span class="code-comment"><i>// storage is removed from stack; the heap is not touched
</i></span>}
</pre>
            </div>
            <p>
                The same system can be used to store very large containers on the heap but still 
                using a monotonic allocator:
            </p>
            <div class="code">
                <pre><b><span class="code-type">void</span></b> <b><span class="code-func">InlineHeapStorage</span></b>()
{
     <i><span class="code-comment">// create inline storage on the heap
</span></i>     <b><span class="code-keyword">std</span></b>::auto_ptr&lt;boost::monotonic::storage&lt;1000*1000*1000&gt; &gt; storage = <b><span 
                    class="code-lang">new </b>boost::monotonic::storage&lt;1000*1000*1000&gt;();

     <i><span class="code-comment">// create a hash-table-based mapping of ints to ints using a monotonic allocator
</span></i>     boost::monotonic::unsorted_map&lt;<b><span class="code-type">int</b>, <b><span 
                    class="code-type">int</span></b>&gt; table(*storage);

     <i><span class="code-comment">// populate the container; no new heap allocations are performed
</span></i>     <b><span class="code-lang">for</span></b> (<b><span class="code-type">int</span></b> n = 0; n &lt; 1000*1000; ++n)
     {
         <i><span class="code-comment">// storage created for the hash-table (including the lists) is pre-allocated
</span></i>         <i><span class="code-comment">// and each allocation requires only a pointer advance
</span></i>         table[rand()] = n;            
     }
}
</pre>
            </div>
            <p>
                Also, the stack-based allocation model can be used for per-frame allocation for 
                temporary storage. By passing the storage down the call-stack (either explicitly 
                as a parameter, or by storing within a visible member field), per-frame 
                containers and other storage can be used without resorting to the heap. At the 
                end of the frame, the storage is automatically released.
            </p>
            <div class="code">
                <pre><b><span class="code-type">void</span></b> <b><span class="code-func">DoSomething</span></b>(boost::monotonic::storage_base &amp;storage)
{      
    boost::monotonic::list&lt;Object&gt; vector(storage);
    <span class="code-comment"><i>// populate and use vector</i>
    DoSomethingElse(storage);
}

<b><span class="code-type">void</span></b> <b><span class="code-func">DoSDoSomethingElse</span></b>(boost::monotonic::storage_base &amp;storage)
{
    boost::monotonic::map&lt;<span class="code-type"><b>int</b>, Object&gt; map(storage);
    <i><span class="code-comment">// populate and use map
</span></i>}

<b><span class="code-type">void</span></b> <b><span class="code-func">MainLoop</span></b>()
{
    <b><span class="code-lang">while</span></b> (!Finished())
    {
         boost::monotonic::inline_storage&lt;10*1000&gt; storage;
         DoSomething(storage);
         <span class="code-comment"><i>// storage is released, ready for next loop</i>
    </span>}
}
</pre>
            </div>
            <p>
                Recursion also benefits from using the stack to store containers. For example, 
                assuming a cyclic graph of objects, we can avoid infinite recursion by using a 
                stack-based set:
            </p>
            <div class="code">
                <pre><b><span class="code-type">void</span></b> <b><span class="code-func">Object::Recurse</span></b>()
{
    boost::monotonic::inline_storage&lt;5000&gt; storage;    <i><span class="code-comment">// create storage on the stack for a set
</span></i>    Recurse(boost::monotonic::set&lt;<b><span class="code-type">int</b>&gt;(storage));      <i><span 
                    class="code-comment">// recurse, passing the set
</span></i>}

<b><span class="code-type">void</span></b> <b><span class="code-func">Object::Recurse</span></b>(boost::monotonic::set&lt;<b><span 
                    class="code-type">int</b>&gt; &amp;set)
{
     <b><span class="code-lang">if</span></b> (set.find(handle) != set.end()) <b><span 
                    class="code-lang">return</span></b>;  <i><span class="code-comment">// avoid infinite recursion
</span></i>     set.insert(handle);                         <i><span class="code-comment">// add handle to set for testing later
</span></i>     DoSomething();                              <i><span class="code-comment">// do something to this object
</span></i>     foreach (child object in <b><span class="code-lang">this</span></b>)              <i><span 
                    class="code-comment">// visit all child objects
</span></i>         Recurse(set);
}
</pre>
            </div>
            <div id="reference" class="section">
                <h2>
                    Notes</h2>
                <p>
                    [1] It can be argued that the proposed allocator is not in fact &quot;STL-compliant&quot;, 
                    as it includes a pointer to storage used by the allocator. This can be addressed 
                    either by changing the standard to allow an allocator to store a pointer, or by 
                    removing this pointer and using a global pointer-to-storage.</p>
                <h2>
                    References</h2>
                <ul class="simple">
                    <li>Boost.AlignedMemory</li>
                    <li>Boost.AutoBuffer (Proposed)</li>
                    <li>Boost.IntrusiveContainer, for an alternative means of creating efficient 
                        containers.</li>
                </ul>
            </div>
        </div>
    </div>



</BODY>
</HTML>
