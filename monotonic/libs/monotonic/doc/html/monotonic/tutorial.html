<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.Monotonic Tutorial</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="../index.html" title="Chapter 1. Boost.Monotonic">
<link rel="up" href="../index.html" title="Chapter 1. Boost.Monotonic">
<link rel="prev" href="../index.html" title="Chapter 1. Boost.Monotonic">
<link rel="next" href="containers.html" title="Heterogenous Containers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../libraries.html">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="containers.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" title="Boost.Monotonic Tutorial">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="monotonic.tutorial"></a><span class="emphasis"><em>Boost.Monotonic</em></span> Tutorial</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#id666779">Overview</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id666790">Basic Usage</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id666823">Using Multiple Containers</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id666851">Using Regions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#id666918">
	Using Monotonic Storage
    </a></span></dt>
<dt><span class="section"><a href="tutorial.html#id666969">Notes</a></span></dt>
</dl></div>
<div class="section" title="Overview">
<div class="titlepage"><div><div><h3 class="title">
<a name="id666779"></a>Overview</h3></div></div></div>
<p>This tutorial progresses through the basic usage of the library, demonstrating how to use a monotonic allocator with STL containers, how to use monotonic storage directly without an allocator, how to use regions and access tags, and finally demonstrates the use of the supplied container library with stack-based local storage.
	</p>
</div>
<div class="section" title="Basic Usage">
<div class="titlepage"><div><div><h3 class="title">
<a name="id666790"></a>Basic Usage</h3></div></div></div>
<p>
    The following is a very quick introduction to <span class="emphasis"><em>Boost.Monotonic</em></span>:
	</p>
<pre class="programlisting">
#include &lt;boost/monotonic/allocator.hpp&gt;

using namespace boost;

int main()
{
    {
	std::list&lt;int, monotonic::allocator&lt;int&gt; &gt; list;
	for (size_t n = 0; n &lt; 1000; ++n)
	    list.push_back(n);
    }
    monotonic::static_storage&lt;&gt;::release();
    return 0;
}
	</pre>
<p>
Here we have created a <code class="computeroutput">std::list</code> using a monotonic allocator. While we add new elements to the list in the for-loop, allocation is coming from storage in the default region with default access. The first 32k of allocation will come from the BSS segment embedded in the application image (the amount of such storage is configurable), then once that local storage is exhausted, later allocation requests will be serviced from the heap. Since de-allocation does nothing in a monotonic allocator, we must manually release the resources once we are finished, as shown above.
	</p>
<p>
    While example is trivial, if you were to benchmark it against using a default std::allocator you will find that monotonic allocation is much faster[1]. This is one of the main reasons for using this library; to provide efficient storage and allocation for temporary containers.
	</p>
<p>
    We shall now move on to some more interesting examples, including how to use multiple containers that share the same strorage, using regions, using local stack-based storage, and dealing with threading issues.
	</p>
</div>
<div class="section" title="Using Multiple Containers">
<div class="titlepage"><div><div><h3 class="title">
<a name="id666823"></a>Using Multiple Containers</h3></div></div></div>
<pre class="programlisting">
int main()
{
    {
	typedef std::vector&lt;int, monotonic::allocator&lt;int&gt; &gt; Vector;
	typedef std::map&lt;int, Vector, std::less&lt;int&gt;, monotonic::allocator&lt;Vector&gt; &gt; Map;
	Map map;
	for (size_t n = 0; n &lt; 10000; ++n)
	{
            map[rand()%100].push_back(n);
	}
    }
    monotonic::static_storage&lt;&gt;::release();
    return 0;
};
	</pre>
<p>
    In this admittedly contrived example, we create a map of ints to vectors of ints, which each container using a monotonic allocator. Again, storage will only ever increase, so we must release it after we have finished using it. Benchmarking the performance of this against other allocation schemes[2] show that monotonic allocation is extremely fast and efficient.
	</p>
<p>
    The key point here is that you can use a <code class="computeroutput">monotonic::allocator</code> anywhere that you would otherwise use a <code class="computeroutput">std::allocator</code> or any other STL-compliant custom allocator. Monotonic allocators of the same type are effectively stateless, and may be default-constructed, used, and discarded as needed. We will deal with stateful monotonic allocators that can use local stack-based storage in a later section.
	</p>
</div>
<div class="section" title="Using Regions">
<div class="titlepage"><div><div><h3 class="title">
<a name="id666851"></a>Using Regions</h3></div></div></div>
<p>
    While it can be useful to have one storage area for all allocations, at times will will want to segment our memory usage into different <span class="emphasis"><em>regions</em></span>. This is done by passing a user-supplied <span class="emphasis"><em>region tag type</em></span> to the type signature of a <code class="computeroutput">monotonic::allocator</code>, as shown here:
	</p>
<pre class="programlisting">
struct my_region_A { };
struct my_region_B { };

int main()
{
    {
	std::list&lt;int, monotonic::allocator&lt;int, my_region_A&gt; &gt; A_list;
	std::list&lt;int, monotonic::allocator&lt;int, my_region_B&gt; &gt; B_list;
	// use A_list and B_list
    }
    monotonic::static_storage&lt;my_region_A&gt;::release();
    monotonic::static_storage&lt;my_region_B&gt;::release();
    return 0;
}
    </pre>
<p>
    Here, we have defined two storage regions, designated with the type-tags <code class="computeroutput">my_region_A</code> and <code class="computeroutput">my_region_B</code>. These are passed as the second type argument to a <code class="computeroutput">monotonic::allocator</code> in order to segment out the storage used.
</p>
<p>
Using segmented storage systems helps with logical seperation of resource usage amoung different sub-systems within an application. It also helps with ensuring privacy when using local storage, as demonstrated below:
</p>
<pre class="programlisting">
class System
{
    struct region {};
    typedef std::vector&lt;Object, monotonic::allocator&lt;Object, region&gt; &gt; Objects;

public:
    void update()
    {
	{
	    Objects objects;
	    // populate and use objects container
	    //...
	}
	// reset storage, ready for next update
	monotonic::static_storage&lt;region&gt;::reset();
    }
};
</pre>
<p>
Here we have used a private region-tag <code class="computeroutput">region</code> to guarantee that storage used by local containers such as <code class="computeroutput">Objects</code> is not shared with any other system. Note that this is a typical use-case for monotonic allocation, as it uses a locally defined container which is populated, used and discarded regularly.
</p>
</div>
<div class="section" title="Using Monotonic Storage">
<div class="titlepage"><div><div><h3 class="title">
<a name="id666918"></a>
	Using Monotonic Storage
    </h3></div></div></div>
<p>
	While monotonic allocators use monotonic storage, we can also use this storage directly and wherever we want efficient resource management.
    </p>
<pre class="programlisting">
int main()
{
    // define local storage of 4k on the stack.
    // allocations will use the heap after the inline stack-based storage
    // has been exhausted.
    monotonic::storage&lt;4*1024&gt; storage;
    {
	int &amp;num = storage.create&lt;int&gt;();
	std::string &amp;str = storage.create&lt;std::string&gt;();
	char *bytes = storage.allocate_bytes&lt;3000&gt;();

	// use num, str, bytes as needed

	// call std::string's destructor directly, or use storage.destroy
	storage.destroy(str);
    }
    return 0;
}
</pre>
<p>
    Of course, we could have just made <code class="computeroutput">num</code>, <code class="computeroutput">str</code> and <code class="computeroutput">bytes</code> on the stack by declaring them as local variables and be done with it. There is no functional difference in this case, except that you are responsible for invoking object destructors. So how is this at all useful?
 </p>
<p>We can use <code class="computeroutput">monotonic::storage</code> as a form of "first-class scope" which can be created, manipulated, passed as as argument, returned as a value or reference, and destroyed as needed. In this sense, <code class="computeroutput">monotonic::storage</code> is just like your very own C++ stack which you can share between objects and functions and even across process boundaries, independantly of the underlying machine-based stack.
</p>
<p>
Also unlike the stack, storage will use the heap when its local inline stack-based buffer is exhuasted. This makes it ideal for using things like local buffers and containers that generally will be small enough to fit onto the stack, but with the fallback safety of transparently using the heap to service later requests for the cases where that inline buffer is not large enough.
</p>
</div>
<div class="section" title="Notes">
<div class="titlepage"><div><div><h3 class="title">
<a name="id666969"></a>Notes</h3></div></div></div>
<p>
[1] See further discussion on efficiency at xxx
</p>
<p>
    [2] See the performance <a href="https://svn.boost.org/svn/boost/sandbox/monotonic/libs/monotonic/test/results" target="_top">results</a>, comparing monotonic allocation with Boost.PoolAllocator, Boost.FastPoolAllocator, std::allocator and Intel's TBB allocation system.
</p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"><p><small>Last revised:  ,  at  </small></p></td>
<td align="right"><div class="copyright-footer">Copyright © 2009 Christian Schladetsch<p>Use, modification and distribution is subject to the Boost
    Software License, Version 1.0. (See accompanying file
    <code class="filename">LICENSE_1_0.txt</code> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="containers.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
