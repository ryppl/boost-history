<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Using Monotonic Storage</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
<link rel="home" href="../../index.html" title="Monotonic Storage 0.3">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="using_regions.html" title="Using Regions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="using_regions.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a>
</div>
<div class="section" title="Using Monotonic Storage">
<div class="titlepage"><div><div><h3 class="title">
<a name="monotonic_storage.tutorial.using_monotonic_storage"></a><a class="link" href="using_monotonic_storage.html" title="Using Monotonic Storage">Using
      Monotonic Storage</a>
</h3></div></div></div>
<p>
        While monotonic allocators use monotonic storage, we can also use this storage
        directly and wherever we want efficient resource management.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="comment">// define local storage of 4k on the stack.
</span>    <span class="comment">// allocations will use the heap after the inline stack-based storage
</span>    <span class="comment">// has been exhausted.
</span>    <span class="identifier">monotonic</span><span class="special">::</span><span class="identifier">storage</span><span class="special">&lt;</span><span class="number">4</span><span class="special">*</span><span class="number">1024</span><span class="special">&gt;</span> <span class="identifier">storage</span><span class="special">;</span>
    <span class="special">{</span>
		<span class="keyword">int</span> <span class="special">&amp;</span><span class="identifier">amp</span><span class="special">;</span><span class="identifier">num</span> <span class="special">=</span> <span class="identifier">storage</span><span class="special">.</span><span class="identifier">create</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;();</span>
		<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span><span class="identifier">amp</span><span class="special">;</span><span class="identifier">str</span> <span class="special">=</span> <span class="identifier">storage</span><span class="special">.</span><span class="identifier">create</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;();</span>
		<span class="keyword">char</span> <span class="special">*</span><span class="identifier">bytes</span> <span class="special">=</span> <span class="identifier">storage</span><span class="special">.</span><span class="identifier">allocate_bytes</span><span class="special">(</span><span class="number">3000</span><span class="special">);</span>     

		<span class="comment">// use num, str, bytes as needed
</span>
		<span class="comment">// call std::string's destructor directly, or use storage.destroy
</span>		<span class="identifier">storage</span><span class="special">.</span><span class="identifier">destroy</span><span class="special">(</span><span class="identifier">str</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        Of course, we could have just made <code class="computeroutput"><span class="identifier">num</span></code>,
        <code class="computeroutput"><span class="identifier">str</span></code> and <code class="computeroutput"><span class="identifier">bytes</span></code>
        on the stack by declaring them as local variables and be done with it - well,
        except for having a dynamically-sized array of bytes on the stack. There
        is no other functional difference in this case, except that you are responsible
        for invoking object destructors. So how is this at all useful?
      </p>
<p>
        We can use <code class="computeroutput"><span class="identifier">monotonic</span><span class="special">::</span><span class="identifier">storage</span></code> as a form of "first-class
        scope" which can be created, manipulated, passed as as argument, returned
        as a value or reference, and destroyed as needed.
      </p>
<p>
        In this sense, <code class="computeroutput"><span class="identifier">monotonic</span><span class="special">::</span><span class="identifier">storage</span></code>
        is just like your very own C++ stack which you can share between objects
        and functions and even across process boundaries, independantly of the underlying
        machine-based stack.
      </p>
<p>
        Also unlike the stack, storage will use the heap when its local inline stack-based
        buffer is exhuasted. This makes it ideal for using things like local buffers
        and containers that generally will be small enough to fit onto the stack,
        but with the fallback safety of transparently using the heap to service later
        requests for the cases where that inline buffer is not large enough.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2009 Christian Schladetsch<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="using_regions.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a>
</div>
</body>
</html>
