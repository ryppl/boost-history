[/
 / Boost.Process
 / Introduction chapter.
 /
 / Copyright (c) 2006, 2007 Julio M. Merino Vidal.
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at
 / http://www.boost.org/LICENSE_1_0.txt.)
 /]

[/ ---------------------------------------------------------------------- ]

[section Introduction]

[/ ---------------------------------------------------------------------- ]

[section Overview]

The Boost Process library provides a flexible framework for the C++
programming language to manage running programs, also known as
['processes].  Among other functionality, this includes the ability to
manage the execution context of the currently running process, the ability
to spawn new child processes, and a way to communicate with them them using
standard C++ streams.

The library is designed in a way to transparently abstract all process
management details to the user, allowing for painless development of
cross-platform applications.  However, as such abstractions often restrict
what the developer can do, the framework allows direct access to operating
system specific functionality __mdash__ obviously losing the portability
features of the library.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Features]

This section contains a summary of the most important features provided by
the library.

[/ ---------------------------------------------------------------------- ]

[section Process management]

Boost.Process' long-term goal is to provide a portable abstraction layer
over the operating system that allows the programmer to manage ['any
running process], not only those spawned by it.  Due to the complexity in
offering such an interface, the library currently focuses on child process
management alone.

As an exception, it also allows access to the caller's process because this
is easy to expose, helps in providing a more modular interface and is a
very useful feature.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Child process management]

Boost.Process' most important feature is the ability to painlessly launch
external applications, control them during their lifetime and set up
communication channels between them and their parent.  Traditionally, this
has been a boring and hard task in C and C++ because there are many details
to take into account: create the new process, launch the external binary,
set up anonymous pipes to communicate with it, wait for its termination,
inspect its exit status, etc.

To make things worse, each major operating system has its own process model
and API to manage child processes.  Writing an application that deals with
both is time consuming and in most cases drives away the developer from his
original goal __mdash__ not related at all to interacting with the
underlying operating system.  Therefore, Boost.Process provides an
abstraction to handle all these details on behalf of the developer.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Input/output redirection]

An application launching a child process typically wants to communicate
with it by means of data transfers.  This ['Inter-Process Communication]
(IPC) happens at the level of file handles[footnote A file handle is a low
level identifier for a data channel exposed by the operating system.] and
typically involves the standard input (__stdin__), the standard output
(__stdout__) and the standard error output (__stderr__).  If the operating
system supports it (e.g. Unix), other unnamed data streams can be
redirected.

In order to properly integrate with the standard C++ library, this IPC is
morphed into the standard C++ streams making interaction with child
processes a piece of cake.  Each of these streams can be configured based
on many predefined modes, which allow you to simply ignore a stream,
collect it for further processing or redirect it to another stream (be it
a program, a file or a low-level file handle).

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Different operation modes]

[/ XXX Rewrite when we get Boost.Asio support. ]

Boost.Process allows a process to be managed in several different operation
modes; these are described below:

* Asynchronous operation: The child process is spawned and the parent
  process continues execution.  This is the most common operation mode
  because the parent will typically need to manage the data generated by
  its child as soon as it is available.  At any point, the parent process
  can decide to synchronize with its child, effectively waiting for its
  termination.

* Synchronous operation: In this scenario, the parent process blocks until
  its newly spawned children finishes execution.  This can be useful in
  those cases where the parent does not directly receive data generated
  from its child (e.g. because it is redirected to a file on disk).

* Disconnected operation: The parent process forgets about the existence of
  its child process, which can continue to exist even when the parent dies.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Pipeline management]

[/ TODO: Add a pipeline diagram here or in the section that describes
pipelines.  In the latter case, add a link. ]

A pipeline is a unidimensional and unidirectional chain of interconnected
processes in which the output of one of them is connected to the input of
the following.  The programmer can then feed data to this pipeline through
the first process' input channel and fetch the results through the last
process' output channel.

The library provides the necessary functionality to model pipelines and
handle them.

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Non-functional features]

[/ ---------------------------------------------------------------------- ]

[section Portability]

Boost.Process is constructed with portability in mind.  Both the POSIX
process management model and the Win32 one are taken into account in the
library and are supported by its API.  More details are available in the
[link boost_process.platforms_and_compilers platforms and compilers]
chapter.

To achieve this goal, the library provides a common and system-agnostic API
that lets the developer manage processes without ever knowing the operating
system the code is running under.  However, it is a fact that each
operating system provides specific and useful features that are not
portable to others; these must not be banned to developers if they need
them.  Therefore, the library provides a way to access these features that
is clearly separated from the cross-platform API to avoid introducing
portability bugs by mistake.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Modularity]

Boost.Process is modelled around a set of abstract concepts that are
implemented in the form of C++ templates and classes.  This allows the
developer to replace any part of the library with custom implementations as
long as they match the requirements of each concept, useful when he may
need extreme performance or highly OS-specific functionality not provided
by the standard classes.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Testability]

The library comes with a very complete set of regression tests to ensure
that it behaves according to its specifications.  These tests try to be as
complete as possible and are an excellent tool to verify that the library
works correctly on a platform where it has not been tested before.

Although the library was not developed following the Test Driven
Development (TDD) methodology, it is still interesting to have as much
automated tests as possible.  Whenever a bug is found or a new
functionality is added, a new test must be introduced to ensure that no
regressions appear and that the fixed/new code works as expected.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Efficiency]

The library is implemented with efficiency in mind although this is not a
primary goal of its development.  Improvements to efficiency are of course
welcome but are a second class item in front of the other goals.  However,
it is understandable that efficiency can be a very important feature for
some developers.  Therefore, and as mentioned in the [link
boost_process.introduction.non_functional_features.modularity modularity
requirement], the programmer is allowed to replace parts of the framework
with custom implementations to improve the areas that may not be efficient
enough.

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]
