[/
 / Boost.Process
 / Concepts chapter.
 /
 / Copyright (c) 2006 Julio M. Merino Vidal.
 /
 / Use, modification, and distribution is subject to the Boost Software
 / License, Version 1.0.  (See accompanying file LICENSE_1_0.txt or copy
 / at http://www.boost.org/LICENSE_1_0.txt.)
 /]

[/ ---------------------------------------------------------------------- ]

[section Concepts]

The following subsections describe the basic concepts behind Boost.Process.
They are first slightly introduced based on the operating system concepts
behind them and are later specified as concepts to be used in templates.

[/ ---------------------------------------------------------------------- ]

[section Handle]

A ''handle'' is an operating system entity that identifies one of its
objects, such as a file or a process.  Handles are used by user space
programs to tell the operating system the object they are referring to.

Given the low-level interactions of Boost.Process with the operating
system, the library lets the user access these handles, should he need them
to call operating system services directly.

It is important to note that handles are object-specific.  An operating
system may use different data types to identify each of its objects.  For
example, POSIX systems refer to files through an `int` value while
processes are referred to by `pid_t` values.  Contrarywise, Win32 uses a
single `HANDLE` type to describe any object.  Therefore, Boost.Process
abstracts these handles in each class where it makes sense using types
named `handle_type`.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Process]

Generally speaking, a process is the execution context of a program.  The
operating system stores one or more objects in its internal tables to
represent this context.  Therefore, it has to be clear that it is incorrect
to call a process an application that is not yet running or that has
already quit.

The `Process` concept represents a process that exists in some way or
another in the system tables; its internal status is irrelevant (it could
be running, sleeping or zombie, for example).  A process represented by
this concept does /not/ necessarily have to be a child of the application
using Boost.Process, which means that the application may not have control
over it.

This concept is implemented by the `basic_process` template and the
`process`, `posix_process` and `win32_process` classes.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Child process]

Processes are internally organized by the operating system as a tree.  Each
process (except for the one at the tree's root) has a parent and can have
multiple children.  A parent process owns its children and therefore has
full control over their execution.

There are two possible statuses for a child process:

* Active: the process is alive.  It may either be running or sleeping, but
  it has not finalized execution.

* Zombie: the process finished execution and is waiting for its parent to
  collect its status.  This may happen due to unexpected and expected
  termination conditions.

The `Child` concept extends `Process`, specializing it to represent a child
process of the currently running application (that is, the program using
Boost.Process services).  The application can directly control the child
process, send and retrieve data from it and collect its finalization
status.

This concept is implemented by the `basic_child` template and the
`child`, `posix_child` and `win32_child` classes.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Attributes]

A process has multiple attributes that describe its execution status.
These attributes are set by the parent when it spawns a new child but can
also be queried while the process is running.  In other words: these
attributes belong to the `Process` concept, not just to the `Child` one.

There are some attributes that are common among all the operating systems
supported by Boost.Process, such as the process' working directory or the
startup command line.  Unfortunately, the vast majority cannot be
generalized and need to be kept specific to the operating system the
library is running under.  For example: POSIX systems have a feature to
change a process' run directory through the chroot(2) call but Windows
systems do not have anything similar.

The `Attributes` concept represents a process' attributes as described
above.  Each `Process` object has one, and only one, `Attributes` object
associated to it.  While launching a child process, the caller can specify
the set of attributes it will use.  (This is the reason for this data to
live in a standalone class.)

This concept is implemented by the `basic_attributes` template and the
`attributes`, `posix_attributes` and `win32_attributes` classes.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Command line]

As already described, a process is the execution context of a program.
This program is launched using a command line, a tuple that includes the
binary to execute and the set of arguments to pass to it.

The command line is an attribute on its own because all the information it
includes can be queried at run time from any process (assuming correct
access rights).  In other words: it is not something used exclusively
during process startup.

The `Command_Line` concept represents a process' startup command line and
is typically wrapped inside the `Attributes` concept.

This concept is implemented by the `cmdline` class.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Launcher]

In order to spawn a child process, the parent needs to provide multiple
data to the operating system.  First, the new process needs a command line
that tells the system /what/ to execute.  Second, it requires the
attributes that specify internal process details.  And third, it needs
information that describes how the new process relates to its parent; this
includes streams for communication among other details.

The `Launcher` concept is an abstract representation used to model a
process' startup procedure.  As said above, a process is something that is
/already/ in the operating system tables: it cannot exist before the
system has explicitly started it.

This concept is implemented by the `basic_launcher` template and the
`launcher`, `posix_launcher` and `win32_launcher` classes.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Exit status]

Upon termination, a process reports information to its parent describing
why it finalized.  This information is known as the /exit status/ and
includes the reason behind termination (regular exit, crash, external
signal, etc.) together with details describing it.

Exit status can only be gathered from zombie processes; that is, child
processes that stopped execution and are waiting for its parent to collect
it.  When the information is collected, the zombie process ceases to exist
from the system tables, invalidating the `Child` object that represented
it.

The `Status` concept is used to represent a process' exit status.

This concept is implemented by the `status` class.

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]
