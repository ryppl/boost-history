[/
 / Boost.Process
 / Features chapter.
 /
 / Copyright (c) 2006 Julio M. Merino Vidal.
 /
 / Use, modification, and distribution is subject to the Boost Software
 / License, Version 1.0.  (See accompanying file LICENSE_1_0.txt or copy
 / at http://www.boost.org/LICENSE_1_0.txt.)
 /]

[/ ---------------------------------------------------------------------- ]

[section Features]

Boost.Process was designed and implemented with a known set of functional
and non-functional requirements.  These are shown here in the form of
provided features that highlight the most important functionality of this
library.

[blurb [*Important note regarding the text below]: Please keep in mind that
this library is under heavy development.  Although all the notes here speak
as if the code already exists, it really does not.  Treat the following
list of features as a list of requirements for the development of the
library. ]  [/ XXX Remove when the library is functional enough. ]

[/ ---------------------------------------------------------------------- ]

[section Process management]

The basic goal behind the Boost Process library is to provide an
abstraction layer over the operating system that allows the programmer to
manage running processes and start new ones.  Despite this generic design,
the library currently focuses on child process management only.

In order to achieve this goal, data representing processes is clearly split
in two blocks: one is always attached to the running process (handled
internally by the system) and one is only meaningful during child process
startup.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Child process management]

Within generic process management, the most important feature of
Boost.Process is the ability to painlessly launch external applications and
control them during their lifetime.  Traditionally, this has been a boring
and hard task in C and C++ because there are many details to take into
account: create the new process, launch the new binary, set up pipes to
communicate with it, wait for its termination, inspect its exit status,
etc.

To make things worse, each major operating system has its own API to manage
child processes.  Writing an application that deals with both is time
consuming and often drives away the developer from his original goal
__mdash__ not related at all to interaction with the underlying operating
system.  Boost.Process provides an abstraction to handle all these details
on behalf of the developer but also lets him bypass it to access the full
power of the operating system his application is running on.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Input/output redirection]

An application launching a child process generally wants to communicate
with it by means of data transfers.  This IPC happens at the level of file
descriptors and typically involves the standard input (__stdin__), the
standard output (__stdout__) and the standard error output (__stderr__).
If the operating system supports it, other unnamed data streams can be
redirected.  [/ XXX I am not sure yet if Windows supports this feature and
how.  If it does and is compatible with POSIX semantics such that a proper
abstraction layer can be implemented, this last sentence ought to be
modified. ]

In order to properly integrate with the standard C++ Iostreams library,
this IPC is modelled after C++ streams, making interaction with child
processes a piece of cake.  In this regard, the
[@http://boost.org/libs/iostreams/doc/index.html Boost Iostreams library]
is used to simplify the overall design and implementation and to remain
consistent with other Boost libraries.  Of special interest are its
[@http://boost.org/libs/iostreams/doc/classes/file_descriptor.html file
descriptors classes].  [/ XXX It may not be really necessary to use this
library as long as integration with C++ Iostreams is accurate. ]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Stream merging]

In some situations, a process emits data through multiple streams.  The
most typical example are applications that print regular messages through
their standard output and error messages through the standard error output.
However, it is sometimes desired to forget about all distinctions and treat
several of these streams as the same one.

Of course, the parent process could perfectly implement some way to wait
for data from the streams it is interested in, but this would be
non-trivial and a potential source of problems.  Either threads or some
kind of polling mechanism would be needed.

This is why the library allows merging different streams at the operating
system level.  This involves much less coding and overhead at the final
application because it will be presented a single stream.  As an example,
consider handling both __stderr__ and __stdout__ with a single stream,
similar to what a POSIX shell does after the
'''<literal>2&gt;&amp;1</literal> ''' construction is specified.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Different operation modes]

A process can be managed in several different operation modes as described
below:

* Asynchronous operation: The child process is spawned and the parent
process continues execution.  This is the most common operation mode
because the parent will typically need to manage the data generated by its
child as soon as it is available.  At any point, the parent process can
decide to synchronize with its child, effectively waiting for its
termination.

* Synchronous operation: In this scenario, the parent process blocks until
its newly spawned children finishes execution.  This can be useful in those
cases where the parent does not directly receive data generated from its
child (e.g. because it is redirected to a file on disk).

* Disconnected operation: The parent process forgets about the existence of
  its child process, which can continue to exist even when the parent dies.

The [@http://asio.sourceforge.net/ Boost Asio library] is used to manage
all asynchronous events that arise while managing processes.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Portability]

Boost.Process is constructed with portability in mind.  Both
POSIX-compliant systems __mdash__ including but not limited to:
[@http://www.NetBSD.org/ NetBSD], Linux and [@http://www.apple.com/macosx/
Mac OS X] __mdash__ as well as [@http://www.microsoft.com/windows/ Windows]
were taken into account during the design phase.  This means that the
library is properly modularized to keep portable and non-portable features
in non-conflicting areas.

The library provides a common and system-agnostic API that lets the
developer manage processes without ever knowing the operating system the
code is running under.  However, it is a fact that each operating system
provides specific and useful features that are not portable to others;
developers must not be banned using them, if they need to.  Therefore, the
library provides a non-portable way to access these features.

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Templated design]

Boost.Process is architected around a set of abstract concepts that are
implemented in the form of C++ templates.  These templates allow the
developer to replace any part of the library with custom implementations of
their respective concepts.  This comes helpful if there is need for extreme
efficiency or highly OS-specific functionality.

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]
