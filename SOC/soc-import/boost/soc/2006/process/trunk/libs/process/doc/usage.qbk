[/
 / Boost.Process
 / Usage chapter.
 /
 / Copyright (c) 2006 Julio M. Merino Vidal.
 /
 / Use, modification, and distribution is subject to the Boost Software
 / License, Version 1.0.  (See accompanying file LICENSE_1_0.txt or copy
 / at http://www.boost.org/LICENSE_1_0.txt.)
 /]

[/ ---------------------------------------------------------------------- ]

[section Usage]

Boost.Process consists of multiple [link reference classes] that cooperate
together to allow the developer to spawn and manage child processes.
Summarizing, the general use case to start a new process boils down to the
following steps:

# Configure a [link boost_process.concepts.command_line command line].
# Configure the child process' execution context through a [link
  boost_process.concepts.launcher launcher].
# Start the child process by passing the command line to the launcher.
# Interact with the returned [link boost_process.concepts.child_process
  child] object that represents the new process.
# Wait for child process finalization.
# Receive and interpret the child's [link
  boost_process.concepts.exit_status exit status].

Similarly, in order to start a pipelined set of processes, one has to
follow the steps outlined below:

# Configure several [link boost_process.concepts.command_line command
  lines], one for each process in the pipeline.
# Configure the pipeline's execution context through an specialized [link
  boost_process.concepts.launcher launcher], generally [classref
  boost::process::pipeline].
# Add the command lines created above to the pipeline.
# Start the process group through the launcher.
# Interact with the returned [link boost_process.concepts.child_process
  process group] that represents the set of processes that form the
  pipeline.  If configured appropriately, one can feed in data to the first
  process in the chain and retrieve data from the last one.
# Wait for the process group's finalization.
# Receive and interpret the finalization [link
  boost_process.concepts.exit_status exit status].

The following sections give more details on all the above instructions.

[/ ---------------------------------------------------------------------- ]

[section Command line configuration]

The [classref boost::process::command_line] class provides a reference
implementation for the [link boost_process.concepts.command_line
Command_Line] concept.  This class represents a generic command line and is
used later on by one of the [link boost_process.concepts.launcher
launchers] to know which process has to be started and which parameters
shall it receive.

A command line can be created either by the individual words that form the
final command line or as a single string that is passed verbatim to the
shell interpreter.  The former syntax is typically safer to quoting issues
because the interpreter is not involved in the execution of the command;
unfortunately, this advantage only exists in POSIX systems.  Contrarywise,
the latter syntax has the advantage of providing wildcard and variable
expansion as well as access to the interpreter's built-in commands because
the interpreter will be the final responsible for the execution of the
command line.

In order to construct a command line parameter by parameter, the following
syntax shall be used:

    boost::process::command_line cl("/path/to/program", "program_name");
    cl.argument("first-parameter").argument("second-parameter");
    cl.argument("third-parameter").argument("etc...");

The [classref boost::process::command_line class]' constructor takes two
parameters: the path to the program to be executed and the program name
that it will receive as its first argument
('''<varname>argv[0]</varname>''').  The [memberref
boost::process::command_line::argument argument] method is later used to
append positional parameters to the command line; this function is
templatized to allow dealing with any data type provided it can be inserted
in an output stream.

Similarly, a shell-based command line can be constructed using an auxiliary
function:

    boost::process::command_line cl = boost::process::command_line::shell
        ("the-program first-parameter ... nth-parameter");

For more details check out the [link boost_process.reference reference
chapter] and the [link boost_process.examples.command_lines command line
examples].

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Interprocess communication]

Each process has three standard communication channels that allow easy
communication between a parent process and a child process or among
different child processes.  Thanks to these ['standard] channels, a program
can easily implement a transformation of the input data without knowing
where it is located and print it in an output channel whose real location
is not known.  Such programs are known as filters and are very common in
Unix-like operating systems.  No matter what, there are many programs that
do not implement a data conversion, yet they use the standard channels to
communicate with the user and, the case that matters now, other processes.

The three standard communication channels are reviewed below:

* The standard input channel (__stdin__ for short): This is used by the
  process to read input data, typically fed in by the user or another
  running process (e.g. its parent).

* The standard output channel (__stdout__ for short): This is used by the
  process to print output messages or data.  The channel is typically
  configured to be buffered and its output is generally dumped to the
  console; of course it can be redirected to another process or file.

* The standard error channel (__stderr__ for short): This is used by the
  process to print error messages and sometimes to simply separate them
  from the output data.  The channel is typically configured to be
  unbuffered and its output is generally dumped to the console; of course
  it can be redirected to another process or file.

The [classref boost::process::launcher] provides mechanisms to handle
these three standard streams, but not more.  If there is a need to
configure more communication channels __mdash__ a feature only supported
in POSIX systems __mdashnospc__, check the [classref
boost::process::posix_launcher] class built on top of the former.

Each communication channel can be configured according to different
predefined behaviors as provided by [enumref
boost::process::stream_behavior].  Please check out the link for more
information on the possible stream behaviors.

Communication channels can also be ['merged].  Merging two communication
channels means that the output of the child's source channel is redirected
to the target channel (be it an input flow or an output one).  The key idea
is that this redirection is done at the lowest possible level: the child
process continues to see multiple streams but, as concerns the operating
system, some of them point to the same internal object.  This feature is
used intensively in the library to allow for efficient retrieval of a
process' __stdout__ and __stderr__ flows.

Given the above, consider the following code snippet.  It configures a
launcher that will have an infinite blank input and that will send both of
its __stdout__ and __stderr__ to the parent's __stdout__:

    boost::process::launcher l;
    l.set_stdin_behavior(silent_stream); // The default.
    l.set_stdout_behavior(inherit_stream);
    l.set_stderr_behavior(close_stream);
    l.set_merge_out_err(true);

When setting a channel to `redirect_stream`, it will later be available
from the class representing the child process through one of its [memberref
boost::process::child::get_stdin], [memberref
boost::process::child::get_stdout] and [memberref
boost::process::child::get_stderr] methods.  These classes return C++
streams as described next.  An input stream for a child process is seen as
an output data flow by the parent, so it is modelled through the [classref
boost::process::postream] class.  On the opposite side, an output stream
for a child process is seen as an input data flow by the parent, hence it
is represented by the [classref boost::process::pistream] class.  These two
classes are regular C++ streams but provide an extra method (`close`) to
allow the explicit shutdown of a communication channel.  This is required,
for example, to let the child know that the parent is not willing to send
any more data through its __stdin__.  (Typically the child will close
output channels on exit and the parent will close input ones.)

The following example illustrates sending some data to a process:

    boost::process::launcher l;
    l.set_stdin_behavior(redirect_stream);
    ... spawn the process ...
    boost::process::postream os = c.get_stdin();
    os << "some-string" << std::endl;
    os << 200 << 1024 << std::endl;
    os.close();

Similary, the following shows how to retrieve the child's data, line by
line:

    boost::process::launcher l;
    l.set_stdout_behavior(redirect_stream);
    ... spawn the process ...
    boost::process::pistream is = c.get_stdout();
    std::string line;
    while (std::getline(is, line))
        std::cout << "Got a line: " << line << std::endl;

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Environment variables]

Each running process has a set of environment variables that it can query
for information.  The parent process is responsible for setting up this
table and passing it to the new child process during startup; hence, it is
the launcher's task to handle the status of these variables.

A launcher object keeps the status of the environment variables that are
passed to a process started through it.  During initialization, this list
is inherited from the current process' environment but can be later
modified by the user by setting new variables, modifying the contents of
existing ones or removing already-set variables.  This can be done by using
the [memberref boost::process::launcher::set_environment] and the
[memberref boost::process::launcher::unset_environment] methods, whose
documentation provides more information on their functionality as well as
some portability notes.

The environment can also be completely cleared by using the [memberref
boost::process::launcher::clear_environment] method.  Care should be taken
when using this method because the new process may expect some standard
variables to be defined for proper operation (e.g. `PATH`).  After using
this call you are responsible for appropriately setting up the minimum
required variables.  Be aware that under Windows an environment cannot be
empty: at the very minimum, it will always contain a blank-named variable
that points to the current working directory; this is transparently
handled by the library.

For quick reference, consider:

    boost::process::launcher l;
    ... l now carries a snapshot of the current environment ...
    l.clear_environment();
    l.set_environment("variable-name", "variable-value");
    l.unset_environment("variable-name");

[endsect]

[/ ---------------------------------------------------------------------- ]

[section The startup work directory]

Another property of a process' execution context is the directory in the
file system in which it starts functioning.  This location is used by the
operating system to resolve relative paths and possibly by the application
to determine the default directory for some of its operations.

Before launching a process, the parent can configure the child's startup
work directory by using the [memberref
boost::process::launcher::set_work_directory] method.  If not specified,
the process is started in the same directory the parent was located in when
it created the [classref boost::process::launcher] object.

For instance:

    boost::process::launcher l;
    ... l now points to the current work directory ...
    l.set_work_directory(tmp_dir_location);

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Child process startup]

Once the command line and the process' execution context are configured, a
new process can be spawned by using the launcher's `start` method, which in
case of the portable launcher is [memberref
boost::process::launcher::start].  This method takes the execution context
as the implicit parameter, the command line as a formal parameter and
returns a [link boost_process.concepts.child child entity] that represents
and allows interaction with the newborn process.

An illustrative (but incomplete) code snippet:

    using namespace boost::process;

    command_line cl(...);
    ... add arguments to cl ...
    launcher l(...);
    ... configure the execution environment through l ...

    child c = l.start(cl);
    ... c now represents the newborn child process ...

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Process termination]

When a child process terminates execution, its parent has to collect its
[link boost_process.concepts.exit_status exit status] to free the operating
system data structures used to store this information.

Depending on the operating system in use, a process can terminate for
different reasons.  Considering the most complete case (a POSIX system), a
process can terminate regularly by itself; it can finish due to an
unhandled signal (which may well be sent from the outside); or it can be
stopped by another process.  All this information is accessible through the
[classref boost::process::status] class, an instance of which is returned
by the [memberref boost::process::child::wait] method.

After a call to that method, the parent is then able to inspect the reasons
behind the child process finalization.  For example:

    boost::process::status s = c.wait();
    if (s.exited()) {
        // The process terminated by itself.
        std::cout << "The exit code was: " << s.exit_status() << std::endl;
    } else
        std::cout << "Abnormal program termination." << std::endl;

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Pipeline management]

As a pipeline is just a process group, its management is built on top of
the regular process [link boost_process.usage.child_process_startup
startup] and [link boost_process.usage.process_termination termination].
The [classref boost::process::basic_pipeline] and [classref
boost::process::children] classes are used to spawn and represent the
process group respectively.

The interface used to manage pipelines is very similar to that used to
handle single processes.  This can be seen in the following simple code
snippet:

    command_line cl1(...);
    ... add arguments to cl1 ...
    command_line cl2(...);
    ... add arguments to cl2 ...

    pipeline p;
    ... configure the execution environment through p ...
    p.add(cl1).add(cl2);

    children cs = p.start();
    ... cs now represents the newborn process group ...

    status s = cs.wait();

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]
