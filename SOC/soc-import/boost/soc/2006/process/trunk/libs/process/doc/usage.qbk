[/
 / Boost.Process
 / Usage chapter.
 /
 / Copyright (c) 2006 Julio M. Merino Vidal.
 /
 / Distributed under the Boost Software License, Version 1.0.
 / (See accompanying file LICENSE_1_0.txt or copy at
 / http://www.boost.org/LICENSE_1_0.txt.)
 /]

[/ ---------------------------------------------------------------------- ]

[section Usage]

This chapter describes all the portable features in Boost.Process that will
let you achieve the most common tasks.  The chapter starts presenting a
couple of quick tutorials for the lazy reader, outlining the general
structure of a program using the library.  It later dives into details
concerning each part of the tutorial.

[/ ---------------------------------------------------------------------- ]

[section Quick tutorials]

[/ ---------------------------------------------------------------------- ]

[section Single process tutorial]

The single process tutorial outlines all the steps necessary to prepare,
launch, manage and terminate a single child process.  It also illustrates
interprocess communication by capturing the child's output messages and
printing them in a different format.  Each step is accompanied with a
snippet to aid in the explanations which, if joined together, produce a
complete example application.  Let's get started.

As happens with any C++ library, the very first step to use Boost.Process
is to include some header file that pulls in the necessary class and
function definitions.  To make things simple, we include the [headerref
boost/process.hpp] all-in-one header file and define an alias for its main
name space.  However, a bigger application will want to include the more
finer grained headers to avoid unnecessary rebuilds shall the library's
code change.

[include ../example/single_process_tutorial.cpp c++ include-headers]

Getting into the child process startup area, the first thing to do is to
tell the library which application has to be started and which arguments
shall be passed to it.  In an attempt to choose a sample child program that
works on all supported platforms, we use the [@http://subversion.tigris.org
Subversion] command line client whose binary is named `svn` (`svn.exe`
under Windows, but this difference is not important).

Our sample command line uses the provided [link
boost_process.concepts.command_line command_line] class, tells it to locate
the binary in the path and asks the program to update the current
directory.  We could specify additional arguments if we wanted to.

[include ../example/single_process_tutorial.cpp c++ command-line]

Following the definition of the command line, we define the execution
context of the new process; this is done by creating a [classref
boost::process::launcher launcher] object.  As Subversion `update` command
updates the "current directory", we will want the child process to start in
another location (that specified in the `dir` variable) so that it updates
the desired directory.  We do this by asking the launcher to use a
different work directory than the current one.  Furthermore, as outlined
above, we also want to capture the standard output and error channels for
later processing, so we end up with the following:

[include ../example/single_process_tutorial.cpp c++ launcher]

Once we have the command line and the launcher configured, we start the new
child process by mixing them together.  (Yes, we could reuse the same
launcher to start different command lines if we wanted to.)

[include ../example/single_process_tutorial.cpp c++ child-start]

At this point the `c` [classref boost::process::child child] instance
represents a running process.  We can use this object to interact with the
child, which in our example means reading its output messages.  We do this
by obtaining a C++ input stream that is connected to the child's standard
output and error channels.  From there on, it is a simple matter of reading
data and processing them as we want:

[include ../example/single_process_tutorial.cpp c++ get-output]

After parsing the output generated by the child process, we wait until it
terminates execution to retrieve its exit status, which is later stored in
the `s` [classref boost::process::status status] object for further
treatment.  (Strictly speaking we get to this call because the process has
already terminated; otherwise the previous loop could not have finished.)

[include ../example/single_process_tutorial.cpp c++ wait]

At last we parse the process' output status stored in `s` to see if
everything was successful:

[include ../example/single_process_tutorial.cpp c++ parse-status]

To sum it up, the complete example code is:

[include ../example/single_process_tutorial.cpp c++ code]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Pipeline tutorial]

Boost.Process integrates mechanisms to spawn and control process groups
using a construction known as a pipeline.  This tutorial outlines the
procedure to prepare, spawn, control and terminate several commands that
are interconnected in a unidimensional chain.  It is recommended to first
read the [link boost_process.usage.quick_tutorials.single_process_tutorial
single process tutorial] because it illustrates simpler concepts than this
one; you should spot the minor differences to really understand how
pipeline management works.

First of all, a simple program that manages pipelines includes the general
Boost.Process header.  Of course, we could include the more fine grained
headers, but for our demonstration purposes we need not to:

[include ../example/pipeline_tutorial.cpp c++ include-headers]

As described earlier, processes are started using a launcher.  When it
comes to pipelines, the concept is the same but differs slightly in its
usage: the [classref boost::process::pipeline pipeline] specialized
launcher is the single process' [classref boost::process::launcher
launcher] homogeneous class but it differs in that it spawns and
interconnects multiple processes.  Both launchers share most of their
public interface, so the code below will look very familiar.

To demonstrate the launcher's construction, we capture the pipeline's
standard input (which is the same as the first process' standard input);
this will allow us to feed it some data for further processing.  On the
other hand we tell the launcher to inherit the parent's standard output so
that the results are printed to the expected stream (typically the screen):

[include ../example/pipeline_tutorial.cpp c++ pipeline]

Next, we tell the library which programs form the pipeline.  Each component
is described by a regular [classref boost::process::command_line command
line], much like we did before in the simple tutorial.  However this
example uses the [memberref boost::process::command_line::shell shell]
constructor to simplify argument passing (and to illustrate a different way
of doing things).

Please be aware that the utilities used in these command lines are specific
to Unix systems.  This does not mean in any way that pipelines are
restricted to the POSIX platform; the code could use equivalent programs
under Windows and behave equally well:

[include ../example/pipeline_tutorial.cpp c++ command-lines]

Once all the pipeline components are defined, we add them to the launcher,
really constructing the pipeline.  The order in which we add them is
important:

[include ../example/pipeline_tutorial.cpp c++ addition]

Just after that we can spawn the whole process group, which is not any
different than starting a single process.  Note that this time we get a
[classref boost::process::children children] object instead of a regular
child because we need to keep track of multiple processes.  We could be
interested in directly interacting with each child and not with the
pipeline black box concept:

[include ../example/pipeline_tutorial.cpp c++ children]

At this point the pipeline is running.  The `children` class offers us an
interface that hides the fact that there are multiple processes running; we
can simply treat it as if it were an instance of `child`.  So, similar to
what we did in the previous tutorial, we obtain the pipeline's standard input
and feed it some data:

[include ../example/pipeline_tutorial.cpp c++ feed-stdin]

Once done, we wait until all processes stop execution and collect their
exit status:

[include ../example/pipeline_tutorial.cpp c++ wait]

At last we process the returned status in `s` to determine if everything
went correctly:

[include ../example/pipeline_tutorial.cpp c++ parse-status]

To sum it up, the complete example code is:

[include ../example/pipeline_tutorial.cpp c++ code]

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section The command line]

The command line is an entity that describes a call to an executable
program.  It is composed of the following components:

[variablelist
    [[The executable]
     [This is the path name to the file on disk that will be executed.
      This can be a full path name, a relative path name or a base name
      without any component.]
    ]

    [[The program name]
     [The program name is a string passed as the executable's first
      argument (e.g. `argv[0]`).  This typically matches the executable's
      base name but can be changed at will in case the program behaves
      differently depending on the value passed in that parameter.]
    ]

    [[The arguments list]
     [Aside from the first argument carrying the program's name, an
      executable may receive a set of extra arguments, similar to function
      parameters.  These are stored in the arguments list.]
    ]
]

All the functions or classes in the library that use a command line are
parametrized on the [link boost_process.concepts.command_line Command_Line]
concept.  This allows the developer to provide a custom implementation,
shall we need to.

For convenience, the library includes a reference implementation class
named [classref boost::process::command_line command_line].  It should be
enough in most cases.  The instructions below may only apply to this
implementation.

There are two main ways to construct a command line as we shall see below.

[section Creation from individual arguments]

The traditional entry point of a C or C++ program looks like:

    int main(int argc, char* argv[]);

Programs receive an ['array of strings] in `argv` that contains all the
arguments passed to them.  The reference command line implementation
provides an interface to construct calls to applications based on the exact
contents of the `argv` array.   If at all possible, the new process will
receive a verbatim copy of the arguments provided by the caller.

Executing programs using this syntax is safe to quotation issues because
the library ensures that the values provided by the user end up in the
child process without modifications.  Furthermore, no other process
__mdash__ not even the shell __mdash__ is involved in the execution
procedure.

Constructing command lines on a parameter basis is the recommended usage,
specially if user input is involved in the construction.  However it might
not be appropriate in all scenarios, as we will see later on.

In order to construct a command line parameter by parameter, we first tell
it which is the executable to launch and, optionally, its program name.  If
the latter is not provided, it is automatically guessed:

    command_line cl("/path/to/executable", "program_name");

The [classref boost::process::command_line class]' constructor takes two
parameters: the path to the executable and its program name.  If the path
does not contain any component path (no slashes nor backslashes), the
executable will be searched in the system's path; could the application
not be found, a [classref boost::process::not_found_error not_found_error<
std::string >] exception is raised as shown below:

    try {
        command_line cl("unknownbinary");
        ...
    } catch (const not_found_error< std::string >& e) {
        std::cerr << e.get_value() << " could not be found" << std::endl;
    }

Once the command line is constructed, additional arguments can be appended
to it by using the [memberref boost::process::command_line::argument
command_line::argument] method.  This function is parametrized on the
argument type to allow dealing with any data type (provided it can be
inserted in an output stream).  Its usage is as follows:

    cl.argument("first-parameter").argument("second-parameter");
    cl.argument("...").argument("nth-parameter");

[endsect]

[section Creation from a single string]

Another way to construct a command line is to define it in terms of the
shell using the [memberref boost::process::command_line::shell
command_line::shell static method].  You create a ['single string] that
represents the whole command line, which is then passed to the default
system shell for later processing.

As the shell is involved, the command line is affected by its parsing rules
such as variable and wildcard expansion, construction of pipelines,
redirections of streams or even execution of built-in commands.

The general syntax is as follows:

    command_line cl = command_line::shell
        ("the-program first-parameter ... nth-parameter");

[endsect]

[section Examples]

The following example program shows multiple command lines from their
construction until their execution:

[include ../example/command_lines.cpp c++ code]

[endsect]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Interprocess communication]

Every process has three standard communication channels that allow easy
communication between either a parent process and a child process or among
different child processes.  Thanks to these ['standard channels], a program
can easily implement a transformation of the input data without knowing
where it is located and print it to an output channel whose real location
is unknown; additionally it can print error messages that will end up
stored where the caller decided.

There are lots of programs that process an input and produce an input, all
using the standard channels previously described.  These are known as
['filters] and are very common in the Unix work.  Of course there are many
other programs that do not implement a data conversion, yet they use the
standard channels to communicate with the user and/or ['with other
processes].

The three standard communication channels are reviewed below.  We can
assume that they are supported by [link
boost_process.platforms_and_compilers.supported_platforms all platforms]
recognized by the library.

[variablelist
    [[Standard input channel or __stdin__]
     [This is used by the process to read input data, typically fed in by
      the user or another running process (e.g. its parent).]
    ]

    [[Standard output channel or __stdout__]
     [This is used by the process to print output messages or data.  The
      channel is typically configured to be buffered and its output is
      generally dumped to the console; of course it can be redirected to
      another process or file.]
    ]

    [[Standard error channel or __stderr__]
     [This is used by the process to print error messages and sometimes to
      simply separate them from the output data.  The channel is typically
      configured to be unbuffered and its output is generally dumped to the
      console; of course it can be redirected to another process or file.]
    ]
]

What concerns us is the ability to interact with these standard streams
from the process spawning a child __mdash__ that is, the one using
Boost.Process.  The parent must tell the new child process how its standard
channels shall behave; this is done by modifying the execution context of
the new process by means of one of the multiple [link
boost_process.concepts.launcher launcher] implementations.

Each communication channel can be configured according to different
predefined behaviors by using the [memberref
boost::process::launcher::set_stdin_behavior launcher::set_stdin_behavior],
[memberref boost::process::launcher::set_stdout_behavior
launcher::set_stdout_behavior] and [memberref
boost::process::launcher::set_stderr_behavior
launcher::set_stderr_behavior] methods.  These take a value that specifies
how they shall behave, as made explicit by the [enumref
boost::process::stream_behavior stream_behavior] enumeration; its
documentation details all the possible values (not repeated here to avoid
inconsistencies).

Boost.Process also provides a feature known as ['channel merging].  Merging
two communication channels means that the output of the child's source
channel is redirected to the target channel (be it an input flow or an
output one).  The key idea is that this redirection is done at the lowest
possible level: the child process continues to see multiple streams but as
concerns the operating system, some of them point to the same internal
object.  This feature is used intensively in the library to allow for
efficient retrieval of a process' __stdout__ and __stderr__ flows; check
out the [memberref boost::process::launcher::set_merge_out_err
launcher::set_merge_out_err] method.

Given the above consider the following code snippet.  It configures a
launcher for a child process that will have an infinite blank input and
which will send both of its __stdout__ and __stderr__ to the parent's
__stdout__:

    launcher l;
    l.set_stdin_behavior(silent_stream);
    l.set_stdout_behavior(inherit_stream);
    l.set_stderr_behavior(close_stream);
    l.set_merge_out_err(true);

Setting a channel to `redirect_stream` has some special consequences.  The
channel affected by this flag will be later available to the parent process
through the class representing the child process.  Depending on the
redirected channel, it can be retrieved using one of the [memberref
boost::process::child::get_stdin child::get_stdin], [memberref
boost::process::child::get_stdout child::get_stdout] and [memberref
boost::process::child::get_stderr child::get_stderr] methods.  These calls
return C++ streams as described next.  An input stream for a child process
is seen as an output data flow by the parent; therefore it is modelled
through the [classref boost::process::postream postream] class.  On the
opposite side, an output stream for a child process is seen as an input
data flow by the parent, hence it is represented by the [classref
boost::process::pistream pistream] class.  These two classes are regular
C++ streams but provide an extra method (`close`) to allow the explicit
shutdown of a communication channel.  This is required, for example, to let
the child know that the parent is not willing to send any more data through
its __stdin__.  (Typically the child will close output channels on exit and
the parent will close input ones.)

The following example illustrates how to some data to a process:

    launcher l;
    l.set_stdin_behavior(redirect_stream);
    ... spawn the process ...
    postream os = c.get_stdin();
    os << "some-string" << std::endl;
    os << 200 << 1024 << std::endl;
    os.close();

Similary, the following shows how to retrieve the child's data, line by
line:

    launcher l;
    l.set_stdout_behavior(redirect_stream);
    ... spawn the process ...
    pistream is = c.get_stdout();
    std::string line;
    while (std::getline(is, line))
        std::cout << "Got a line: " << line << std::endl;

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Environment variables]

Every process has a map of variable/value pairs that forms part of its
execution context; these variables are generally known as ['environment
variables] and their values are always represented as text strings.  The
process can query these variables at will to retrieve information passed in
by the parent process; in fact, they can be seen as kind of interprocess
communication mechanism.  Therefore, it is the parent's responsibility to
configure the environment variables that its child receives.

New variables can be added and existing ones can be modified using the
[memberref boost::process::launcher::set_environment
launcher::set_environment] method.  Similarly, existing variables can be
removed by using the [memberref boost::process::launcher::unset_environment
launcher::unset_environment] method.  At last, the [memberref
boost::process::launcher::clear_environment launcher::clear_environment]
method provides a way to zap all existing environment variables.  Care
should be taken when using this method because the new process may expect
some standard variables to be defined for proper operation (e.g. `PATH`).
After using this call you are responsible for appropriately setting up the
minimum required variables.

For quick reference, consider:

    launcher l;
    ... l now carries a snapshot of the current environment ...
    l.clear_environment();
    l.set_environment("variable-name", "variable-value");
    l.unset_environment("variable-name");

And also check out the following example program:

[include ../example/environment.cpp c++ code]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section The startup work directory]

Every process has a property in its execution context that denotes the
['current working directory].  This location is used by the operating
system to resolve relative path names.  Because this property is part of
the execution context, it shall be configured prior process spawning by the
process launcher.  The value set is known as the ['startup work directory]
because it is where the application will start processing; the process is
later free to change it to whichever other directory it wishes.

A child's startup work directory can be configured through the launcher by
using the [memberref boost::process::launcher::set_work_directory
launcher::set_work_directory] method.  If not specified, the process is
started in the same directory the parent was located when it created the
[classref boost::process::launcher launcher] object.

For instance:

    launcher l;
    ... l now points to the parent's current working directory ...
    l.set_work_directory(tmp_dir_location);

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Single process startup and termination]

A new process is defined by a [link boost_process.usage.the_command_line
command line] and a [link boost_process.concepts.launcher launcher].  Once
these two items are configured, the child process can be spawned by a call
to the [memberref boost::process::launcher::start launcher::start] method
which receives the command line to be executed.  For example:

    command_line cl(...);
    ... add arguments to cl ...
    launcher l(...);
    ... configure the execution environment through l ...

    child c = l.start(cl);
    ... c now represents the newborn child process ...

If needed a launcher can be reused to spawn multiple child processes,
possibly with different command lines.  Similarly, a single command line
can be passed to different launchers to start processes with different
properties.

When the child process terminates execution, its parent collects its [link
boost_process.concepts.exit_status exit status] to check whether the
process ran fine or not.  Furthermore, collecting this information is
required in order to free the operating system data structures used to
store it.  The termination information includes the specific reason for
this event as well as any additional details associated to it.

All this information is accessible through the [classref
boost::process::status status] class, an instance of which is returned by
the [memberref boost::process::child::wait child::wait] method.  Through
this instance, the parent inspects the reasons behind the child process
finalization.  For example:

    status s = c.wait();
    if (s.exited()) {
        // The process terminated by itself.
        std::cout << "The exit code was: " << s.exit_status() << std::endl;
    } else
        std::cout << "Abnormal program termination." << std::endl;

Of special interest are the values returned by [memberref
boost::process::status::exit_status status::exit_status]', a method that
can only be called when [memberref boost::process::status::exited
status::exited] is `true`.  As the name states, this call returns the
integer that the child program gave the operating system during exit.  For
readability and portability reasons you should check the returned value
against the standard macros defined in the `cstdlib` header, shown in the
table:

[table
    [[Exit status] [Symbolic constant] [Typical value]]

    [[Success.]
     [`EXIT_SUCCESS`] [0]]

    [[Failure.  Many applications will use multiple values to denote
     denote different error conditions though, so do not assume that this
     value alone is used to report a failed execution.]
     [`EXIT_FAILURE`] [Not 0]]
]

Aside regular exit, some platforms allow retrieving more fine-grained
information on the termination cause.  This information is available though
non-portable classes, as is described later on.

The following complete code example illustrates how to start and stop
multiple processes:

[include ../example/generic.cpp c++ code]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Pipeline startup and termination]

As we saw in the [link
boost_process.usage.quick_tutorials.pipeline_tutorial tutorial], managing a
pipeline is very similar to controlling a single child process because the
whole pipeline is treated by the library's most external API as a single
unit.  There are some differences though, as we shall see below:

Instead of using the regular launcher, pipelines are spawned by the
specialized [classref boost::process::basic_pipeline basic_pipeline] class.
Similarly, pipelines are represented by a [classref
boost::process::children children] object instead of a regular child to
illustrate the fact that they really are a group of processes.  Despite
these notational changes, the external interface of these pipeline-specific
classes is very similar to that used in their homologous single process
management objects.

The following example outlines how to prepare, start and wait for a
pipeline's termination:

    command_line cl1(...);
    ... add arguments to cl1 ...
    command_line cl2(...);
    ... add arguments to cl2 ...

    pipeline p;
    ... configure the execution environment through p ...
    p.add(cl1).add(cl2);

    children cs = p.start();
    ... cs now represents the newborn process group ...

    status s = cs.wait();

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]
