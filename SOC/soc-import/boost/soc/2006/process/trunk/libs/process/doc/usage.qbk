[/
 / Boost.Process
 / Usage chapter.
 /
 / Copyright (c) 2006 Julio M. Merino Vidal.
 /
 / Use, modification, and distribution is subject to the Boost Software
 / License, Version 1.0.  (See accompanying file LICENSE_1_0.txt or copy
 / at http://www.boost.org/LICENSE_1_0.txt.)
 /]

[/ ---------------------------------------------------------------------- ]

[section Usage]

This chapter describes all the portable features in Boost.Process that will
let you achieve the most common tasks.  The chapter starts presenting a
couple of quick tutorials for the lazy reader, outlining the general
structure of a program using the library.  It later dives into details
concerning each part of the tutorial.

[/ ---------------------------------------------------------------------- ]

[section Quick tutorials]

[/ ---------------------------------------------------------------------- ]

[section Single process tutorial]

The single process tutorial outlines all the steps necessary to prepare,
launch, manage and terminate a single child process.  It also illustrates
interprocess communication by capturing the child's output messages and
printing them in a different format.  Each step is accompanied with a
snippet to aid in the explanations which, if joined together, produce a
complete example application.  Let's get started.

As happens with any C++ library, the very first step to use Boost.Process
is to include some header file that pulls in the necessary class and
function definitions.  To make things simple, we include the [headerref
boost/process.hpp] all-in-one header file and define an alias for its main
name space.  However, a bigger application will want to include the more
finer grained headers to avoid unnecessary rebuilds shall the library's
code change.

[include ../example/single_process_tutorial.cpp c++ include-headers]

Getting into the child process startup area, the first thing to do is to
tell the library which application has to be started and which arguments
shall be passed to it.  In an attempt to choose a sample child program that
works on all supported platforms, we use the [@http://subversion.tigris.org
Subversion] command line client whose binary is named `svn` (`svn.exe`
under Windows, but this difference is not important).

Our sample command line uses the provided [link
boost_process.concepts.command_line command_line] class, tells it to locate
the binary in the path and asks the program to update the current
directory.  We could specify additional arguments if we wanted to.

[include ../example/single_process_tutorial.cpp c++ command-line]

Following the definition of the command line, we define the execution
context of the new process; this is done by creating a [classref
boost::process::launcher launcher] object.  As Subversion `update` command
updates the "current directory", we will want the child process to start in
another location (that specified in the `dir` variable) so that it updates
the desired directory.  We do this by asking the launcher to use a
different work directory than the current one.  Furthermore, as outlined
above, we also want to capture the standard output and error channels for
later processing, so we end up with the following:

[include ../example/single_process_tutorial.cpp c++ launcher]

Once we have the command line and the launcher configured, we start the new
child process by mixing them together.  (Yes, we could reuse the same
launcher to start different command lines if we wanted to.)

[include ../example/single_process_tutorial.cpp c++ child-start]

At this point the `c` [classref boost::process::child child] instance
represents a running process.  We can use this object to interact with the
child, which in our example means reading its output messages.  We do this
by obtaining a C++ input stream that is connected to the child's standard
output and error channels.  From there on, it is a simple matter of reading
data and processing them as we want:

[include ../example/single_process_tutorial.cpp c++ get-output]

After parsing the output generated by the child process, we wait until it
terminates execution to retrieve its exit status, which is later stored in
the `s` [classref boost::process::status status] object for further
treatment.  (Strictly speaking we get to this call because the process has
already terminated; otherwise the previous loop could not have finished.)

[include ../example/single_process_tutorial.cpp c++ wait]

At last we parse the process' output status stored in `s` to see if
everything was successful:

[include ../example/single_process_tutorial.cpp c++ parse-status]

To sum it up, the complete example code is:

[include ../example/single_process_tutorial.cpp c++ code]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Pipeline tutorial]

Boost.Process integrates mechanisms to spawn and control process groups
using a construction known as a pipeline.  This tutorial outlines the
procedure to prepare, spawn, control and terminate several commands that
are interconnected in a unidimensional chain.  It is recommended to first
read the [link boost_process.usage.single_process_tutorial single process
tutorial] because it illustrates simpler concepts than this one; you should
spot the minor differences to really understand how pipeline management
works.

First of all, a simple program that manages pipelines includes the general
Boost.Process header.  Of course, we could include the more fine grained
headers, but for our demonstration purposes we need not to:

[include ../example/pipeline_tutorial.cpp c++ include-headers]

As described earlier, processes are started using a launcher.  When it
comes to pipelines, the concept is the same but differs slightly in its
usage: the [classref boost::process::pipeline pipeline] specialized
launcher is the single process' [classref boost::process::launcher
launcher] homogeneous class but it differs in that it spawns and
interconnects multiple processes.  Both launchers share most of their
public interface, so the code below will look very familiar.

To demonstrate the launcher's construction, we capture the pipeline's
standard input (which is the same as the first process' standard input);
this will allow us to feed it some data for further processing.  On the
other hand we tell the launcher to inherit the parent's standard output so
that the results are printed to the expected stream (typically the screen):

[include ../example/pipeline_tutorial.cpp c++ pipeline]

Next, we tell the library which programs form the pipeline.  Each component
is described by a regular [classref boost::process::command_line command
line], much like we did before in the simple tutorial.  However this
example uses the [memberref boost::process::command_line::shell shell]
constructor to simplify argument passing (and to illustrate a different way
of doing things).

Please be aware that the utilities used in these command lines are specific
to Unix systems.  This does not mean in any way that pipelines are
restricted to the POSIX platform; the code could use equivalent programs
under Windows and behave equally well:

[include ../example/pipeline_tutorial.cpp c++ command-lines]

Once all the pipeline components are defined, we add them to the launcher,
really constructing the pipeline.  The order in which we add them is
important:

[include ../example/pipeline_tutorial.cpp c++ addition]

Just after that we can spawn the whole process group, which is not any
different than starting a single process.  Note that this time we get a
[classref boost::process::children children] object instead of a regular
child because we need to keep track of multiple processes.  We could be
interested in directly interacting with each child and not with the
pipeline black box concept:

[include ../example/pipeline_tutorial.cpp c++ children]

At this point the pipeline is running.  The `children` class offers us an
interface that hides the fact that there are multiple processes running; we
can simply treat it as if it were an instance of `child`.  So, similar to
what we did in the previous tutorial, we obtain the pipeline's standard input
and feed it some data:

[include ../example/pipeline_tutorial.cpp c++ feed-stdin]

Once done, we wait until all processes stop execution and collect their
exit status:

[include ../example/pipeline_tutorial.cpp c++ wait]

At last we process the returned status in `s` to determine if everything
went correctly:

[include ../example/pipeline_tutorial.cpp c++ parse-status]

To sum it up, the complete example code is:

[include ../example/pipeline_tutorial.cpp c++ code]

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section The command line]

The command line is an entity that describes a call to an executable
program.  It is composed of the following components:

[variablelist
    [[The executable]
     [This is the path name to the file on disk that will be executed.
      This can be a full path name, a relative path name or a base name
      without any component.]
    ]

    [[The program name]
     [The program name is a string passed as the executable's first
      argument (e.g. `argv[0]`).  This typically matches the executable's
      base name but can be changed at will in case the program behaves
      differently depending on the value passed in that parameter.]
    ]

    [[The arguments list]
     [Aside from the first argument carrying the program's name, an
      executable may receive a set of extra arguments, similar to function
      parameters.  These are stored in the arguments list.]
    ]
]

All the functions or classes in the library that use a command line are
parametrized on the [link boost_process.concepts.command_line Command_Line]
concept.  This allows the developer to provide a custom implementation,
shall we need to.

For convenience, the library includes a reference implementation class
named [classref boost::process::command_line command_line].  It should be
enough in most cases.  The instructions below may only apply to this
implementation.

There are two main ways to construct a command line as we shall see below.

[section Creation from individual arguments]

The traditional entry point of a C or C++ program looks like:

    int main(int argc, char* argv[]);

Programs receive an ['array of strings] in `argv` that contains all the
arguments passed to them.  The reference command line implementation
provides an interface to construct calls to applications based on the exact
contents of the `argv` array.   If at all possible, the new process will
receive a verbatim copy of the arguments provided by the caller.

Executing programs using this syntax is safe to quotation issues because
the library ensures that the values provided by the user end up in the
child process without modifications.  Furthermore, no other process
__mdash__ not even the shell __mdash__ is involved in the execution
procedure.

Constructing command lines on a parameter basis is the recommended usage,
specially if user input is involved in the construction.  However it might
not be appropriate in all scenarios, as we will see later on.

In order to construct a command line parameter by parameter, we first tell
it which is the executable to launch and, optionally, its program name.  If
the latter is not provided, it is automatically guessed:

    command_line cl("/path/to/executable", "program_name");

The [classref boost::process::command_line class]' constructor takes two
parameters: the path to the executable and its program name.  If the path
does not contain any component path (no slashes nor backslashes), the
executable will be searched in the system's path; could the application
not be found, a [classref boost::process::not_found_error not_found_error<
std::string >] exception is raised as shown below:

    try {
        command_line cl("unknownbinary");
        ...
    } catch (const not_found_error< std::string >& e) {
        std::cerr << e.get_value() << " could not be found" << std::endl;
    }

Once the command line is constructed, additional arguments can be appended
to it by using the [memberref boost::process::command_line::argument
command_line::argument] method.  This function is parametrized on the
argument type to allow dealing with any data type (provided it can be
inserted in an output stream).  Its usage is as follows:

    cl.argument("first-parameter").argument("second-parameter");
    cl.argument("...").argument("nth-parameter");

[endsect]

[section Creation from a single string]

Another way to construct a command line is to define it in terms of the
shell using the [memberref boost::process::command_line::shell
command_line::shell static method].  You create a ['single string] that
represents the whole command line, which is then passed to the default
system shell for later processing.

As the shell is involved, the command line is affected by its parsing rules
such as variable and wildcard expansion, construction of pipelines,
redirections of streams or even execution of built-in commands.

The general syntax is as follows:

    command_line cl = command_line::shell
        ("the-program first-parameter ... nth-parameter");

[endsect]

[section Examples]

The following example program shows multiple command lines from their
construction until their execution:

[include ../example/command_lines.cpp c++ code]

[endsect]

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Interprocess communication]

Every process has three standard communication channels that allow easy
communication between either a parent process and a child process or among
different child processes.  Thanks to these ['standard channels], a program
can easily implement a transformation of the input data without knowing
where it is located and print it to an output channel whose real location
is unknown; additionally it can print error messages that will end up
stored where the caller decided.

There are lots of programs that process an input and produce an input, all
using the standard channels previously described.  These are known as
['filters] and are very common in the Unix work.  Of course there are many
other programs that do not implement a data conversion, yet they use the
standard channels to communicate with the user and/or ['with other
processes].

The three standard communication channels are reviewed below.  We can
assume that they are supported by [link
boost_process.platforms_and_compilers.supported_platforms all platforms]
recognized by the library.

[variablelist
    [[Standard input channel or __stdin__]
     [This is used by the process to read input data, typically fed in by
      the user or another running process (e.g. its parent).]
    ]

    [[Standard output channel or __stdout__]
     [This is used by the process to print output messages or data.  The
      channel is typically configured to be buffered and its output is
      generally dumped to the console; of course it can be redirected to
      another process or file.]
    ]

    [[Standard error channel or __stderr__]
     [This is used by the process to print error messages and sometimes to
      simply separate them from the output data.  The channel is typically
      configured to be unbuffered and its output is generally dumped to the
      console; of course it can be redirected to another process or file.]
    ]
]

What concerns us is the ability to interact with these standard streams
from the process spawning a child __mdash__ that is, the one using
Boost.Process.  The parent must tell the new child process how its standard
channels shall behave; this is done by modifying the execution context of
the new process by means of one of the multiple [link
boost_process.concepts.launcher launcher] implementations.

Each communication channel can be configured according to different
predefined behaviors by using the [memberref
boost::process::launcher::set_stdin_behavior launcher::set_stdin_behavior],
[memberref boost::process::launcher::set_stdout_behavior
launcher::set_stdout_behavior] and [memberref
boost::process::launcher::set_stderr_behavior
launcher::set_stderr_behavior] methods.  These take a value that specifies
how they shall behave, as made explicit by the [enumref
boost::process::stream_behavior stream_behavior] enumeration; its
documentation details all the possible values (not repeated here to avoid
inconsistencies).

Boost.Process also provides a feature known as ['channel merging].  Merging
two communication channels means that the output of the child's source
channel is redirected to the target channel (be it an input flow or an
output one).  The key idea is that this redirection is done at the lowest
possible level: the child process continues to see multiple streams but as
concerns the operating system, some of them point to the same internal
object.  This feature is used intensively in the library to allow for
efficient retrieval of a process' __stdout__ and __stderr__ flows; check
out the [memberref boost::process::launcher::set_merge_out_err
launcher::set_merge_out_err] method.

Given the above consider the following code snippet.  It configures a
launcher for a child process that will have an infinite blank input and
which will send both of its __stdout__ and __stderr__ to the parent's
__stdout__:

    launcher l;
    l.set_stdin_behavior(silent_stream);
    l.set_stdout_behavior(inherit_stream);
    l.set_stderr_behavior(close_stream);
    l.set_merge_out_err(true);

Setting a channel to `redirect_stream` has some special consequences.  The
channel affected by this flag will be later available to the parent process
through the class representing the child process.  Depending on the
redirected channel, it can be retrieved using one of the [memberref
boost::process::child::get_stdin child::get_stdin], [memberref
boost::process::child::get_stdout child::get_stdout] and [memberref
boost::process::child::get_stderr child::get_stderr] methods.  These calls
return C++ streams as described next.  An input stream for a child process
is seen as an output data flow by the parent; therefore it is modelled
through the [classref boost::process::postream postream] class.  On the
opposite side, an output stream for a child process is seen as an input
data flow by the parent, hence it is represented by the [classref
boost::process::pistream pistream] class.  These two classes are regular
C++ streams but provide an extra method (`close`) to allow the explicit
shutdown of a communication channel.  This is required, for example, to let
the child know that the parent is not willing to send any more data through
its __stdin__.  (Typically the child will close output channels on exit and
the parent will close input ones.)

The following example illustrates how to some data to a process:

    launcher l;
    l.set_stdin_behavior(redirect_stream);
    ... spawn the process ...
    postream os = c.get_stdin();
    os << "some-string" << std::endl;
    os << 200 << 1024 << std::endl;
    os.close();

Similary, the following shows how to retrieve the child's data, line by
line:

    launcher l;
    l.set_stdout_behavior(redirect_stream);
    ... spawn the process ...
    pistream is = c.get_stdout();
    std::string line;
    while (std::getline(is, line))
        std::cout << "Got a line: " << line << std::endl;

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Environment variables]

Each running process has a set of environment variables that it can query
for information.  The parent process is responsible for setting up this
table and passing it to the new child process during startup; hence, it is
the launcher's task to handle the status of these variables.

A launcher object keeps the status of the environment variables that are
passed to a process started through it.  During initialization, this list
is inherited from the current process' environment but can be later
modified by the user by setting new variables, modifying the contents of
existing ones or removing already-set variables.  This can be done by using
the [memberref boost::process::launcher::set_environment
launcher::set_environment] and the [memberref
boost::process::launcher::unset_environment launcher::unset_environment]
methods, whose documentation provides more information on their
functionality as well as some portability notes.

The environment can also be completely cleared by using the [memberref
boost::process::launcher::clear_environment launcher::clear_environment]
method.  Care should be taken when using this method because the new
process may expect some standard variables to be defined for proper
operation (e.g. `PATH`).  After using this call you are responsible for
appropriately setting up the minimum required variables.  Be aware that
under Windows an environment cannot be empty: at the very minimum, it will
always contain a blank-named variable that points to the current working
directory; this is transparently handled by the library.

For quick reference, consider:

    launcher l;
    ... l now carries a snapshot of the current environment ...
    l.clear_environment();
    l.set_environment("variable-name", "variable-value");
    l.unset_environment("variable-name");

[endsect]

[/ ---------------------------------------------------------------------- ]

[section The startup work directory]

Another property of a process' execution context is the directory in the
file system in which it starts functioning.  This location is used by the
operating system to resolve relative paths and possibly by the application
to determine the default directory for some of its operations.

Before launching a process, the parent can configure the child's startup
work directory by using the [memberref
boost::process::launcher::set_work_directory launcher::set_work_directory]
method.  If not specified, the process is started in the same directory the
parent was located in when it created the [classref
boost::process::launcher launcher] object.

For instance:

    launcher l;
    ... l now points to the current work directory ...
    l.set_work_directory(tmp_dir_location);

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Child process startup]

Once the command line and the process' execution context are configured, a
new process can be spawned by using the launcher's `start` method, which in
case of the portable launcher is [memberref boost::process::launcher::start
launcher::start].  This method takes the execution context as the implicit
parameter, the command line as a formal parameter and returns a [link
boost_process.concepts.child child entity] that represents and allows
interaction with the newborn process.

An illustrative (but incomplete) code snippet:

    command_line cl(...);
    ... add arguments to cl ...
    launcher l(...);
    ... configure the execution environment through l ...

    child c = l.start(cl);
    ... c now represents the newborn child process ...

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Process termination]

When a child process terminates execution, its parent has to collect its
[link boost_process.concepts.exit_status exit status] to free the operating
system data structures used to store this information.

Depending on the operating system in use, a process can terminate for
different reasons.  Considering the most complete case (a POSIX system), a
process can terminate regularly by itself; it can finish due to an
unhandled signal (which may well be sent from the outside); or it can be
stopped by another process.  All this information is accessible through the
[classref boost::process::status status] class, an instance of which is
returned by the [memberref boost::process::child::wait child::wait] method.

After a call to that method, the parent is then able to inspect the reasons
behind the child process finalization.  For example:

    status s = c.wait();
    if (s.exited()) {
        // The process terminated by itself.
        std::cout << "The exit code was: " << s.exit_status() << std::endl;
    } else
        std::cout << "Abnormal program termination." << std::endl;

[endsect]

[/ ---------------------------------------------------------------------- ]

[section Pipeline management]

As a pipeline is just a process group, its management is built on top of
the regular process [link boost_process.usage.child_process_startup
startup] and [link boost_process.usage.process_termination termination].
The [classref boost::process::basic_pipeline basic_pipeline] and [classref
boost::process::children children] classes are used to spawn and represent
the process group respectively.

The interface used to manage pipelines is very similar to that used to
handle single processes.  This can be seen in the following simple code
snippet:

    command_line cl1(...);
    ... add arguments to cl1 ...
    command_line cl2(...);
    ... add arguments to cl2 ...

    pipeline p;
    ... configure the execution environment through p ...
    p.add(cl1).add(cl2);

    children cs = p.start();
    ... cs now represents the newborn process group ...

    status s = cs.wait();

For more details check out the [link boost_process.reference reference
chapter] and the [link boost_process.examples.pipelines pipeline example].

[endsect]

[/ ---------------------------------------------------------------------- ]

[endsect]
