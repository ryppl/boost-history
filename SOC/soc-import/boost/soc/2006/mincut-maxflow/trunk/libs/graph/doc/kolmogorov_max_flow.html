<HTML>
<!--
  -- Copyright (c) Stephan Diederich 2006
  --
  -->
<Head>
<Title>Boost Graph Library: Kolmogorov Maximum Flow</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../boost.png" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>

<H1><A NAME="sec:kolmogorov_max_flow">
<TT>kolmogorov_max_flow</TT>
</H1>

<b>TODO:</b><br>
-Dont add extra reverse edges like push-relabel <br>
-why and When use kolmogorov instead of push-relabel<br>
-Add kolmogorov to boost:graph:bibliography<br>
-add links to kolmogorov from push-relabel & edmund-kap<br>


<P>
<PRE>
<i>// named parameter version</i>
template &lt;class Graph, class P, class T, class R&gt;
typename property_traits< typename property_map<Graph, edge_capacity_t>::const_type>::value_type
push_relabel_max_flow(Graph&amp; g, 
   typename graph_traits&lt;Graph&gt;::vertex_descriptor src,
   typename graph_traits&lt;Graph&gt;::vertex_descriptor sink,
   const bgl_named_params&lt;P, T, R&gt;&amp; params = <i>all defaults</i>)

<i>// non-named parameter version</i>
  template &lt;class Graph, class CapacityEdgeMap, class ResidualCapacityEdgeMap, class ReverseEdgeMap, 
    class PredecessorMap, class ColorMap, class DistanceMap, class IndexMap &gt;
      typename property_traits< typename property_map&lt;Graph, edge_capacity_t&gt;::const_type&gt;::value_type  
    kolmogorov_max_flow
      (Graph&amp; g, 
       CapacityEdgeMap cap,
       ResidualCapacityEdgeMap res_cap,
       ReverseEdgeMap rev_map,
       PredecessorMap pre_map,
       ColorMap color,
       DistanceMap dist,
       IndexMap idx,
       typename graph_traits &lt;Graph&gt;::vertex_descriptor src,
       typename graph_traits &lt;Graph &gt;::vertex_descriptor sink
       )
</PRE>

<P>
The <tt>kolmogorov_max_flow()</tt> function calculates the maximum flow
of a network. See Section <a
href="./graph_theory_review.html#sec:network-flow-algorithms">Network
Flow Algorithms</a> for a description of maximum flow.  The calculated
maximum flow will be the return value of the function. The function
also calculates the flow values <i>f(u,v)</i> for all <i>(u,v)</i> in
<i>E</i>, which are returned in the form of the residual capacity
<i>r(u,v) = c(u,v) - f(u,v)</i>

<br><br>
<b>Requirements:</b><br>
The directed graph <i>G=(V,E)</i> that represents the network must be augmented to
include the reverse edge for every edge in <i>E</i>. Unlike the push-relabel-algorithm, 
there is no necessarity to double all the edges in a graph.
Just make sure that for each edge <i>(u,v)</i> there exists an edge <i>(v,u)></i>.


<p>
This algorithm was developed by <a 
href="www.adastral.ucl.ac.uk/~vladkolm/">Kolmogorov</a>. TODO

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/kolmogorov_max_flow.hpp"><TT>boost/graph/kolmogorov_max_flow.hpp</TT></a>

<P>

<h3>Parameters</h3>

IN: <tt>Graph&amp; g</tt>
<blockquote>
  A directed graph. The
  graph's type must be a model of 
<a href="./VertexListGraph.html">Vertex List Graph</a>, 
<a href="./EdgeListGraph.html">Edge List Graph</a> and
<a href="./IncidenceGraph.html">Incidence Graph</a>. 

For each edge
  <i>(u,v)</i> in the graph, the reverse edge <i>(v,u)</i> must also
  be in the graph.
</blockquote>

IN: <tt>vertex_descriptor src</tt>
<blockquote>
  The source vertex for the flow network graph.
</blockquote>
  
IN: <tt>vertex_descriptor sink</tt>
<blockquote>
  The sink vertex for the flow network graph.
</blockquote>

<h3>Named Parameters</h3>
  
IN: <tt>capacity_map(EdgeCapacityMap cap)</tt>
<blockquote>
  The edge capacity property map. The type must be a model of a
  constant <a
  href="../../property_map/LvaluePropertyMap.html">Lvalue Property Map</a>. The
  key type of the map must be the graph's edge descriptor type.<br>
  <b>Default:</b> <tt>get(edge_capacity, g)</tt>
</blockquote>
  
OUT: <tt>residual_capacity_map(ResidualCapacityEdgeMap res)</tt>
<blockquote>
  The edge residual capacity property map. The type must be a model of
  a mutable <a
  href="../../property_map/LvaluePropertyMap.html">Lvalue Property Map</a>. The
  key type of the map must be the graph's edge descriptor type.<br>
  <b>Default:</b> <tt>get(edge_residual_capacity, g)</tt>
</blockquote>
  
IN: <tt>reverse_edge_map(ReverseEdgeMap rev)</tt>
<blockquote>
  An edge property map that maps every edge <i>(u,v)</i> in the graph
  to the reverse edge <i>(v,u)</i>. The map must be a model of
  constant <a
  href="../../property_map/LvaluePropertyMap.html">Lvalue Property Map</a>. The
  key type of the map must be the graph's edge descriptor type.<br>
  <b>Default:</b> <tt>get(edge_reverse, g)</tt>
</blockquote>

UTIL: <tt>vertex_predecessor (PredecessorMap pre_map)</tt>
<blockquote>
  A vertex property map that stores of edge vertex a predecessor in form of an edge. 
  The map must be a model of mutable <a
  href="../../property_map/LvaluePropertyMap.html">Lvalue Property Map</a>. The
  key type of the map must be the graph's vertex descriptor type.<br>
  <b>Default:</b> <tt>get(vertex_predecessor, g)</tt>
</blockquote>

OUT/UTIL: <tt>vertex_color (ColorMap color)</tt>
<blockquote>
  A vertex  property map that stores a color for edge vertex. If the color of a vertex after running the algorithm is white, the vertex belongs to the source tree, else to the sink-tree (used for minimum cuts)
  The map must be a model of mutable <a
  href="../../property_map/LvaluePropertyMap.html">Lvalue Property Map</a>. The
  key type of the map must be the graph's vertex descriptor type.<br>
  <b>Default:</b> <tt>get(vertex_color, g)</tt>
</blockquote>

UTIL: <tt>vertex_distance (DistanceMap dist)</tt>
<blockquote>
  A vertex  property map that stores distance to source/sink nodes. It's a utility-map for speeding up the algorithm
  The map must be a model of mutable <a
  href="../../property_map/LvaluePropertyMap.html">Lvalue Property Map</a>. The
  key type of the map must be the graph's vertex descriptor type.<br>
  <b>Default:</b> <tt>get(vertex_distance, g)</tt>
</blockquote>
       

IN: <tt>vertex_index_map(VertexIndexMap index_map)</tt>
<blockquote>
  Maps each vertex of the graph to a unique integer in the range
  <tt>[0, num_vertices(g))</tt>. The map must be a model of constant <a
  href="../../property_map/LvaluePropertyMap.html">LvaluePropertyMap</a>. The
  key type of the map must be the graph's vertex descriptor type.<br>
  <b>Default:</b> <tt>get(vertex_index, g)</tt>
</blockquote>


<h3>Example</h3>

This reads in an example maximum flow problem (a graph with edge
capacities) from a file in the DIMACS format (<a
href="../example/max_flow.dat"><tt>example/max_flow.dat</tt></a>.). The source for this
example can be found in <a
href="../example/kolmogorov-eg.cpp"><tt>example/kolmogorov-eg.cpp</tt></a>.

<pre>
#include &lt;boost/config.hpp&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;boost/graph/kolmogorov_map_flow.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/read_dimacs.hpp&gt;

int
main()
{
  using namespace boost;

  typedef adjacency_list_traits&lt;vecS, vecS, directedS&gt; Traits;
  typedef adjacency_list&lt;vecS, vecS, directedS, 
    property&lt;vertex_name_t, std::string&gt;,
    property&lt;edge_capacity_t, long,
      property&lt;edge_residual_capacity_t, long,
	property&lt;edge_reverse_t, Traits::edge_descriptor&gt; &gt; &gt;
  &gt; Graph;

  Graph g;
  long flow;

  property_map&lt;Graph, edge_capacity_t&gt;::type 
    capacity = get(edge_capacity, g);
  property_map&lt;Graph, edge_reverse_t&gt;::type 
    rev = get(edge_reverse, g);
  property_map&lt;Graph, edge_residual_capacity_t&gt;::type 
    residual_capacity = get(edge_residual_capacity, g);

  Traits::vertex_descriptor s, t;
  read_dimacs_max_flow(g, capacity, rev, s, t);

  flow = kolmogorov_max_flow(g, s, t);

  std::cout &lt;&lt; "c  The total flow:" &lt;&lt; std::endl;
  std::cout &lt;&lt; "s " &lt;&lt; flow &lt;&lt; std::endl &lt;&lt; std::endl;

  std::cout &lt;&lt; "c flow values:" &lt;&lt; std::endl;
  graph_traits&lt;Graph&gt;::vertex_iterator u_iter, u_end;
  graph_traits&lt;Graph&gt;::out_edge_iterator ei, e_end;
  for (tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter)
    for (tie(ei, e_end) = out_edges(*u_iter, g); ei != e_end; ++ei)
      if (capacity[*ei] &gt; 0)
        std::cout &lt;&lt; "f " &lt;&lt; *u_iter &lt;&lt; " " &lt;&lt; target(*ei, g) &lt;&lt; " " 
                  &lt;&lt; (capacity[*ei] - residual_capacity[*ei]) &lt;&lt; std::endl;
  return 0;
}
</pre>
The output is:
<pre>
c  The total flow:
s 13

c flow values:
f 0 6 3
f 0 1 0
f 0 2 10
f 1 5 1
f 1 0 0
f 1 3 0
f 2 4 4
f 2 3 6
f 2 0 0
f 3 7 5
f 3 2 0
f 3 1 1
f 4 5 4
f 4 6 0
f 5 4 0
f 5 7 5
f 6 7 3
f 6 4 0
f 7 6 0
f 7 5 0
</pre>

<h3>See Also</h3>

<a href="./edmunds_karp_max_flow.html"><tt>edmunds_karp_max_flow()</tt></a>,<br>
<a href="./push_relabel_max_flow.html"><tt>push_relabel_max_flow()</tt></a>.

<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2006</TD><TD>
Stephan Deiderich, University Mannheim(<A HREF="mailto:diederich@ti.uni-manheim.de">diederich@ti.uni-manheim.de</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
