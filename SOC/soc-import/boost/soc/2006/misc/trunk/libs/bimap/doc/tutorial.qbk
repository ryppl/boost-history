[/license

    Boost.Bimap
    Matias Capeletto 2006
    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
]

[/ QuickBook Document version 1.3 ]

[section The tutorial]

[section Roadmap]

# Boost.Bimap is intuitive because it is based on the standard template library. However new
concepts are presented to extend the mapping framework to bidirectional maps. The first step
is to firmly grasp the new framework. The first section:
[link boost_bimap.the_tutorial.discovering_the_new_framework Discovering the new framework]
aims to explain it.

# Being based in Boost.MultiIndex, Boost.Bimap has been able to offer a lot more than just
a one to one ordered unique bidirectional map. We will be able to control the set type of
each side of the relationship that bimap is representing leading to one to many containers,
hashed bidirectional containers and others useful containers that may fit better in the
problem you are confronting. The second section:
[link boost_bimap.the_tutorial.controlling_the_set_types Controlling the set types] explain
how to instantiate a bimap to have different collection constrains.

# Metafunctions are a very important part of this library. They will clean the way to a more
powerful and scalable way of coding.
The next section [link boost_bimap.the_tutorial.metafunctions Metafunctions] will explain
the most important ones.

# The types of a bimap can be tagged so then each side can be access through using something
more close to the problem than ['left] and ['right]. This will lead to more readable code
and self documenting code. The fourth section: 
[link boost_bimap.the_tutorial.tagging Tagging] shows how to use this feature.

# The are a lot of problems were each related pair have other attributes. Imagine a bimap that
tie an employee name with his id. You may want to store his age, family members and other stuff.
Boost.Bimap let you hook a data structure to each relation making unnecessary the creation of
another container to hold this not indexed attributes. The section:
[link boost_bimap.the_tutorial.hooking_data Hooking Data] explains this feature.

# Maybe the hardest to understand is the subtle problem of the set of relations.
The section: [link boost_bimap.the_tutorial.the_set_of_relations_type The set of relations type]
explain this problem and how to create new types of bidirectional maps.

# The complexity of insertion, deletion and modification of elements in a bimap is not trivial.
In the section: [link boost_bimap.the_tutorial.complexity Complexity] a detailed reference of
the complexity of each function is presented.

# The last section:
[link boost_bimap.the_tutorial.complete_instantiation_scheme Complete Instantiation Scheme]
resume the bimap instantiation and introduced the way to change the allocator type to use.

[endsect]

[section Discovering the new framework]

Relations between data in the stl are represented with maps.
A std::map is a directed relation, by using it you are representing a mapping.
In this directed relation, first_type is related to second_type but it is not true
that the inverse relationship holds.
This is useful in a lot of situations, but there are some relationships that are
bidirectional by nature, and it is more comfortable and in many cases more efficient
in time and space to represent the relationship as a bidirectional mapping between
the two collections of data.
Boost.Bimap allows to represent this kind of relations and offers a ready-to-use
arsenal to play with. The design is very influenced by the stl.

[h2 Standard mapping framework]

A std::map has to be thought of as a directed mapping between a set of keys and a
collection of data values.
The following diagram shows the represented relationship and the view point where the
user is placed.

__STANDARD_MAPPING_FRAMEWORK__

This is not wrong, and it is a lot more efficient to use std::maps than bimaps if
you never have to observe the relationship from the other side.

__STD_PAIR__

The stl designer noted that this was a directed relationship and named the data it
contains according to it. A ['std::pair'] is a directed relation between *x* and *y*. That is
why the names ['first] for *x* and ['second] for *y* are natural.
Note how the code looks.

    X x;
    Y y;

    std::pair
    <
        X, /* ----> */ Y

    > directed_relation(x,y);

    directed_relation.first;
    directed_relation.second;

Note that the type of the collection of X is a set because we have chosen a map for the
example, but the collection type on the left can be different. The following table
shows the equivalence for the std associative containers.

[table std associative containers
[[container         ][left set type     ][right set type]]
[[map               ][set               ][collection    ]]
[[multimap          ][multiset          ][collection    ]]
[[unordered_map     ][unordered_set     ][collection    ]]
[[unordered_multimap][unordered_multiset][collection    ]]
]

[h2 Extended mapping framework]

Boost.Bimap design is based on the stl, and extends the framework in a natural way.
The following diagram represents the new situation.

__EXTENDED_MAPPING_FRAMEWORK__

Look that now the std::maps are a particular case of a Boost.Bimap container where you
can only view one of the sides of the relationship and can only control
the constrains of one of the collections.
Boost.Bimap allows the user to view the relationship from the three points of view.
You can view it from a side, getting a std::map compatible container or you can
work directly with the whole relation.
The only thing left to do is to find a way to represent this new framework in C++
code, so it is both easy to read and to remember how to write it.
The first thing is to get rid of the std::pair to represent the contained
data of the bimap. The two collections are now at the same level, so it is not
correct to name them as first/second or a/b. These names clearly impose an ordering
of the two values.

The solution is to view *x* as the ['left] member and *y* as the ['right] one.
The left/right naming puts the two values exactly at the same level, and allows
us to refer easily to the view. We can now say: "The map indexed by the left member",
and the meaning is very clear.

__RELATION__

The new type will be called ['relation]. It will have two members, one will be called
['left] and the other one ['right].
The code now looks like

    X x;
    Y y;

    boost::relation
    <
        X, /* <---> */ Y

    > relation(x,y);

    relation.left; relation.right;


[endsect]

[section Controlling the set types]

As we said before, in the stl maps you can only control the constrains from
one of the collection, the one that you are viewing.
In Boost.Bimap you can control both of them and it is as easy as using the stl.
The idea is to use the same constrains names that are used in the standard.
If you don't specify the collection type, Boost.Bimap assumes that the collection
is a set.
The instantiation of a bimap with custom set types looks like:

    typedef bimap< ``*SetType*``_of<A>, ``*SetType*``_of<B> > bm_type;

The following is the list of all supported set types.

[table Set of Key Types
[[name                   ][Features          ][map view type            ]]
[[`set_of`               ][['ordered, unique]][`map_view`               ]]
[[`multiset_of`          ][['ordered        ]][`multimap_view`          ]]
[[`unordered_set_of`     ][['hashed, unique ]][`unordered_map_view`     ]]
[[`unordered_multiset_of`][['hashed         ]][`unordered_multimap_view`]]
[[`list_of`              ][['sequenced      ]][`list_map_view`          ]]
[[`vector_of`            ][['random access  ]][`vector_map_view`        ]]
]

The last two map views are not associate to any existing stl associative containers.
They are two examples of unsorted associative containers.

__BIMAP_STRUCTURES__

The selection of the set type affects the possible operations, and the time it takes to
do each of them, that you can perform with each side of the bimap. If we have:

    typedef bimap< ``*SetType*``_of<A>, ``*SetType*``_of<B> > bm_type;
    bm_type bm;

Now the following is the description of the resulting map views of the bidirectional map.

* `bm.left` is signature compatible with *LeftMapType*`<A,B>`
* `bm.right` is signature compatible with *RightMapType*`<B,A>`

[h2 Configuration parameters]

Each set type template have different parameters to control it behaviour. For example
in the `set_of` specification you can pass a Functor type that compares two types. All
these parameters are exactly the same one of the standard library container. The only
parameter missing is the allocator type. You will be learn later how to change the
allocator for a bimap.

The following table enumerate the parameters meaning for each set type.

[table
[[name                     ][Additional Parameters]]

[[`set_of<T,KeyComp>`\n
  `multiset_of<T,KeyComp>` ]
[[*KeyComp ] is a Functor that compares for less two types. By default it is std::less<T>. ]]

[[`unordered_set_of<T,HashFunctor,EqualKey>`\n
  `unordered_multiset_of<T,HashFunctor,EqualKey>`]
[[*HashFunctor ] converts a T object into an integer value. By default it is boost::hash<T>.\n
 [*EqualKey ] is a Functor that compare for equality two types. By default it is std::equal_to<T>. ]]
[[`list_of<T>`              ][No additional parameters.]]
[[`vector_of<T>`            ][No additional parameters.]]
]

[endsect]

[section Metafunctions]

[/
[h2 data_type_of
Metafunction to obtain the data type of one of the sides in a bimap.
This is the actual data type stored in the bimap.

[h2 iterator_type_by
Metafunction to obtain the iterator type of the map view by one of the sides.

[h2 key_type_of
Metafunction to obtain the key type of one of the sides in a bimap.
The returned type is one of the {SetType}_of definition classes.

[h2 value_type_by
Metafunction to obtain the value type of a bimap indexed by one of the sides. The tag parameter can be either a user defined tag or member_at::{side}. The returned type is compatible with std::pair. More...

struct    pair_type_by
Metafunction to obtain the view type indexed by one of the sides. More...
  struct    value_type_of
     Metafunction to obtain the value type of one of the sides. More...

  Functions
  template<class Tag, class Relation> 
  result_of::get< Tag, Relation 
 >::type   get (Relation &r)
     Gets the value of one of the members in a symmetrical class. 
  template<class Tag, class Relation> 
  result_of::pair_by< Tag, Relation 
 >::type   pair_by (Relation &)
     Gets a pair view of the relation. 

]

__UNDER_CONSTRUCTION__

[endsect]

[section Tagging]

The code produced in this fashion tends to be obscure and error prone.
The bimap family let you tag your types so they can be accessed by a more descriptive name.

__TAGGED__

__UNDER_CONSTRUCTION__

[/
The above example can be rewritten as:

    struct dni  {}; // Tag for the national identification number
    struct name {}; // Tag for the name of the person

    typedef bimap
    <
        tagged< int   , dni  >,
        tagged< string, name >

    > People;

    People people_info;

    // Ask for a view, and use it as a standard map

    map_type_by<name,People>::type map( people_info );
    map["Gray Simpson" = 28928546;

    // Metafunctions can be used to get nice code to

    map_by<dni>(people_info)[28928546 = "Gray Simpson";


This will produce more readable code. You can notice how the
`map_by<name>(people_info)` is self descriptive:
it state that the type is "map by name this people".
]

[endsect]

[section Hooking Data]

This is one of the things that will make Boost.Bimap very appealing to attack
a problem. In general programmers use maps to access information quickly.
Boost.Bimap allows the user to hook data inside the bimap so it is not
necessary to maintain another map.

    typedef bimap< int, string, hook_data< string > > bm_type;
    bm_type bm;

    //...

    bm.left_map.data(28928546) = "carpintero";
    bm.right_map.data("John Wayne") = "actor";

    bm_type::left_iterator iter = bm.left_map.find(23345647);
    iter->data = "programador";

    bm_type::iterator iter = bm.find( bm_type::pair_by<member_at::left>(23345647,"Green Dert") );
    iter->data = "estudiante";

    bm.insert( bm_type::value_type_by<member_at::left>(1456783342,"Fred Bypass","retirado") );

__UNDER_CONSTRUCTION__

[endsect]

[section The set of relations type]

The constrains of the bimap set view are another very important feature.
In general, Boost.Bimap users will base the set view type in one of the
two set types of their keys. However it may be useful to give this set
another constraints or simple order it differently.
By default Boost.Bimap will base the set of the relation in the left key
but the user is allowed to choose between:

* based_in_left_key
* based_in_right_key
* set_of_relation<>
* multiset_of_relation<>
* unordered_set_of_relation<>
* unordered_multiset_of_relation<>

In the first two cases there are only two indexes in the multi_index_core and
for this reason are the prefeared option.

__UNDER_CONSTRUCTION__

[endsect]


[section Complete instantiation scheme]

The possible bimap instantiation are enumerated here:
{Side}KeyType can be directly a type, this is default to
set_of<{Side}KeyType>, or can be a {SetType}_of<Type>
specification. Additionally this two parameters can be tagged
to specify others tags instead of the usual member_at::{Side}
ones.
The three last parameters are used to specify the set type of
the relation, an inplace hooked data class and the allocator
type. As a help to the bimap user, these parameters support
default types but use a special idiom that allow them to be
specified without interleaving the usual use_default keyword.

\n

    bimap<LeftKeyType,RightKeyType>

* set_of_relation_type: based on the left key type
* hook_data:            no additional data
* allocator:            default allocator

\n

    bimap<LeftKeyType,RightKeyType>

* set_of_relation_type: based on the left key type
* hook_data:            no additional data
* allocator:            Allocator

\n

    bimap<LeftKeyType,RightKeyType,SetOfRelationType>

* set_of_relation_type: SetOfRelationType
* hook_data:            no additional data
* allocator:            default allocator

\n

    bimap<LeftKeyType,RightKeyType,SetOfRelationType,Allocator>

* set_of_relation_type: SetOfRelationType
* hook_data:            no additional data
* allocator:            Allocator

\n

    bimap<LeftKeyType,RightKeyType,DataToHook>

* set_of_relation_type: based on the left key type
* hook_data:            DataToHook
* allocator:            default allocator

\n

    bimap<LeftKeyType,RightKeyType,DataToHook,Allocator>

* set_type_of_relation: based on the left key type
* hook_data:            DataToHook
* allocator:            Allocator

\n

    bimap<LeftKeyType,RightKeyType,SetOfRelationType,DataToHook>

* set_of_relation_type: SetOfRelationType
* hook_data:            DataToHook
* allocator:            default allocator

\n

    bimap<LeftKeyType,RightKeyType,SetOfRelationType,DataToHook,Allocator>

* set_of_relation_type: SetOfRelationType
* hook_data:            DataToHook
* allocator:            Allocator

__UNDER_CONSTRUCTION__

[endsect]


[endsect]
