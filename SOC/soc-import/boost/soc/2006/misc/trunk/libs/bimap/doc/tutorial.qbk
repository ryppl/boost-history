[/license

Boost.Bimap

Copyright (c) 2006 Matias Capeletto

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)

]

[/ QuickBook Document version 1.3 ]

[section The tutorial]

[section Roadmap]

# Boost.Bimap is intuitive because it is based on the standard
template library. New concepts are however presented to extend the
mapping framework to bidirectional maps. The first step is to gain a
firm grasp of the new framework. The first section
([link boost_bimap.the_tutorial.discovering_the_new_framework Discovering the new framework])
aims to explain this.

# Boost.Bimap offers much more than just a one-to-one ordered unique
bidirectional map. It is possible to control the set type of each side
of the relationship that the bimap represents, giving one-to-many
containers, hashed bidirectional containers and others that may be more
suitable to the the task at hand. The second section
([link boost_bimap.the_tutorial.controlling_set_types Controlling set types])
explains how to instantiate a bimap with different collection constraints.

# The types of a bimap can be tagged so that each side is accessible
by something closer to the problem than left and right. This leads to
more readable, self-documenting code. The fourth section
([link boost_bimap.the_tutorial.tagging Tagging]) shows how to use this feature.

# What is perhaps the hardest issue to understand is the subtle
problem of the set type of relations. The section
([link boost_bimap.the_tutorial.the_set_of_relations_type The "set of relations" type])
explains this problem and how to create new types of bidirectional maps.

# The extended mapping framework allows to disable a view of a bimap, including the standard
mapping containers as a particular case. The section
[link boost_bimap.the_tutorial.unconstrained_sets Unconstrained Sets] explains how they work.

# In the section [link boost_bimap.the_tutorial.updating_a_bimap Updating a Bimap] we will
learn how to modify the elements of this container.

# The final section
([link boost_bimap.the_tutorial.complete_instantiation_scheme Complete Instantiation Scheme])
summarizes bimap instantiation and explains how change the allocator type to be used.

[endsect]

[section Discovering the new framework]

Relationships between data in the STL are represented by maps. A
`std::map` is a directed relation; by using it, you represent a mapping.
In this directed relation, `first_type` is related to `second_type` but it
is not true that the inverse relationship holds. This is useful in many
situations, but there are some relationships that are bidirectional by
nature, and it is more natural and, in many cases, more efficient in
terms of time and memory to represent the relationship as a
bidirectional mapping between the two collections of data. Boost.Bimap
enables this this kind of relation to be represented and provides a
ready-to-use arsenal. Its design is very influenced by the STL.

[h2 Standard mapping framework]

A `std::map` can be thought as a directed mapping between a set of keys
and an unconstrained collection of data values. The following diagram
shows the relationship represented and the user's viewpoint.

__STANDARD_MAPPING_FRAMEWORK__

This is not wrong, and it is a lot more efficient to use `std::maps` than bimaps if
you never have to observe the relationship from the other side.

__STD_PAIR__

The designer of the STL observed that this was a directed relationship
and named the data that it contains accordingly. A `std::pair` is a
directed relation between *x* and *y*; hence the names `first` for *x* and
`second` for *y* are natural. Note how the code looks.

    X x;
    Y y;

    std::pair
    <
        X, /* ----> */ Y

    > directed_relation(x,y);

    directed_relation.first;
    directed_relation.second;

Note that the type of the collection of X is a set because we have
chosen a `map` for the example, but the type of the collection on the left
can be different. The following table shows the equivalent types for the
std associative containers.

[table std associative containers
[[container         ][left set type     ][right set type]]
[[map               ][set               ][no constraints]]
[[multimap          ][multiset          ][no constraints]]
[[unordered_map     ][unordered_set     ][no constraints]]
[[unordered_multimap][unordered_multiset][no constraints]]
]

[h2 Extended mapping framework]

Boost.Bimap design is based on the STL, and extends the framework in a natural way.
The following diagram represents the new situation.

__EXTENDED_MAPPING_FRAMEWORK__

Notice that now the `std::maps` are a particular case of a Boost.Bimap
container, where you can view only one side of the relationship and can
control the constraints of only one of the collections. Boost.Bimap
allows the user to view the relationship from three viewpoints.
You can view it from one side, obtaining a `std::map` compatible
container, or you can work directly with the whole relation. The one
remaining task is to find a way to represent this new framework in C++
code so it is easy to read it and to remember how to write it. The first
thing is to get rid of the std::pair representing the data contained by
the bimap. The two collections are then at the same level, so it is
incorrect to name them as `first`/`second` or `a`/`b`. These names clearly
impose an ordering on the two values.

The solution is to view *x* as the `left` member and *y* as the `right` one. The
`left`-`right` naming puts the two values on the same level and allows us to
refer to the view easily. We can now say: "The map indexed by the left
member", and the meaning is very clear.

__RELATION__

The new type will be called `relation`. It will have two members: one
called `left` and the other `right`. The code now looks as follows:

    X x;
    Y y;

    boost::relation
    <
        X, /* <---> */ Y

    > relation(x,y);

    relation.left; relation.right;


[endsect]

[section Controlling set types]

As has already been said, in STL maps, you can only control the
constraints from one of the collections, namely the one that you are
viewing.

__EXTENDED_MAPPING_FRAMEWORK__

In Boost.Bimap, you can control both and it is as easy as using the STL.
The idea is to use the same constraint names that are used in the
standard. If you don't specify the collection type, Boost.Bimap assumes
that the collection is a set. The instantiation of a bimap with custom
set types looks like this:

    typedef bimap< ``*SetType*``_of<A>, ``*SetType*``_of<B> > bm_type;

The following is the list of all supported set types.

[table Set of Key Types
[[name                   ][Features          ][map view type            ]]
[[`set_of`               ][['ordered, unique]][`map`                    ]]
[[`multiset_of`          ][['ordered        ]][`multimap`               ]]
[[`unordered_set_of`     ][['hashed, unique ]][`unordered_map`          ]]
[[`unordered_multiset_of`][['hashed         ]][`unordered_multimap`     ]]
[[`list_of`              ][['sequenced      ]][`list_map`               ]]
[[`vector_of`            ][['random access  ]][`vector_map`             ]]
[[`unconstrained_set_of` ][['unconstrained  ]][['can not be viewed]     ]]
]

`list_of` and `vector_of` map views are not associated with any existing STL
associative containers. They are two examples of unsorted associative
containers. `unconstrained_set_of` allow the user to ignore a view. This
will be explained later.

__BIMAP_STRUCTURES__

The selection of the set type affects the possible operations that you
can perform with each side of the bimap and the time it takes to do
each. If we have:

    typedef bimap< ``*SetType*``_of<A>, ``*SetType*``_of<B> > bm_type;
    bm_type bm;

The following now describes the resulting map views of the bidirectional
map.

* `bm.left` is signature-compatible with *LeftMapType*`<A,B>`
* `bm.right` is signature-compatible with *RightMapType*`<B,A>`

[h2 Configuration parameters]

Each set type template has different parameters to control its
behaviour. For example, in `set_of` specification, you can pass a Functor
type that compares two types. All of these parameters are exactly the
same as those of the standard library container, except for the
allocator type. You will learn later how to change the allocator for a
bimap.

The following table lists the meanings of each set type's parameters.

[table
[[name                     ][Additional Parameters]]

[[`set_of<T,KeyComp>`\n
  `multiset_of<T,KeyComp>` ]
[[*KeyComp ] is a Functor that compares two types using a less-than operator.
By default, this is `std::less<T>`. ]]

[[`unordered_set_of<T,HashFunctor,EqualKey>`\n
  `unordered_multiset_of<T,HashFunctor,EqualKey>`]
[[*HashFunctor ] converts a `T` object into an integer value. By default it is `boost::hash<T>`.\n
 [*EqualKey ] is a Functor that tests two types for equality. By default, the
equality operator is `std::equal_to<T>`. ]]
[[`list_of<T>`              ][No additional parameters.]]
[[`vector_of<T>`            ][No additional parameters.]]
[[`unconstrained_set_of<T>` ][No additional parameters.]]
]


[endsect]

[section Tagging]

The code produced in this fashion tends to be obscure and error-prone.
The bimap family lets you tag your types so they can be accessed by a
more descriptive name. This produces more readable code.

__TAGGED__

A tagged type is a type that has been labelled using a tag. A tag is any
valid C++ type. In a bimap, the types are always tagged. If you do not
specify your own tag, the container uses `member_at::left` and
`member_at::right` to tag the left and right sides respectively. In order
to specify a custom tag, the set type specification of each side has to
be tagged. Tagging a type is very simple:

    typedef tagged< int, a_tag > tagged_int;

For example, if you want to use the tag `id` and `name` a bimap from a set
of ids to a multiset of names such as this one:

    typedef bimap
    <
        int,
        multiset_of<string>

    > People;

    People people;

    // ...

    people.left[28928546] = "Gray Simpson";

    people.right.insert( People::right_value_type("Marta Smith",30215692) );

    cout << (*people.begin()).left;

you can rewrite it as:

    struct id   {}; // Tag for the identification number
    struct name {}; // Tag for the name of the person

    typedef bimap
    <
        tagged< int                , id   >,
        tagged< multiset_of<string>, name >

    > People;

    People people;

    // ...

    map_by<id>(people)[28928546] = "Gray Simpson";

    map_by<name>(people).insert( value_type_by<name,People>("Marta Smith",30215692) );

    cout << get<id>(*people.begin());


Here are the functions and metafunctions you can use with tags. In each,
the tag parameter can be either a user-defined tag or `member_at::{side}`,
even when there is no user-defined tag. This allows you to use this
function in non-tagged bimaps, and then be able to tag them later
without changing the code.

\n\n
[h2 For a bimap]

[variablelist Metafunctions
[[value_type_by][
Metafunction to obtain the value type of one of the sides in a bimap.
``
    template< class Tag, class Bimap >
    struct value_type_by
    {
        typedef typename Bimap::{side}_value_type type;
    };
``
]]
[[key_type_of][
Metafunction to obtain the key type of one of the sides in a bimap.
``
    template< class Tag, class Bimap >
    struct key_type_of
    {
        typedef typename Bimap::{side}_key_type type;
    };
``
]]
[[data_type_of][
Metafunction to obtain the data type of one of the sides in a bimap.
``
    template< class Tag, class Bimap >
    struct data_type_of
    {
        typedef typename Bimap::{side}_data_type type;
    };
``
]]
[[iterator_type_by][
Metafunction to obtain the iterator type of the map view by one of the sides.
``
    template< class Tag, class Bimap >
    struct iterator_type_by
    {
        typedef typename Bimap::{side}_iterator type;
    };

    template< class Tag, class Bimap >
    struct const_iterator_type_by
    {
        typedef typename Bimap::{side}_iterator type;
    };

    // The following metafunctions are valid only if the selected views
    // support these types of iteration.

    template< class Tag, class Bimap >
    struct reverse_iterator_type_by
    {
        typedef -unspecified- type;
    };

    template< class Tag, class Bimap >
    struct const_reverse_iterator_type_by
    {
        typedef -unspecified- type;
    };

    template< class Tag, class Bimap >
    struct local_iterator_type_by
    {
        typedef -unspecified- type;
    };

    template< class Tag, class Bimap >
    struct const_local_iterator_type_by
    {
        typedef -unspecified- type;
    };
``
]]
]
\n

[variablelist Functions

[[map_by][
Gets a map view of a bimap.
``
    template<class Tag, class Relation>
    result_of::map_by< Tag, Bimap>::type map_by(Bimap &);
``
]]

]
\n\n
[h2 For a Relation]

[variablelist metafunctions

[[value_type_of][
Metafunction to obtain the value type of one of the sides.
``
    template< class Tag, class Relation >
    struct value_type_of
    {
        typedef typename Relation::{side}_type type;
    };
``
]]
[[ pair_type_by][
Metafunction to obtain the view type indexed by one of the sides.
``
    template< class Tag, class Relation >
    struct pair_type_by
    {
        typedef {compatible with std::pair} type;
    };
``
]]
]
\n

[variablelist Functions
[[get][
Gets the value of one of the members in a symmetrical class.
``
    template<class Tag, class Relation>
    result_of::get< Tag, Relation>::type get(Relation &r);
``
]]
[[pair_by][
Gets a pair view of a relation.
``
    template<class Tag, class Relation>
    result_of::pair_by< Tag, Relation>::type pair_by(Relation &);
``
]]
]

[endsect]

[section The set of relations type]

Being able to change the set type of the bimap relation view is another
very important feature.

In general, Boost.Bimap users will base the set type of a relation on
the type of the set on one of the two sides. There are times however
where it is useful to give this set other constraints or simply to order
it differently. By default, Boost.Bimap will base the set type of the
relation on the type of the left set, but the user is allowed to choose
between:

* left_based
* right_based
* set_of_relation<>
* multiset_of_relation<>
* unordered_set_of_relation<>
* unordered_multiset_of_relation<>
* list_of_relation
* vector_of_relation
* unconstrained_set_of_relation

[tip
The first two options and the last produce faster bimaps, so prefer
these where possible.
]

The set type of relation can be used to create powerful containers. For
example, if you need to maximize search speed, then the best
bidirectional map possible is one that relates elements from an
`unordered_set` to another `unordered_set`. The problem is that this
container cannot be iterated. If you need to know the list of relations
inside the container, you need another set type of relation. In this
case, a `list_of_relation` is a good choice. The resulting container
trades insertion and deletion time against fast search capabilities and
the possibility of bidirectional iteration.

    #include <iostream>
    #include <string>
    #include <boost/bimap/bimap.hpp>
    #include <boost/bimap/list_of.hpp>
    #include <boost/bimap/unordered_set_of.hpp>

    struct english {};
    struct spanish {};

    int main()
    {
        using namespace boost::bimap;

        typedef bimap
        <
            tagged< unordered_set_of< std::string >, spanish >,
            tagged< unordered_set_of< std::string >, english >
            list_of_relation

        > translator_bimap;

        typedef translator_bimap::relation translation;
        translator_bimap translator;
        translator.insert( translation("hola"  ,"hello"   ) );
        translator.insert( translation("adios" ,"goodbye" ) );
        translator.insert( translation("rosa"  ,"rose"    ) );
        translator.insert( translation("mesa"  ,"table"   ) );

        std::cout << "enter a word" << std::endl;
        std::string word;
        std::getline(std::cin,word);

        // Search the queried word on the from index (Spanish) */

        iterator_type_by<spanish,translator_bimap>::type is = map_by<spanish>(d).find(word);

        if( is != map_by<spanish>(d).end() )
        {
            std::cout << word << " is said " << get<english>(*is) << " in English" << std::endl;
        }
        else
        {
            // Word not found in Spanish, try our luck in English

            iterator_type_by<english,translator_bimap>::type ie = map_by<english>(d).find(word);
            if( ie != map_by<english>(d).end() )
            {
                std::cout << word << " is said " << get<spanish>(*ie) << " in Spanish" << std::endl;
            }
            else
            {
                // Word not found, show the possible translations

                std::cout << "No such word in the dictionary" << std::endl;
                std::cout << "These are the possible translations" << std::endl;
                for( translator_bimap::iterator i = translator.begin(), i_end = translator.end();
                     i != i_end ; ++i )
                {
                    std::cout << get<spanish>(*i) << " <---> " << get<english>(*i) << std::endl;
                }
            }
        }
        return 0;
    }


[h2 Configuration parameters]

Each set type of relation has different parameters to control its
behaviour. For example, in the `set_of_relation` specification, you can
pass a Functor type that compares two types. All of the parameters are
exactly the as in the standard library container, except for the type,
which is set to the bimap relation and the allocator type. To help users
in the creation of each functor, the set type of relation templates
takes an mpl lambda expression where the relation type will be evaluated
later. A placeholder named `_relation` is available to bimap users.

The following table lists the meaning of the parameters for each set type.

[table
[[name                     ][Additional Parameters]]

[[`left_based`                        ][Not a template.]]
[[`right_based`                       ][Not a template.]]
[[`set_of_relation<KeyComp>`\n
  `multiset_of_relation<KeyComp>` ]
[[*KeyComp ] is a Functor that compares two types using less than. By
default, the less-than operator is `std::less<_relation>`. ]]

[[`unordered_set_of_relation<HashFunctor,EqualKey>`\n
  `unordered_multiset_of_relation<HashFunctor,EqualKey>`]
[[*HashFunctor ] converts the `relation` into an integer value. By default it is `boost::hash<_relation>`.\n
 [*EqualKey ] is a Functor that tests two relations for equality. By default,
the equality operator is `std::equal_to<_relation>`. ]]
[[`list_of_relation`                  ][Not a template.]]
[[`vector_of_relation`                ][Not a template.]]
[[`unconstrained_set_of_relation`     ][Not a template.]]

]

[endsect]

[section Unconstrained Sets]

Unconstrained sets allow the user to disable one of the views of a
bimap. Doing so makes the bimap operations execute faster and reduces
memory consumption. This completes the bidirectional mapping framework
by including unidirectional mappings as a particular case.

For example, the following code creates a type that is similar to a regular
`std::map`.

    typedef bimap< int, unconstrained_set_of< string > > bm_type;

    bm_type b;
    b.left[1] = "one";
    b.left[2] = "two";

Unconstrained sets are useful for the following reasons:

* A bimap type has stronger guarantees than its standard equivalent,
and includes some useful functions (replace, modify) that the standard
does not have.
* You can view the mapping from above as a set of relations.
* Using this kind of map makes the code very extensible. If, at any
moment of the development, the need to perform searches from the right
side of the mapping arises, the only necessary change is to the `typedef`.

[endsect]

[section Updating a Bimap]

[h2 iterator::value_type]

The relations stored in the Bimap will not be in most cases modifiable
directly by iterators because both sides are used as keys of
['key-based] sets. When a `bimap<A,B>` left view iterator is dereferenced
the return type is ['signature-compatible] with a
`std::pair< const A, const B >`.
However there are some set types that are not ['key_based], for example
list_of. If a Bimap uses one of these set types there is no problem with
modifying the data of that side. The following code is valid:

    typedef bimap< int, list_of< std::string > > bm_type;
    bm_type bm;
    bm.insert( bm_type::relation( 1, "one" ) );
    ...
    bm.left.find(1)->second = "1";

In this case, when the iterator is dereferenced the return type is
['signature-compatible] with a `std::pair<const int, std::string>`.

The following table shows the constness of the dereferenced data of each
set type of:

[table
[[Set type of            ][Dereferenced data]]
[[`set_of`               ][['constant]]]
[[`multiset_of`          ][['constant]]]
[[`unordered_set_of`     ][['constant]]]
[[`unordered_multiset_of`][['constant]]]
[[`list_of`              ][['mutable] ]]
[[`vector_of`            ][['mutable] ]]
[[`unconstrained_set_of` ][['mutable] ]]
]

Here are some examples. When dereferenced the iterators returns a type that
is ['signature-compatible] with these types.

[table
[[Bimap type   ][Signature-compatible types]]
[[`bimap<A,B>`][
    `iterator      ` *->* `relation<const A,const B>`\n
    `left_iterator ` *->* `pair<const A,const B>`\n
    `right_iterator` *->* `pair<const B,const A>`
]]
[[`bimap<multiset_of<A>,unordered_set_of<B> >`][
    `iterator      ` *->* `relation<const A,const B>`\n
    `left_iterator ` *->* `pair<const A,const B>`\n
    `right_iterator` *->* `pair<const B,const A>`
]]
[[`bimap<set_of<A>,list_of<B> >`][
    `iterator      ` *->* `relation<const A,B>`\n
    `left_iterator ` *->* `pair<const A,B>`\n
    `right_iterator` *->* `pair<B,const A>`
]]
[[`bimap<vector_of<A>,set_of<B> >`][
    `iterator      ` *->* `relation<A,const B>`\n
    `left_iterator ` *->* `pair<A,const B>`\n
    `right_iterator` *->* `pair<const B,A>`
]]
[[`bimap<list_of<A>,unconstrained_set_of<B> >`][
    `iterator      ` *->* `relation<A,B>`\n
    `left_iterator ` *->* `pair<A,B>`\n
    `right_iterator` *->* `pair<B,A>`
]]
]

[h2 `operator[]`]

`set_of` and `unordered_set_of` views overload `operator[]` to retrieve the 
associated data of a given key.
The symmetry of bimap imposes some constraints on `operator[]` that are
not found in `std::map` or `std::unordered_map`. If other views are unique,
`bimap::duplicate_value` is thrown whenever an assignment is attempted to
a value that is already a key in these views. As for
`bimap::value_not_found`, this exception is thrown while trying to access
a non-existent key: this behaviour differs from the standard containers,
which automatically assigns a default value to non-existent keys referred to
by `operator[]`.

\n

    const data_type & operator[](const typename key_type & k) const;

[:  Returns the `data_type` reference that is associated with `k`, or
    throws `bimap::value_not_found` if such an element does not exist.\n
]
\n

    ``['-unspecified data_type proxy-]`` operator[](const typename key_type & k);

[:  Returns a proxy to a `data_type` associated with `k` and the
    bimap. The proxy behaves as a reference to the `data_type` object. If this
    proxy is read and `k` was not in the bimap, the bimap::value_not_found is
    thrown. If it is written then `bimap::duplicate_value` is thrown if the
    assignment is not allowed by one of the other views of the `bimap`.\n
]
\n

The following example shows the behaviour of `operator[]`

    bimap<int,std::string> bm;

    bm.left[1] = "one"; // Ok

    bm.right["two"] = 2; // Ok

    if( bm.left[3] == "three" ) // throws bimap::value_not_found
    {
        ...
    }

    bm.left[3] = "one"; // throws bimap::duplicate_value

\n

[h2 `modify` and `replace`]

These two functions are members of the views of a bimap that are not founded in 
their standard counterparts.

The `replace` member function performs in-place replacement of a given element as
the following example shows:

    typedef bimap< int, std::string > bm_type;
    bm_type bm;
    bm[1] = "one";
    bm[2] = "two";
    ...
    bm_type::right_iterator it = bm.right.find("two");

    bm_type::right_value_type v = *it;
    v.first = "2";

    bm_type.right.replace( it, v );

replace performs this substitution in such a manner that:

* The complexity is constant time if the changed element retains its original order
with respect to all views; it is logarithmic otherwise.
* Iterator and reference validity are preserved.
* The operation is strongly exception-safe, i.e. the `bimap` remains unchanged if 
some exception (originated by the system or the user's data types) is thrown.

`replace` is a powerful operation not provided by standard STL containers, and one that
is specially handy when strong exception-safety is required.

The observant reader might have noticed that the convenience of replace comes at a
cost: namely the whole element has to be copied ['twice] to do the updating (when
retrieving it and inside `replace`). If elements are expensive to copy, this may
be quite a computational cost for the modification of just a tiny part of the
object. To cope with this situation, Boost.Bimap provides an alternative
updating mechanism called `modify`.

`modify` accepts a functor (or pointer to function) taking two references to the each
data of the relation to be changed, thus eliminating the need for spurious copies. Like
`replace`, `modify` does preserve the internal orderings of all the indices of the
`bimap`. However, the semantics of modify is not entirely equivalent
to replace. Consider what happens if a collision occurs as a result of modifying
the element, i.e. the modified element clashes with another with respect to some
unique view. In the case of `replace`, the original value is kept and
the method returns without altering the container, but `modify` cannot afford such
an approach, since the modifying functor leaves no trace of the previous value
of the element. Integrity constraints thus lead to the following policy: when a
collision happens in the process of calling modify, the element is erased and
the method returns false. This difference in behavior between replace and `modify`
has to be considered by the programmer on a case-by-case basis.

Boost.Bimap defines new placeholders to allow a sounder solution. For
pairs, two new placeholders are instantiated: `_first` and `_second`, and
for a relation, two more complete the set: `_left` and `_right`.

    typedef bimap< int, std::string > bm_type;
    bm_type bm;
    bm[1] = "one";
    bm[2] = "two";
    ...
    bm_type::right_iterator it = bm.right.find("two");

    bm_type.right.modify( it , _first = "2" );

[endsect]

[section Complete instantiation scheme]

To summarize, this is the complete instantiation scheme.

    typedef bimap< LeftKeyType, RightKeyType [, SetTypeOfRelation ] [,Allocator] > bm;

`{Side}KeyType` can directly be a type. This defaults to
`set_of<{Side}KeyType>`, or can be a `{SetType}_of<Type>` specification.
Additionally, these two parameters can be tagged to specify other tags
instead of the usual `member_at::{Side}` tags. The last two parameters are
used to specify the set type of the relation and the allocator type.If
you want to specify a custom allocator type while relying on the default
value of SetTypeOfRelation, you can do so by simply writing
`bimap<LeftKeyType, RightKeyType, Allocator>`. Boost.Bimap's internal
machinery detects that the third parameter in this case does not refer
to the relation type but rather to an allocator.

The following are the possible ways of instantiating a bimap:

\n

    bimap<LeftKeyType,RightKeyType>

* set_of_relation_type: based on the left key type
* allocator:            default allocator

\n

    bimap<LeftKeyType,RightKeyType,Allocator>

* set_of_relation_type: based on the left key type
* allocator:            Allocator

\n

    bimap<LeftKeyType,RightKeyType,SetOfRelationType>

* set_of_relation_type: SetOfRelationType
* allocator:            default allocator

\n

    bimap<LeftKeyType,RightKeyType,SetOfRelationType,Allocator>

* set_of_relation_type: SetOfRelationType
* allocator:            Allocator


[endsect]



[endsect]
