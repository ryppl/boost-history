[/license

Boost.Bimap

Copyright (c) 2006 Matias Capeletto

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)

]

[/ QuickBook Document version 1.3 ]

[section vector_of Reference]

[section Header "boost/bimap/vector_of.hpp" synopsis]

    namespace boost {
    namespace bimap {


    template< class KeyType >
    struct vector_of;

    struct vector_of_relation;


    } // namespace bimap
    } // namespace boost


[endsect]

[section vector_of views]

vector_of views are free-order sequences with constant time positional
access and random access iterators. Elements in a vector_of view are by
default sorted according to their order of insertion: this means that new elements
inserted through a different view of the `bimap` are appended to
the end of the vector_of view; additionally, facilities are provided for
further rearrangement of the elements. The public interface of vector_of views
includes that of list_of views, with differences in the complexity
of the operations, plus extra operations for positional access
(`operator[]` and `at()`) and for capacity handling. Validity of iterators and
references to elements is preserved in all operations, regardless of the
capacity status.

As is the case with list_of views, vector_of views have the following
limitations with respect to STL sequence containers:

* vector_of views
are not __SGI_ASSIGNABLE__ (like any other view.)
* Insertions into a vector_of view may fail due to clashings with other views.
This alters the semantics of the operations provided with respect to their analogues
in STL sequence containers.
* Elements in a vector_of view are not mutable, and can only be changed by
means of replace and modify member functions.

Having these restrictions into account, vector of views are models of
__SGI_RANDOM_ACCESS_CONTAINER__ and __SGI_BACK_INSERTION_SEQUENCE__. Although these views
do not model __SGI_FRONT_INSERTION_SEQUENCE__, because front insertion and deletion
take linear time, front operations are nonetheless provided to match the interface
of list_of views. We only describe those types and operations that are either
not present in the concepts modeled or do not exactly conform to the requirements
for these types of containers.


    namespace boost {
    namespace bimap {
    namespace views {

    template< ``['-implementation defined parameter list-]`` >
    class ``['-implementation defined view name-]``
    {
        public:

        // types

        typedef ``['-unspecified-]`` value_type;
        typedef ``['-unspecified-]`` allocator_type;
        typedef ``['-unspecified-]`` reference;
        typedef ``['-unspecified-]`` const_reference;
        typedef ``['-unspecified-]`` iterator;
        typedef ``['-unspecified-]`` const_iterator;
        typedef ``['-unspecified-]`` size_type;
        typedef ``['-unspecified-]`` difference_type;
        typedef ``['-unspecified-]`` pointer;
        typedef ``['-unspecified-]`` const_pointer;
        typedef ``['-unspecified-]`` reverse_iterator;
        typedef ``['-unspecified-]`` const_reverse_iterator;

        // construct / copy / destroy

        this_type & operator=(this_type & x);

        template <class InputIterator>
        void assign(InputIterator first, InputIterator last);
        void assign(size_type n, const value_type & value);

        allocator_type get_allocator() const;

        // iterators

        iterator               begin();
        const_iterator         begin() const;
        iterator               end();
        const_iterator         end() const;
        reverse_iterator       rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator       rend();
        const_reverse_iterator rend() const;

        // capacity

        bool      empty() const;
        size_type size() const;
        size_type max_size() const;
        size_type capacity() const;
        void      reserve(size_type m);

        void resize(size_type n, const value_type & x = value_type());

        // access

        const_reference operator[](size_type n) const;
        const_reference at(size_type n) const;
        const_reference front() const;
        const_reference back() const;

        // modifiers

        std::pair<iterator,bool> push_front(const value_type & x);
        void                     pop_front();
        std::pair<iterator,bool> push_back(const value_type & x);
        void                     pop_back();

        std::pair<iterator,bool> insert(iterator position, const value_type & x);
        void insert(iterator position, size_type m, const value_type & x);
        template<typename InputIterator>
        void insert(iterator position, InputIterator first, InputIterator last);

        iterator erase(iterator position);
        iterator erase(iterator first, iterator last);

        bool replace(iterator position, const value_type & x);
        template<typename Modifier> bool modify(iterator position, Modifier mod);

        void clear();

        // list operations

        void splice(iterator position, this_type & x);
        void splice(iterator position, this_type & x, iterator i);
        void splice(
            iterator position, this_type & x, iterator first, iterator last);

        void remove(const value_type & value);
        template<typename Predicate> void remove_if(Predicate pred);

        void unique();
        template <class BinaryPredicate>
        void unique(BinaryPredicate binary_pred);

        void merge(this_type & x);
        template <typename Compare> void merge(this_type & x, Compare comp);

        void sort();
        template <typename Compare> void sort(Compare comp);

        void reverse();

        // rearrange operations

        void relocate(iterator position, iterator i); 
        void relocate(iterator position, iterator first, iterator last);
        template<typename InputIterator> void rearrange(InputIterator first);
    };

    // view comparison

    bool operator==(const this_type & v1, const this_type & v2 );
    bool operator< (const this_type & v1, const this_type & v2 );
    bool operator!=(const this_type & v1, const this_type & v2 );
    bool operator> (const this_type & v1, const this_type & v2 );
    bool operator>=(const this_type & v1, const this_type & v2 );
    bool operator<=(const this_type & v1, const this_type & v2 );

    } // namespace views
    } // namespace bimap
    } // namespace boost


[section Complexity signature]

Here and in the descriptions of operations of `vector_of` views, we adopt
the scheme outlined in the
[link complexity_signature_explanation complexity signature section].
The complexity signature of `vector_of` view is:

* copying: `c(n) = n * log(n)`,
* insertion: `i(n) = 1` (amortized constant),
* hinted insertion: `h(n) = 1` (amortized constant),
* deletion: `d(n) = m`, where m is the distance from the deleted element to the
end of the sequence,
* replacement: `r(n) = 1` (constant),
* modifying: `m(n) = 1` (constant).

The following expressions are also used as a convenience for writing down some
of the complexity formulas:

[blurb
`shl(a,b) = a+b` if a is nonzero, 0 otherwise.\n
`rel(a,b,c) =` if `a<b`, `c-a`, else `a-b`,\n
]

(`shl` and `rel` stand for ['shift left] and ['relocate], respectively.)

[endsect]

[section Instantiation types]

`vector_of` views are instantiated internally to `bimap` and specified
by means of the set type specifiers and the bimap itself.
Instantiations are dependent on the following types:

* `Value` from `vector_of`,
* `Allocator` from `bimap`,

[endsect]

[section Constructors, copy and assignment]

As explained in the views concepts section,
views do not have public constructors or destructors.
Assignment, on the other hand, is provided.

    this_type & operator=(const this_type & x);

[:  [*Effects:] `a=b;`\n
    where a and b are the `bimap` objects to which `*this` and
    `x` belong, respectively.\n
    [*Returns:] *this.
]
\n

    template <class InputIterator>
    void assign(InputIterator first, InputIterator last);

[:  [*Requires:] `InputIterator` is a model of __SGI_INPUT_ITERATOR__ over elements
    of type `value_type` or a type convertible to `value_type`. `first` and `last` are
    not iterators into any view of the `bimap` to which this
    view belongs. `last` is reachable from `first`.\n
    [*Effects:]\n
    `clear();`\n
    `insert(end(),first,last);`
]
\n

    void assign(size_type n, const value_type & value);

[:  [*Effects:]\n
    `clear();`\n
    `for(size_type i = 0; i < n; ++n) push_back(v);`
]
\n

[endsect]

[section Capacity operations]

    size_type capacity() const;

[:  [*Returns:] The total number of elements `c` such that, when `size() < c`,
    back insertions happen in constant time (the general case as described by
    i(n) is ['amortized] constant time.) \n
    [*Note:] Validity of iterators and references to elements is preserved
    in all insertions, regardless of the capacity status.
]
\n


    void reserve(size_type m);

[:  [*Effects:] If the previous value of `capacity()` was greater than or equal
    to `m`, nothing is done; otherwise, the internal capacity is changed so that
    `capacity()>=m`.\n
    [*Complexity:] If the capacity is not changed, constant; otherwise O(n).\n
    [*Exception safety:] If the capacity is not changed, nothrow; otherwise, strong.
]
\n

    void resize(size_type n, const value_type & x = value_type());

[:  [*Effects:]\n
    `if( n > size() ) insert(end(), n-size(), x);`\n
    `else if(n<size())erase(begin()+n,end());`\n
    [*Note:] If an expansion is requested, the size of the view is not guaranteed
    to be n after this operation (other views may ban insertions.)
]
\n

[endsect]

[section Modifiers]

    std::pair<iterator,bool> push_front(const value_type & x);

[:  [*Effects:] Inserts x at the beginning of the sequence if no other view
    of the `bimap` bans the insertion.\n
    [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only if
    insertion took place. On successful insertion, `p.first` points to the element
    inserted; otherwise, `p.first` points to an element that caused the insertion
    to be banned. Note that more than one element can be causing insertion not
    to be allowed.\n
    [*Complexity:] O(n+I(n)).\n
    [*Exception safety:] Strong.
]
\n

    std::pair<iterator,bool> push_back(const value_type & x);

[:  [*Effects:] Inserts `x` at the end of the sequence if no other view of
    the `bimap` bans the insertion.\n
    [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only
    if insertion took place. On successful insertion, `p.first` points to the
    element inserted; otherwise, `p.first` points to an element that caused
    the insertion to be banned. Note that more than one element can be
    causing insertion not to be allowed.\n
    [*Complexity:] O(I(n)).\n
    [*Exception safety:] Strong.
]
\n

    std::pair<iterator,bool> insert(iterator position, const value_type & x);

[:  [*Requires:] `position` is a valid iterator of the view.\n
    [*Effects:] Inserts `x` before position if insertion is allowed by all
    other views of the `bimap`.\n
    [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only
    if insertion took place. On successful insertion, `p.first` points to the
    element inserted; otherwise, `p.first` points to an element that caused the
    insertion to be banned. Note that more than one element can be causing
    insertion not to be allowed.\n
    [*Complexity:] O(shl(end()-position,1) + I(n)).\n
    [*Exception safety:] Strong.
]
\n

    void insert(iterator position, size_type m, const value_type & x);

[:  [*Requires:] `position` is a valid iterator of the view.\n
    [*Effects:] `for(size_type i = 0; i < m; ++i) insert(position, x);`\n
    [*Complexity:] O(shl(end()-position,m) + m*I(n+m)).
]
\n

    template<typename InputIterator>
    void insert(iterator position, InputIterator first, InputIterator last);

[:  [*Requires:] `position` is a valid iterator of the view. `InputIterator`
    is a model of __SGI_INPUT_ITERATOR__ over elements of type `value_type` or a type
    convertible to `value_type`. `first` and `last` are not iterators into any view
    of the `bimap` to which this view belongs. `last` is reachable
    from `first`.\n
    [*Effects:] `while(first!=last)insert(position,*first++);`\n
    [*Complexity:] O(shl(end()-position,m) + m*I(n+m)), where m is the number
    of elements in `[first,last)`.\n
    [*Exception safety:] Basic.
]
\n

    iterator erase(iterator position);

[:  [*Requires:] `position` is a valid dereferenceable iterator of the view.\n
    [*Effects:] Deletes the element pointed to by `position`.\n
    [*Returns:] An iterator pointing to the element immediately following the
    one that was deleted, or `end()` if no such element exists.\n
    [*Complexity:] O(D(n)).\n
    [*Exception safety:] nothrow.
]
\n

    iterator erase(iterator first, iterator last);

[:  [*Requires:] `[first,last)` is a valid range of the view.\n
    [*Effects:] Deletes the elements in `[first,last)`.\n
    [*Returns:] last.\n
    [*Complexity:] O(m*D(n)), where m is the number of elements in `[first,last)`.\n
    [*Exception safety:] nothrow.
]
\n

    bool replace(iterator position, const value_type & x);

[:  [*Requires:] `position` is a valid dereferenceable iterator of the view.\n
    [*Effects:] Assigns the value x to the element pointed to by position into
    the `bimap` to which the view belongs if replacing is allowed
    by all other views of the `bimap`.\n
    [*Postconditions:] Validity of position is preserved in all cases.\n
    [*Returns:] `true` if the replacement took place, `false` otherwise.\n
    [*Complexity:] O(R(n)).\n
    [*Exception safety:] Strong. If an exception is thrown by some user-provided
    operation the `bimap` to which the view belongs remains in its
    original state.
]
\n

    template<typename Modifier> bool modify(iterator position,Modifier mod);

[:  [*Requires:] `Modifier` is a model of __SGI_BINARY_FUNCTION__ accepting arguments of
    type:\n
    ['Map View:] `first_type&` and `second_type&`\n
    ['Set View:] `left_type&` and `right_type&`\n
    `position` is a valid dereferenceable iterator of the view.\n
    [*Effects:]\n
    ['Map View:] Calls `mod(e.first,e.second)`\n
    ['Set View:] Calls `mod(e.left,e.right)`\n
    where e is the element pointed to by `position` and
    rearranges `*position` into all the views of the `bimap`.
    Rearrangement on `vector_of` views does not change the position of the
    element with respect to the view; rearrangement on other views may or
    might not suceed. If the rearrangement fails, the element is erased.\n
    [*Postconditions:] Validity of `position` is preserved if the operation succeeds.\n
    [*Returns:] `true` if the operation succeeded, `false` otherwise.\n
    [*Complexity:] O(M(n)).\n
    [*Exception safety:] Basic. If an exception is thrown by some user-provided
    operation (except possibly `mod`), then the element pointed to by position
    is erased.
]
\n


[endsect]

[section List operations]

`vector_of` views replicate the interface of `list_of` views, which
in turn includes the list operations provided by `std::list`. The syntax and
behavior of these operations exactly matches those of `list_of` views, but
the associated complexity bounds differ in general.

    void splice(iterator position, this_type & x);

[:  [*Requires:] `position` is a valid iterator of the view. `&x!=this`.\n
    [*Effects:] Inserts the contents of `x` before position, in the same order
    as they were in `x`. Those elements successfully inserted are erased from `x`.\n
    [*Complexity:] O(shl(end()-position,x.size()) + x.size()*I(n+x.size()) + x.size()*D(x.size())).\n
    [*Exception safety:] Basic.
]
\n

    void splice(iterator position, this_type & x,iterator i);

[:  [*Requires:] `position` is a valid iterator of the view. `i` is a valid
    dereferenceable iterator `x`.\n
    [*Effects:] Inserts the element pointed to by `i` before `position`: if
    insertion is successful, the element is erased from `x`. In the special
    case `&x==this`, no copy or deletion is performed, and the operation is
    always successful. If `position==i`, no operation is performed.\n
    [*Postconditions:] If `&x==this`, no iterator or reference is invalidated.\n
    [*Complexity:] If `&x==this`, O(rel(position,i,i+1));
    otherwise O(shl(end()-position,1) + I(n) + D(n)).\n
    [*Exception safety:] If `&x==this`, nothrow; otherwise, strong.
]
\n

    void splice(iterator position, this_type & x, iterator first, iterator last);

[:  [*Requires:] `position` is a valid iterator of the view. `first` and
    `last` are valid iterators of `x`. `last` is reachable from `first`. `position` is
    not in the range `[first,last)`.\n
    [*Effects:] For each element in the range `[first,last)`, insertion is
    tried before `position`; if the operation is successful, the element is
    erased from `x`. In the special case `&x==this`, no copy or deletion is
    performed, and insertions are always successful.\n
    [*Postconditions:] If `&x==this`, no iterator or reference is invalidated.\n
    [*Complexity:] If `&x==this`, O(rel(position,first,last));
    otherwise O(shl(end()-position,m) + m*I(n+m) + m*D(x.size()))
    where m is the number of elements in `[first,last)`.\n
    [*Exception safety:] If `&x==this`, nothrow; otherwise, basic.
]
\n

    void remove(const value_type & value);

[:  [*Effects:] Erases all elements of the view which compare equal to `value`.\n
    [*Complexity:] O(n + m*D(n)), where m is the number of elements erased.\n
    [*Exception safety:] Basic.
]
\n

    template<typename Predicate> void remove_if(Predicate pred);

[:  [*Effects:] Erases all elements `x` of the view for which `pred(x)` holds.\n
    [*Complexity:] O(n + m*D(n)), where m is the number of elements erased.\n
    [*Exception safety:] Basic.
]
\n

    void unique();

[:  [*Effects:] Eliminates all but the first element from every consecutive
    group of equal elements referred to by the iterator `i` in the range
    `[first+1,last)` for which `*i==*(i-1)`.\n
    [*Complexity:] O(n + m*D(n)), where m is the number of elements erased.\n
    [*Exception safety:] Basic.
]
\n

    template <class BinaryPredicate> void unique(BinaryPredicate binary_pred); 

[:  [*Effects:] Eliminates all but the first element from every consecutive
    group of elements referred to by the iterator i in the range `[first+1,last)`
    for which `binary_pred(*i, *(i-1))` holds.\n
    [*Complexity:] O(n + m*D(n)), where m is the number of elements erased.\n
    [*Exception safety:] Basic.
]
\n

    void merge(this_type & x);

[:  [*Requires:] `std::less<value_type>` is a __SGI_STRICT_WEAK_ORDERING__ over
    `value_type`. Both the view and `x` are sorted according to `std::less<value_type>`.\n
    [*Effects:] Attempts to insert every element of x into the corresponding
    position of the view (according to the order). Elements successfully
    inserted are erased from `x`. The resulting sequence is stable, i.e. equivalent
    elements of either container preserve their relative position. In the special
    case `&x==this`, no operation is performed.\n
    [*Postconditions:] Elements in the view and remaining elements in `x` are
    sorted. Validity of iterators to the view and of non-erased elements of `x`
    references is preserved.\n
    [*Complexity:] If `&x==this`, constant;
    otherwise O(n + x.size()*I(n+x.size()) + x.size()*D(x.size())).\n
    [*Exception safety:] If `&x==this`, nothrow; otherwise, basic.
]
\n

    template <typename Compare> void merge(this_type & x, Compare comp);

[:  [*Requires:] `Compare` is a __SGI_STRICT_WEAK_ORDERING__ over `value_type`.
    Both the view and `x` are sorted according to comp.\n
    [*Effects:] Attempts to insert every element of `x` into the corresponding
    position of the view (according to `comp`). Elements successfully inserted
    are erased from `x`. The resulting sequence is stable, i.e. equivalent
    elements of either container preserve their relative position. In the
    special case `&x==this`, no operation is performed.\n
    [*Postconditions:] Elements in the view and remaining elements in `x` are
    sorted according to `comp`. Validity of iterators to the view and of
    non-erased elements of `x` references is preserved.\n
    [*Complexity:] If `&x==this`, constant;
    otherwise O(n + x.size()*I(n+x.size()) + x.size()*D(x.size())).\n
    [*Exception safety:] If `&x==this`, nothrow; otherwise, basic.
]
\n

    void sort();

[:  [*Requires:] `std::less<value_type>` is a __SGI_STRICT_WEAK_ORDERING__ over `value_type`.\n
    [*Effects:] Sorts the view according to `std::less<value_type>`.
    The sorting is stable, i.e. equivalent elements preserve their relative position.\n
    [*Postconditions:] Validity of iterators and references is preserved.\n
    [*Complexity:] O(n*log(n)).\n
    [*Exception safety:] Basic.
]
\n

    template <typename Compare> void sort(Compare comp);

[:  [*Requires:] Compare is a __SGI_STRICT_WEAK_ORDERING__ over `value_type`.\n
    [*Effects:] Sorts the view according to `comp`. The sorting is stable, i.e.
    equivalent elements preserve their relative position.\n
    [*Postconditions:] Validity of iterators and references is preserved.\n
    [*Complexity:] O(n*log(n)).\n
    [*Exception safety:] Basic.
]
\n

    void reverse(); 

[:  [*Effects:] Reverses the order of the elements in the view.\n
    [*Postconditions:] Validity of iterators and references is preserved.\n
    [*Complexity:] O(n).\n
    [*Exception safety:] nothrow.
]
\n

[endsect]


[section Serialization]

Views cannot be serialized on their own, but only as part of the `bimap`
into which they are embedded. In describing the additional preconditions and guarantees
associated to `vector_of` views with respect to serialization of their embedding
containers, we use the concepts defined in the `bimap` serialization section.

[blurb [*Operation:] saving of a `bimap` b to an output archive (XML archive) ar.]
[:  [*Requires:] No additional requirements to those imposed by the container.
]
\n

[blurb [*Operation:] loading of a `bimap` b' from an input archive (XML archive) ar.]
[:  [*Requires:] No additional requirements to those imposed by the container.\n
    [*Postconditions:] On successful loading, each of the elements of `[begin(), end())` is a
    restored copy of the corresponding element in `[m.get<i>().begin(), m.get<i>().end())`,
    where `i` is the position of the `vector_of` view in the container.
]
\n

[blurb [*Operation:] saving of an `iterator` or `const_iterator` `it` to an output archive (XML archive) ar.]
[:  [*Requires:] it is a valid iterator of the view. The associated `bimap`
has been previously saved.
]
\n

[blurb [*Operation:] loading of an `iterator` or `const_iterator` `it`' from an input archive (XML archive) ar.]
[:  [*Postconditions:] On successful loading, if it was dereferenceable then `*it`' is the
    restored copy of `*it`, otherwise `it`'`==end()`.\n
    [*Note:] It is allowed that it be a `const_iterator` and the restored `it`' an `iterator`,
    or viceversa.
]

[endsect]
[endsect]


[endsect]