[/license

    Boost.Bimap
    Matias Capeletto 2006
    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
]

[/ QuickBook Document version 1.3 ]

[section Bimap Reference]

[section Views concepts]

`bimap` instantiations comprise two side views and an view of the relation
specified at compile time. Each view allows read/write access to the elements contained
in a definite manner, mathing a STL container signature.

Views are not isolated objects, and so cannot be constructed on their own.
Rather they are an integral part of a `bimap`. The name of the view class
implementation proper is never directly exposed to the user, who has only access to
the associated view type specifier.

Insertion and erasing of elements are always performed through the appropriate
interface of any of the three views of the `bimap`; these operations, however,
do have an impact on all other views as well: for instance, insertion through
a given view may fail because there exists another view which bans the operation
in order to preserve its invariant (like uniqueness of elements.) The global
operations performed in a joint manner among the any view can be reduced to six
primitives:

* Copying
* insertion of an element
* hinted insertion, where a preexisting element is suggested in order to improve
the efficiency of the operation
* deletion of an element
* replacement of the value of an element, which may trigger the rearrangement of
this element in one or more views, or the banning of the replacement
* modification of an element, and its subsequent rearrangement/banning by the
various views

The last two primitives deserve some further explanation: in order to
guarantee the invariants associated to each view (e.g. some definite ordering,)
elements of a `bimap` are not mutable. To overcome this restriction, the views
expose member functions for updating and modifying, which allow for the
mutation of elements in a controlled fashion.

[endsect]

[#complexity_signature_explanation] 

[section Complexity signature]

Some member functions of a view interface are implemented by global primitives
from the list above. Complexity of these operations thus depends on all views
of a given `bimap`, not just the currently used view.

In order to establish complexity estimates, a view is characterized by its
complexity signature, consisting of the following associated functions on the
number of elements:

* `c(n)`: copying
* `i(n)`: insertion
* `h(n)`: hinted insertion
* `d(n)`: deletion
* `r(n)`: replacement
* `m(n)`: modifying

Each function yields the complexity estimate of the contribution of the view
to the corresponding global primitive. Let us consider an instantiation of
`bimap`. If the set type of the relation is left_based or right_based, and
we use an `l` subscript to denote the left view and a `r` for the right view
then the insertion of an element in such a container is then of complexity
O(i_l(n)+i_r(n)) where n is the number of elements. If the set type of
relation is not side based then there is an additional term to sum that is
aported by the set of relation view. Using 'a' to denote the above view, now
the order of insertion will be O(i_l(n)+i_r(n)+i_a(n)).
To abbreviate notation, we adopt the following definitions:

* `C(n) = c_l(n) + c_r(n) [ + c_a(n) ]`
* `I(n) = i_l(n) + i_r(n) [ + i_a(n) ]`
* `H(n) = h_l(n) + h_r(n) [ + h_a(n) ]`
* `D(n) = d_l(n) + d_r(n) [ + d_a(n) ]`
* `R(n) = r_l(n) + r_r(n) [ + r_a(n) ]`
* `M(n) = m_l(n) + m_r(n) [ + m_a(n) ]`

[endsect]

[section Set type specification]

Set type specifiers are passed as instantiation arguments to `bimap`
and provide the information needed to incorporate the corresponding views.
Currently, Boost.Bimap provides the set type specifiers
The ['side set type] specifiers defines the constraints of the two map
views of the bimap. The ['set type of relation] specifiers defines the main
set view constraints.
If `left_based` (the default parameter) or `right_based` is used, then the
['set type of relation] will be based on the left or right set type
correspondingly.

[table
[[Side set type             ][Set type of relation            ][Include                                 ]]
[[`set_of`                  ][`set_of_relation`               ][`boost/bimap/set_of.hpp`                ]]
[[`multiset_of`             ][`multiset_of_relation`          ][`boost/bimap/multiset_of.hpp`           ]]
[[`unordered_set_of`        ][`unordered_set_of_relation`     ][`boost/bimap/unordered_set_of.hpp`      ]]
[[`unordered_multiset_of`   ][`unordered_multiset_of_relation`][`boost/bimap/unordered_multiset_of.hpp` ]]
[[`list_of`                 ][`list_of_relation`              ][`boost/bimap/list_of.hpp`               ]]
[[`vector_of`               ][`vector_of_relation`            ][`boost/bimap/vector_of.hpp`             ]]
[[                          ][`left_based`                    ][`boost/bimap/bimap.hpp`                 ]]
[[                          ][`right_based`                   ][`boost/bimap/bimap.hpp`                 ]]
]

[endsect]

[section Tags]

Tags are just conventional types used as mnemonics for the types stored in a
`bimap`. Boost.Bimap uses the tagged idiom to let the user specified this tags.

[endsect]

[section Header "boost/bimap/bimap.hpp" synopsis]

    namespace boost {
    namespace bimap {

    template< class Type, typename Tag >
    struct tagged;

    // Metafunctions for a bimap

    template< class Tag, class Bimap > struct value_type_by;
    template< class Tag, class Bimap > struct key_type_of;
    template< class Tag, class Bimap > struct data_type_of;
    template< class Tag, class Bimap > struct iterator_type_by;
    template< class Tag, class Bimap > struct const_iterator_type_by;
    template< class Tag, class Bimap > struct reverse_iterator_type_by;
    template< class Tag, class Bimap > struct const_reverse_iterator_type_by;
    template< class Tag, class Bimap > struct local_iterator_type_by;
    template< class Tag, class Bimap > struct const_local_iterator_type_by;

    // Functions for a bimap

    template<class Tag, class Relation>
    result_of::map_by< Tag, Bimap>::type map_by(Bimap &);

    // Metafunctions for a relation

    template< class Tag, class Relation > struct value_type_of;
    template< class Tag, class Relation > struct pair_type_by;

    // Functions for a relation

    template<class Tag, class Relation>
    result_of::get< Tag, Relation>::type get(Relation &r);

    template<class Tag, class Relation>
    result_of::pair_by< Tag, Relation>::type pair_by(Relation &);

    // exceptions

    class duplicate_value;
    class value_not_found;

    // bimap template class

    template
    <
        class LeftSetType, class RightSetType,

        class AdditionalParameter_1 = detail::not_specified,
        class AdditionalParameter_2 = detail::not_specified
    >
    class bimap ``['- implementation defined { : public SetView } -]``
    {

        public:

        typedef ``['-unspecified-]`` left_tag;
        typedef ``['-unspecified-]`` left_data_type;
        typedef ``['-unspecified-]`` left_value_type;
        typedef ``['-unspecified-]`` left_key_type;
        typedef ``['-unspecified-]`` left_iterator;
        typedef ``['-unspecified-]`` left_const_iterator;
        typedef ``['-unspecified-]`` left_reverse_iterator;
        typedef ``['-unspecified-]`` left_const_reverse_iterator;
        typedef ``['-unspecified-]`` left_set_type;
        typedef ``['-unspecified-]`` left_map_type;

        typedef ``['-unspecified-]`` right_tag;
        typedef ``['-unspecified-]`` right_data_type;
        typedef ``['-unspecified-]`` right_value_type;
        typedef ``['-unspecified-]`` right_key_type;
        typedef ``['-unspecified-]`` right_iterator;
        typedef ``['-unspecified-]`` right_const_iterator;
        typedef ``['-unspecified-]`` right_reverse_iterator;
        typedef ``['-unspecified-]`` right_const_reverse_iterator;
        typedef ``['-unspecified-]`` right_set_type;
        typedef ``['-unspecified-]`` right_map_type;

        typedef ``['-unspecified-]`` relation_set_type_of;
        typedef ``['-unspecified-]`` relation_set;

         left_map_type  left;
        right_map_type right;

        bimap();

        template< class InputIterator >
        bimap(InputIterator first,InputIterator last);

    };


    } // namespace bimap
    } // namespace boost

[endsect]

[section Class template bimap]

This is the main component of Boost.Bimap.

[section Complexity]

In the descriptions of operations of `bimap`, we adopt the scheme
outlined in the complexity signature section.

[endsect]

[section Instantiation types]

`bimap` is instantiated with the following types:

# LeftSetType and RightSetType are set types specification optionally tagged, or any type optional
tagged, in which case that side act as a set.
# AdditionalParameter_{1/2} can be any ordered subset of:
    * SetTypeOfRelation specification
    * Allocator

[endsect]

[section Nested types]

    left_tag, right_tag

[:  Tags for each side of the bimap. If the user has not specified any tag the
    tags default to `member_at::left` and `member_at::right`.
]
\n

    left_key_type, right_key_type

[:  Key type of each side. In a `bimap<A,B> ` `left_key_type` is `A` and
    `right_key_type` is `B`.\n
    If there are tags, it is better to use: `key_type_of<Tag,Bimap>::type`.
]
\n


    left_data_type, right_data_type

[:  Data type of each side. In a bimap<A,B> left_key_type is B and
    right_key_type is A.\n
    If there are tags, it is better to use: `data_type_of<Tag,Bimap>::type`.
]
\n


    left_value_type, right_value_type

[:  Value type used for the views.\n
    If there are tags, it is better to use: `value_type_by<Tag,Bimap>::type`.
]
\n


    left_iterator, right_iterator
    left_const_iterator, right_const_iterator

[:  Iterators of the views.\n
    If there are tags, it is better to use:
    `iterator_type_by<Tag,Bimap>::type` and
    `const_iterator_type_by<Tag,Bimap>::type`.
]
\n


    left_set_type, right_set_type

[:  Set type of specification of each side.
]
\n


    left_map_type, right_map_type

[:  Map view type of each side.
    If there are tags, it is better to use:
    `map_type_by<Tag,Bimap>::type`.
]
\n


    relation_set_type_of

[:  Set type of relation specification.
]
\n


    relation_set

[:  Set view type of the relation.
]
\n

[endsect]

[section Constructors, copy and assignment]

    bimap();

[:  [*Effects:] Constructs an empty `bimap`.\n
    [*Complexity:] Constant.
]
\n

    template<typename InputIterator>
    bimap(InputIterator first,InputIterator last);

[:  [*Requires:] `InputIterator` is a model of Input Iterator over elements of
    type `relation` or a type convertible to `relation`. last is reachable from `first`.\n
    [*Effects:] Constructs and empty `bimap` and fills it with the elements in the range
    `[first,last)`. Insertion of each element may or may not succeed depending on
    the acceptance by the set types of the `bimap`.\n
    [*Complexity:] O(m*H(m)), where m is the number of elements in `[first,last)`.
]
\n

    bimap(const bimap & x);

[:  [*Effects:] Constructs a copy of x, copying its elements as well as its
    internal objects (key extractors, comparison objects, allocator.)\n
    [*Postconditions:] `*this == x`. The order on the views of the `bimap`
    is preserved as well.\n
    [*Complexity:] O(x.size()*log(x.size()) + C(x.size())).
]
\n

    ~bimap()

[:  [*Effects:] Destroys the `bimap` and all the elements contained.
    The order in which the elements are destroyed is not specified.\n
    [*Complexity:] O(n).
]
\n

    bimap& operator=(const bimap& x);

[:  [*Effects:] Replaces the elements and internal objects of the `bimap`
    with copies from x.\n
    [*Postconditions:] `*this==x`. The order on the views of the `bimap`
    is preserved as well.\n
    [*Returns:] `*this`.\n
    [*Complexity:] O(n + x.size()*log(x.size()) + C(x.size())).\n
    [*Exception safety:] Strong, provided the copy and assignment operations
    of the types of `ctor_args_list` do not throw.
]
\n

    allocator_type get_allocator() const;

[:  [*Effects:] Returns a copy of the `allocator_type` object used to construct
    the `bimap`.\n
    [*Complexity:] Constant.
]

\n

[endsect]

[section Serialization]

`bimap` can be archived/retrieved by means of __BOOST_SERIALIZATION__.
Boost.Bimap does not expose a public serialization interface, as this is
provided by Boost.Serialization itself. Both regular and XML archives are supported.

Each of the set specifications comprising a given `bimap` contributes its
own preconditions as well as guarantees on the retrieved containers. In describing
these, the following concepts are used. A type `T` is ['serializable]
(resp. XML-serializable) if any object of type `T` can be saved to an output
archive (XML archive) and later retrieved from an input archive (XML archive)
associated to the same storage. If `x`' of type `T` is loaded from the serialization
information saved from another object x, we say that x' is a ['restored copy] of x.
Given a __SGI_BINARY_PREDICATE__ `Pred` over `(T, T)`, and objects `p` and `q` of type `Pred`, we
say that `q` is ['serialization-compatible] with `p` if

* `p(x,y) == q(x`'`,y`'`)`

for every `x` and `y` of type `T` and `x`' and `y`' being restored copies of `x`
and `y`, respectively.

[blurb [*Operation:] saving of a `bimap b` to an output archive
(XML archive) ar.]

[:  [*Requires:] Value is serializable (XML-serializable). Additionally, each
    of the views of b can impose another requirements.\n
    [*Exception safety:] Strong with respect to `b`. If an exception is thrown, ar
    may be left in an inconsistent state.
]

[blurb [*Operation:] loading of a `bimap` m' from an input archive
(XML archive) ar.]

[:  [*Requires:] Value is serializable (XML-serializable). Additionally, each of
    the views of `b`' can impose another requirements.\n
    [*Exception safety:] Basic. If an exception is thrown, ar may be left in an
    inconsistent state.
]

[endsect]
[endsect]

[endsect]