[/license

Boost.Bimap

Copyright (c) 2006 Matias Capeletto

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)

]

[/ QuickBook Document version 1.3 ]

[section list_of Reference]

[section Header "boost/bimap/list_of.hpp" synopsis]

    namespace boost {
    namespace bimap {


    template< class KeyType >
    struct list_of;

    struct list_of_relation;


    } // namespace bimap
    } // namespace boost

[endsect]

[section list_of Views]

A list_of set view is a std::list signature compatible
interface to the underlying heap of elements contained in a `bimap`.

If you look the bimap by a side, you will use a map view and if you looked
it as a whole you will be using a set view.

Elements in a list_of view are by default sorted according to
their order of insertion: this means that new elements inserted through a
different view of the `bimap` are appended to the end of the
list_of view. Additionally, the view allows for free reordering of elements
in the same vein as `std::list` does. Validity of iterators and references to
elements is preserved in all operations.

There are a number of differences with respect to `std::lists`:

* list_of views are not
__SGI_ASSIGNABLE__ (like any other view.)
* Unlike as in `std::list`, insertions into a list_of view may fail due to
clashings with other views. This alters the semantics of the operations
provided with respect to their analogues in `std::list`.
* Elements in a list_of view are not mutable, and can only be changed
by means of `replace` and `modify` member functions.

Having these restrictions into account, list_of views are models of
__SGI_REVERSIBLE_CONTAINER__, __SGI_FRONT_INSERTION_SEQUENCE__ and
__SGI_BACK_INSERTION_SEQUENCE__.
We only provide descriptions of those types and operations that are either
not present in the concepts modeled or do not exactly conform to the
requirements for these types of containers.

    namespace boost {
    namespace bimap {
    namespace views {

    template< ``['-implementation defined parameter list-]`` >
    class ``['-implementation defined view name-]``
    {
        public:

        // types

        typedef ``['-unspecified-]`` value_type;
        typedef ``['-unspecified-]`` allocator_type;
        typedef ``['-unspecified-]`` reference;
        typedef ``['-unspecified-]`` const_reference;
        typedef ``['-unspecified-]`` iterator;
        typedef ``['-unspecified-]`` const_iterator;
        typedef ``['-unspecified-]`` size_type;
        typedef ``['-unspecified-]`` difference_type;
        typedef ``['-unspecified-]`` pointer;
        typedef ``['-unspecified-]`` const_pointer;
        typedef ``['-unspecified-]`` reverse_iterator;
        typedef ``['-unspecified-]`` const_reverse_iterator;

        // construct/copy/destroy

        this_type & operator=(const this_type & x);

        template< class InputIterator >
        void assign(InputIterator first, InputIterator last);
        void assign(size_type n, const value_type & value);

        allocator_type get_allocator() const;

        // iterators

        iterator               begin();
        const_iterator         begin() const;
        iterator               end();
        const_iterator         end() const;
        reverse_iterator       rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator       rend();
        const_reverse_iterator rend() const;

        // capacity

        bool      empty() const;
        size_type size() const;
        size_type max_size() const;

        void resize(size_type n, const value_type & x = value_type());

        // access

        const_reference front() const;
        const_reference back() const;

        // modifiers

        std::pair<iterator,bool> push_front(const value_type & x);
        void                     pop_front();
        std::pair<iterator,bool> push_back(const value_type & x);
        void                     pop_back();

        std::pair<iterator,bool> insert(iterator position, const value_type & x);
        void insert(iterator position, size_type n, const value_type & x);
        template<typename InputIterator>
        void insert(iterator position, InputIterator first, InputIterator last);

        iterator erase(iterator position);
        iterator erase(iterator first, iterator last);

        bool replace(iterator position, const value_type & x);
        template<typename Modifier> bool modify(iterator position, Modifier mod);


        void clear();

        // list operations

        void splice(iterator position, this_type & x);
        void splice(iterator position, this_type & x, iterator i);
        void splice(
            iterator position, this_type & x, iterator first, iterator last);

        void remove(const value_type & value);
        template<typename Predicate> void remove_if(Predicate pred);

        void unique();
        template <class BinaryPredicate>
        void unique(BinaryPredicate binary_pred);

        void merge(this_type & x);
        template <typename Compare> void merge(this_type & x,Compare comp);

        void sort();
        template <typename Compare> void sort(Compare comp);

        void reverse();

        // rearrange operations

        void relocate(iterator position, iterator i); 
        void relocate(iterator position, iterator first, iterator last);
        template<typename InputIterator> void rearrange(InputIterator first);
    }

    // view comparison

    bool operator==(const this_type & v1, const this_type & v2 );
    bool operator< (const this_type & v1, const this_type & v2 );
    bool operator!=(const this_type & v1, const this_type & v2 );
    bool operator> (const this_type & v1, const this_type & v2 );
    bool operator>=(const this_type & v1, const this_type & v2 );
    bool operator<=(const this_type & v1, const this_type & v2 );

    } // namespace views
    } // namespace bimap
    } // namespace boost


[section Complexity signature]

Here and in the descriptions of operations of `list_of` views, we adopt the
scheme outlined in the
[link complexity_signature_explanation complexity signature section].
The complexity signature of a `list_of` view is:

* copying: `c(n) = n * log(n)`,
* insertion: `i(n) = 1` (constant),
* hinted insertion: `h(n) = 1` (constant),
* deletion: `d(n) = 1` (constant),
* replacement: `r(n) = 1` (constant),
* modifying: `m(n) = 1` (constant).

[endsect]

[section Instantiation types]

`list_of` views are instantiated internally to `bimap` and specified
by means of the set type specifiers and the bimap itself.
Instantiations are dependent on the following types:

* `Value` from `list_of`,
* `Allocator` from `bimap`,

[endsect]

[section Constructors, copy and assignment]

As explained in the view concepts section, views do not have public
constructors or destructors. Assignment, on the other hand, is provided.

    this_type & operator=(const this_type & x);

[:  [*Effects:] `a = b;`\n
    where a and b are the `bimap` objects to which `*this` and `x` belong,
    respectively.\n
    [*Returns:] `*this`.
]
\n

    template <class InputIterator>
    void assign(InputIterator first, InputIterator last);

[:  [*Requires:] `InputIterator` is a model of __SGI_INPUT_ITERATOR__ over elements of type
    `value_type` or a type convertible to `value_type`. first and last are not
    iterators into any views of the `bimap` to which this view belongs.
    `last` is reachable from `first`.\n
    [*Effects:]\n
    `clear();`\n
    `insert(end(),first,last);`
]
\n

    void assign(size_type n, const value_type & value);

[:  [*Effects:]\n
    `clear();`\n
    `for(size_type i = 0; i < n ; ++n) push_back(v);`
]
\n

[endsect]

[section Capacity operations]

    void resize(size_type n,const value_type& x=value_type()); 

[:  [*Effects:]\n
    `if( n > size() ) insert(end(), n - size(), x);`\n
    `else if( n < size() ){`\n
    `    iterator it = begin();`\n
    `    std::advance(it, n);`\n
    `    erase(it, end());`\n
    `}`
    [*Note:] If an expansion is requested, the size of the view is not
    guaranteed to be n after this operation (other views may ban insertions.)
]

[endsect]

[section Modifiers]

    std::pair<iterator,bool> push_front(const value_type& x);

[:  [*Effects:] Inserts `x` at the beginning of the sequence if no other views
    of the `bimap` bans the insertion.\n
    [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only
    if insertion took place. On successful insertion, `p.first` points to the element
    inserted; otherwise, `p.first` points to an element that caused the insertion to be
    banned. Note that more than one element can be causing insertion not to be allowed.\n
    [*Complexity:] O(I(n)).\n
    [*Exception safety:] Strong.
]
\n

    std::pair<iterator,bool> push_back(const value_type & x);

[:  [*Effects:] Inserts `x` at the end of the sequence if no other views of the
    `bimap` bans the insertion.\n
    [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only if
    insertion took place. On successful insertion, `p.first` points to the element
    inserted; otherwise, `p.first` points to an element that caused the insertion
    to be banned. Note that more than one element can be causing insertion not
    to be allowed.\n
    [*Complexity:] O(I(n)).\n
    [*Exception safety:] Strong.
]
\n

    std::pair<iterator,bool> insert(iterator position, const value_type & x);

[:  [*Requires:] `position` is a valid `iterator` of the view.\n
    [*Effects:] Inserts `x` before position if insertion is allowed by all other
    views of the `bimap`.\n
    [*Returns:] The return value is a pair `p`. `p.second` is `true` if and only if
    insertion took place. On successful insertion, `p.first` points to the element
    inserted; otherwise, `p.first` points to an element that caused the insertion
    to be banned. Note that more than one element can be causing insertion not
    to be allowed.\n
    [*Complexity:] O(I(n)).\n
    [*Exception safety:] Strong.
]
\n

    void insert(iterator position, size_type n, const value_type & x);

[:  [*Requires:] `position` is a valid `iterator` of the view.
    [*Effects:] `for(size_type i = 0; i < n; ++i) insert(position, x);`
]
\n

    template<typename InputIterator>
    void insert(iterator position,InputIterator first,InputIterator last);

[:  [*Requires:] `position` is a valid `iterator` of the view. `InputIterator` is
    a model of __SGI_INPUT_ITERATOR__ over elements of type `value_type`.
    `first` and `last` are not iterators into any view of the
    `bimap` to which this view belongs. `last` is reachable from `first`.\n
    [*Effects:] `while(first != last) insert(position, *first++);`\n
    [*Complexity:] O(m*I(n+m)), where m is the number of elements in `[first,last)`.\n
    [*Exception safety:] Basic.
]
\n

    iterator erase(iterator position);

[:  [*Requires:] `position` is a valid dereferenceable `iterator` of the view.\n
    [*Effects:] Deletes the element pointed to by `position`.\n
    [*Returns:] An iterator pointing to the element immediately following the
    one that was deleted, or `end()` if no such element exists.\n
    [*Complexity:] O(D(n)).\n
    [*Exception safety:] nothrow.
]
\n

    iterator erase(iterator first, iterator last); 

[:  [*Requires:] `[first,last)` is a valid range of the view.\n
    [*Effects:] Deletes the elements in `[first,last)`.\n
    [*Returns:] `last`.\n
    [*Complexity:] O(m*D(n)), where m is the number of elements in `[first,last)`.\n
    [*Exception safety:] nothrow.
]
\n



    bool replace(iterator position,const value_type& x);

[:  [*Requires:] `position` is a valid dereferenceable iterator of the view.\n
    [*Effects:] Assigns the value `x` to the element pointed to by `position` into
    the `bimap` to which the view belongs if replacing is allowed by
    all other views of the `bimap`.\n
    [*Postconditions:] Validity of `position` is preserved in all cases.\n
    [*Returns:] `true` if the replacement took place, `false` otherwise.\n
    [*Complexity:] O(R(n)).\n
    [*Exception safety:] Strong. If an exception is thrown by some user-provided
    operation the `bimap` to which the view belongs remains in its
    original state.
]
\n

    template<typename Modifier> bool modify(iterator position,Modifier mod);

[:  [*Requires:] `Modifier` is a model of __SGI_BINARY_FUNCTION__ accepting arguments of
    type:\n
    ['Map View:] `first_type&` and `second_type&`\n
    ['Set View:] `left_type&` and `right_type&`\n
    `position` is a valid dereferenceable iterator of the view.\n
    [*Effects:]\n
    ['Map View:] Calls `mod(e.first,e.second)`\n
    ['Set View:] Calls `mod(e.left,e.right)`\n
    where `e` is the element pointed to by `position` and
    rearranges `*position` into all the views of the `bimap`.
    Rearrangement on `list_of` views does not change the position of the element
    with respect to the view; rearrangement on other views may or might not suceed.
    If the rearrangement fails, the element is erased.\n
    [*Postconditions:] Validity of `position` is preserved if the operation succeeds.\n
    [*Returns:] `true` if the operation succeeded, `false` otherwise.\n
    [*Complexity:] O(M(n)).\n
    [*Exception safety:] Basic. If an exception is thrown by some user-provided
    operation (except possibly `mod`), then the element pointed to by position is erased.
]
\n

[endsect]

[section List operations]

`list_of` views provide the full set of list operations found in `std::list`;
the semantics of these member functions, however, differ from that of `std::list`
in some cases as insertions might not succeed due to banning by other views.
Similarly, the complexity of the operations may depend on the other views
belonging to the same `bimap`.

    void splice(iterator position, this_type & x);

[:  [*Requires:] `position` is a valid iterator of the view. `&x!=this`.\n
    [*Effects:] Inserts the contents of `x` before position, in the same order as
    they were in `x`. Those elements successfully inserted are erased from `x`.\n
    [*Complexity:] O(`x.size()`*I(n+`x.size()`) + `x.size()`*D(`x.size()`)).\n
    [*Exception safety:] Basic.
]
\n

    void splice(iterator position, this_type & x,iterator i);

[:  [*Requires:] `position` is a valid iterator of the view. `i` is a valid
    dereferenceable iterator `x`.\n
    [*Effects:] Inserts the element pointed to by `i` before position: if insertion
    is successful, the element is erased from `x`. In the special case `&x==this`,
    no copy or deletion is performed, and the operation is always successful. If
    `position==i`, no operation is performed.\n
    [*Postconditions:] If `&x==this`, no iterator or reference is invalidated.\n
    [*Complexity:] If `&x==this`, constant; otherwise O(I(n) + D(n)).\n
    [*Exception safety:] If `&x==this`, nothrow; otherwise, strong.
]
\n

    void splice(iterator position, this_type & x, iterator first, iterator last);

[:  [*Requires:] `position` is a valid iterator of the view. `first` and `last` are
    valid iterators of `x`. last is reachable from `first`. position is not in the
    range `[first,last)`.\n
    [*Effects:] For each element in the range `[first,last)`, insertion is tried
    before position; if the operation is successful, the element is erased from x.
    In the special case `&x==this`, no copy or deletion is performed, and insertions
    are always successful.\n
    [*Postconditions:] If `&x==this`, no iterator or reference is invalidated.\n
    [*Complexity:] If `&x==this`, constant; otherwise O(m*I(n+m) + m*D(x.size()))
    where m is the number of elements in `[first,last)`.\n
    [*Exception safety:] If `&x==this`, nothrow; otherwise, basic.
]
\n

    void remove(const value_type & value);

[:  [*Effects:] Erases all elements of the view which compare equal to `value`.\n
    [*Complexity:] O(n + m*D(n)), where m is the number of elements erased.\n
    [*Exception safety:] Basic.
]
\n

    template<typename Predicate> void remove_if(Predicate pred);

[:  [*Effects:] Erases all elements `x` of the view for which `pred(x)` holds.\n
    [*Complexity:] O(n + m*D(n)), where m is the number of elements erased.\n
    [*Exception safety:] Basic.
]
\n

    void unique();

[:  [*Effects:] Eliminates all but the first element from every consecutive
    group of equal elements referred to by the iterator `i` in the range
    `[first+1,last)` for which `*i==*(i-1)`.\n
    [*Complexity:] O(n + m*D(n)), where m is the number of elements erased.\n
    [*Exception safety:] Basic.
]
\n

    template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);

[:  [*Effects:] Eliminates all but the first element from every consecutive
    group of elements referred to by the iterator i in the range \[first+1,last)
    for which `binary_pred(*i,*(i-1))` holds.\n
    [*Complexity:] O(n + m*D(n)), where m is the number of elements erased.\n
    [*Exception safety:] Basic.
]
\n

    void merge(this_type & x);

[:  [*Requires:] `std::less<value_type>` is a __SGI_STRICT_WEAK_ORDERING__ over `value_type`.
    Both the view and `x` are sorted according to `std::less<value_type>`.\n
    [*Effects:] Attempts to insert every element of `x` into the corresponding
    position of the view (according to the order). Elements successfully inserted
    are erased from `x`. The resulting sequence is stable, i.e. equivalent elements
    of either container preserve their relative position. In the special case
    `&x==this`, no operation is performed.\n
    [*Postconditions:] Elements in the view and remaining elements in `x` are sorted.
    Validity of iterators to the view and of non-erased elements of `x` references
    is preserved.\n
    [*Complexity:] If `&x==this`, constant; otherwise
    O(n + `x.size()`*I(n+`x.size()`) + `x.size()`*D(`x.size()`)).\n
    [*Exception safety:] If `&x==this`, nothrow; otherwise, basic.
]
\n

    template <typename Compare> void merge(this_type & x,Compare comp);

[:  [*Requires:] Compare is a __SGI_STRICT_WEAK_ORDERING__ over `value_type`. Both the view
    and `x` are sorted according to `comp`.\n
    [*Effects:] Attempts to insert every element of `x` into the corresponding position
    of the view (according to `comp`). Elements successfully inserted are erased from `x`.
    The resulting sequence is stable, i.e. equivalent elements of either container preserve
    their relative position. In the special case `&x==this`, no operation is performed.\n
    [*Postconditions:] Elements in the view and remaining elements in `x` are sorted
    according to `comp`. Validity of iterators to the view and of non-erased elements
    of `x` references is preserved.\n
    [*Complexity:] If `&x==this`, constant;
    otherwise O(n + `x.size()`*I(n+`x.size()`) + `x.size()`*D(`x.size()`)).\n
    [*Exception safety:] If `&x==this`, nothrow; otherwise, basic.
]
\n

    void sort();

[:  [*Requires:] `std::less<value_type>` is a __SGI_STRICT_WEAK_ORDERING__ over value_type.\n
    [*Effects:] Sorts the view according to `std::less<value_type>`. The sorting is stable,
    i.e. equivalent elements preserve their relative position.\n
    [*Postconditions:] Validity of iterators and references is preserved.\n
    [*Complexity:] O(n*log(n)).\n
    [*Exception safety:] nothrow if `std::less<value_type>` does not throw; otherwise, basic.
]
\n

    template <typename Compare> void sort(Compare comp); 

[:  [*Requires:] Compare is a __SGI_STRICT_WEAK_ORDERING__ over value_type.\n
    [*Effects:] Sorts the view according to comp. The sorting is stable, i.e. equivalent
    elements preserve their relative position.\n
    [*Postconditions:] Validity of iterators and references is preserved.\n
    [*Complexity:] O(n*log(n)).\n
    [*Exception safety:] nothrow if comp does not throw; otherwise, basic.
]
\n

    void reverse();

[:  [*Effects:] Reverses the order of the elements in the view.\n
    [*Postconditions:] Validity of iterators and references is preserved.\n
    [*Complexity:] O(n).\n
    [*Exception safety:] nothrow.
]
\n

[endsect]

[section Serialization]

Views cannot be serialized on their own, but only as part of the
`bimap` into which they are embedded. In describing the additional
preconditions and guarantees associated to `list_of` views with respect to
serialization of their embedding containers, we use the concepts defined in the
`bimap` serialization section.

[blurb [*Operation:] saving of a `bimap` b to an output archive
(XML archive) ar.]
[:  [*Requires:] No additional requirements to those imposed by the container.
]
\n

[blurb [*Operation:] loading of a `bimap` b' from an input archive
(XML archive) ar.]
[:  [*Requires:] No additional requirements to those imposed by the container.\n
    [*Postconditions:] On successful loading, each of the elements of
    `[begin(), end())`
    is a restored copy of the corresponding element in
    `[m.get<i>().begin(), m.get<i>().end())`,
    where `i` is the position of the `list_of` view in the container.
]
\n

[blurb [*Operation:] saving of an `iterator` or `const_iterator` it to an output
archive (XML archive) ar.]
[:  [*Requires:] `it` is a valid iterator of the view. The associated
    `bimap` has been previously saved.
]
\n

[blurb [*Operation:] loading of an `iterator` or `const_iterator it`' from an input
archive (XML archive) ar.]
[:  [*Postconditions:] On successful loading, if it was dereferenceable then `*it`' is the
    restored copy of `*it`, otherwise `it`'` == end()`.\n
    [*Note:] It is allowed that `it` be a `const_iterator` and the restored `it`' an iterator,
    or viceversa.
]

[endsect]
[endsect]


[endsect]
