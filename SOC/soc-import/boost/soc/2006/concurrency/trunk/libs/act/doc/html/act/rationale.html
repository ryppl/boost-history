<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Rationale</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.70.1">
<link rel="start" href="../index.html" title="Act 0.5b">
<link rel="up" href="../index.html" title="Act 0.5b">
<link rel="prev" href="interlocked_integer.html" title="Interlocked Integer">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%">
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.htm">Home</a></td>
<td align="center"><a href="../libraries.html">Libraries</a></td>
<td align="center"><a href="../../../people/people.htm">People</a></td>
<td align="center"><a href="../../../more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="interlocked_integer.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="act.rationale"></a><a href="rationale.html" title="Rationale">Rationale</a></h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="rationale.html#act.rationale.policy_based_design">Policy-Based Design</a></span></dt>
<dt><span class="section"><a href="rationale.html#act.rationale.actions_vs__futures">Actions vs. Futures</a></span></dt>
</dl></div>
<p>
      Boost.Act is a fairly large library and makes some controversial design decisions.
      This section is provided to briefly describe the rationale behind some of these
      decisions.
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="act.rationale.policy_based_design"></a><a href="rationale.html#act.rationale.policy_based_design" title="Policy-Based Design">Policy-Based Design</a></h3></div></div></div>
<p>
        Boost.Act offers programmers customizability through two kinds of policies
        which control algorithm execution and active qualification implementation.
        These policies allow one to adjust whether algorithms run in parallel when
        possible or always serially, and allow one to adjust whether active types
        create their own thread or operate in the master thread. Default policies
        used can be overriden at a global level or individually at points of instantiation.
        The reason this may be considered controversial is that some may argue that
        the use of policies here adds needless complexity at little gain. <span class="emphasis"><em>In
        short, why not just use the STL in cases where algorithms need to be run
        serially and why not just not use active objects in places where you do not
        need your object to exist in its own thread?</em></span>
      </p>
<p>
        The reasons for choosing policies stem mostly from the fact that they provide
        an easy way to switch execution models for arbitrary amounts of code with
        very few changes to the code using the library. Reasons one may wish to switch
        policies at the call-site range from reasons of optimization to reasons of
        debugging. In terms of optimization, using active objects and parallel algorithms
        may have a negative impact on performance in single-core systems, therefore
        the ability to toggle the execution model by merely changing the default
        policy used allows a programmer to target both single-core and multicore
        processors by simply rebuilding after changing the policy being used. In
        theory, using policies which target single-core sytems can be optimized to
        the same code as a project which avoided the abstraction entirely.
      </p>
<p>
        As an example of switching policies for debugging, single-threaded algorithms
        can often be more simple to debug than multi-threaded algorithms. If a bug
        is narrowed down to a single algorithm which runs in parallel, one may easily
        switch execution for that call to be serial, making it much easier to step
        through in order to find the problem. This also helps in figuring out if
        certain unwanted behavior is being caused by multi-threading issues or if
        there is a more simple logical problem which exists at a higher-level in
        the algorithm's design.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="act.rationale.actions_vs__futures"></a><a href="rationale.html#act.rationale.actions_vs__futures" title="Actions vs. Futures">Actions vs. Futures</a></h3></div></div></div>
<p>
        Another fairly controversial design decision is the absence of futures, or
        at least futures as they are commonly known. Rather than returning futures
        from asynchronous function calls and function calls queued on active objects,
        <code class="literal">actions</code> are yielded which represent the running function
        and provide an indirect interface to an instance of the active qualified
        form of the return type. This choice was made for a variety of reasons. First
        and foremost, this allows a programmer to work with the results of such function
        calls without losing concurrency by default, as functions upon them are queued
        rather than performed immediately after implicitly or explicitly forcing
        the function to complete. The traditional blocking form of futures, while
        can potentially be implemented in such a way that is [slightly] more optimized
        for single-core processors, implies an unnecessary loss of concurrency and
        becomes less efficient if multiple cores are available. Still, the traditional
        behavior of futures can be forced through actions by simply copying the active
        result to an active-unqualified form of the result type using <code class="literal">inactive_value</code>,
        forcing a wait for the function to complete. This gives actions of Boost.Act
        a superset of the functionality provided by futures meaning that those who
        wish to use actions in a future-like manner may do so.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright © 2006 , 2007 Matthew Calabrese</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="interlocked_integer.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a>
</div>
</body>
</html>
