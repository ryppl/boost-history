[/ 
 /  Copyright (c) 2006, Bernhard Reiter
 /
 /  Distributed under the Boost Software License, Version 1.0.
 /  (See accompanying file LICENSE_1_0.txt or copy at
 /  http://www.boost.org/LICENSE_1_0.txt)
 /
 //////////////////////////////////////////////////////////////////////////////////////////////
 /
 / Boost.Tree
 / TODO file; part of documentation also.
 /]
 
[section TODO]

General:

* have `erase()` operations return cursor/iterator instead of void (as in new STD)
* modify parity/parent specs according to newsgroup thread, but members add to binary_tree cursor!
* Add O(n) generations(ancestor, descendant) algorithm (vertical distance) yielding number
  of generations between ancestor and descendant (ascending cursor only)
  Or rather, as this introduces something that shouldn't be conceptually different from
  std::distance: introduce a (forward, of course) (hierarchy_)ascending::iterator that just moves up 
  towards the root when incremented.
* We might need still more binary_tree members for more efficient functions operating on
  ranges...
* `insert()` and `erase()` semantics need reworking. For instance, Proposal 23.X.4.1.4 ยง2 
  (and related for deletion and multiway tree insertion/deletion) are way too convoluted
  for a really basic operation. Still, it's important to consider special cases such as
  root nodes and fields of use such as `forest_trees`; but for the latter, something similar
  as inorder_insert might come in handy.

Proposal:

* Add InputCursor requirements: binary cursor if it's a binary_tree member function, etc.
* Cursor validity after insertion/erasure/clearing
* Possibly rename ascending to hierarchy cursor? (because of other uses for ascending/cursors in a graph context)
* Remove operator* requirement? (for upward-growing trees with data only on the bottom level --- like B+trees)
* Add tree lower_bound algorithm (to namespace inorder because it's somewhat inorder dependent? or is it?)
* Refactor balancer section to map implementation 
	(balanced_tree template class using policies -- like red_black -- from namespace balancers)
* Add new metadata approach
* Add inorder_erase to balanced_tree requirements

Implementation:

* Implement remaining (binary_tree) balancers, augmentors
* Implement forest. Can its cursor type have an O(1) parent()?
* Implement nary_tree, multiway_tree, b_tree, b_star_tree
* Add tests for and rework
	* binary_tree: subtree insert; splice operations
	* red_black
	* searcher
* Concept checks.
* Interoperability with BGL algorithms.
* C++0x: Add template typedefs (e.g. red_black_tree is balanced_tree<red_black_balancer, binary_tree>)

Documentation:

* Add some illustrations
* Overview: develop hierarchy/cursor concept step by step, using illustrations that 
  depict what is introduced at what step (nodes with pointers to their siblings, children, parents,
  a frame around a given cursor [and possibly additionally required information stated]
  that signifies what amount of information is contained within that cursor.

Further applications:

* Implement associative containers and priority_queue specialization using searcher
* Implement (binary) heap

[endsect]
