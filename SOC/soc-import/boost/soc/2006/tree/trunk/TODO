Short-term TODO:

-implement sibling_iter::insert, some c/dtors and what else is required for a minimum test of forest's basic 
functionality (dysfunctional as of yet...),
-add other iterator types plus specialization for forest
-add node implementation that uses (std-)container for children
-add binary positional objects...
.
.
.
-directory reorg-
-get doxygen to work with boostbook/quickbook

One of the next things to do is implement a prototypical "sequential preorder"
memory represented tree (cf. TAOCP1). This requires a special kind of node;
and a "sequential memory representation", of course, which means an array or
vector saving some memory otherwise required for e.g. next_sibling links.
The tricky part is if we can get this done by just designing a neat kind 
of allocator, how exactly tree::root must look like in order for this and 
other representations to work and what components must know about what other
ones (especally concerning insertion operations -- node_type, alloc_type etc.)

Doc: 
One of the main issues that arises from the concept of position-indicating
objects is that like iterators, they serve orthogonal purposes:
-if we even view them as iterators, there is the position-indicating/
value-returning duality
-but a node can also be seen as the container of its children...