<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- boostinspect:nolink -->

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Hierarchical Data Structures and Related Concepts for the C++
  Standard Library (TR2)</title>
<style type="text/css">
  /*<![CDATA[*/
  li.c1 {list-style: none}
  .std {
    font-family: serif;
  }
  .std {
    margin: 1em;
    padding: 1em 0em 1em 1.5em;
    border-top: 1px solid grey;
    border-bottom: 1px solid grey;
  }
  .std ol {
    margin: 0em;
    padding: 0em;
  }
  .std ol li {
    margin: 0em 0em 1em 0em;
    padding: 0em 0em 0em 0em;
  }
  .std table {
    border: 1px solid;
    margin: 0em auto 0em auto;
    border-spacing: 0em;
  }
  .std table caption {
    font-weight: bold;
    margin: 0em auto 1em auto;
    align: center;
    caption-side: top;
  }
  .std table.reqmts th {
    border-bottom: 1px solid;
    padding: 0.25em 0.5em 0em 0.5em;
  }
  .std table.reqmts td {
    border-top: 1px solid;
    vertical-align: top;
    padding: 0.25em 0.5em 0em 0.5em;
  }
  .docref {
    float: right;
  }
  .docref dt {
    float: left;
    font-style: italic;
  }
  .docref dd {
    margin-left: 8em;
  }
  h1, h2, h3, h4, h5, h6 {
    clear: both;
  }
  .byline {
    text-align: center;
  }
  .note {
    background: #DDDDDD;
    border: 1px solid #AAAAAA;
  }
  .add {
    text-decoration: overline;
  }
  /*]]>*/
</style>
</head>

<body>
  <dl class="docref">
    <dt>Document No.</dt>

    <dd>WG21/D2101=J16/06-0171</dd>

    <dt>Date</dt>

    <dd>2006-10-??</dd>

    <dt>Project</dt>

    <dd>Programming Language C++</dd>

    <dt>Reply to</dt>

    <dd>Bernhard Reiter &lt;<a href=
    "ockham@gmx.net">ockham@gmx.net&gt;</a>,<br />
    Rene Rivera &lt;<a href=
    "mailto:rrivera@acm.org">rrivera@acm.org</a>&gt;</dd>
  </dl>

  <h1>Hierarchical Data Structures and Related Concepts for the C++ Standard
  Library</h1>

  <h2 class="byline">Bernhard Reiter and Rene Rivera</h2>

  <h2>Introduction</h2>

  <p>This paper proposes addition of library components covering tree
  structures and related concepts to the C++ Standard Library Technical
  Report 2. The proposal is based on work towards a Boost tree component
  library (see <a href=
  "https://boost-consulting.com:8443/trac/soc/wiki/tree">https://boost-consulting.com:8443/trac/soc/wiki/tree</a>).</p>

  <p>The library strives to cover many of the relevant aspects within the
  vast field linked to the notion of trees in computer science.</p>

  <h2>Motivation and Scope</h2>

  <h3>Why is this important?</h3>

  <p>This proposal is motivated by the wish to establish methods of dealing
  with hierarchical data structures in a manner that is similar to that of
  the <abbr title="Standard Template Libraries">STL</abbr> for linear ones.
  That is, it seeks to provide clear, straight-forward, versatile and
  comprehensive concepts, data structures and algorithms for trees and
  related structures that allow efficient implementation while not exposing
  implementation details.</p>

  <p>In particular, this proposal strives to unite types of hierarchical data
  structures that have historically been treated separately, although there
  is arguably good reason to view their role for algorithms as different
  aspects of common underlying concepts. Formally, this proposal's desired
  scope is covering all <em>rooted ordered connected acyclic graphs</em>.</p>

  <h3>What kinds of problems does it address, and what kinds of programmers
  is it intended to support?</h3>

  <p>Existing tree implementations as listed in the References section as
  well as the number of posts on C++ related newsgroups give an evidence of
  very general, high interest in tree and related data structures.
  Formalization of how to deal with hierarchical data structures seems to be
  relevant as programmers of any level of skill working in any given field is
  likely to need such a structure at one point.</p>

  <h3>Is it based on existing practice?</h3>

  <p>No; this proposal originates in an effort to create a generic tree
  container component for <a href="http://www.boost.org">Boost</a> in summer
  of 2006, so at the time of this writing, implementation work is still
  unfinished and, however inspired by and striving to avoid past issues it
  is, it has not been used in practice yet.</p>

  <h3>Is there a reference implementation?</h3>

  <p>Yes; the current state is available from <abbr title=
  "Subversion">svn</abbr> from <a href=
  "https://www.boost-consulting.com:8443/svn/main/boost/soc/2006/tree/trunk">https://www.boost-consulting.com:8443/svn/main/boost/soc/2006/tree/trunk</a>.
  Alternatively, the source code can be viewed in a web browser at <a href=
  "https://boost-consulting.com:8443/trac/soc/browser/boost/soc/2006/tree">https://boost-consulting.com:8443/trac/soc/browser/boost/soc/2006/tree</a>.</p>

  <h2>Impact on the Standard</h2>

  <h3>What does it depend on, and what depends on it?</h3>

  <p>It depends on some standard library components, such as
  <tt>std::allocator</tt> which is used as the default allocator template
  argument at some points. Concepts like allocators or iterators are reused
  and in some cases adapted.</p>

  <h3>Is it a pure extension, or does it require changes to standard
  components?</h3>

  <p>Most of the proposed library is a pure extension.</p>

  <p>Some modifications to <tt>&lt;algorithm&gt;</tt> are proposed, so binary
  search algorithms can be applied to hierarchical data structures as well.
  [...]</p>

  <h3>Can it be implemented using today's compilers, or does it require
  language features that will only be available as part of C++0x?</h3>

  <p>It can be (and has been) implemented with today's compilers. [...]<br />
  [... We'd profit from template typedefs to say e.g.</p>
  <pre>
template&lt;class T, class Alloc = std::allocator&lt;T&gt; &gt; using rank_tree = binary_tree&lt;T, rank_balance, rank_augment, Alloc&gt;;
  
</pre>

  <p>Note that it might be worthwile to investigate if the present Container
  concept should be modified so that it only covers the requirements as of
  paragraph 2 of section [tr.hierarchy.req] of this proposal, which
  correspond to the current Container concept with the exception of any
  expressions that implicitly assume linear internal structure and outsource
  those to a "Linear Container" concept as similarly formalized in the
  <a href="http://boost.org/libs/range/doc/range.html">Boost Range
  concept</a> externally to the Standard.</p>

  <h2>Important Design Decisions</h2>

  <h3>Why did you choose the specific design that you did?</h3>

  <p>One of the most important assets of the present design is the cursor
  concept as a hierarchical continuation to the STL's iterator concept (and
  the externally defined range concept). Among their benefits, cursors allow
  to handle both client data access (by dereference) and subtree access while
  hiding the normally underlying node structure, providing a uniform
  interface to algorithms that are thus enabled to deal with a number of
  different kinds of trees. On the other hand, this abstraction achieves
  independence of implementation details (such as nodes for storage in many
  cases), allowing the underlying concepts to be applicable to other possible
  implementations as well.</p>

  <h3>What alternatives did you consider, and what are the tradeoffs?</h3>

  <dl>
    <dt>Trees of trees</dt>

    <dd>Trees, being recursively defined data structures, seem to somewhat
    lend themselves to recursive implementation, i.e. declaring them in a way
    so they consist of a client value part and a certain number of trees in
    turn (as e.g. in case of <a href="#ref.haas">[haas]</a>). While allowing
    for a somewhat uniform treatment of a given trees' subtrees, such an
    approach would duplicate allocators and yield imply structural
    information being overly present, as a tree, like the existing STL
    containers, should be responsible of its data storage.</dd>

    <dt>Store metadata differently</dt>

    <dd>[...]</dd>
  </dl>

  <h3>What are the consequences of your choices, for users and
  implementors?</h3>

  <h3>What decisions are left up to implementors?</h3>

  <h3>If there are any similar libraries in use, how do their design
  decisions compare to yours?</h3>

  <p>Trees, having attracted much attention in the C++ community, are found
  in various implementations and as subjects of a number of papers.
  Contrarily to the present proposal, ractically all of them deal either with
  trees as used for sorted associative containers (with logarithmic time
  complexity for more relevant operations, achieved by some sort of
  balancing; examples are <a href="ref.dreizin">[dreizin]</a>, <a href=
  "ref.ekman">[ekman]</a> and <a href="ref.karas">[karas]</a>; plus, most
  current STL implementations use a red-black tree as their associative
  containers' base) or with what we call "external" hierarchies in the
  following (whose structure is dictated e.g. by a filesystem directory tree,
  an <abbr title="Extensible Markup Language">XML</abbr> file or an
  <abbr title="Abstract syntax tree">AST</abbr>; see e.g. <a href=
  "ref.gottschlich">[gottschlich]</a>, <a href="ref.haas">[haas]</a>,
  <a href="ref.parent">[parent]</a> and <a href="ref.peeters">[peeters]</a>),
  but rarely both fields of application.</p>

  <p>Approaches as found in <a href="ref.austern">[austern]</a> or <a href=
  "ref.mirwaisi">[mirwaisi]</a> go some steps further and have provided
  valuable inspiration for this projects, but still do not formalize anything
  similar as the cursor-based interface in this proposal for dealing with a
  tree's contents.</p>

  <p>The <a href="http://www.boost.org/libs/graph/"><abbr title=
  "Boost Graph Library">BGL</abbr></a>, finally, deals with graphs that are
  even more general than hierarchical ones, which does not allow them to
  profit from specific hierarchy properties as much as the ones presented in
  this proposal.</p>

  <h2>Proposed Text for Technical Report 2</h2>

  <div class="std">
    <h2>0 Containers <span class="section-id">[tr.cont]</span></h2>

    <h3>0.1 Hierarchy containers <span class=
    "section-id">[tr.hierarchy]</span></h3>

    <h4>0.1.1 Hierarchy container requirements <span class=
    "section-id">[tr.hierarchy.req]</span></h4>

    <ol>
      <li>
        <p>A hierarchy is an object that stores a finite set of objects, all
        of the same type, in a hierarchical manner. Hierarchies introduce a
        cursor concept for navigation instead of iterators. The library
        provides two kinds of hierarchies: <tt>binary_tree</tt>, and
        <tt>nary_tree</tt>.</p>
      </li>

      <li>
        <p>Hierarchy containers conform to the requirements of Containers
        ([lib.container.requirements]), except that the expressions in Table
        1 are not required to be valid, where <tt>a</tt> and <tt>b</tt>
        denote values of a type <tt>X</tt>, and <tt>X</tt> is a hierarchy
        container class:</p>

        <table summary=
        "Container requirements that are not required for hierarchy containers"
        class="reqmts">
          <caption>
            Table 1: Container requirements that are not required for
            hierarchy containers
          </caption>

          <thead>
            <tr>
              <th>unsupported expression</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::iterator</tt></td>
            </tr>

            <tr>
              <td><tt>X::const_iterator</tt></td>
            </tr>

            <tr>
              <td><tt>a.begin()</tt></td>
            </tr>

            <tr>
              <td><tt>a.end()</tt></td>
            </tr>

            <tr>
              <td><tt>a &lt; b</tt></td>
            </tr>

            <tr>
              <td><tt>a &gt; b</tt></td>
            </tr>

            <tr>
              <td><tt>a &lt;= b</tt></td>
            </tr>

            <tr>
              <td><tt>a &gt;= b</tt></td>
            </tr>
          </tbody>
        </table>
      </li>

      <li>
        <p>Non-constant complexity requirements in this clause are stated in
        one of two different ways: unless specified otherwise, they are
        expressed in terms of the number of operations <tt>n</tt>, which
        stands for the total number of elements in the hierarchy; or in terms
        of the number of operations <tt>c</tt>, which stands for the number
        of child elements of a given element.</p>
      </li>

      <li>
        <p>In Table 2: <tt>X</tt> denotes a hierarchy class containing
        objects of type <tt>T</tt> and <tt>a</tt> denotes a value of type
        X.</p>

        <table summary="Hierarchy requirements (in addition to container)"
        class="reqmts">
          <caption>
            Table 2 - Hierarchy requirements (in addition to container)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>assertion/note<br />
              pre/post-condition</th>

              <th>complexity</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::cursor</tt></td>

              <td>cursor type pointing to <tt>T</tt></td>

              <td>any cursor category</td>

              <td>compile time</td>
            </tr>

            <tr>
              <td><tt>X::const_cursor</tt></td>

              <td>cursor type pointing to <tt>const T</tt></td>

              <td>any cursor category</td>

              <td>compile time</td>
            </tr>

            <tr>
              <td><tt>a.root()</tt></td>

              <td><tt>iterator</tt> for mutable <tt>a</tt>;<br />
              <tt>const_iterator</tt> for constant <tt>a</tt></td>

              <td></td>

              <td>constant</td>
            </tr>

            <tr>
              <td><tt>a.croot()</tt></td>

              <td><tt>const_iterator</tt></td>

              <td></td>

              <td>constant</td>
            </tr>

            <tr>
              <td><tt>a.shoot()</tt></td>

              <td><tt>iterator</tt> for mutable <tt>a</tt>;<br />
              <tt>const_iterator</tt> for constant <tt>a</tt></td>

              <td></td>

              <td>(Note A)</td>
            </tr>

            <tr>
              <td><tt>a.cshoot()</tt></td>

              <td><tt>const_iterator</tt></td>

              <td></td>

              <td>(Note A)</td>
            </tr>
          </tbody>
        </table>

        <p>Notes: Those entries marked "(Note A)" should have at worst linear
        complexity. See the individual hierarchy containers for specific
        complexity.</p>
      </li>

      <li>
        <p><tt>root()</tt> and <tt>croot()</tt> returns a cursor referring to
        the uppermost element in the hierarchy. <tt>shoot()</tt> returns a
        cursor which is the past-the-end value that is found one past the
        hierarchy's rightmost element. If the hierarchy is empty, then
        <tt>root() == shoot()</tt>;</p>
      </li>

      <li>
        <p>Copy constructors for all hierarchy types defined in this clause
        copy the allocator argument from their respective first parameters.
        All other constructors for these hierarchy types take an
        <tt>Allocator&amp;</tt> argument (20.1.5). A copy of this argument is
        used for any memory allocation performed, by these constructors and
        by all member functions, during the lifetime of each hierarchy
        object. In all hierarchy types defined in this clause, the member
        <tt>get_allocator()</tt> returns a copy of the Allocator object used
        to construct the hierarchy.</p>
      </li>

      <li>
        <p>In Table 3, <tt>X</tt> denotes a hierarchy class, <tt>a</tt>
        denotes a value of <tt>X</tt>, <tt>p</tt> denotes a valid, non-on-top
        cursor to <tt>a</tt>, <tt>q</tt> denotes a valid, dereferenceable
        cursor to <tt>a</tt>, and <tt>t</tt> denotes a value of
        <tt>X::value_type</tt>.</p>

        <table summary="Mutable hierarchy requirements" class="reqmts">
          <caption>
            Table 3: Mutable hierarchy requirements
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>assertion/note<br />
              pre/post-condition</th>

              <th>complexity</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>a.insert(p,t)</tt></td>

              <td><tt>cursor</tt></td>

              <td>inserts a copy of <tt>t</tt> in the position indicated by
              <tt>p</tt></td>

              <td>(Note A)</td>
            </tr>

            <tr>
              <td><tt>a.clear(q)</tt></td>

              <td><tt>void</tt></td>

              <td>erases the subtree of <tt>q</tt></td>

              <td>(Note A)</td>
            </tr>

            <tr>
              <td><tt>a.clear()</tt></td>

              <td><tt>void</tt></td>

              <td><tt>a.clear(a.root());</tt><br />
              post: <tt>a.size() == 0</tt></td>

              <td>(Note A)</td>
            </tr>
          </tbody>
        </table>

        <p>Notes: Those entries marked "(Note A)" should have at worst linear
        complexity. See the individual hierarchy containers for specific
        complexity.</p>
      </li>

      <li>The actual semantics of the <tt>insert</tt> 
      <!--and <tt>erase</tt>--> expression is hierarchy dependent. Depending
      on whether or not the previous hierarchy structure is always kept as an
      invariant, also after an insertion (only with an element added in the
      position specified by the <tt>p</tt> or <tt>q</tt> parameters, as in
      Table 3), hierarchies are further categorized as <em>unbalanced</em>
      and <em>balanced</em> ones.</li>

      <li><em>Balanced Hierarchies</em> satisfy both Hierarchy as well as
      Sequence requirements (see clause 23.1.1). Contrarily to unbalanced
      hierarchies, their hierarchical structure may change upon modification,
      as long as the linear order defined by their iterator types and
      corresponding functions is retained.</li>

      <li>For a given balanced hierarchy class <tt>X</tt>,
      <tt>X::iterator</tt> must be convertible to <tt>X::cursor</tt>, and
      <tt>X::const_iterator</tt> must be convertible to
      <tt>X::const_cursor</tt>; and vice versa. If the respective
      <tt>iterator</tt> or <tt>const_iterator</tt> is valid and
      dereferenceable, the <tt>cursor</tt> or <tt>const_cursor</tt> resulting
      from the conversion will also be valid and dereferenceable; and vice
      versa.</li>

      <li>As in some cases there might be interest to store additional
      information along with the client data in the tree that is
      automatically updated whenever the tree is modified, depending on
      either the client data, the tree structure, or both, a tree can be
      <em>augmented</em> in which case it will perform operations to effect
      this behavior.</li>

      <li>Data which is not directly passed by the user but governed by a
      given balancer or augmentor is called <em>metadata</em>.</li>
    </ol>

    <h4>0.1.2 Hierarchy container classes <span class=
    "section-id">[tr.hierarchy.tree]</span></h4>

    <h5>0.1.2.1 Header &lt;tree&gt; synopsis <span class=
    "section-id">[tr.hierarchy.syn.tree]</span></h5>
    <pre>
namespace std {
namespace tr2 {
} <i>// namespace tr2</i>
} <i>// namespace std</i>
</pre>

    <h5>0.1.2.2 Header &lt;binary_tree&gt; synopsis <span class=
    "section-id">[tr.hierarchy.syn.bintree]</span></h5>
    <pre>
namespace std {
namespace tr2 {
  <i>// Class template binary_tree</i>
  template &lt;
    class T,
    class Balance = std::tr2::tree::balancers::unbalanced,
    class Augment = std::tr2::tree::augmentors::unaugmented,
    class Alloc = std::allocator&lt;T&gt;
    &gt;
  class binary_tree;
} <i>// namespace tr2</i>
} <i>// namespace std</i>
</pre>

    <h4>0.1.2.2 Class template <tt>binary_tree</tt></h4>
    <pre>
namespace std {
namespace tr2 {
  template &lt;
    class T,
    class Balance = std::tr2::tree::balancers::unbalanced,
    class Augment = std::tr2::tree::augmentors::unaugmented,
    class Alloc = std::allocator&lt;T&gt;
    &gt;
  class binary_tree
  {
  public:
    <i>// types:</i>
    typedef T                                             value_type;
    typedef Balance                                       balancer_type;
    typedef Augment                                       augmentor_type;
    typedef Alloc                                         allocator_type;

    typedef <i>implementation defined</i>                        cursor;
    typedef <i>implementation defined</i>                        const_cursor;

    typedef std::tr2::inorder::iterator&lt;cursor&gt;           iterator;
    typedef std::tr2::inorder::iterator&lt;const_cursor&gt;     const_iterator;

    typedef std::reverse_iterator&lt;iterator&gt;               reverse_iterator;
    typedef std::reverse_iterator&lt;const_iterator&gt;         const_reverse_iterator;

    typedef typename allocator_type::pointer              pointer;
    typedef typename allocator_type::const_pointer        const_pointer;
    typedef typename allocator_type::reference            reference;
    typedef typename allocator_type::const_reference      const_reference;
    typedef typename allocator_type::size_type            size_type;
    typedef typename allocator_type::difference_type      difference_type;

    <i>// construct/copy/destroy:</i>
    explicit binary_tree (allocator_type const&amp; = allocator_type());
    explicit binary_tree (size_type n, value_type const&amp; value = value_type(),
      allocator_type const&amp; = allocator_type());
    template &lt;class InputIterator&gt;
      binary_tree (InputIterator first, InputIterator last,
        allocator_type const&amp; = allocator_type());
    binary_tree (binary_tree&lt;T, Balance, Augment, Alloc&gt; const&amp; x);
    ~binary_tree();
    binary_tree&lt;T, Balance, Augment, Alloc&gt;&amp; operator=(
      binary_tree&lt;T, Balance, Augment, Alloc&gt; const&amp; x);
    template &lt;class InputIterator&gt;
      void assign(InputIterator first, InputIterator last);
    template &lt;class Size, class T&gt;
      void assign(Size n, const T&amp; t = T());
    allocator_type get_allocator() const;

    <i>// cursors:</i>
    cursor        root();
    const_cursor  croot() const;
    cursor        shoot();
    const_cursor  cshoot() const;

    <i>// iterators:</i>
    iterator                begin();
    const_iterator          cbegin() const;
    iterator                end();
    const_iterator          cend() const;
    reverse_iterator        rbegin();
    const_reverse_iterator  crbegin() const;
    reverse_iterator        rend();
    const_reverse_iterator  crend() const;

    <i>// capacity:</i>
    bool      empty() const;
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, T c = T());

    <i>// element access:</i>
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    <i>// modifiers:</i>
    void      push_front(const T&amp; x);
    void      push_back(const T&amp; x);
    cursor    insert(cursor position, value_type const&amp; x = value_type());
    iterator  insert(iterator position, value_type const&amp; x = value_type());
    void      insert(iterator position, size_type n, value_type const&amp; x);
    template &lt;class InputIterator&gt;
      void    insert (iterator position, InputIterator first, InputIterator last);
    void      pop_front();
    void      pop_back();
    iterator  erase(iterator position);
    iterator  erase(iterator first, iterator last);
    void      swap(binary_tree&lt;Tp, Balance, Augment, Alloc&gt;&amp;);
    void      clear(cursor position);
    void      clear();
  };

  template &lt;class Tp, class Balance, class Augment, class Alloc&gt;
    bool operator==(  binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; x,
                      binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; y);
  template &lt;class Tp, class Balance, class Augment, class Alloc&gt;
    bool operator&lt; (  binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; x,
                      binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; y);
  template &lt;class Tp, class Balance, class Augment, class Alloc&gt;
    bool operator!=(  binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; x,
                      binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; y);
  template &lt;class Tp, class Balance, class Augment, class Alloc&gt;
    bool operator&gt; (  binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; x,
                      binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; y);
  template &lt;class Tp, class Balance, class Augment, class Alloc&gt;
    bool operator&gt;=(  binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; x,
                      binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; y);
  template &lt;class Tp, class Balance, class Augment, class Alloc&gt;
    bool operator&lt;=(  binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; x,
                      binary_tree&lt;Tp, Balance, Augment, Alloc&gt; const&amp; y);

  <i>// specialized algorithms:</i>
  template &lt;class Tp, class Balance, class Augment, class Alloc&gt;
  void swap(  binary_tree&lt;Tp, Balance, Augment, Alloc&gt;&amp; x,
              binary_tree&lt;Tp, Balance, Augment, Alloc&gt;&amp; y);
} <i>// namespace tr2</i>
} <i>// namespace std</i>
</pre>

    <h4>0.1.2.3 Hierarchy adaptors</h4>

    <ol>
      <li>
        <p>The hierarchy adaptors each take a Hierarchy template parameter,
        and each constructor takes a Hierarchy reference argument. This
        hierarchy is copied into the Hierarchy member of each adapter.</p>
      </li>
    </ol>

    <h5>0.1.2.3.1 Template class <tt>forest</tt></h5>

    <ol>
      <li>
        <p>A <tt>forest</tt> is a kind of modifiable, unbalanced hierarchy
        that is instantiated with another modifiable, unbalanced hierarchy
        whose cursor class provides <tt>begin()</tt>, <tt>end()</tt> and
        <tt>parent()</tt> operations. [...]</p>
        <pre>
namespace std {
namespace tr2 {
  template &lt;class T, class Hierarchy = binary_tree&lt;T&gt; &gt;
  class forest {
  public:
    typedef typename Hierarchy                            hierarchy_type;
    typedef typename hierarchy_type::value_type           value_type;
    typedef typename hierarchy_type::size_type            size_type;
  protected:
    hierarchy_type h;
    
  public:
    typedef typename forest_cursor&lt;typename hierarchy_type::cursor&gt;
                                                          cursor;
    typedef typename forest_cursor&lt;typename hierarchy_type::const_cursor&gt;
                                                          const_cursor;
    
    explicit forest(hierarchy_type const&amp; = hierarchy_type());
    
    bool      empty() const { return h.empty(); }
    size_type size() const  { return h.size(); }
    
    cursor        root()    { return h.root(); }
    const_cursor  croot()   { return h.croot(); }
  };
} <i>// namespace tr2</i>
} <i>// namespace std</i>
</pre>
      </li>
    </ol>

    <h5>0.1.2.3.2 Class template <tt>multiway_tree</tt></h5>

    <ol>
      <li>
        <p>A <tt>multiway_tree</tt> is [...]</p>
        <pre>
namespace std {
namespace tr2 {
  template &lt;class T, class Hierarchy&gt;
  class multiway_tree {
  public:
    typedef typename Hierarchy                            hierarchy_type;
    typedef typename T                                    value_type;
    typedef typename hierarchy_type::size_type            size_type;
  protected:
    hierarchy_type h;
    
  public:
    typedef typename multiway_cursor&lt;typename hierarchy_type::cursor&gt;
                                                          cursor;
    typedef typename multiway_cursor&lt;typename hierarchy_type::const_cursor&gt;
                                                          const_cursor;
    
    explicit multiway_tree(hierarchy_type const&amp; = hierarchy_type());
    
    bool      empty() const { return h.empty(); }
    size_type size() const  { return h.size(); }
    
    cursor        root()    { return h.root(); }
    const_cursor  croot()   { return h.croot(); }
  };
}
} <i>// namespace tr2</i>
} <i>// namespace std</i>
</pre>
      </li>
    </ol>

    <h3>0.2 Cursors <span class="section-id">[tr.cursors]</span></h3>

    <ol>
      <li>Cursors provide a uniform way of applying algorithms to
      hierarchical data structures. In order to also allow for algorithms
      relevant when dealing with linear data structures, any cursor class is
      actually a refinement of a corresponding iterator class. 
      <!--whose traversal
            related capabilities map to traversal of among a given cursor's
            immediate descendants or "child cursors" (or just "children", as
            defined in the following paragraph).--></li>

      <li>If exactly one application of the expression <tt>i =
      i.begin()</tt>, followed by a finite sequence of applications of the
      expression <tt>++j</tt> makes <tt>i == j</tt>, <tt>j</tt> is a
      <em>child</em> (or <em>immediate descendant</em> ) of <tt>i</tt>, and
      <tt>i</tt> is the <em>parent</em> (or the <em>immediate ancestor</em>)
      of <tt>j</tt>. A cursor <tt>j</tt> is another cursor <tt>i</tt>'s
      <tt>descendant</tt> if there is a finite sequential combination of
      applications of either of the expressions <tt>++i</tt> and <tt>i =
      i.begin()</tt> that makes <tt>i == j</tt>; <tt>i</tt> is then called
      <tt>j</tt>'s ancestor. If two cursors <tt>i</tt> and <tt>j</tt> share
      at least one common ancestor, they refer to the same container. The
      descending traversal capabilites of a class relate to the range of
      children of a given instance of that class.</li>

      <li>In additon to a cursor's descending traversal tags, two of them are
      reused to indicate a cursor's ascending traversal abilities, namely
      <em>forward</em> and <em>bidirectional</em> traversal in order to
      indicate whether a given cursor provides traversal to the parent.</li>

      <li>Apart from cursors that are <em>past-the-end</em> (like their
      iterator counterparts can be), the notion of a cursor <em>on-top</em>
      is introduced, denoting a cursor that is ancestor to all other cursors
      within a hierarchy is introduced; and just as for past-the-end ones,
      the library generally does not assume on-top cursors be
      dereferenceable; nor that they be incrementable or decrementable unless
      stated otherwise in a given hierarchy's requirement specifications. 
      <!--In other words, as opposed to
            non-on-top cursurs, on-top cursors fulfill only the Range concept
            requirements, but not any Iterator concept requirements.--></li>

      <li>A cursor <tt>i</tt> for which <tt>i.emtpy() == true</tt> is called
      <em>leaf cursor</em>. A leaf cursor's children are never assumed to be
      dereferenceable.</li>

      <li>A cursor, like an iterator, can have a singular value that is not
      associated with any hierarchy, meaning that most expressions are
      undefined for it, with the exception of assignment of a non-singular
      value to a cursor that holds a singular value. The children of a leaf
      cursor's child are never assumed to be non-singular; nor is the parent
      of an on-top node.</li>

      <li>
        <p>In the following sections <tt>X</tt> denotes a cursor over values
        of type <tt>T</tt>, <tt>a</tt> and <tt>b</tt> denotes an identifier,
        <tt>r</tt> denotes a value of <tt>T&amp;</tt> and <tt>t</tt> denotes
        a value of type <tt>T</tt>.</p>
      </li>
    </ol>

    <h4>0.2.1 Cursor <span class=
    "section-id">[tr.cursor.requirements]</span></h4>

    <ol>
      <li>
        <p>A class <tt>X</tt> satisfies the requirements of a cursor if the
        following expressions are valid, as show in Table 4, in addition to
        satifying the requirements of input iterators
        (<tt>[lib.input.iterators]</tt>) and output iterators
        (<tt>[lib.output.iterators]</tt>):</p>

        <table summary=
        "Cursor requirements (in addition to input and output iterators)"
        class="reqmts">
          <caption>
            Table 4 - Cursor requirements (in addition to input and output
            iterators)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>operational sematics</th>

              <th>assertion/note<br />
              pre/post-condition</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::value_type</tt></td>

              <td>T</td>

              <td>Any non-reference, non-cv-qualified type</td>

              <td>compile time</td>
            </tr>

            <tr>
              <td><tt>X::type</tt></td>

              <td>Convertible to <tt>cursor_tag</tt>,
              <tt>input_iterator_tag</tt>, and
              <tt>output_iterator_tag</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>

            <tr>
              <td><tt>X::cursor</tt></td>

              <td>Convertible to <tt>X</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>

            <tr>
              <td><tt>X::const_cursor</tt></td>

              <td>Convertible to <tt>const X</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>

            <tr>
              <td><tt>X::metadata_type</tt></td>

              <td></td>

              <td>Any non-reference, non-cv-qualified type</td>

              <td>compile time</td>
            </tr>

            <tr>
              <td><tt>a.parity()</tt></td>

              <td><tt>size_type</tt></td>

              <td></td>

              <td>?</td>
            </tr>

            <tr>
              <td><tt>a.metadata()</tt></td>

              <td><tt>metadata_type &amp;</tt>; <tt>metadata_type const
              &amp;</tt> for constant a</td>

              <td></td>

              <td>constant</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ol>

    <h5>0.2.1.1 Descending Cursor <span class=
    "section-id">[tr.descending.cursors]</span></h5>

    <ol>
      <li>
        <p>A class <tt>X</tt> satisfies the requirements of a descending
        cursor if, in addition to satisfying the requirements for cursors
        ([tr.cursor.requirements]) the following expression are valid, as
        shown in Table 5:</p>

        <table summary=
        "Descending cursor requirements (in addition to cursor)" class=
        "reqmts">
          <caption>
            Table 5 - Descending cursor requirements (in addition to cursor)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>operational sematics</th>

              <th>assertion/note<br />
              pre/post-condition</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::type</tt></td>

              <td>Convertible to <tt>descending_cursor_tag</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>

            <tr>
              <td><tt>a.begin()</tt></td>

              <td><tt>cursor</tt> or <tt>const_cursor</tt> for constant
              a</td>

              <td></td>

              <td>constant</td>
            </tr>

            <tr>
              <td><tt>a.end()</tt></td>

              <td><tt>cursor</tt> or <tt>const_cursor</tt> for constant
              a</td>

              <td></td>

              <td>constant</td>
            </tr>

            <tr>
              <td><tt>a.cbegin()</tt></td>

              <td><tt>const_cursor</tt></td>

              <td></td>

              <td>constant</td>
            </tr>

            <tr>
              <td><tt>a.cend()</tt></td>

              <td><tt>const_cursor</tt></td>

              <td></td>

              <td>constant</td>
            </tr>
          </tbody>
        </table>
      </li>

      <li>
        <p>Additionaly a descending cursors conform to the container
        requirements (<tt>[lib.container.requirements]</tt>) with the
        exception of the following expressions:</p>

        <table summary="Container requirements that are not supported" class=
        "reqmts">
          <caption>
            Table 6 - Container requirements that are not supported
          </caption>

          <thead>
            <tr>
              <th>unsupported expression</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>(&amp;a)-&gt;~X();</tt></td>
            </tr>

            <tr>
              <td><tt>X(a);</tt></td>
            </tr>

            <tr>
              <td><tt>X u(a);<br />
              X u = a;</tt></td>
            </tr>

            <tr>
              <td><tt>a.begin()</tt></td>
            </tr>

            <tr>
              <td><tt>a.end()</tt></td>
            </tr>

            <tr>
              <td><tt>a == b</tt></td>
            </tr>

            <tr>
              <td><tt>a != b</tt></td>
            </tr>

            <tr>
              <td><tt>a.swap(b)</tt></td>
            </tr>

            <tr>
              <td><tt>r = a</tt></td>
            </tr>

            <tr>
              <td><tt>a &lt; b</tt></td>
            </tr>

            <tr>
              <td><tt>a &gt; b</tt></td>
            </tr>

            <tr>
              <td><tt>a &lt;= b</tt></td>
            </tr>

            <tr>
              <td><tt>a &gt;= b</tt></td>
            </tr>
          </tbody>
        </table>

        <p>Notes: The expressions <tt>a.begin()</tt> and <tt>a.end()</tt>
        are, as shown in Table 5, replaced with equivalent expressions for
        cursors.</p>
      </li>
    </ol>

    <h5>0.2.1.2 Descending Forward Cursor <span class=
    "section-id">[tr.descending.forward.cursors]</span></h5>

    <ol>
      <li>
        <p>A class type <tt>X</tt> satisfies the requirements of a descending
        forward cursor if the following expressions are valid, as shown in
        Table 7, in addition to the requirements of descending cursors
        ([tr.descending.cursors]) and forward iterators
        ([lib.forward.iterators]):</p>

        <table summary=
        "Descending forward cursor requirements (in addition to descending cursors and forward iterators)"
        class="reqmts">
          <caption>
            Table 7 - Descending forward cursor requirements (in addition to
            descending cursors and forward iterators)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>operational sematics</th>

              <th>assertion/note<br />
              pre/post-condition</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::type</tt></td>

              <td>Convertible to <tt>descending_forward_cursor_tag</tt> and
              <tt>forward_iterator_tag</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ol>

    <h5>0.2.1.3 Descending Bidirectional Cursor <span class=
    "section-id">[tr.descending.bidirectional.cursors]</span></h5>

    <ol>
      <li>
        <p>A class type <tt>X</tt> satisfies the requirements of a descending
        bidirectional cursor if the following expressions are valid, as show
        in Table 8, in addition to satisfying the requirements for descending
        forward cursors ([tr.descending.forward.cursors]) and bidirectional
        iterators ([lib.bidirectional.iterators]):</p>

        <table summary=
        "Descending bidirectional cursor requirements (in addition to descending forward cursors and bidirectional iterators)"
        class="reqmts">
          <caption>
            Table 8 - Descending bidirectional cursor requirements (in
            addition to forward descending cursors and bidirectional
            iterators)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>operational sematics</th>

              <th>assertion/note<br />
              pre/post-condition</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::type</tt></td>

              <td>Convertible to <tt>descending_bidirectional_cursor_tag</tt>
              and <tt>bidirectional_iterator_tag</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ol>

    <h5>0.2.1.4 Descending Random Access Cursor <span class=
    "section-id">[tr.descending.random.access.cursors]</span></h5>

    <ol>
      <li>
        <p>A class type <tt>X</tt> satisfies the requirements of a descending
        random access cursor if the following expressions are valid, as shown
        in Table 9, in addition to satisfying the requirements for descending
        bidirectional cursors ([tr.descending.bidirectional.cursors]) and
        random access iterators ([lib.random.access.iterators]):</p>

        <table summary=
        "Descending random access cursor requirements (in addition to descending bidirectional cursors and random access iterators)"
        class="reqmts">
          <caption>
            Table 9 - Descending random access cursor requirements (in
            addition to descending bidirectional cursors and random access
            iterators)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>operational sematics</th>

              <th>assertion/note<br />
              pre/post-condition</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::type</tt></td>

              <td>Convertible to <tt>descending_random_access_cursor_tag</tt>
              and <tt>random_access_iterator_tag</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ol>

    <h5>0.2.1.5 Ascending Cursor <span class=
    "section-id">[tr.ascending.cursors]</span></h5>

    <ol>
      <li>
        <p>A class type <tt>X</tt> satisfies the requirements of an ascending
        cursor if the following expressions are valid, as shown in Table 10,
        in addition to satisfying the requirements for descending cursors
        ([tr.descending.cursors]):</p>

        <table summary=
        "Acending cursor requirements (in addition to descending cursors)"
        class="reqmts">
          <caption>
            Table 10 - Acending cursor requirements (in addition to
            descending cursors)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>operational sematics</th>

              <th>assertion/note<br />
              pre/post-condition</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::type</tt></td>

              <td>Convertible to <tt>ascending_cursor_tag</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>

            <tr>
              <td><tt>a.parent()</tt></td>

              <td><tt>cursor</tt>; <tt>const_cursor</tt> for a constant
              <tt>a</tt></td>

              <td></td>

              <td>(Note A)</td>
            </tr>

            <tr>
              <td><tt>!r</tt></td>

              <td><tt>X&amp;</tt></td>

              <td><tt>r = r.parent();</tt></td>

              <td>pre: <tt>r</tt> is dereferenceable.<br />
              post: <tt>r</tt> is dereferenceable or <tt>r</tt> is
              on-top.<br />
              <tt>r == s</tt> and <tt>r</tt> is dereferenceable implies
              <tt>!r == !s</tt>.<br />
              <tt>&amp;r == &amp;</tt><br />
              (Note A)</td>
            </tr>
          </tbody>
        </table>

        <p>Notes: Those entries marked "(Note A)" should have at worst linear
        complexity. See the individual hierarchy containers for specific
        complexity.</p>
      </li>
    </ol>

    <h5>0.2.1.6 Ascending Forward Cursor <span class=
    "section-id">[tr.ascending.forward.cursors]</span></h5>

    <ol>
      <li>
        <p>A class type X satisfies the requirements of an ascending forward
        cursor if the following expressions are valid, as shown in Table 11,
        in addition to satisfying the requirements for ascending cursors
        ([tr.ascending.cursors]) and descending forward cursors
        ([tr.descending.forward.cursors]):</p>

        <table summary=
        "Ascending forward cursor requirements (in addition to ascending cursors and descending forward cursors)"
        class="reqmts">
          <caption>
            Table 11 - Ascending forward cursor requirements (in addition to
            ascending cursors and descending forward cursors)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>operational sematics</th>

              <th>assertion/note<br />
              pre/post-condition</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::type</tt></td>

              <td>Convertible to <tt>ascending_forward_cursor_tag</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ol>

    <h5>0.2.1.7 Ascending Bidirectional Cursor <span class=
    "section-id">[tr.ascending.bidirectional.cursors]</span></h5>

    <ol>
      <li>
        <p>A class type X satisfies the requirements of an ascending
        bidirectional cursor if the following expressions are valid, as shown
        in Table 12, in addition to satisfying the requirements of ascending
        forward cursors ([tr.ascending.forward.cursors]) and descending
        bidirectional cursors ([tr.descending.bidirectional.cursors]):</p>

        <table summary=
        "Ascending bidirectional cursor requirements (in addition to ascending forward cursors and descending bidirectional cursors)"
        class="reqmts">
          <caption>
            Table 12 - Ascending bidirectional cursor requirements (in
            addition to ascending forward cursors and descending
            bidirectional cursors)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>operational sematics</th>

              <th>assertion/note<br />
              pre/post-condition</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::type</tt></td>

              <td>Convertible to
              <tt>ascending_bidirectional_cursor_tag</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ol>

    <h5>0.2.1.8 Ascending Random Access Cursor <span class=
    "section-id">[tr.ascending.random.access.cursors]</span></h5>

    <ol>
      <li>
        <p>A class type <tt>X</tt> satisfies the requirements of an ascending
        random access cursor if the following expressions are valid, as shown
        in Table 9, in addition to satisfying the requirements for ascending
        bidirectional cursors ([tr.ascending.bidirectional.cursors]) and
        descending random access cursors
        ([tr.descending.random.access.cursors]):</p>

        <table summary=
        "Ascending random access cursor requirements (in addition to ascending bidirectional cursors and descending random access cursors)"
        class="reqmts">
          <caption>
            Table 9 - Ascending random access cursor requirements (in
            addition to ascending bidirectional cursors and descending random
            access cursors)
          </caption>

          <thead>
            <tr>
              <th>expression</th>

              <th>return type</th>

              <th>operational sematics</th>

              <th>assertion/note<br />
              pre/post-condition</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><tt>X::type</tt></td>

              <td>Convertible to
              <tt>ascending_random_access_cursor_tag</tt></td>

              <td></td>

              <td>compile time</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ol>

    <h4>0.2.2 Header <tt>&lt;cursor&gt;</tt> synopsis <span class=
    "section-id">[tr.cursor.synopsis]</span></h4>
    <pre>
namespace std {
namespace tr2 {
  template &lt;class Cursor&gt; struct cursor_value;
  template &lt;class Cursor&gt; struct cursor_reference;
  template &lt;class Cursor&gt; struct cursor_const_reference;
  template &lt;class Cursor&gt; struct cursor_pointer;
  template &lt;class Cursor&gt; struct cursor_difference;
  template &lt;class Cursor&gt; struct cursor_size;
  template &lt;class Cursor&gt; struct cursor_category;

  template &lt;class Cat, class T, class Dist = ptrdiff_t, class Size = size_t,
            class Ptr = T*, class Ref = T&amp;&gt; struct cursor;


  struct cursor_tag 
    : public input_iterator_tag, public output_iterator_tag {};
  struct descending_cursor_tag
    : public cursor_tag {};
  struct descending_forward_cursor_tag
    : public descending_cursor_tag, public forward_iterator_tag {};
  struct descending_bidirectional_cursor_tag
    : public descending_cursor_tag, public bidirectional_iterator_tag {};
  struct descending_random_access_cursor_tag
    : public descending_cursor_tag, public random_access_iterator_tag {};
  struct ascending_cursor_tag
        : public descending_cursor_tag {};
  struct ascending_forward_cursor_tag
    : public descending_forward_cursor_tag {};
  struct ascending_bidirectional_cursor_tag
    : public descending_bidirectional_cursor_tag {};
  struct ascending_random_access_cursor_tag
    : public descending_random_access_cursor_tag {};
} <i>// namespace tr2</i>
} <i>// namespace std</i>
</pre>

    <h4>0.2.3 Cursor primitives<span class=
    "section-id">[tr.cursor.primitives]</span></h4>

    <ol>
      <li>To simplify the task of defining cursors, the library provides
      several classes and functions:</li>
    </ol>

    <h5>0.2.3.1 Cursor traits<span class=
    "section-id">[tr.cursor.traits]</span></h5>

    <ol>
      <li>The following classes are required to be defined appropriately for
      a cursor of type <tt>Cursor</tt>:
        <pre>
  template &lt;class Cursor&gt; struct cursor_value {
        typedef typename Cursor::value_type type;
  };

  template &lt;class Cursor&gt; struct cursor_reference {
        typedef typename Cursor::reference type;
  };

  template &lt;class Cursor&gt; struct cursor_const_reference {
        typedef typename Cursor::const_reference type;
  };

  template &lt;class Cursor&gt; struct cursor_pointer {
        typedef typename Cursor::pointer type;
  };

  template &lt;class Cursor&gt; struct cursor_difference {
        typedef typename Cursor::difference_type type;
  };

  template &lt;class Cursor&gt; struct cursor_size {
        typedef typename Cursor::size_type type;
  };

  template &lt;class Cursor&gt; struct cursor_category {
        typedef typename Cursor::cursor_category type;
  };
        
</pre>
      </li>
    </ol>

    <h5>0.2.3.2 Basic cursor<span class=
    "section-id">[tr.cursor.basic]</span></h5>

    <ol>
      <li>The <tt>cursor</tt> template may be used as a base class to ease
      the definition of required types for new cursors.
        <pre>
template &lt;class Cat, class T, class Dist = ptrdiff_t, class Size = size_t,
          class Ptr = T*, class Ref = T&amp;&gt;
struct cursor {
        typedef Cat     cursor_category;
        typedef T       value_type;
        typedef Dist        difference_type;
        typedef Size        size_type;
        typedef Ptr     pointer;
        typedef Ref     reference;      
};
        
</pre>
      </li>
    </ol>

    <h5>0.2.3.3 Standard cursor tags<span class=
    "section-id">[tr.cursor.tags]</span></h5>

    <ol>
      <li>Cursor tags pick up the notion of iterator tags (24.3.3) and extend
      them by adding information about a given cursor class' descending or
      ascending traversal capabilities (0.2.1). This yields the cursor tags
      <tt>cursor_tag</tt>, <tt>descending_cursor_tag</tt>,
      <tt>descending_forward_cursor_tag</tt>,
      <tt>descending_bidirectional_cursor_tag</tt>,
      <tt>descending_random_access_cursor_tag</tt>,
      <tt>ascending_cursor_tag</tt>, <tt>ascending_forward_cursor_tag</tt>,
      <tt>ascending_bidirectional_cursor_tag</tt> and
      <tt>ascending_random_access_cursor_tag</tt>. For every cursor of type
      <tt>Cursor</tt>, <tt>cursor_category&lt;Cursor&gt;::type</tt> must be
      defined to be the most specific category tag that describes the
      cursor's behavior.
        <pre>
namespace std {
namespace tr2 {
  struct cursor_tag 
    : public input_iterator_tag, public output_iterator_tag {};
  struct descending_cursor_tag
    : public cursor_tag {};
  struct descending_forward_cursor_tag
    : public descending_cursor_tag, public forward_iterator_tag {};
  struct descending_bidirectional_cursor_tag
    : public descending_cursor_tag, public bidirectional_iterator_tag {};
  struct descending_random_access_cursor_tag
    : public descending_cursor_tag, public random_access_iterator_tag {};
  struct ascending_cursor_tag
        : public descending_cursor_tag {};
  struct ascending_forward_cursor_tag
    : public descending_forward_cursor_tag {};
  struct ascending_bidirectional_cursor_tag
    : public descending_bidirectional_cursor_tag {};
  struct ascending_random_access_cursor_tag
    : public descending_random_access_cursor_tag {};
} // namespace tr2
} // namespace std
        
</pre>
      </li>
    </ol>

    <h3>24.2 Header <tt>&lt;iterator&gt;</tt> synopsis <span class=
    "section-id">[lib.iterator.synsopsis]</span></h3>

    <div class="note">
      Append to section introduced with <i>// subclause 24.4, predefined
      iterators:</i>
    </div>
    <pre>
  namespace tr2 {
  namespace preorder {
  template &lt;class Cursor&gt; class iterator;
  
  template &lt;class Cursor&gt;
  bool operator==(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);

  template &lt;class Cursor&gt;
  bool operator!=(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);
  } // namespace preorder   

  namespace postorder {
  template &lt;class Cursor&gt; class iterator;
  
  template &lt;class Cursor&gt;
  bool operator==(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);

  template &lt;class Cursor&gt;
  bool operator!=(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);
  } // namespace postorder   

  namespace inorder {
  template &lt;class Cursor&gt; class iterator;
  
  template &lt;class Cursor&gt;
  bool operator==(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);

  template &lt;class Cursor&gt;
  bool operator!=(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);
  } // namespace inorder   
  } // namespace tr2
  
</pre>

    <h4>24.4.X Linear order traversal iterators <span class=
    "section-id">[tr.order.iterators]</span></h4>

    <ol>
      <li>For linear traversal of hierarchies, the library offers a number of
      useful predefined iterators, namely for <tt>preorder</tt>,
      <tt>postorder</tt> and <tt>inorder</tt> traversal in namespaces named
      accordingly.</li>

      <li><em>Preorder traversal</em> means that after a given element, first
      the subtree to its left, then the one to its right will be
      visited.</li>

      <li><em>Postorder traversal</em> means that before a given element,
      first the subtree to its left, then the one to its right will be
      visited.</li>

      <li><em>Inorder traversal</em> means that a given element will be
      visited after the subtree to its left and before the one to its right
      will be visited.</li>

      <li>For each of the above kinds of traversal order, the library offers
      a kind of order traversal iterator adaptor template class whose
      template parameter is a bidirectional or random access (either
      ascending or descending) cursor class. Increment and decrement
      operations for these iterator adaptor classes are implemented to allow
      stepwise iteration according to the respective requirements. 
      <!--Additionally, for cursors with bidirectional vertical
            traversal property, algorithms <tt>forward</tt> and <tt>back</tt> in
            the respective namespaces are provided that set their argument cursor
            to the next or previous, resp., in the corresponding traversal
            order.--></li>
    </ol>

    <h5>24.4.X.1 Template class <tt>iterator</tt> <span class=
    "section-id">[tr.order.iterator]</span></h5>

    <ol>
      <li>
        <p>In the following, the template class <tt>iterator</tt> and related
        operators only as in <tt>namespace preorder</tt> are shown. Note that
        template classes and operators of same name and interface must also
        be present in <tt>namespace postorder</tt> as well as in
        <tt>namespace inorder</tt>.</p>
        <pre>
namespace std {
namespace tr2 {
namespace preorder {
  template &lt;class Cursor&gt;
  class iterator :
    public iterator&lt;typename iterator_traits&lt;Cursor&gt;::iterator_category,
                    typename iterator_traits&lt;Cursor&gt;::value_type,
                    typename iterator_traits&lt;Cursor&gt;::difference_type,
                    typename iterator_traits&lt;Cursor&gt;::pointer,
                    typename iterator_traits&lt;Cursor&gt;::reference&gt; {
  protected:
    Cursor current;
  public:
    typedef Cursor cursor_type;
    iterator();
    explicit iterator(Cursor x);
    
    Cursor base() const;         // explicit
    Reference operator*() const;
    Pointer   operator-&gt;() const;
    
    iterator&amp; operator++();
    iterator  operator++(int);
    iterator&amp; operator--();
    iterator  operator--(int);
  };

template &lt;class Cursor&gt;
  bool operator==(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);

template &lt;class Cursor&gt;
  bool operator!=(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);

} // namespace preorder
} // namespace tr2
} // namespace std
      
</pre>
      </li>
    </ol>

    <h5>24.4.X.2 Linear order <tt>iterator</tt> requirements <span class=
    "section-id">[tr.order.iter.requirements]</span></h5>

    <ol>
      <li>The template parameter <tt>Cursor</tt> shall meet all the
      requirements of a Forward Cursor.</li>

      <li>Additionally, <tt>Cursor</tt> shall meet the requirements of a
      Bidirectional Cursor (24.1.5) if the member <tt>operaror--</tt>
      (24.4.X.3.7) is referenced in a way that requires instantiation
      (14.7.1).</li>
    </ol>

    <h5>24.4.X.3 <tt>inorder::iterator</tt> operations <span class=
    "section-id">[tr.order.iter.ops]</span></h5>

    <h6>24.4.X.3.1 <tt>inorder::iterator</tt> constructor <span class=
    "section-id">[tr.order.iter.cons]</span></h6>
    <pre>
explicit iterator(Cursor x);
    
</pre>

    <ol>
      <li>Effects: Initializes <tt>current</tt> with <tt>x</tt>.</li>
    </ol>

    <h6>24.4.X.3.2 Conversion <span class=
    "section-id">[tr.order.iter.conv]</span></h6>
    <pre>
Iterator base() const; // explicit
    
</pre>

    <ol>
      <li>Returns: <tt>current</tt></li>
    </ol>

    <h6>24.4.X.3.3 <tt>operator*</tt> <span class=
    "section-id">[tr.order.iter.op.star]</span></h6>
    <pre>
Reference operator*() const;
    
</pre>

    <ol>
      <li>Returns: <tt>*current</tt></li>
    </ol>

    <h6>24.4.X.3.4 <tt>operator-&gt;</tt> <span class=
    "section-id">[tr.order.iter.opref]</span></h6>
    <pre>
Pointer operator-&gt;() const;
    
</pre>

    <ol>
      <li>Returns: <tt>&amp;(operator*())</tt></li>
    </ol>

    <h6>24.4.X.3.5 <tt>operator++</tt> <span class=
    "section-id">[tr.order.iter.op++]</span></h6>
    <pre>
iterator&amp; operator++() const;
    
</pre>

    <ol>
      <li>Effects: Sets <tt>current</tt> to the next cursor in the given
      order.</li>

      <li>Returns: <tt>*this</tt></li>
    </ol>
    <pre>
iterator operator++(int) const;
    
</pre>

    <ol>
      <li>Effects:
        <pre>
iterator tmp = *this;
this-&gt;operator++();
return tmp;
      
</pre>
      </li>
    </ol>

    <h6>24.4.X.3.6 <tt>operator--</tt> <span class=
    "section-id">[tr.order.iter.op--]</span></h6>
    <pre>
iterator&amp; operator++() const;
    
</pre>

    <ol>
      <li>Effects: Sets <tt>current</tt> to the previous cursor in the given
      order.</li>

      <li>Returns: <tt>*this</tt></li>
    </ol>
    <pre>
iterator operator--(int) const;
    
</pre>

    <ol>
      <li>Effects:
        <pre>
iterator tmp = *this;
this-&gt;operator--();
return tmp;
      
</pre>
      </li>
    </ol>

    <h6>24.4.X.3.7 <tt>operator==</tt> <span class=
    "section-id">[tr.order.iter.op==]</span></h6>
    <pre>
template &lt;class Cursor&gt;
  bool operator==(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);
    
</pre>

    <ol>
      <li>Returns: <tt>x.current == y.current</tt></li>
    </ol>

    <h6>24.4.X.3.8 <tt>operator!=</tt> <span class=
    "section-id">[tr.order.iter.op!=]</span></h6>
    <pre>
template &lt;class Cursor&gt;
  bool operator!=(
    const iterator&lt;Cursor&gt;&amp; x,
    const iterator&lt;Cursor&gt;&amp; y);
    
</pre>

    <ol>
      <li>Returns: <tt>x.current != y.current</tt></li>
    </ol>
  </div>

  <h2>References</h2>

  <dl>
    <dt><a id="ref.austern" name="ref.austern">[austern]</a></dt>

    <dd>Austern, Matthew H.; Stroustrup, Bjarne; Thorup, Mikkel; Wilikinson,
    John. <em>Untangling the Balancing and Searching of Balanced Binary
    Search Trees</em>, Software: Practice and Experience 33(13): 1273-1298
    (2003)<br />
    Electronic Appendix: <a href=
    "http://www.research.att.com/~bs/tree-appendix.pdf">http://www.research.att.com/~bs/tree-appendix.pdf</a></dd>

    <dt><a id="ref.dreizin" name="ref.dreizin">[dreizin]</a></dt>

    <dd>Dreizin, Vladimir; Kosnik, Benjamin; Tavory, Ami. <em>Policy-Based
    Data Structures</em>, <a href=
    "http://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/">http://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/</a></dd>

    <dt><a id="ref.ekman" name="ref.ekman">[ekman]</a></dt>

    <dd>Ekman, Rasmus. <em>Structured Associative Containers</em>, <a href=
    "http://www.abc.se/~re/code/tst">http://www.abc.se/~re/code/tst</a></dd>

    <dt><a id="ref.gottschlich" name="ref.gottschlich">[gottschlich]</a></dt>

    <dd>Gottschlich, Justin. <em>C++ Trees</em>, <a href=
    "http://www.gamedev.net/reference/articles/article2192.asp">http://www.gamedev.net/reference/articles/article2192.asp</a>
    and <a href=
    "http://www.gamedev.net/reference/articles/article2233.asp">http://www.gamedev.net/reference/articles/article2233.asp</a></dd>

    <dt><a id="ref.haas" name="ref.haas">[haas]</a></dt>

    <dd>Haas, Mitchell. <em>Tree Container Library</em>, <a href=
    "http://www.datasoftsolutions.net/tree_container_library/overview.php">http://www.datasoftsolutions.net/tree_container_library/overview.php</a></dd>

    <dt><a id="ref.karas" name="ref.karas">[karas]</a></dt>

    <dd>Karas, Walt. <em>C++ AVL Tree Template</em>, <a href=
    "http://us.geocities.com/wkaras/gen_cpp/avl_tree.html">http://us.geocities.com/wkaras/gen_cpp/avl_tree.html</a></dd>

    <dt><a id="ref.mirwaisi" name="ref.mirwaisi">[mirwais]</a></dt>

    <dd>Mirwaisi, Jeff. <em>treelib</em>, <a href=
    "https://boost-consulting.com:8443/trac/soc/attachment/wiki/tree/resources/trees/treelib.tar.bz2">
    https://boost-consulting.com:8443/trac/soc/attachment/wiki/tree/resources/trees/treelib.tar.bz2</a></dd>

    <dt><a id="ref.parent" name="ref.parent">[parent]</a></dt>

    <dd>Parent, Sean <i>et al</i>. <em>Forest</em>, <a href=
    "http://opensource.adobe.com/group__forest__related.html">http://opensource.adobe.com/group__forest__related.html</a></dd>

    <dt><a id="ref.peeters" name="ref.peeters">[peeters]</a></dt>

    <dd>Peeters, Kasper. <em>tree.hh: an STL-like C++ tree class</em>,
    <a href=
    "http://www.aei.mpg.de/~peekas/tree/">http://www.aei.mpg.de/~peekas/tree/</a></dd>

    <dt><a id="ref.rivera" name="ref.rivera">[rivera]</a></dt>

    <dd>Rivera, Ren&eacute;. <em>RankTree.h</em>, <a href=
    "http://redshift-software.com/~grafik/RankTree.h">http://redshift-software.com/~grafik/RankTree.h</a></dd>
  </dl>
</body>
</html>
