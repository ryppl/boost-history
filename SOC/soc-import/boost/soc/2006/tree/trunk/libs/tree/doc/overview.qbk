[/
 /  Copyright (c) 2006, Bernhard Reiter
 /
 /  This code may be used under either of the following two licences:
 /
 /  Permission is hereby granted, free of charge, to any person obtaining a copy 
 /  of this software and associated documentation files (the "Software"), to deal 
 /  in the Software without restriction, including without limitation the rights 
 /  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
 /  copies of the Software, and to permit persons to whom the Software is 
 /  furnished to do so, subject to the following conditions:
 /
 /  The above copyright notice and this permission notice shall be included in 
 /  all copies or substantial portions of the Software.
 /
 /  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 /  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 /  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
 /  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 /  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
 /  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
 /  THE SOFTWARE. OF SUCH DAMAGE.
 /
 /  Or:
 /
 /  Distributed under the Boost Software License, Version 1.0.
 /  (See accompanying file LICENSE_1_0.txt or copy at
 /  http://www.boost.org/LICENSE_1_0.txt)
 /
 //////////////////////////////////////////////////////////////////////////////////////////////
 /
 / Boost.Tree
 / Overview documentation file.
 /]


[section Overview]

[section Motivation]
Existing efforts concerning C++ tree designs and implementations mostly try either to present somewhat 
STL-compatible iterator-like types and tree classes for mapping the latter kind of external or "explicit" 
structures (ref); or, on the other hand, untangle balancing mechanisms from key search and other 
additional features (which are referred to as "augmenting" here, using the terminology from 
[link clrs CLRS]). 
At the time of this writing, no efforts are known to the author that would cater for both cases; and, as 
an aspect of this fact, there are presently no efforts that try in turn to separate the underlying tree 
structure or "topology" from searching, balancing and augmenting.

The present approach in providing a consistent framework for trees is arranged roughly around the following 
principles:

* ['Cursors] as a consequent continuation of the iterator concept for tree structures.
* ['Multiway tree search] as a generalization of binary tree search that in turn is viewed as a generalization
of existing "linear" binary search algorithms (like `lower_bound`, `upper_bound` etc.) for STL containers.

Note that this approach seeks to hide ['nodes] as much as possible from the library client, although they 
play of course an important role in the assembly of a tree; nevertheless it was felt that they were not
suitable for interface purposes. (Note e.g. that nodes are not as atomic an element for a tree as they
might seem at first glance; in case of multiway trees, for example, each node contains a number of 
values.)
[endsect] [/ Motivation]

[section Scope]
Due to the nature of the fields of interest concerning trees (as opposed to their graph superset) in 
computer science as well as the underlying technique, we implicitly mean a ['rooted ordered connected 
acyclic graph] when we're
talking about trees in the following.

This includes, but is not limited to

* Binary search trees; most notably, self-balancing ones, such as
	* Red-black trees
* B-trees
* Ternary search trees
* Forests, i.e. trees that aren't primarily used for searching but for mapping a hierarchical strucutre.
...

[endsect] [/ Scope]


[section (Multiway) Tree Search]
Due to their implicit-only nature within the Standard Library (as used by `map`or `set` internally), 
there are no algorithms that deal with tree structures -- which naturally require an approach differing 
from the one-dimesional, iterator(-interval)-based ones present in the STL. Most notably, binary search 
algorithms like `lower_bound` and `upper_bound` hardly make sense using a linearized version of the tree 
structure, i.e. given iterators pointing to the element containing the least and one past the one 
containing the greatest element. Nevertheless, one-dimensional binary search can be logically continued 
to binary tree search (as implicitly done by the associative containers' `lower_bound` etc. member 
functions) and even multiway tree search, thus allowing consistent tree search for all types of sorted 
multiway and binary trees (the latter being considered a special case of the former in the following).

The (multiway tree) cursor design present in this library supports this continuation. 
To motivate this, we illustrate this by crafting a `lower_bound` binary tree search algorithm. 
To do so, consider the following piece of code:

	std::vector<int> v(1, 1066); // c contains one element: 1066
	std::vector<int>::const_iterator ci996  = std::lower_bound(v.begin(), v.end(),  996);
	std::vector<int>::const_iterator ci1066 = std::lower_bound(v.begin(), v.end(), 1066);
	std::vector<int>::const_iterator ci2006 = std::lower_bound(v.begin(), v.end(), 2006);

	assert(ci996  == v.begin());
	assert(ci1066 == v.begin());
	assert(ci2006 == v.end());

If this doesn't really excite you, that's perfectly okay. Note however that this kind of binary "flat"
search does something that is similar to what a binary tree search algorithm just as well at every 
branching point (node): 

* Compare the search value to the node's.
	* If the search value is greater than the node value, move down to the node's right child.
	* Otherwise, move left.

So we have two possible results depending on one given value, similar to a binary tree node where
comparison with one value controls moving to either of two possible children.
It would be nice (though admittedly still not overwhelming) to associate the existing `std::lower_bound`
algorithm's result with another container (or, less strictly, another range) that we can move on to
depending on the result of the former.

That is what tree cursors offer in a very straight-forward manner: the result of `std::lower_bound` 
(in the binary case either `c.begin()` or `c.end()` for a cursor `c`) ['is] again a tree cursor. 
The background is that a tree cursor refines both a range ['and] a corresponding iterator concept (e.g. a
Forward Readable Range with a Forward Readable Iterator). 

Note that while coupling range with iterator concepts, we decide at the same time for a separation
of the (user-supplied) value contents of a tree cursor and its children. This reflects the desire
that tree traversal, as achieved by cursors, should be mapped a structural matter rather than a
content-dependent one (which can more concretely be seen e.g. in the fact that there is always one
 child node more than values in a (multiway) tree).

In particular, although `c.end()` can still not be dereferenced, there may well be other valid operations
(independent of its `*` and `->` operators - those would only be useful in case ). In our case, this is
 mainly range operations like `c.end().begin()` and `c.end().end()`; but as we can hardly always guarantee
that there actually ['is] a child range, we need some way to detect these operations are actually legal.
This is what `c.empty()` is used for, and this includes an actual change to its expression semantics; it
is guaranteed to be legal for any valid cursor `c` even if that cursor's `c.begin()` and `c.end()` are not
(so we cannot really say that it is equivalent to `c.begin() == c.end()`). It is, however, about the
only reasonable meaning `empty()` can assume in case of a cursor.

[warning TODO: Add some graphics!]

Going back to our binary tree search example, we as a first approach write down iterative invocation
of `std::lower_bound`, to be terminated if a node has no further children:

	while(!x.empty())
		x = std::lower_bound(x.begin(), x.end(), val);

There are some properties inherent to the tree cursor design that may look somewhat peculiar at 
first glance. Given the child cursor obtained by `c.end()` - how do we obtain its value? The only 
consequently possible answer is that we have to dereference its `begin()` child in turn, i.e. by 
invoking `*(c.end().begin())`. The above example owns its clarity actually to this pecularity.

Still, it is not yet complete. Given a tree's root as the initial `c`, we will traverse that tree
as long as it has children - but what cursor do we return as our algorithm's result? Obviously, it is
not necessarily the last value visited. Instead, we need to keep track of the last value visited ['that 
was greater than the search value] and return that value eventually. In order to do so, we introduce the
`parity()` function: `x.parity()` returns `0` if `x` was obtained as its parent's `begin()` cursor and 
`1` if it is its parent's `end()`.

	while(!x.empty()) {
		x = std::lower_bound(x.begin(), x.end(), val);
		if (!x.parity())
			y = x;
	}
	
If there is no such value in the entire (sub)tree (because all values
are less than the search value or because it is empty), we'd intuitively want to return something like
a "tree `end()`" to indicate the position where the search value could be inserted without changing the
ordering. As we normally depart from a `tree.root()` that makes hardly sense to be called `begin()` 
instead in the given context, we provide a function `shoot()` that points one position past the rightmost 
node in the tree. In order for the algorithm to work not only for trees but also for any given subtree
described by its root and shoot cursors, we state a version with two cursors instead of a tree as first
parameters:

	template <class TreeCursor, class T>
	TreeCursor lower_bound(TreeCursor x, TreeCursor y, T const& val)
	{
		while (x.empty()) {
			x = std::lower_bound(x.begin(), x.end(), val);
			if (!x.parity())
				y = x;
		}
		return y;
	}

This should look very clear and illustrative; the nice thing about binary tree search is that you
can use the same algorithm for whatever balancing mechanism you choose for it, so the above should
work for red-black trees just as well as for treaps or splays (though in the latter case, you shouldn't
forget to call the splay operation afterwards!).
If you wonder if replacing a simple two-way decision control structure by a 
not-exactly-so-lightweight STL algorithm was really worth it, let me for the time being refer you to the 
following exercises...

[section Exercises]
# Replace `std::lower_bound` in the above algorithm by `custom_lower_bound`. The latter should invoke
an inlined `trivial_lower_bound` function if its first two arguments are binary cursors, and 
`std::lower_bound` otherwise.
# "Specialize" the above algorithm for search values of a string type. (cf. Austern et al.)
# Generalize the above algorithm for "multiway" trees.
# Implement `upper_bound` for multiway trees.
# Implement a two-argument version that takes a tree as the first (the search value as the second)
argument and uses the tree's `root` and `shoot` members in lieu of `x` and `y`. (You'll actually need
two versions of that algorithm, one for `const` trees and one for mutable ones.)
[/# Replace the member functions in the two-argument versions from the previous exercise by freestanding 
ones. Implement them for non-cursor iterators so that `empty(iter)` always returns true.]
[endsect] [/ Exercises]


[endsect] [/ (Multiway) Tree Search]

[section Components]
[section Searcher]
[endsect] [/ Searcher]
[endsect] [/ Components]

[endsect] [/ Overview]

