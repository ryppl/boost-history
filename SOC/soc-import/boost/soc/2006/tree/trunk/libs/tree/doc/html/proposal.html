<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- boostinspect:nolink -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Tree Structures and Related Concepts for the C++ Standard Library (TR2)</title>
</head>

<body>
<h1>Tree Structures and Related Concepts for the C++ Standard Library (TR2)</h1>
<h2>Introduction</h2>
<p>
This paper proposes addition of library components covering tree structures and related concepts
to the C++ Standard Library Technical Report 2. The proposal is based on work towards a Boost 
tree component library (see <a href="https://boost-consulting.com:8443/trac/soc/wiki/tree">
https://boost-consulting.com:8443/trac/soc/wiki/tree</a>)<!-- that was started in the course of 
Boost's participation as a mentoring organization in 
<a href="http://code.google.com/soc/boost/appinfo.html?csaid=E17EA7C7C537C131">
Google Summer of Code 2006</a>&#8482;-->.
</p>
<p>
The library strives to cover many of the relevant aspects within the vast field linked to the 
notion of trees in computer science<!--; among other things, it aims to cater for binary search trees,
[...]-->.
</p>

<h2>Motivation and Scope</h2>
<h3>What does it depend on, and what depends on it?</h3>
<p>
It depends on some standard library components, [...]
</p>
<h3>Is it a pure extension, or does it require changes to standard components?</h3>
<p>
Most of the proposed library is a pure extension. [...]
</p>
<h3>Can it be implemented using today's compilers, or does it require language 
features that will only be available as part of C++0x?</h3>
<p>
It can be (and has been) implemented with today's compilers. [...]
<br />
[... We'd profit from template typedefs to say e.g. 
</p>
<pre>
template&lt;class T, class Alloc = std::allocator&lt;T&gt; &gt; using rank_tree = binary_tree&lt;T, rank_balance, rank_augment, Alloc&gt;;
</pre>


<h2>Impact on the Standard</h2>

<h2>Important Design Decisions</h2>
<h3>Why did you choose the specific design that you did?</h3>


<h3>What alternatives did you consider, and what are the tradeoffs?</h3>

<dl>
<dt>Trees of trees</dt><dd>Duplicates allocators etc. ...</dd>
<dt>Store metadata differently</dt><dd>Duplicates allocators etc. ...</dd>
</dl>

<h3>What are the consequences of your choices, for users and implementors?</h3>
<h3>What decisions are left up to implementors?</h3>
<h3>If there are any similar libraries in use, how do their design decisions compare to yours?</h3>
<p>
<a href="https://boost-consulting.com:8443/trac/soc/wiki/tree/resources/trees">Online resources</a>
</p>

<h2>Proposed Text for Technical Report 2</h2>

<h3>23.1.X Hierarchies</h3>

<ol>
<li>
A hierarchy is an object that stores a finite set of objects, all of the same type, in a
hierarchical manner. They fulfill many, but not all of the containers requirements; unlike 
containers, hierarchies introduce a cursor concept for navigation as opposed to iterators as 
used by containers. The library provides ... kinds of hierarchies: ...
</li>
<li>
Non-constant complexity requirements in this clause are stated in one out of two different ways: 
unless specified otherwise, they are expressed in terms of the number of operations <tt>n</tt>, 
which stands for the total number of elements in the hierarchy; or in terms of the number 
of operations <tt>c</tt>, which stands for the number of child elements of a given element (as
introduced by paragraph ... of subclause ...). 
</li>
<li>
The type of objects stored in these components must meet the requirements of <tt>CopyConstructible</tt>
types (20.1.3), and the additional requirements of <tt>Assignable</tt> types.
</li>
<li>
In Table Y, <tt>X</tt> denotes a hierarchy class containing objects of type <tt>T</tt>, 
<tt>a</tt> denotes a value of type X, <tt>u</tt> denotes an identifier and <tt>r</tt> denotes 
a value of <tt>X&amp;</tt>.

<table>
<caption>
Table Y &#8212; Hierarchy requirements
</caption>
<tr>
<th>
expression
</th>
<th>
return type
</th>
<th>
assertion note<br />pre/post-condition
</th>
<th>
complexity
</th>
</tr>

<tr>
<td>
<tt>X::value_type</tt>
</td>
<td>
<tt>T</tt>
</td>
<td>
<tt>T</tt> is <tt>Assignable</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::reference</tt>
</td>
<td>
lvalue of <tt>T</tt>
</td>
<td>

</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::const_reference</tt>
</td>
<td>
const lvalue of <tt>T</tt>
</td>
<td>

</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::cursor</tt>
</td>
<td>
cursor type pointing to <tt>T</tt>
</td>
<td>
any cursor category
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::const_cursor</tt>
</td>
<td>
cursor type pointing to <tt>const T</tt>
</td>
<td>
any cursor category
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::difference_type</tt>
</td>
<td>
signed integral type
</td>
<td>
is identical to the distance type of <tt>X::iterator</tt> and <tt>X::const_iterator</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::size_type</tt>
</td>
<td>
unsigned integral type
</td>
<td>
<tt>size_type</tt> can represent any non-negative value of <tt>difference_type</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X u;</tt>
</td>
<td>

</td>
<td>
post: <tt>u.size() == 0</tt>
</td>
<td>
constant
</td>
</tr>

<tr>
<td>
<tt>X()</tt>
</td>
<td>

</td>
<td>
<tt>X().size() == 0</tt>
</td>
<td>
constant
</td>
</tr>

<tr>
<td>
<tt>X(a);</tt>
</td>
<td>

</td>
<td>
<tt>a == X(a)</tt>
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>X u(a);</tt><br /><tt>X u = a;</tt>
</td>
<td>

</td>
<td>
post: <tt>u == a</tt><br />Equivalent to: X u; u = a;
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>(&amp;a)->~X();</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
note: the destructor is applied to every element of <tt>a</tt>; all the memory is returned
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>a.root()</tt>
</td>
<td>
<tt>iterator</tt> for mutable <tt>a</tt>; <br /><tt>const_iterator</tt> for constant <tt>a</tt>
</td>
<td>

</td>
<td>
constant
</td>
</tr>

<tr>
<td>
<tt>a.shoot()</tt>
</td>
<td>
<tt>iterator</tt> for mutable <tt>a</tt>; <br /><tt>const_iterator</tt> for constant <tt>a</tt>
</td>
<td>

</td>
<td>
logarithmic [... or constant?]
</td>
</tr>

<tr>
<td>
<tt>a == b</tt>
</td>
<td>
convertible to <tt>bool</tt>
</td>
<td>
<tt>==</tt> is an equivalence relation. <br />
<tt>a.size() == b.size() &amp;&amp; ... [equality of elements]</tt>
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
convertible to <tt>bool</tt>
</td>
<td>
Equivalent to: <tt>a != b</tt>
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>a.swap(b)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>swap(a,b)</tt>
</td>
<td>
(Note A)
</td>
</tr>

<tr>
<td>
<tt>r = a</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
post: <tt>r == a</tt>
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>a.size()</tt>
</td>
<td>
<tt>size_type</tt>
</td>
<td>

</td>
<td>
(Note A)
</td>
</tr>

<tr>
<td>
<tt>a.max_size()</tt>
</td>
<td>
<tt>size_type</tt>
</td>
<td>
Operational semantics: <tt>size()</tt> of the largest possible hierarchy
</td>
<td>
(Note A)
</td>
</tr>

<tr>
<td>
<tt>a.empty()</tt>
</td>
<td>
convertible to <tt>bool</tt>
</td>
<td>
Operational semantics: <tt>a.size() == 0</tt>
</td>
<td>
(Note A)
</td>
</tr>

<tr>
<td>
<tt>...</tt>
</td>
<td>
[Comparison functions?]
</td>
<td>
</td>
<td>
</td>
</tr>

</table>

Notes: the algorithms <tt>swap()</tt> and <tt>equal()</tt> <!--and lexicographical_compare()-->
are defined in Clause 25. Those entries marked "(Note A)" should have constant complexity.

</li>
<li>
The member function <tt>size()</tt> returns the number of elements in the hierarchy. 
Its semantics is defined by the rules of constructors, inserts, and erases.
</li>
<li>
<tt>root()</tt> returns a cursor referring to the uppermost element in the hierarchy. 
<tt>shoot()</tt> returns a cursor which is the past-the-end value that is found one past
the hierarchy's rightmost element. 
If the hierarchy is empty, then <tt>root() == shoot()</tt>;
</li>
<li>
Copy constructors for all hierarchy types defined in this clause copy the allocator argument 
from their respective first parameters. All other constructors for these hierarchy types take an 
<tt>Allocator&amp;</tt> argument (20.1.5). A copy of this argument is used for any memory 
allocation performed, by these constructors and by all member functions, during the lifetime of 
each hierarchy object. In all hierarchy types defined in this clause, the member 
<tt>get_allocator()</tt> returns a copy of the Allocator object used to construct the
hierarchy.
</li>
<li>[... Reverse hierarchies?]</li>
</ol>

<h3>23.1.X.X Modifiable Hierarchies [... better name?]</h3>
<ol>
<li>
A hierarchy is called <em>modifiable</em> if it allows modification of its contents by insertion
and/or erasure of elements. <!--Both of these kinds of modification operations require a 
position parameter that specifies where in a given hierarchy the desired operation has to take
place.-->
</li>
<li>
In Table Y, <tt>X</tt> denotes a hierarchy class, <tt>a</tt> denotes a class of <tt>X</tt>, 
<tt>p</tt> denotes a valid, non-on-top cursor to <tt>a</tt>, <tt>q</tt> denotes a valid,
dereferenceable cursor to <tt>a</tt>, and <tt>t</tt> denotes a value of 
<tt>X::value_type</tt>. [...]
</li>
<li>
The actual semantics of the <tt>insert</tt> and <tt>erase</tt> expressions are hierarchy 
dependent.
Depending on whether or not the previous hierarchy structure is always kept as an invariant, also
after an insertion or erasure (only with an element added or removed in the position specified 
by the <tt>p</tt> or <tt>q</tt> parameters, as in Table Y), modifiable hierarchies are further 
categorized in <em>unbalanced</em> and <em>balanced</em> ones. (In the latter case, the invariant
that is kept by balanced modifiable hierarchies, is the <em>inorder</em> of elements, as defined
in clause [...].)
</li>

<li>
<table>
<caption>
Table Y &#8212; Modifiable Hierarchy requirements
</caption>
<tr>
<th>
expression
</th>
<th>
return type
</th>
<th>
assertion/note<br />
pre/post-condition
</th>
</tr>
<tr>
<td>
<tt>a.insert(p,t)</tt>
</td>
<td>
<tt>cursor</tt>
</td>
<td>

</td>
</tr>
</table>
</li>

</ol>

<h4>Template class<tt>forest</tt></h4>

<h3>24.X Cursors</h3>
<ol>
<li>
Cursors provide a uniform way of applying algorithms to hierarchical data structures.
In order to also allow for algorithms relevant when dealing with linear data structures, any 
cursor class is actually a refinement of a corresponding iterator class whose traversal related
capabilities map to horizontal traversal. <!-- among a given cursor's immediate descendants or 
"child cursors" (or just "children").-->
Furthermore, as a cursor is meant to provide a means of descending within a hierarchy, it refines
parts of a Container corresponding to the kind of Iterator it models which have been formalized
as the 
<a href="file:///home/bernie/projects/boost/libs/range/doc/range.html">Range concept</a>
externally to the Standard.
</li>

<li>
If exactly one application of the expression <tt>i = i.begin()</tt>, followed by a finite 
sequence of applications of the expression <tt>++j</tt> makes <tt>i == j</tt>, <tt>j</tt> 
is a <em>child</em> (or <em>immediate descendant </em>) of <tt>i</tt>, and <tt>i</tt> is the 
<em>parent</em> (or the <em>immediate ancestor</em>) of <tt>j</tt>.
A cursor <tt>j</tt> is another cursor <tt>i</tt>'s <tt>descendant</tt> if there
is a finite sequential combination of applications of either of the expressions <tt>++i</tt> and
<tt>i = i.begin()</tt> that makes <tt>i == j</tt>; <tt>i</tt> is then called <tt>j</tt>'s 
ancestor.
If two cursors <tt>i</tt> and <tt>j</tt> share at least one common ancestor, they refer to the
same container.
The horizontal traversal capabilites of a class relate to the range of children of a 
given instance of that class.
</li>
<li>
In additon to a cursor's horizontal (iterator) traversal tags, two of them are reused to indicate
a cursor's vertical traversal abilities, namely <em>forward</em> and <em>bidirectional</em>
traversal in order to indicate whether a given cursor provides a method that returns its 
parent cursor.
</li>
<li>
Apart from cursors that are <em>past-the-end</em> (like their iterator counterparts can be),
the notion of a cursor <em>on-top</em> is introduced, denoting a cursor that is ancestor to all
other cursors within a hierarchy is introduced; and just as for past-the-end
ones, the library never assumes on-top cursors be dereferenceable; nor that they be incrementable
or decrementable. In other words, as opposed to non-on-top cursurs, on-top cursors fulfill only 
the Range concept requirements, but not any Iterator concept requirements.
</li>
[Leaf cursors/ empty()]
</ol>
<h3>24.X [...?] Hierarchy traversal</h3>
<ol>
<li>
For linear traversal of hierarchies, the library offers a number of useful algorithms, namely for
<tt>preorder</tt>, <tt>postorder</tt> and <tt>inorder</tt> traversal in namespaces named 
accordingly. 
</li>
<li>
<em>Preorder traversal</em> means that after a given element, first the subtree to its left, 
then the one to its right will be visited. 
</li>
<li>
<em>Postorder traversal</em> means that before a given element, first the subtree to its left, 
then the one to its right will be visited.
</li>
<li>
<em>Inorder traversal</em> means that a given element will be visited after the subtree to its 
left and before the one to its right will be visited.
</li>
<li>
For each of the above kinds of traversal order, the library offers a kind of order traversal 
iterator adaptor template class around a given cursor, for which increment and decrement 
operations are implemented allow stepwise iteration according to the respective requirements. 
Additionally, for cursors with bidirectional vertical traversal property, algorithms 
<tt>forward</tt> and <tt>back</tt> in the respective namespaces are provided that set their 
argument cursor to the next or previous, resp., in the corresponding traversal order.
</li>

<li>Traversal header</li>

</ol>
</body>
</html>
