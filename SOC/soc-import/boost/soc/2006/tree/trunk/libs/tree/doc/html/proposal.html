<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- boostinspect:nolink -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Tree Structures and Related Concepts for the C++ Standard Library (TR2)</title>
</head>

<body>
<h1>Tree Structures and Related Concepts for the C++ Standard Library (TR2)</h1>
<h2>Introduction</h2>
<p>
This paper proposes addition of library components covering tree structures and related concepts
to the C++ Standard Library Technical Report 2. The proposal is based on work towards a Boost 
tree component library (see <a href="https://boost-consulting.com:8443/trac/soc/wiki/tree">
https://boost-consulting.com:8443/trac/soc/wiki/tree</a>)<!-- that was started in the course of 
Boost's participation as a mentoring organization in 
<a href="http://code.google.com/soc/boost/appinfo.html?csaid=E17EA7C7C537C131">
Google Summer of Code 2006</a>&#8482;-->.
</p>
<p>
The library strives to cover many of the relevant aspects within the vast field linked to the 
notion of trees in computer science<!--; among other things, it aims to cater for binary search trees,
[...]-->.
</p>

<h2>Motivation and Scope</h2>
<h3>What does it depend on, and what depends on it?</h3>
<p>
It depends on some standard library components, [...]
</p>
<h3>Is it a pure extension, or does it require changes to standard components?</h3>
<p>
Most of the proposed library is a pure extension. [...]
</p>
<h3>Can it be implemented using today's compilers, or does it require language 
features that will only be available as part of C++0x?</h3>
<p>
It can be (and has been) implemented with today's compilers. [...]
<br />
[... We'd profit from template typedefs to say e.g. 
</p>
<pre>
template&lt;class T, class Alloc = std::allocator&lt;T&gt; &gt; using rank_tree = binary_tree&lt;T, rank_balance, rank_augment, Alloc&gt;;
</pre>


<h2>Impact on the Standard</h2>

<h2>Important Design Decisions</h2>
<h3>Why did you choose the specific design that you did?</h3>


<h3>What alternatives did you consider, and what are the tradeoffs?</h3>

<dl>
<dt>Trees of trees</dt><dd>Duplicates allocators etc. ...</dd>
</dl>

<h3>What are the consequences of your choices, for users and implementors?</h3>
<h3>What decisions are left up to implementors?</h3>
<h3>If there are any similar libraries in use, how do their design decisions compare to yours?</h3>
<p>
<a href="https://boost-consulting.com:8443/trac/soc/wiki/tree/resources/trees">Online resources</a>
</p>

<h2>Proposed Text for Technical Report 2</h2>

<h3>23.1.X Hierarchies</h3>

<ol>
<li>
A hierarchy is an object that stores a finite set of objects, all of the same type, in a
hierarchical manner. They fulfill many, but not all of the containers requirements; unlike 
containers, hierarchies introduce a cursor concept for navigation as opposed to iterators as 
used by containers. The library provides ... kinds of hierarchies: ...
</li>
<li>
Non-constant complexity requirements in this clause are stated in one out of two different ways: 
unless specified otherwise, they are expressed in terms of the number of operations <tt>n</tt>, 
which stands for the total number of elements in the hierarchy; or in terms of the number 
of operations <tt>c</tt>, which stands for the number of child elements of a given element. 
</li>
<li>
The type of objects stored in these components must meet the requirements of <tt>CopyConstructible</tt>
types (20.1.3), and the additional requirements of <tt>Assignable</tt> types.
</li>
<li>
In Table Y, <tt>X</tt> denotes a hierarchy class containing objects of type <tt>T</tt>, 
<tt>a</tt> denotes a value of type X, <tt>u</tt> denotes an identifier and <tt>r</tt> denotes 
a value of <tt>X&amp;</tt>.

<table>
<caption>
Table Y &#8212; Hierarchy requirements
</caption>
<tr>
<th>
expression
</th>
<th>
return type
</th>
<th>
assertion note<br />pre/post-condition
</th>
<th>
complexity
</th>
</tr>

<tr>
<td>
<tt>X::value_type</tt>
</td>
<td>
<tt>T</tt>
</td>
<td>
<tt>T</tt> is <tt>Assignable</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::reference</tt>
</td>
<td>
lvalue of <tt>T</tt>
</td>
<td>

</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::const_reference</tt>
</td>
<td>
const lvalue of <tt>T</tt>
</td>
<td>

</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::cursor</tt>
</td>
<td>
cursor type pointing to <tt>T</tt>
</td>
<td>
any cursor category
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::const_cursor</tt>
</td>
<td>
cursor type pointing to <tt>const T</tt>
</td>
<td>
any cursor category
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::difference_type</tt>
</td>
<td>
signed integral type
</td>
<td>
is identical to the distance type of <tt>X::iterator</tt> and <tt>X::const_iterator</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::size_type</tt>
</td>
<td>
unsigned integral type
</td>
<td>
<tt>size_type</tt> can represent any non-negative value of <tt>difference_type</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X u;</tt>
</td>
<td>

</td>
<td>
post: <tt>u.size() == 0</tt>
</td>
<td>
constant
</td>
</tr>

<tr>
<td>
<tt>X()</tt>
</td>
<td>

</td>
<td>
<tt>X().size() == 0</tt>
</td>
<td>
constant
</td>
</tr>

<tr>
<td>
<tt>X(a);</tt>
</td>
<td>

</td>
<td>
<tt>a == X(a)</tt>
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>X u(a);</tt><br /><tt>X u = a;</tt>
</td>
<td>

</td>
<td>
post: <tt>u == a</tt><br />Equivalent to: X u; u = a;
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>(&amp;a)->~X();</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
note: the destructor is applied to every element of <tt>a</tt>; all the memory is returned
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>a.root()</tt>
</td>
<td>
<tt>iterator</tt> for mutable <tt>a</tt>; <br /><tt>const_iterator</tt> for constant <tt>a</tt>
</td>
<td>

</td>
<td>
constant
</td>
</tr>

<tr>
<td>
<tt>a.shoot()</tt>
</td>
<td>
<tt>iterator</tt> for mutable <tt>a</tt>; <br /><tt>const_iterator</tt> for constant <tt>a</tt>
</td>
<td>

</td>
<td>
logarithmic [... or constant?]
</td>
</tr>

<tr>
<td>
<tt>a == b</tt>
</td>
<td>
convertible to <tt>bool</tt>
</td>
<td>
<tt>==</tt> is an equivalence relation. <br />
<tt>a.size() == b.size() &amp;&amp; ... [equality of elements]</tt>
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
convertible to <tt>bool</tt>
</td>
<td>
Equivalent to: <tt>a != b</tt>
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>a.swap(b)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>swap(a,b)</tt>
</td>
<td>
(Note A)
</td>
</tr>

<tr>
<td>
<tt>r = a</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
post: <tt>r == a</tt>
</td>
<td>
linear
</td>
</tr>

<tr>
<td>
<tt>a.size()</tt>
</td>
<td>
<tt>size_type</tt>
</td>
<td>

</td>
<td>
(Note A)
</td>
</tr>

<tr>
<td>
<tt>a.max_size()</tt>
</td>
<td>
<tt>size_type</tt>
</td>
<td>
Operational semantics: <tt>size()</tt> of the largest possible hierarchy
</td>
<td>
(Note A)
</td>
</tr>

<tr>
<td>
<tt>a.empty()</tt>
</td>
<td>
convertible to <tt>bool</tt>
</td>
<td>
Operational semantics: <tt>a.size() == 0</tt>
</td>
<td>
(Note A)
</td>
</tr>

<tr>
<td>
<tt>...</tt>
</td>
<td>
[Comparison functions?]
</td>
<td>
</td>
<td>
</td>
</tr>

</table>

Notes: the algorithms <tt>swap()</tt> and <tt>equal()</tt> <!--and lexicographical_compare()-->
are defined in Clause 25. Those entries marked "(Note A)" should have constant complexity.

</li>
<li>
The member function <tt>size()</tt> returns the number of elements in the hierarchy. 
Its semantics is defined by the rules of constructors, inserts, and erases.
</li>
<li>
<tt>root()</tt> returns a cursor referring to the uppermost element in the hierarchy. 
<tt>shoot()</tt> returns a cursor which is the past-the-end value that is found one past
the hierarchy's rightmost element. 
If the hierarchy is empty, then <tt>root() == shoot()</tt>;
</li>
<li>
Copy constructors for all hierarchy types defined in this clause copy the allocator argument 
from their respective first parameters. All other constructors for these hierarchy types take an 
<tt>Allocator&amp;</tt> argument (20.1.5). A copy of this argument is used for any memory 
allocation performed, by these constructors and by all member functions, during the lifetime of 
each hierarchy object. In all hierarchy types defined in this clause, the member 
<tt>get_allocator()</tt> returns a copy of the Allocator object used to construct the
hierarchy.
</li>
<li>[... Reverse hierarchies?]</li>
</ol>

<h3>23.1.X.X Modifiable Hierarchies [... better name?]</h3>
<ol>
<li>
Modifiable hierarchies allow modification of their contents by insertion and/or deletion of 
elements.
</li>
</ol>

<h3>24.X Cursors</h3>
<ol>
<li>
Cursors provide a uniform way of applying algorithms to hierarchical data structures.
In order to also allow for algorithms relevant when dealing with linear data structures, any 
cursor class is actually a refinement of a corresponding iterator class whose traversal related
capabilities map to horizontal traversal among a given cursor's immediate descendants or 
"child cursors" (or just "children").
Furthermore, as a cursor is meant to provide a means of descending within a hierarchy, it refines
parts of a Container corresponding to the kind of Iterator it models which have been formalized
as the 
<a href="file:///home/bernie/projects/boost/libs/range/doc/range.html">Range concept</a>
externally to the Standard.
</li>
<li>
In additon to a cursor's horizontal (iterator) traversal tags, two of them are reused to indicate
a cursor's vertical traversal abilities, namely <em>forward</em> and <em>bidirectional</em>
traversal in order to indicate whether a given cursor provides a method that returns its 
immediate ancestor or "parent" cursor.
</li>
<li>
The iterator related notion of reachability must be modified as follows in order to be sensibly 
applicable to cursors: a cursor <tt>j</tt> is reachable from another cursor <tt>i</tt> if there
is a finite sequential combination of applications of either of the expressions <tt>++i</tt> and
<tt>i = i.begin()</tt> that makes <tt>i == j</tt>. If <tt>j</tt> is reachable from <tt>i</tt>, 
they refer to the same container.
</li>
<li>
Apart from cursors that are <em>past-the-end</em> (like their iterator counterparts can be),
the notion of a cursor <em>on-top</em> is introduced, denoting a cursor that is ancestor to all
other cursors possibly reachable within a hierarchy is introduced; and just as for past-the-end
ones, the library never assumes on-top cursors be dereferenceable; nor that they be incrementable
or decrementable. In other words, as opposed to non-on-top cursurs, on-top cursors fulfill only 
the Range concept requirements, but not any Iterator concept requirements.
</li>

</ol>
</body>
</html>
