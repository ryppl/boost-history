[/
 /  Copyright (c) 2006-2008, Bernhard Reiter
 /
 /  Distributed under the Boost Software License, Version 1.0.
 /  (See accompanying file LICENSE_1_0.txt or copy at
 /  http://www.boost.org/LICENSE_1_0.txt)
 /
 //////////////////////////////////////////////////////////////////////////////////////////////
 /
 / Boost.Tree
 / Algorithms documentation file.
 /]

[import ../../../boost/tree/detail/algorithm/cursor/preorder.hpp]
[import ../../../boost/tree/detail/algorithm/cursor/inorder.hpp]
[import ../../../boost/tree/detail/algorithm/cursor/postorder.hpp]
[import ../example/for_each.cpp]

[section Algorithms]

While STL algorithms operate on (at least a pair of) iterators, for hierarchic structures
as trees it is just natural to operate on a subtree which in turn are referenced by their
"subtree root" cursor.

Contrarily to iterator-based algorithms that normally just traverse a range given by two
iterators starting at the first element linearly and terminating past the last element,
there is no one such "natural" traversal for subtrees.

There are, conversely, several different methods how to traverse a (sub)tree - one 
has to choose eg whether to "visit" an element before, between or after its descendants.

These three types of traversal are called /preorder/, /inorder/ and /postorder/, and 
consequently, an algorithm can come in each out of these three flavors 
(and many algorithms will come in all three). For clarity, all the algorithms 
of one such traversal type are bundled in a namespace of the corresponding 
name (ie, `preorder`, `inorder`, and `postorder`).

Algorithms can be used via

[for_each_include_algorithm]

TODO: Include illustration of example data tree.

[section Pre-, In-, and Postorder Algorithms]

[section for_each]

[preorder_for_each]
[inorder_for_each]
[postorder_for_each]

[funcref boost::tree:preorder::for_each]

[section Example]
[for_each]
[endsect] [/Example]
[endsect] [/for_each]

[endsect] [/ Pre-, In-, and Postorder Algorithms]

[endsect] [/ Algorithms]
