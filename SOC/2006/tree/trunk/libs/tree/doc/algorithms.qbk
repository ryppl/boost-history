[/
 /  Copyright (c) 2006-2008, Bernhard Reiter
 /
 /  Distributed under the Boost Software License, Version 1.0.
 /  (See accompanying file LICENSE_1_0.txt or copy at
 /  http://www.boost.org/LICENSE_1_0.txt)
 /
 //////////////////////////////////////////////////////////////////////////////////////////////
 /
 / Boost.Tree
 / Algorithms documentation file.
 /]

[section Algorithms]

While STL algorithms operate on (at least a pair of) iterators, for hierarchic structures
as trees it is just natural to operate on a subtree which in turn are referenced by their
"subtree root" cursor.

Contrarily to iterator-based algorithms that normally just traverse a range given by two
iterators starting at the first element linearly and terminating past the last element,
there is no one such "natural" traversal for subtrees.

There are, conversely, several different methods how to traverse a (sub)tree - one 
has to choose eg whether to "visit" an element before, between or after its descendants.

These three types of traversal are called pre- in- and postorder, and consequently, an
algorithm can come in each out of these three flavors (and many algorithms will come in 
all three). For clarity, all the algorithms of one such traversal type are bundled in a
namespace of the corresponding name (ie, `preorder`, `inorder`, and `postorder`).

[section Pre-, In-, and Postorder Algorithms]
[endsect] [/ Pre-, In-, and Postorder Algorithms]

[endsect] [/ Algorithms]
