[/ 
 /  Copyright (c) 2006-2008, Bernhard Reiter
 /
 /  Distributed under the Boost Software License, Version 1.0.
 /  (See accompanying file LICENSE_1_0.txt or copy at
 /  http://www.boost.org/LICENSE_1_0.txt)
 /
 //////////////////////////////////////////////////////////////////////////////////////////////
 /
 / Boost.Tree
 / TODO file; part of documentation also.
 /]
 
[section TODO]

General:
* Re-organize traversal tests:
  * Verify recursive algorithms to work
    * 1. with a tree filled with given data
    * 2. with an empty tree
  * Same for iterators
  * Start with an empty tree, fill it with data. At each step, check if
    cursor and iterator algorithms yield the same result.
    (Or, alternatively, if neither is to be trusted: compare to subsets of
    the complete test data.)
  * With the tree complete, do the same recursively for all its subtrees.
* Also test copy with two trees (not just one tree and a container/output iterator)
* Rename parity() (which looks somewhat binary-related) to index (more general for forest
  trees etc)?
* _Possibly_ move detail/algorithm/cursor/ to detail/cursor/algorithm/ or even just
  detail/cursor/ (same for iterator).
* Make *order iterators work with empty subtrees; same for cursor algorithms.
* Get rid of checks for/assignments to root in pre/post/inorder algorithms,
  as they are otherwise limited to "whole" trees and cannot be applied to subtrees.
  In order to work for subtrees, it's probable that we need at least an int to store
  the current depth. (Which, in turn, would make the free-standing forward/back/next/prior 
  algorithms etc. more or less useless without that piece of extra information and would
  only leave us with the iterators to store it.)
  -> This is going to be done by the RootTracker object, which I personally hate,
  but I don't see much of a choice for iterative traversal of subtrees other than that
  (and haven't found any on the Web, either).
* Deprecate shoot()? It's main use was for inorder::end(), which is now root().
  Would (binary tree) lower_bound() be possible without shoot()? What would it have to be 
  like? What would be the implications for balanced_trees? (Especially the lower_bound 
  for search vs insert purposes problem.)
* Take care of inorder::begin() for binary_tree<int>.  
* Keep in mind it's not necessarily a good thing to have *order::end() be the last element's
  right child. For inorder and postorder, it seems like the subtree root is a better choice.
  For preorder, things are pretty diffcult.
* Do a unit test that creates a random tree with a given number of elements. 
  Let the cursor based *order algorithms then copy its elements into linear structures 
  and compare these linear structures to an iterator-based *order traversal.
* Should const_cursor have cbegin(), cend() and cparent() members?
* Implement "flat" (sequential *order representation) trees (cf. Knuth, Fundamental Algorithms,
  pp. 348--351). Those should be especially useful for automated testing of "real" (binary, 
  forest) trees.
* have `erase()` operations return cursor/iterator instead of void (as in new STD)
* modify parity/parent specs according to newsgroup thread, but members add to binary_tree cursor!
* We might need still more binary_tree members for more efficient functions operating on
  ranges...
* `insert()` and `erase()` semantics need reworking. For instance, Proposal 23.X.4.1.4 ยง2 
  (and related for deletion and multiway tree insertion/deletion) are way too convoluted
  for a really basic operation. Still, it's important to consider special cases such as
  root nodes and fields of use such as `forest_trees`; but for the latter, something similar
  as inorder_insert might come in handy.
* Add (inorder-)threaded binary trees?? Are they useful? Can they be balanced?
* Start an RFC: what subtree algorithms should there be? In particular, of which of
  the STL's linear algorithms should there be a hierarchical version?

Proposal:

* Write a cursor_facade, cursor_adaptor as well as ascending_adaptor 
  (and output_cursor_iterator_wrapper?) proposal.
* Add a revision log:
 * Add to_parent() (replaces operator!()), to_begin() and to_end() descending cursor members.
 * Remove shoot()
* Add (subtree) cursor algorithms.
* Probably split up cursor categories into: cursor (value access) category, vertical traversal 
  and horizontal traversal (along the lines of the new iterator concepts).
* cursor's begin(), end() and parent() members now only return cursor, same for const_cursor.
  (This somewhat breaks with container requirements, but it makes sense this way.)
* Add InputCursor requirements: binary cursor if it's a binary_tree member function, etc.
* Cursor validity after insertion/erasure/clearing
* Possibly rename ascending to hierarchy cursor? (because of other uses for ascending/cursors in a graph context)
* Remove operator* requirement? (for upward-growing trees with data only on the bottom level --- like B+trees)
* Add tree lower_bound algorithm (to namespace inorder because it's somewhat inorder dependent? or is it?)
* Refactor balancer section to map implementation 
	(balanced_tree template class using policies -- like red_black -- from namespace balancers)
* Add new metadata approach
* Add inorder_erase to balanced_tree requirements

Implementation:

* Implement remaining (binary_tree) balancers, augmentors
* Implement forest. Can its cursor type have an O(1) parent()?
* Implement nary_tree, multiway_tree, b_tree, b_star_tree
* Add tests for and rework
	* binary_tree: subtree insert; splice operations
	* red_black
	* searcher
* Concept checks.
* Interoperability with BGL algorithms.
* C++09: Add template typedefs (e.g. red_black_tree is balanced_tree<red_black_balancer, binary_tree>)

Documentation:

* Add some illustrations
* Overview: develop hierarchy/cursor concept step by step, using illustrations that 
  depict what is introduced at what step (nodes with pointers to their siblings, children, parents,
  a frame around a given cursor [and possibly additionally required information stated]
  that signifies what amount of information is contained within that cursor.

Further applications:

* Implement associative containers and priority_queue specialization using searcher
* Implement (binary) heap

[endsect]
