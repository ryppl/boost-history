[/ 
 /  Copyright (c) 2006-2008, Bernhard Reiter
 /
 /  Distributed under the Boost Software License, Version 1.0.
 /  (See accompanying file LICENSE_1_0.txt or copy at
 /  http://www.boost.org/LICENSE_1_0.txt)
 /
 //////////////////////////////////////////////////////////////////////////////////////////////
 /
 / Boost.Tree
 / TODO file; part of documentation also.
 /]
 
[section TODO]

General:

* Possibly sort out some more concepts, like trees with "downwards" or "upwards" insertion
  (insert()/insert_above()), trees with values only at the leaves (makes sense in combination
  with "upwards" insertion"), etc.
* === The is_root problem() and its solution ===
  Get rid of checks for/assignments to root in pre/post/inorder algorithms,
  as they are otherwise limited to "whole" trees and cannot be applied to subtrees.
  In order to work for subtrees, it's probable that we need at least an int to store
  the current depth.
  Solution:
  Introduce a root tracking cursor concept providing c.is_root(). *order::forward(), back(),
  next() and prior() functions as well as *order::iterators then require this concept.
  Write a root_tracking_cursor adaptor that does exactly that, with suitable specializations
  for different underlying cursors. 
  (Why? Because any root_tracker object would have to be
  passed along with a cursor, plus in- or decremented when going down or up in the hierarchy, 
  resp. This kind of naturally suggests some kind of encapsulation/adaptation.)
* Do we want/need an O(1) inorder_begin() for binary_tree? 
  Does Gnu's rb_tree (used in std::map) have one?
* Is it really a good idea to use InCursor::size_type for size(Cursor)?
  For a binary_cursor, a boolean size_type would be enough - but
  not for a subtree algorithm like this one. Maybe we need two different size_types for
  cursor - a "children" one for iterator compatibility and a "subtree" one for
  "larger scale".
* Use the example trees form Knuth as test example data.
* Write (internal/external?) adaptors for other tree libraries, as Kaspar Peeters' or
  Adobe's.
  * External: what would we need? next()/prior(), plus to_begin()/to_end()/to_parent(),
    deref, ...?
  * Compare to BGL: Is it possible to modify adapted graphs using graph semantics?
    If not, adaptation within the BGL would only map inspecting (read-only) functions.
    (Compare this again to container vs sequence; also look into graph concepts.)
    Finally, mind the implications for internal/external adaptation; they might be
    generalised, if the above assumption is true.
* Revisit binary_tree. Can it be usable for both balanced and forest trees and still be
  "light-weight" at the same time?
* Re-organize traversal tests:
  * Verify recursive algorithms to work
    * 1. with a tree filled with given data
    * 2. with an empty tree
  * Same for iterators
  * Start with an empty tree, fill it with data. At each step, check if
    cursor and iterator algorithms yield the same result.
    (Or, alternatively, if neither is to be trusted: compare to subsets of
    the complete test data.)
  * With the tree complete, do the same recursively for all its subtrees.
* Also test copy with two trees (not just one tree and a container/output iterator)
* Rename parity() (which looks somewhat binary-related) to index (more general for forest
  trees etc)?
* _Possibly_ move detail/algorithm/cursor/ to detail/cursor/algorithm/ or even just
  detail/cursor/ (same for iterator).
* Make *order iterators work with empty subtrees; same for cursor algorithms.
  (Not necessarily! If that means a check for empty(), it's better to leave it to
  the user!)
* Investigate the lower_bound for search vs insert purposes problem.
* Take care of inorder::begin() for binary_tree<int>.  
* Keep in mind it's not necessarily a good thing to have *order::end() be the last element's
  right child. For inorder and postorder, it seems like the subtree root is a better choice.
  For preorder, things are pretty diffcult.
* Do a unit test that creates a random tree with a given number of elements. 
  Let the cursor based *order algorithms then copy its elements into linear structures 
  and compare these linear structures to an iterator-based *order traversal.
* Should const_cursor have cbegin(), cend() and cparent() members?
* Implement "flat" (sequential *order representation) trees (cf. Knuth, Fundamental Algorithms,
  pp. 348--351). Those should be especially useful for automated testing of "real" (binary, 
  forest) trees.
* have `erase()` operations return cursor/iterator instead of void (as in new STD)
* modify parity/parent specs according to newsgroup thread, but members add to binary_tree cursor!
* We might need still more binary_tree members for more efficient functions operating on
  ranges...
* `insert()` and `erase()` semantics need reworking. For instance, Proposal 23.X.4.1.4 ยง2 
  (and related for deletion and multiway tree insertion/deletion) are way too convoluted
  for a really basic operation. Still, it's important to consider special cases such as
  root nodes and fields of use such as `forest_trees`; but for the latter, something similar
  as inorder_insert might come in handy.
* Add (inorder-)threaded binary trees?? Are they useful? Can they be balanced?
  They'd surely be interesting for experimenting with algorithms!
* Start an RFC: what subtree algorithms should there be? In particular, of which of
  the STL's linear algorithms should there be a hierarchical version?

Ask on the mailing list:

* [iterator] Can we get rid of the need to declare iterator_core_access a friend (as we're already 
  doing so with cursor_core_access, this should be enough).
* [property_map]: any need for an extract_property_map?

Proposal:

* Change complexity requirements for *order end() to constant? We're using root(), and
  for postorder begin() - which is also root() - it's already constant. Then again, how much
  do we cater for "pathological" implementations (and not so pathological ones, like 
  threaded trees)?
* Write a cursor_facade, cursor_adaptor as well as ascending_adaptor 
  (and output_cursor_iterator_wrapper?) proposal.
* Add a revision log:
 * Add to_parent() (replaces operator!()), to_begin() and to_end() descending cursor members.
 * Remove shoot(), size()
 * Change some occurences of "vector" (oops) to the respective tree type.
* Add (subtree) cursor algorithms.
* Probably split up cursor categories into: cursor (value access) category, vertical traversal 
  and horizontal traversal (along the lines of the new iterator concepts).
* cursor's begin(), end() and parent() members now only return cursor, same for const_cursor.
  (This somewhat breaks with container requirements, but it makes sense this way.)
* Add InputCursor requirements: binary cursor if it's a binary_tree member function, etc.
* Cursor validity after insertion/erasure/clearing
* Possibly rename ascending to hierarchy cursor? (because of other uses for ascending/cursors in a graph context)
* Remove operator* requirement? (for upward-growing trees with data only on the bottom level --- like B+trees)
* Add tree lower_bound algorithm (to namespace inorder because it's somewhat inorder dependent? or is it?)
* Refactor balancer section to map implementation 
	(balanced_tree template class using policies -- like red_black -- from namespace balancers)
* Add new metadata approach
* Add inorder_erase to balanced_tree requirements

Implementation:

* Implement remaining (binary_tree) balancers, augmentors
* Implement forest. Can its cursor type have an O(1) parent()?
* Implement nary_tree, multiway_tree, b_tree, b_star_tree
* Add tests for and rework
	* binary_tree: subtree insert; splice operations
	* red_black
	* searcher
* Concept checks.
* Interoperability with BGL algorithms.
* C++09: Add template typedefs (e.g. red_black_tree is balanced_tree<red_black_balancer, binary_tree>)

Documentation:

* Take a look at BGL docs; they seem to be really well structured and written.
* Add some illustrations
* Overview: develop hierarchy/cursor concept step by step, using illustrations that 
  depict what is introduced at what step (nodes with pointers to their siblings, children, parents,
  a frame around a given cursor [and possibly additionally required information stated]
  that signifies what amount of information is contained within that cursor.

Further applications:

* Implement associative containers and priority_queue specialization using searcher
* Implement (binary) heap
* Is it possible to implement BGL's traversal algorithms using tree semantics?

[endsect]
