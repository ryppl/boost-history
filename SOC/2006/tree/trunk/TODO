[/ 
 /  Copyright (c) 2006, Bernhard Reiter
 /
 /  Distributed under the Boost Software License, Version 1.0.
 /  (See accompanying file LICENSE_1_0.txt or copy at
 /  http://www.boost.org/LICENSE_1_0.txt)
 /
 //////////////////////////////////////////////////////////////////////////////////////////////
 /
 / Boost.Tree
 / TODO file; part of documentation also.
 /]
 
[section TODO]

General:

* Unify const_cusor and cursor facades/adapters. Otherwise their use is ridiculously complicated and redundant.
  (Something along the lines of implementing one of them and then providing a shortcut to build the other one around it).
* Implement "flat" (sequential *order representation) trees (cf. Knuth, Fundamental Algorithms,
  pp. 348--351). Those should be especially useful for automated testing of "real" (binary, 
  forest) trees.
* have `erase()` operations return cursor/iterator instead of void (as in new STD)
* modify parity/parent specs according to newsgroup thread, but members add to binary_tree cursor!
* Add O(n) generations(ancestor, descendant) algorithm (vertical distance) yielding number
  of generations between ancestor and descendant (ascending cursor only)
  Or rather, as this introduces something that shouldn't be conceptually different from
  std::distance: introduce a (forward, of course) (hierarchy_)ascending::iterator that just moves up 
  towards the root when incremented.
* We might need still more binary_tree members for more efficient functions operating on
  ranges...
* `insert()` and `erase()` semantics need reworking. For instance, Proposal 23.X.4.1.4 ยง2 
  (and related for deletion and multiway tree insertion/deletion) are way too convoluted
  for a really basic operation. Still, it's important to consider special cases such as
  root nodes and fields of use such as `forest_trees`; but for the latter, something similar
  as inorder_insert might come in handy.
* Actually implement stack-based pre- and postorder iterators for forward cursors.
* Get rid of checks for/assignments to root and shoot in pre/post/inorder algorithms,
  as they are otherwise limited to "whole" trees and cannot be applied to subtrees.
  In order to work for subtrees, it's probable that we need at least an int to store
  the current depth. (Which, in turn, would make the free-standing forward/back/next/prior 
  algortihms etc. more or less useless without that piece of extra information and would
  only leave us with the iterators to store it.)
  Alternatively (or additionally), we could implement (hierarchical) "subtree" versions
  of linear algorithms (as in the STL) in the respective namespace, eg 
  template <class Cur, class Op> Cur preorder::foreach(Cur subtree, Op f) { /* ... */ }
  That would leave to the algorithm how to store information about what the root is,
  or just not require that information by working recursively instead. (It might therefore even be
  faster than a "linear" algorithm using the *order iterator adaptors.)
  As for such an subtree-based algorithm approach, note that we already have an example:
  inorder::lower_bound (and upper_bound, of course) performs binary tree search and just
  *can't* be simulated via std::lower_bound (which just performs ordinary binary search)
  in an equally efficient way.
* Add (inorder-)threaded binary trees?? Are they useful? Can they be balanced?
* Start an RFC: what subtree algorithms should there be? In particular, of which of
  the STL's linear algorithms should there be a hierarchical version?
* How much sense would an output cursor make? Especially within the context 
  of the previous item.

Proposal:

* Add InputCursor requirements: binary cursor if it's a binary_tree member function, etc.
* Cursor validity after insertion/erasure/clearing
* Possibly rename ascending to hierarchy cursor? (because of other uses for ascending/cursors in a graph context)
* Remove operator* requirement? (for upward-growing trees with data only on the bottom level --- like B+trees)
* Add tree lower_bound algorithm (to namespace inorder because it's somewhat inorder dependent? or is it?)
* Refactor balancer section to map implementation 
	(balanced_tree template class using policies -- like red_black -- from namespace balancers)
* Add new metadata approach
* Add inorder_erase to balanced_tree requirements

Implementation:

* Implement remaining (binary_tree) balancers, augmentors
* Implement forest. Can its cursor type have an O(1) parent()?
* Implement nary_tree, multiway_tree, b_tree, b_star_tree
* Add tests for and rework
	* binary_tree: subtree insert; splice operations
	* red_black
	* searcher
* Concept checks.
* Interoperability with BGL algorithms.
* C++09: Add template typedefs (e.g. red_black_tree is balanced_tree<red_black_balancer, binary_tree>)

Documentation:

* Add some illustrations
* Overview: develop hierarchy/cursor concept step by step, using illustrations that 
  depict what is introduced at what step (nodes with pointers to their siblings, children, parents,
  a frame around a given cursor [and possibly additionally required information stated]
  that signifies what amount of information is contained within that cursor.

Further applications:

* Implement associative containers and priority_queue specialization using searcher
* Implement (binary) heap

[endsect]
