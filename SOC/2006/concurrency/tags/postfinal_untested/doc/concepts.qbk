[part Boost.Act
    [quickbook 1.4]
    [version 0.4b]
    [id act]
    [dirname act]
    [copyright 2006 Matthew Calabrese]
    [category C++ Concurrency Library]
    [authors [Calabrese, Matthew]]
    [source-mode c++]
]

[def __alert__           [$images/alert.png]]
[def __note__            [$images/note.png]]
[def __OpenMP__          [@http://www.OpenMP.org OpenMP]]

[section Concepts]

[section Act Model]

[table Act Model Requirements
[[Expression]         [Return Type]       [Pre/Post-Condition]                 ]
[[M::param< P >::type][Converted parameter
                       type.
                      ]                   [The converted type of given parameter
                                           type which is used to store arguments
                                           which are passed when a function is
                                           signalled using M as an =act model=.
                                          ]                                    ]
[[M::active_impl< T >][A type which is a
                       model of
                       =active impl=.
                      ]                   [Pre: T is a /cv-unqualified/ type.
                      
                                           Post:
                                           M::active_impl< T >::represented_type
                                           is T.
                                          ]                                    ]
[[M::action_impl< T >][A type which is a
                       model of
                       =action impl=.
                      ]                   [Pre: T is a /cv-unqualified/ type.
                      
                                           Post:
                                           M::action_impl< T >::represented_type
                                           is T.
                                          ]                                    ]
]

[section Active Implementation]

[table Active Implementation Requirements
[[Expression]         [Return Type]       [Pre/Post-Condition]                 ]
]

[endsect]

[section Action Implementation]

[table Action Implementation Requirements
[[Expression]         [Return Type]       [Pre/Post-Condition]                 ]
]

[endsect]

[section Function Package]

[table Function Package Requirements
[[Expression]         [Return Type]       [Pre/Post-Condition]                 ]
[[M::stored_type]     [A nullary function
                       object type.
                      ]                   []                                   ]
[[m.store()]          [M::stored_type]    []                                   ]
]

[endsect]

[endsect]

[section Active Interface]

=Active interfaces= 

[endsect]

[section Active Type]

=Active types= are a actually a family of concepts as opposed to a single
concept on their own. More precisely, an =active type= is a type which has been
qualified using one of the forms of `BOOST_ACTIVE` or the corresponding
`add_active` metafunctions described in the Type Traits section of this
documentation. 

[endsect]

[section Algorithm Model]

[table Algorithm Model Concept
[[Expression]        [Return Type]                       [Pre/Post Condition]  ]
[[M::algo_model_tag] [implementation-defined tag type]   [M::algo_model_tag is
                                                          unique to that of all
                                                          other algorithm models
                                                         ]                     ]
]

[endsect]

[section Atomic Type]



[endsect]

[section Concurrent Active Main]

=Concurrent Active Main= types are used when overriding the main function of the
thread that is used by an instantiation of a concurrent active type.

[endsect]

[section Polymorphic Algorithm]

A =polymorphic algorithm= is an algorithm whose model of execution is able to be
toggled on a 

[endsect]

[section Parallel-Safe Assignable]

There are two concepts used to describe the safety of copy-assignment operations
of a given type in =Boost.Act= ; the =basic parallel-safe assignable= concept,
and the =strong parallel-safe assignable concept=. When using certain algorithms
in =Boost.Act=, labeled models of these concepts may perform better than is
otherwise possible due to optimizations which rely on behavior as defined by
these associated concepts.

[section Basic Parallel-Safe Assignable]

A type is considered =basic parallel-safe assignable= if its copy-assignment
operation is a =parallel-safe operation= in cases where each thread is
guaranteed to be performing an assignment to a different instance of that type.

Types which are =basic parallel-safe assignable= may allow for certain
optimizations when working with =polymorphic algorithms=. For instance, calling
`copy[ parallel_algo_model() ]( first1, last1, first2 )` where
`iterator_value_type< first1 >::type` and `iterator_value_type< first2 >::type`
are the same `basic parallel-safe assignable` type will allow the execution to
be split up into multiple threads, whereas if the type is not
=basic parallel-safe assignable=, the algorithm will be run serially.

Users may identify their types as being =basic parallel-safe assignable= by
publically inheritting from `basic_parallel_safe_assignable` or by specializing
the `is_basic_parallel_safe_assignable` template describe in the =Type Traits=
section of this documentation.

[note By this definition, most types are =basic parallel-safe assignable=,
particularly any types which have trivial copy-assignment operations, however,
without the necessary compiler intrinsics this is impossible to detect
automatically. Examples of types which would not be considered
=basic parallel-safe assignable= include a hypothetical smart-pointer type which
does not perform thread-safe reference counting.
]

[endsect]

[section Strong Parallel-Safe Assignable]

[*Refinement of:] =basic parallel-safe assignable=

A type is considered =strong parallel-safe assignable= if its copy-assignment
operation is a =parallel-safe operation= regardless of the operand. Types which
fall into this category include atomic types and types whose copy-assignment
operation is entirely thread-safe (for instance, if it is performed while under
a lock).

Users may identify their types as being =strong parallel-safe assignable= by
publically inheritting from `strong_parallel_safe_assignable` or by specializing
the `is_strong_parallel_safe_assignable` template describe in the =Type Traits=
section of this documentation. Note that if a type is labeled as being
=strong parallel-safe assignable= through either of these techniques,
applications of the `is_basic_parallel_sage_assignable` metafunction will also
automatically yield `true`.

[endsect]

[endsect]

[section Parallel-Safe Operation]

A function is considered to be a =parallel-safe operation= if it may be safely
executed by `N` threads in parallel and have the same desired effect as if it
were run in one thread `N` times with the respective parameters.

A function object is considered to be a =parallel-safe operation= if `N` copies
of it may be safely executed executed by `N` threads in parallel and have the
same desired effect as if the original function object were executed in one
thread `N` times with the respective parameters.

[endsect]

[section Worker Allocator]

=Worker allocators= are used to spawn off additional threads of execution. In
Boost.Act, =worker allocators= are used when instantiating the
=basic_concurrent_act_model= template.

In order to be considered a valid =worker allocator=, the following expressions
must be well-formed and have the indicated effects (where `TA` is the type in
question and `ta` is an instance of that type).

[table Worker Allocator Requirements
[[Expression]      [Return Type]     [Pre/Post-Condition]                      ]
[[X::worker]        []                [The corresponding worker type.]         ]
[[a.allocate(f)]   [X::worker]       [A thread is allocated with `f` executing
                                      as its main function.
                                     ]                                         ]
[[X()]             []                [Creates a default instance. Note: a
                                      destructor is assumed.
                                     ]                                         ]
[[X a(b);]         []                [Post: `X(a) == b`]                       ]
]

[endsect]

[section Worker]

=Worker allocators= are used to spawn off additional threads of execution. In
Boost.Act, =worker allocators= are used when instantiating the
=basic_concurrent_act_model= template.

In order to be considered a valid =worker allocator=, the following expressions
must be well-formed and have the indicated effects (where `TA` is the type in
question and `ta` is an instance of that type).

[table Worker Requirements
[[Expression]      [Return Type]     [Pre/Post-Condition]                      ]
[[W::allocator]    []                [The worker's allocator type.]            ]
[[W w(a,f)]        []                [A worker is constructed with `f` as its
                                      main function.
                                     ]                                         ]
[[w.join()]        [Not used]        [The current thread waits for `w` to
                                      complete execution.
                                     ]                                         ]
]

[endsect]

[endsect]
