<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN" "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<article id="act" name="Boost.Act" dirname="act" last-revision="$Date: 2006/09/23 23:12:15 $"
 xmlns:xi="http://www.w3.org/2001/XInclude">
  <articleinfo>
    <author>
      <firstname>Matthew</firstname> <surname>Calabrese</surname>
    </author>
    <copyright>
      <year>2006</year> <holder>Matthew Calabrese</holder>
    </copyright>
    <legalnotice>
      <para>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
      </para>
    </legalnotice>
    <articlecategory name="category:C++ Concurrency Library"></articlecategory>
  </articleinfo>
  <title>Boost.Act 0.4b</title>
  <section id="act.brief_description">
    <title><link linkend="act.brief_description">Brief Description</link></title>
    <para>
      Boost.Act is a C++ library which introduces STL-style algorithms that may be
      toggled to run in parallel or serially, and which provides tools for creating
      and working with parallelable algorithms, asynchronous function calls, active
      objects, and atomic objects, all with implementations adjustable via policies.
    </para>
  </section>
  <section id="act.beta_warning">
    <title><link linkend="act.beta_warning">Beta Warning</link></title>
    <caution>
      <para>
        <literal>Boost.Act</literal> is still in beta and is not yet up for formal
        review. The documentation that follows details both features which are fully
        implemented and those which are partially. Because of this, <literal>Boost.Act</literal>
        is currently only recommended for testing and experimentation. Current compilers
        used during testing are Visual C++ 8.0, MinGW, and Intel 9.1.
      </para>
    </caution>
  </section>
  <section id="act.introduction">
    <title><link linkend="act.introduction">Introduction</link></title>
    <para>
      With the advent of multi-core processors reaching the mainstream user along
      with the gradual tapering of the increase of individual core speeds, there
      is a growing need for high-level tools to simplify the creation of multi-threaded
      applications in order to allow for scalability of software over the years to
      come. Preferably, a solution should also allow existing code-bases to be easily
      and incrementally updated to take advantage of modern day processors, and as
      well, code which may be targetting both multi-core and single-core processors
      should not have to suffer by strictly using one model of execution. Rather,
      behavior should be toggleable on a variety of levels such that alterations
      in a small number of locations in code could change the technique used for
      execution over a large portion of a given project.
    </para>
    <para>
      Boost.Act attempts to supply a solution to this problem in the form of a portable
      library which provides STL-style algorithms that can be toggled via template
      policies to execute either synchronously or in parallel, and by providing templates
      and macros to allow the creation of asynchronous functions, active objects,
      and atomic objects. In addition, Boost.Act also allows the decoupling of signaling
      function calls from their actual invocations in such a way that one may switch
      between immediate, concurrent, lazy evaluation, or a user-provided evaluation
      strategy on a case-by-case basis with potentially no runtime cost to the application.
    </para>
    <section id="act.introduction.polymorphic_algorithms">
      <title><link linkend="act.introduction.polymorphic_algorithms">Polymorphic
      Algorithms</link></title>
      <para>
        For the scope of this library, a polymorphic algorithm is considered to be
        an algorithm whose model of execution may vary depending on policies passed
        prior to invocation. For example, a polymorphic algorithm may run serially
        with one policy and may internally run in parallel and rejoin with a different
        policy. Regardless of which policies are used, the same logical operation
        is performed, allowing users to switch between different execution models
        with minimal changes to code.
      </para>
      <para>
        One of the fundamental components of Boost.Act is its collection of STL-style
        polymorphic algorithms. Those familiar with the STL will find themselves
        right at home, as the majority of the algorithms correspond directly with
        those in the STL and are callable in a similar manner, with the additional
        ability to toggle the execution model of the algorithm. Along with the standard
        algorithms provided by the STL, other templates are also included for the
        sole purpose of the creation of user-defined polymorphic algorithms.
      </para>
    </section>
    <section id="act.introduction.algorithm_models">
      <title><link linkend="act.introduction.algorithm_models">Algorithm Models</link></title>
      <para>
        By default, Boost.Act algorithms are performed in parallel whenever possible.
        Algorithm models are types which are used as policies to alter this behavior
        when required on both a global and call-by-call level. In addition to the
        parallel algorithm model, a serial algorithm model is provided which forces
        calls to be made in a single thread. Users may also create their own algorithm
        models if the desired behavior is not provided by either of those included
        with the library.
      </para>
    </section>
    <section id="act.introduction.actions">
      <title><link linkend="act.introduction.actions">Actions</link></title>
      <para>
        It is often desirable to be able to signal a function, perform other unrelated
        operations, and then eventually wait for the signaled function's completion.
        In order to provide such functionality, Boost.Act introduces the concept
        of an <literal>action</literal>.
      </para>
      <para>
        An <literal>action</literal> is a type which represents a signaled operation.
        With a stored <literal>action</literal>, you have access to that operation
        such that you may wait for the function's completion if you need the effects
        to have taken place prior to reaching a certain point in code. Actions also
        provide an indirect interface to the result of a signaled function.
      </para>
    </section>
    <section id="act.introduction.active_objects">
      <title><link linkend="act.introduction.active_objects">Active Objects</link></title>
      <para>
        Much like we have a way of decoupling the signaling of a function from the
        actual invocation of that function, Boost.Act also provides a way to separate
        the signaling of intrinsic functions of a type from the invocation of such
        functions, yet guarantees the same order of execution of such functions relative
        to one another. Since the invocations of such functions are also implicitly
        serialized, it makes it easy to signal several functions which all deal with
        the same object without having to worry that one call may occur while another
        is executing, and with the guarantee that they are called in the same order
        as they were signaled.
      </para>
    </section>
    <section id="act.introduction.act_models">
      <title><link linkend="act.introduction.act_models">Act Models</link></title>
      <para>
        While the main purpose of Boost.Act is to introduce higher-level threading
        facilities to C++, it does so in a manner that makes their behavior toggleable
        and very customizable. Modularity with respect to actions and active objects
        is accomplished by allowing their implementation to be altered through the
        use of policies called act models, much like how algorithm models are used
        to alter the implementation of parallelable algorithms. Whenever you instantiate
        an active type or an action, you have the option of passing an act model
        which may alter its implementation. If you choose not to pass a policy explicitly,
        the default policy is used, which is also changeable.
      </para>
      <para>
        Act models currently provided with Boost.Act are an immediate act model,
        a concurrent act model, and a lazy act model. Each model causes very distinct
        behavior, yet does not change the way you interface with the rest of the
        library. In brief, the immediate act model guarantees that operations are
        performed immediately when they are signaled and the function will not return
        until execution is complete. The concurrent act model allows active function
        calls to occur in their own thread and may also store active objects in their
        own thread. The lazy act model receives active function signals and adds
        them to a queue. The actual functions which are signaled will not be called
        until the result is required by the user through an explicit or implicit
        wait.
      </para>
      <para>
        By default, the concurrent act model is used, though this behavior is adjustable.
      </para>
    </section>
    <section id="act.introduction.atomic_objects">
      <title><link linkend="act.introduction.atomic_objects">Atomic Objects</link></title>
      <para>
        Frequently when working with multithreaded applications, a need arises to
        access a single object from multiple threads. Those experienced in multithreaded
        programming realize that this is not a trivial task for even relatively simple
        types.
      </para>
      <para>
        A thread-safe active object implementation is one way of making such functionality
        fairly simple to achieve without the possibility of deadlocks, however it
        also has the side-effect of having functions result in <literal>actions</literal>
        which can add needless complexity to the application if they are not needed.
        Atomic types provide a simpler solution by sharing the same interface as
        active objects but with functions that are executed immediately and that
        return their values directly as opposed to through actions.
      </para>
      <para>
        By default, all atomic objects internally use active objects, although the
        <literal>atomic_type</literal> template may be specialized to provide more
        efficient implementations where possible. <emphasis>Note: If OpenMP is supported,
        such optimizations are performed for standard scalar types</emphasis>.
      </para>
    </section>
  </section>
  <section id="act.compiler_setup">
    <title><link linkend="act.compiler_setup">Compiler Setup</link></title>
    <section id="act.compiler_setup.downloading_boost">
      <title><link linkend="act.compiler_setup.downloading_boost">Downloading Boost</link></title>
      <para>
        <literal>Boost.Act</literal> uses some libraries which will be in Boost 1.34
        yet are not available in 1.33. Because of this, if you wish to use <literal>Boost.Act</literal>,
        you must grab the latest version from the <ulink url="http://boost.org/more/getting_started.html#CVS">Boost
        CVS Repository</ulink>.
      </para>
    </section>
    <section id="act.compiler_setup.enabling_parallel_algorithms">
      <title><link linkend="act.compiler_setup.enabling_parallel_algorithms">Enabling
      Parallel Algorithms</link></title>
      <para>
        With the current implementation, in order to take advantage of the parallel
        algorithms provided by Boost.Act you must have a compiler that supports
        <ulink url="http://www.OpenMP.org">OpenMP</ulink> 1.0 extensions or higher.
      </para>
      <important>
        <para>
          <emphasis role="bold">If your compiler does not support the OpenMP extensions
          or if they are not enabled, <literal>polymorphic algorithms</literal> will
          execute serially regardless of whether or not you are using the <literal>parallel_algo_model</literal>
          policy.</emphasis>&nbsp;<sbr/> <sbr/> The following table is intended to
          be a quick reference for some of the more commonly used compilers. If your
          compiler is not listed it does not mean that OpenMP is not supported, but
          rather, it means that you should check your compiler's documentation to
          determine if you will be able to enable the OpenMP extensions in order
          to take advantage of parallel algorithms through Boost.Act.
        </para>
      </important>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">OpenMP Extension Support</phrase>
        </bridgehead>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Compiler</entry><entry>OpenMP Support</entry><entry>Compiler
              Switch</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><emphasis role="bold">Borland C++ Builder</emphasis></entry><entry>No</entry><entry>N/A</entry>
            </row>
            <row>
              <entry><emphasis role="bold">G++</emphasis></entry><entry><emphasis
              role="bold">GCC 4.2 and up:</emphasis> OpenMP 2.5</entry><entry>-fopenmp</entry>
            </row>
            <row>
              <entry><emphasis role="bold">IBM XLC</emphasis></entry><entry>OpenMP
              2.5</entry><entry>-qsmp=omp</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Intel C++</emphasis></entry><entry><emphasis
              role="bold">9.0 and up:</emphasis> OpenMP 2.5</entry><entry><emphasis
              role="bold">Windows:</emphasis> /Qopenmp <sbr/> <emphasis role="bold">Linux:</emphasis>
              -openmp </entry>
            </row>
            <row>
              <entry><emphasis role="bold">Lahey/Fujitsu</emphasis></entry><entry>OpenMP
              1.0? <emphasis>(ToDo: Check)</emphasis></entry><entry>--openmp</entry>
            </row>
            <row>
              <entry><emphasis role="bold">PG++</emphasis></entry><entry><emphasis
              role="bold">Linux only:</emphasis> OpenMP 2.5</entry><entry>-mp</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Sun Studio Compilers</emphasis></entry><entry>OpenMP
              2.5</entry><entry>-xopenmp</entry>
            </row>
            <row>
              <entry><emphasis role="bold">Visual C++</emphasis></entry><entry><emphasis
              role="bold">2005 Professional and up:</emphasis> OpenMP 2.0 </entry><entry>
              /openmp <sbr/> <sbr/> <link linkend="vc_openmp">Through IDE </link>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <anchor id="vc_openmp" />
      <para>
      </para>
      <anchor id="act.compiler_setup.enabling_parallel_algorithms.activating_openmp_support_in_visual_c___2005"/>
      <bridgehead renderas="sect4">
        <link linkend="act.compiler_setup.enabling_parallel_algorithms.activating_openmp_support_in_visual_c___2005">Activating
        OpenMP Support in Visual C++ 2005</link>
      </bridgehead>
      <para>
        In Visual Studio 2005 Professional Edition and higher, you may enable and
        disable OpenMP support by opening up the properties for your project, selecting
        <literal>Configuration Properties -&gt; C/C++ -&gt; Language</literal>, and
        setting <literal>OpenMP Support</literal> to <literal>Yes</literal>. Note
        that Visual Studio 2005 Express Edition and Standard Edition do <emphasis
        role="bold">not</emphasis> support OpenMP despite the option being there,
        so if you attempt to enable it you will get a linker error upon build.
      </para>
    </section>
    <section id="act.compiler_setup.linking_with_boost_threads">
      <title><link linkend="act.compiler_setup.linking_with_boost_threads">Linking
      with Boost.Threads</link></title>
      <para>
        In order to compile programs which use <literal>Boost.Act</literal>, you
        must build and link to <literal>Boost.Threads</literal>. For details on building
        Boost, see <ulink url="http://boost.org/more/getting_started.html#Build_Install">Build
        and Install</ulink>.
      </para>
    </section>
    <section id="act.compiler_setup.compiling_the_library">
      <title><link linkend="act.compiler_setup.compiling_the_library">Compiling the
      Library</link></title>
      <para>
        For simplicity during testing, <literal>Boost.Act</literal> is currently
        contained entirely in header files. Therefore, you do not need to explicitly
        build or link to <literal>Boost.Act</literal> in order to use it.
      </para>
    </section>
  </section>
  <section id="act.basic_usage">
    <title><link linkend="act.basic_usage">Basic Usage</link></title>
    <section id="act.basic_usage.parallel_copy">
      <title><link linkend="act.basic_usage.parallel_copy">Parallel Copy</link></title>
      <para>
        One operation which is easily parallelable is an algorithm which copies the
        objects represented in one range to another range. Much like <literal>::std::copy</literal>
        in the standard library, the corresponding algorithm in Boost.Act takes a
        source iterator range, represented by a begin and end iterator, followed
        by the begin iterator of a target range. Use of the algorithm is similar,
        only it exists in the <literal>::boost::act</literal> namespace as opposed
        to the <literal>::std</literal> namespace, and it also has the benefit of
        being useable with Boost.Lambda.
      </para>
      <para>
        The following code uses Boost.Act to copy one range to another, making the
        call parallel if the concurrent act model is the current default and the
        compiler supports OpenMP.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">algorithm</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">deque</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">vector</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">deque</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">copy</phrase><phrase role="special">;</phrase>

  <phrase role="comment">// Source range of 100 elements, each having the value 5
</phrase>  <phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">source</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase><phrase role="special">,</phrase> <phrase role="number">5</phrase> <phrase role="special">);</phrase>

  <phrase role="comment">//Target range
</phrase>  <phrase role="identifier">deque</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">target</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase> <phrase role="special">);</phrase>

  <phrase role="comment">// Uses ::boost::act::copy to copy from source to target
</phrase>  <phrase role="identifier">copy</phrase><phrase role="special">(</phrase> <phrase role="identifier">source</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase> <phrase role="identifier">source</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="identifier">target</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()</phrase> <phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Note that with user-defined types, an additional step has to be taken to
        allow the algorithm to execute in parallel. For more details, see __parallel<emphasis
        role="underline">traits</emphasis>_.
      </para>
    </section>
    <section id="act.basic_usage.parallel_for_each">
      <title><link linkend="act.basic_usage.parallel_for_each">Parallel For Each</link></title>
      <para>
        Another common algorithm which is often easily parallelable is <literal>for_each</literal>.
        Just like with <literal>copy</literal>, the semantics of <literal>for_each</literal>
        are similar to those of <literal>for_each</literal> in the STL. Here, the
        first two arguments are the begin and end iterators of a desired range, and
        the last is a function object to be applied on each of the elements in that
        range. This code also introduces a new mechanism, in the form of a base type
        called <literal>parallel_safe</literal>, which specifies that the given function
        object may be copied any number of times with each copy able to be invoked
        at the same time in different threads of execution and have the effect be
        the same as if a single instance were used in one thread for all iterations.
      </para>
      <para role="blurb">
        <inlinemediaobject><imageobject><imagedata fileref="images/alert.png"></imagedata></imageobject>
        <textobject>
          <phrase>alert</phrase>
        </textobject>
        </inlinemediaobject> Without inheriting from the <literal>parallel_safe</literal>
        base type or using other means to identify your function as being safe for
        use in a parallel algorithm described in the __parallel<emphasis role="underline">traits</emphasis>_
        section, calling <literal>for_each</literal> or any other parallelable algorithm
        provided by Boost.Act with an instance of your function object type will
        cause the algorithm to run synchronously.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">algorithm</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">parallel_safe</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">vector</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">increment</phrase>
  <phrase role="special">:</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">parallel_safe</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="keyword">int</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">target</phrase> <phrase role="special">)</phrase> <phrase role="keyword">const</phrase>
  <phrase role="special">{</phrase>
    <phrase role="special">++</phrase><phrase role="identifier">target</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase><phrase role="special">;</phrase>

  <phrase role="comment">// Source range of 100 elements, each having the value 4
</phrase>  <phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">source</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase><phrase role="special">,</phrase> <phrase role="number">4</phrase> <phrase role="special">);</phrase>

  <phrase role="comment">// Uses ::boost::act::for_each to increment each element
</phrase>  <phrase role="identifier">for_each</phrase><phrase role="special">(</phrase> <phrase role="identifier">source</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase> <phrase role="identifier">source</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase> <phrase role="identifier">increment</phrase><phrase role="special">()</phrase> <phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
    </section>
    <section id="act.basic_usage.creating_polymorphic_algorithms">
      <title><link linkend="act.basic_usage.creating_polymorphic_algorithms">Creating
      Polymorphic Algorithms</link></title>
      <para>
        While Boost.Act provides many common polymorphic algorithms, it would not
        be complete without the ability for users to create their own. The creation
        of such algorithms in Boost.Act is performed through the use of the function
        object <literal>basic_for</literal>. <literal>basic_for</literal> is a simplified
        form of for loop construct which limits the loop variable to built-in integral
        types, limits the comparison to ordered comparison operators, and limits
        the step expression to additive operations applied to the loop variable.
        All values other than the loop variable are calculated once upon entry into
        the algorithm. If an attempt is made to specify more complex expressions
        than described, the code will not compile.
      </para>
      <para>
        In order to use the <literal>basic_for</literal> algorithm, you may <code><phrase
        role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase
        role="identifier">boost</phrase><phrase role="special">/</phrase><phrase
        role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">algorithm</phrase><phrase
        role="special">/</phrase><phrase role="identifier">basic_for</phrase><phrase
        role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
        or <code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase role="special">&lt;</phrase><phrase
        role="identifier">boost</phrase><phrase role="special">/</phrase><phrase
        role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">algorithm</phrase><phrase
        role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>.
        Initialization, condition, and step expressions are specified as the first,
        second, and third arguments respectively, using <literal>boost::act::for_var</literal>
        to refer to the loop variable. The type of the loop variable is determined
        by the type of the variable of which it is initialized to. To represent the
        body of the for loop, one must pass a function object as an argument to the
        index operator following the call to <literal>basic_for</literal>, or as
        a fourth argument to <literal>basic_for</literal>. Function objects passed
        in this manner are applied during each iteration of the associated <literal>basic_for</literal>
        operation and receive the current loop variable value as an argument with
        each call.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">algorithm</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">output_for_var</phrase>
  <phrase role="special">:</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">parallel_safe</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">index</phrase> <phrase role="special">)</phrase> <phrase role="keyword">const</phrase>
  <phrase role="special">{</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">index</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_for</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">for_var</phrase><phrase role="special">;</phrase>
  
  <phrase role="identifier">basic_for</phrase><phrase role="special">(</phrase> <phrase role="identifier">for_var</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="identifier">for_var</phrase> <phrase role="special">&lt;</phrase> <phrase role="number">10</phrase><phrase role="special">,</phrase> <phrase role="special">++</phrase><phrase role="identifier">for_var</phrase> <phrase role="special">)</phrase>
  <phrase role="special">[</phrase>
    <phrase role="identifier">output_for_var</phrase><phrase role="special">()</phrase>
  <phrase role="special">];</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        In future releases, Boost.Act will expose more constructs other than <literal>basic_for</literal>.
      </para>
    </section>
    <section id="act.basic_usage.creating_actions">
      <title><link linkend="act.basic_usage.creating_actions">Creating Actions</link></title>
      <para>
        Having algorithms run in parallel and join prior to returning is one easy
        way to take advantantage of multi-threading capabilities. However, as previously
        described, often times one may wish to signal an operation to be performed
        and not require the actual operation to complete its execution until some
        later point in code. This allows you to signal one task, perform some other
        unrelated operations, and then come back at some later point in time to optionally
        force a wait for the original operation to complete. Such behavior is expressible
        in Boost.Act through the use of <literal>actions</literal>.
      </para>
      <para>
        In the following code, an <literal>action</literal> is used to signal a function
        call using the default act model, perform some simple calculations on unrelated
        data, and then finally go back and obtain the result of the operation.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">action</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">factorial</phrase><phrase role="special">(</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">value</phrase> <phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">return</phrase> <phrase role="special">(</phrase> <phrase role="identifier">value</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase> <phrase role="special">)</phrase> <phrase role="special">?</phrase> <phrase role="number">1</phrase> <phrase role="special">:</phrase> <phrase role="identifier">value</phrase> <phrase role="special">*</phrase> <phrase role="identifier">factorial</phrase><phrase role="special">(</phrase> <phrase role="identifier">value</phrase> <phrase role="special">-</phrase> <phrase role="number">1</phrase> <phrase role="special">);</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">action</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">as_function</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase>

  <phrase role="comment">// Where unsigned int is the return type of the function
</phrase>  <phrase role="identifier">action</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">fac_10</phrase><phrase role="special">(</phrase> <phrase role="identifier">as_function</phrase><phrase role="special">(</phrase> <phrase role="identifier">factorial</phrase> <phrase role="special">),</phrase> <phrase role="number">10</phrase> <phrase role="special">);</phrase>

  <phrase role="identifier">factorial</phrase><phrase role="special">(</phrase> <phrase role="number">15</phrase> <phrase role="special">);</phrase>

  <phrase role="comment">// Wait for the return value and store it in result
</phrase>  <phrase role="keyword">int</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">result</phrase> <phrase role="special">=</phrase> <phrase role="identifier">fac_10</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">inactive_value</phrase><phrase role="special">();</phrase>

  <phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;10! = &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">result</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        The above code presents some unfamiliar functions. First, we have <literal>as_function</literal>,
        which is used to specify that the first argument you are passing to the action
        constructor is a function to execute. This is necessary for disambiguation
        between other action constructors which will be described later. Following
        that argument is the value 10, which is the argument to be passed to <literal>factorial</literal>
        for invocation. Finally, before main finishes execution, we indirectly call
        <literal>inactive_value</literal> through <literal>fac_10</literal>, which
        is how we specify that we wish to obtain a copy of the result of the function
        call, implicitly waiting for the function to complete. In this example, a
        function was used, however, a function object could have been used as well.
      </para>
    </section>
    <section id="act.basic_usage.instantiating_active_types">
      <title><link linkend="act.basic_usage.instantiating_active_types">Instantiating
      Active Types</link></title>
      <para>
        Active objects in Boost.Act are implemented through the use of a pseudo-qualifier
        applied via a macro. Much like <literal>const</literal> or <literal>volatile</literal>,
        you can take any type and add the qualifier to it, which limits the interface
        of the type to only active qualified member functions and other functions
        which take an active qualified version as a parameter. Like with <literal>const</literal>
        or <literal>volatile</literal> member functions, you must specify in their
        definition that the object must be appropriately qualified for use with the
        function. Such calls return <literal>actions</literal> so that you may wait
        for completion and access the result of the call similar to the manner in
        which you would for active function calls as described in the previous section.
        Boost.Act defines appropriate operations for built-ins such that you may,
        for example, work with active arithmetic types intuitively.
      </para>
      <para>
        The simplest way to qualify a type with active is to <code><phrase role="preprocessor">#include</phrase>
        <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
        role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase
        role="identifier">active</phrase><phrase role="special">.</phrase><phrase
        role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
        and use the macro <literal>BOOST_ACTIVE</literal>, which takes a single type
        as a parameter enclosed in parenthesis yields a datatype which has the same
        const-qualification as the type which was passed and which represents the
        active form of the type.
      </para>
      <para>
        The following code defines an active int and performs a series of operations
        on it.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">action</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">active</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">action</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>

  <phrase role="comment">// Note that int is encapsulated in an extra set of parenthesis
</phrase>  <phrase role="identifier">BOOST_ACTIVE</phrase><phrase role="special">((</phrase><phrase role="keyword">int</phrase><phrase role="special">))</phrase> <phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">value</phrase> <phrase role="special">+=</phrase> <phrase role="number">10</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="special">*-</phrase><phrase role="identifier">value</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">action</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">result</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value</phrase> <phrase role="special">+</phrase> <phrase role="identifier">value</phrase><phrase role="special">;</phrase>

  <phrase role="special">++</phrase><phrase role="identifier">value</phrase><phrase role="special">;</phrase>

  <phrase role="comment">// result's value may not be calculated at this point
</phrase>
  <phrase role="comment">// Output the result (forcing a wait)
</phrase>  <phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;value after the calculation is completed: &quot;</phrase>
       <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">result</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">inactive_value</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        The above code creates an active <literal>int</literal> and signals several
        operations to be performed using its value. While each operation is guaranteed
        to be performed in order, it's dependent on the default act model as to when
        they will be run. At the end of main, the application waits for the result,
        much like the code in the previous section. Here, the wait also implies that
        the other calculations on value signaled prior to result's initialization
        are completed by the time the call to <literal>inactive_value</literal> returns.
        The call to <literal>++value</literal>, however, may have not yet occured.
      </para>
      <anchor id="act.basic_usage.instantiating_active_types.active_qualifying_types_dependent_on_template_arguments"/>
      <bridgehead renderas="sect4">
        <link linkend="act.basic_usage.instantiating_active_types.active_qualifying_types_dependent_on_template_arguments">Active-qualifying
        Types Dependent on Template Arguments</link>
      </bridgehead>
      <para>
        While you may normally use the BOOST_ACTIVE macro to active-qualify a given
        type, in cases where the type being qualified is dependent on a template
        argument you must use BOOST_ACTIVE_T instead.
      </para>
    </section>
    <section id="act.basic_usage.instantiating_atomic_types">
      <title><link linkend="act.basic_usage.instantiating_atomic_types">Instantiating
      Atomic Types</link></title>
      <para>
        Atomic types in Boost.Act share the same interface as corresponding active
        types, with the exception being that their functions directly return their
        values as opposed to returning <literal>actions</literal>. Also unlike active
        types is the exclusion of an explicit act model.
      </para>
      <para>
        Instantiation of atomic types is done using the <literal>BOOST_ATOMIC</literal>
        macro and its associated forms. Much like with <literal>BOOST_ACTIVE</literal>,
        the type being passed must be surrounded by an extra set of parenthesis.
      </para>
      <para>
        The following code defines an <literal>atomic</literal> int and manipulates
        in two different threads.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">action</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">atomic</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">modify_value</phrase><phrase role="special">(</phrase> <phrase role="identifier">BOOST_ATOMIC</phrase><phrase role="special">((</phrase><phrase role="keyword">int</phrase><phrase role="special">))&amp;</phrase> <phrase role="identifier">value</phrase> <phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">// value is updated atomically
</phrase>  <phrase role="identifier">value</phrase> <phrase role="special">*=</phrase> <phrase role="number">2</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">action</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">as_function</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
  
  <phrase role="comment">// Create an atomic int
</phrase>  <phrase role="identifier">BOOST_ATOMIC</phrase><phrase role="special">((</phrase><phrase role="keyword">int</phrase><phrase role="special">))</phrase> <phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="number">20</phrase><phrase role="special">;</phrase>
  
  <phrase role="comment">// Execute the modify_value function asynchronous to the call-site
</phrase>  <phrase role="identifier">action</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">void</phrase><phrase role="special">,</phrase> <phrase role="identifier">concurrent_act_model</phrase> <phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase>
    <phrase role="identifier">modify_value_action</phrase><phrase role="special">(</phrase> <phrase role="identifier">as_function</phrase><phrase role="special">(</phrase> <phrase role="identifier">modify_value</phrase> <phrase role="special">)</phrase>
                       <phrase role="special">,</phrase> <phrase role="identifier">value</phrase>
                       <phrase role="special">);</phrase>
  
  <phrase role="comment">// value is updated atomically
</phrase>  <phrase role="identifier">value</phrase> <phrase role="special">/=</phrase> <phrase role="number">2</phrase><phrase role="special">;</phrase>
  
  <phrase role="identifier">modify_value_action</phrase><phrase role="special">.</phrase><phrase role="identifier">wait</phrase><phrase role="special">();</phrase>
  
  <phrase role="comment">// Output is guaranteed to be the value 20
</phrase>  <phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;value: &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">value</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
    </section>
    <section id="act.basic_usage.accessing_active_objects_via_actions">
      <title><link linkend="act.basic_usage.accessing_active_objects_via_actions">Accessing
      Active Objects via Actions</link></title>
      <para>
        As was mentioned, the results of actions can be accessed indirectly through
        action objects. This allows you to make active function calls and signal
        operations on the result without having to wait for the initial function
        to complete.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">action</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">factorial</phrase><phrase role="special">(</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">value</phrase> <phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">return</phrase> <phrase role="special">(</phrase> <phrase role="identifier">value</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase> <phrase role="special">)</phrase> <phrase role="special">?</phrase> <phrase role="number">1</phrase> <phrase role="special">:</phrase> <phrase role="identifier">value</phrase> <phrase role="special">*</phrase> <phrase role="identifier">factorial</phrase><phrase role="special">(</phrase> <phrase role="identifier">value</phrase> <phrase role="special">-</phrase> <phrase role="number">1</phrase> <phrase role="special">);</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">action</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">as_function</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>

  <phrase role="comment">// Where int is the return type of the function
</phrase>  <phrase role="identifier">action</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">fac_10</phrase><phrase role="special">(</phrase> <phrase role="identifier">as_function</phrase><phrase role="special">(</phrase> <phrase role="identifier">factorial</phrase> <phrase role="special">),</phrase> <phrase role="number">10</phrase> <phrase role="special">);</phrase>

  <phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="identifier">factorial</phrase><phrase role="special">(</phrase> <phrase role="number">15</phrase> <phrase role="special">);</phrase>

  <phrase role="comment">// Use -&gt; and * to access the result value as though it were an active
</phrase>  <phrase role="comment">// object. Note that this does not a force a wait, but rather, it adds the
</phrase>  <phrase role="comment">// += operation to a queue
</phrase>  <phrase role="identifier">action</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">result</phrase> <phrase role="special">=</phrase> <phrase role="special">(*</phrase><phrase role="identifier">fac_10</phrase><phrase role="special">)</phrase> <phrase role="special">+=</phrase> <phrase role="identifier">value</phrase><phrase role="special">;</phrase>

  <phrase role="comment">// fac_10's value may not be calculated at this point
</phrase>
  <phrase role="comment">// Forces a wait to get the resultant value
</phrase>  <phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;10! + 15! = &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">result</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">inactive_value</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
    </section>
    <section id="act.basic_usage.creating_active_interfaces">
      <title><link linkend="act.basic_usage.creating_active_interfaces">Creating
      Active Interfaces</link></title>
      <para>
        Working with built-in types is great, but without the ability to define active
        interfaces for your own types, Boost.Act would leave much to be desired.
        The code needed to make simple interfaces for active objects tends to be
        somewhat complicated, so a collection of macros are provided to make the
        development of active interfaces easier.
      </para>
      <para>
        To create an active interface for a type, you must start by partially specializing
        <literal>active_interface</literal> in <literal>boost::act</literal> for
        your type. The body of the template specialization now corresponds to an
        extension of the body of the type for which you are making the active interface.
        Here you may use macros provided by Boost.Act to create member functions
        and friend functions which may be used with active qualified instantiations
        of your type. From within the defintion of these functions, you have access
        to the active-unqualified version of your object.
      </para>
      <para>
        From that point on, you may use the functions you created when you instantiate
        your type with active qualification.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">action</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">active</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">your_type</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">your_type</phrase><phrase role="special">()</phrase> <phrase role="special">:</phrase> <phrase role="identifier">value</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase> <phrase role="special">)</phrase> <phrase role="special">{}</phrase>
  <phrase role="keyword">int</phrase> <phrase role="identifier">value</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase>
<phrase role="special">{</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">act</phrase>
<phrase role="special">{</phrase>

<phrase role="identifier">BOOST_ACT_ACTIVE_INTERFACE_SPEC</phrase><phrase role="special">(</phrase> <phrase role="special">::</phrase><phrase role="identifier">your_type</phrase> <phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">BOOST_ACT_MEM_FUN</phrase><phrase role="special">(</phrase> <phrase role="special">(</phrase><phrase role="keyword">void</phrase><phrase role="special">),</phrase> <phrase role="identifier">update_value</phrase><phrase role="special">,</phrase> <phrase role="special">((</phrase><phrase role="keyword">int</phrase><phrase role="special">),</phrase><phrase role="identifier">left</phrase><phrase role="special">)</phrase> <phrase role="special">((</phrase><phrase role="keyword">int</phrase><phrase role="special">),</phrase><phrase role="identifier">right</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">using</phrase> <phrase role="special">::</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">using</phrase> <phrase role="special">::</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
    
    <phrase role="comment">// Use target to access the target object
</phrase>    <phrase role="identifier">target</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase> <phrase role="special">+=</phrase> <phrase role="identifier">left</phrase> <phrase role="special">*</phrase> <phrase role="identifier">right</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;New value: &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">target</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase>

<phrase role="special">}</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">action</phrase><phrase role="special">;</phrase>

  <phrase role="identifier">BOOST_ACTIVE</phrase><phrase role="special">((</phrase><phrase role="identifier">your_type</phrase><phrase role="special">))</phrase> <phrase role="identifier">object</phrase><phrase role="special">;</phrase>
  
  <phrase role="comment">// Call update value (queues function, returns immediately)
</phrase>  <phrase role="identifier">object</phrase><phrase role="special">.</phrase><phrase role="identifier">update_value</phrase><phrase role="special">(</phrase> <phrase role="number">3</phrase><phrase role="special">,</phrase> <phrase role="number">4</phrase> <phrase role="special">);</phrase>
  
  <phrase role="identifier">action</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">running_fun</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">.</phrase><phrase role="identifier">update_value</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">2</phrase> <phrase role="special">);</phrase>
  
  <phrase role="identifier">object</phrase><phrase role="special">.</phrase><phrase role="identifier">update_value</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">6</phrase> <phrase role="special">);</phrase>
  
  <phrase role="identifier">running_fun</phrase><phrase role="special">.</phrase><phrase role="identifier">wait</phrase><phrase role="special">();</phrase> <phrase role="comment">// Force running_fun to complete
</phrase><phrase role="special">}</phrase>
</programlisting>
    </section>
  </section>
  <section id="act.advanced_usage">
    <title><link linkend="act.advanced_usage">Advanced Usage</link></title>
    <section id="act.advanced_usage.specifying_algorithm_models_at_the_call_site">
      <title><link linkend="act.advanced_usage.specifying_algorithm_models_at_the_call_site">Specifying
      Algorithm Models at the Call-Site</link></title>
      <para>
        While changing the default algorithm model allows one to adjust how parallelable
        algorithms run, you may also adjust the execution model explicitly at each
        call-site, overriding the default. This is performed by passing an algorithm
        model instantiation to a call to the index operation of provided parallelable
        algorithms.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">algorithm</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">parallel_safe</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">common_algo_models</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">vector</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">operation</phrase>
  <phrase role="special">:</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">::</phrase><phrase role="identifier">parallel_safe</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">value</phrase> <phrase role="special">)</phrase> <phrase role="keyword">const</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">// Implementation here
</phrase>  <phrase role="special">}</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">;</phrase>
  
  <phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">dummy_data</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase> <phrase role="special">);</phrase>
  
  <phrase role="comment">// Executes in parallel regardless of default algorithm model
</phrase>  <phrase role="identifier">for_each</phrase><phrase role="special">[</phrase> <phrase role="identifier">parallel</phrase> <phrase role="special">](</phrase> <phrase role="identifier">dummy_data</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase> <phrase role="identifier">dummy_data</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">()</phrase>
                      <phrase role="special">,</phrase> <phrase role="identifier">operation</phrase><phrase role="special">()</phrase>
                      <phrase role="special">);</phrase>

  <phrase role="comment">// Executes serially regardless of default algorithm model
</phrase>  <phrase role="identifier">for_each</phrase><phrase role="special">[</phrase> <phrase role="identifier">serial</phrase> <phrase role="special">](</phrase> <phrase role="identifier">dummy_data</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase> <phrase role="identifier">dummy_data</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">()</phrase>
                    <phrase role="special">,</phrase> <phrase role="identifier">operation</phrase><phrase role="special">()</phrase>
                    <phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
    </section>
    <section id="act.advanced_usage.passing_model_specific_arguments_to_polymorphic_algorithms">
      <title><link linkend="act.advanced_usage.passing_model_specific_arguments_to_polymorphic_algorithms">Passing
      Model-Specific Arguments to Polymorphic Algorithms</link></title>
      <para>
        In addition to using an algorithm model as a policy for polymorphic algorithms,
        you may also adjust the implementation of algorithms by passing model-specific
        arguments. Arguments passed in this manner are specified in place of the
        algorithm model, and the algorithm model is then deduced by the type of the
        arguments.
      </para>
      <para>
        The most common use of this feature is to pass the number of worker threads
        that the parallel algorithm model should use in its implementation. Without
        specifying this count, the application will automatically determine the number
        of worker threads to use at runtime.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">algorithm</phrase><phrase role="special">/</phrase><phrase role="identifier">copy</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">common_algo_models</phrase><phrase role="special">/</phrase><phrase role="identifier">parallel_algo_model</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">using</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">;</phrase>
  
  <phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">source</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase> <phrase role="special">),</phrase>
                <phrase role="identifier">target</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase> <phrase role="special">);</phrase>
  
  <phrase role="comment">// Executes in parallel regardless of default algorithm model
</phrase>  <phrase role="comment">// Specifies that 10 worker threads should be used
</phrase>  <phrase role="identifier">copy</phrase><phrase role="special">[</phrase> <phrase role="identifier">parallel</phrase><phrase role="special">,</phrase> <phrase role="identifier">worker_count</phrase> <phrase role="special">=</phrase> <phrase role="number">10</phrase> <phrase role="special">](</phrase> <phrase role="identifier">source</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()</phrase>
                                     <phrase role="special">,</phrase> <phrase role="identifier">source</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">()</phrase>
                                     <phrase role="special">,</phrase> <phrase role="identifier">target</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()</phrase>
                                     <phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
    </section>
    <section id="act.advanced_usage.specifying_act_models_during_action_and_active_type_instantiation">
      <title><link linkend="act.advanced_usage.specifying_act_models_during_action_and_active_type_instantiation">Specifying
      Act Models during Action and Active Type Instantiation</link></title>
      <para>
        Specifying act models during the instantiation of active types and actions
        is just as easy. For active types, use BOOST_ACTIVE_M and pass the act model
        as a second argument, encapsulated in parenthesis. For actions, pass the
        act model as a second template argument to the standard action template.
        Keep in mind that if you signal a function on an active object and wish to
        have a handle to the running operation in the form of an action, you must
        instantiate the action template with the same act model type.
      </para>
      
<programlisting>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">active</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">action</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase role="identifier">common_act_models</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">act</phrase><phrase role="special">;</phrase>
  
  <phrase role="comment">// Use the concurrent act model regardless of the default
</phrase>  <phrase role="identifier">BOOST_ACTIVE_M</phrase><phrase role="special">(</phrase> <phrase role="special">(</phrase><phrase role="keyword">int</phrase><phrase role="special">),</phrase> <phrase role="special">(</phrase><phrase role="identifier">concurrent</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase> <phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
  
  <phrase role="comment">// Must use the same act model as above
</phrase>  <phrase role="identifier">action</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="identifier">concurrent</phrase> <phrase role="special">&gt;</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">other_value</phrase> <phrase role="special">=</phrase> <phrase role="identifier">value</phrase> <phrase role="special">+</phrase> <phrase role="number">5</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para role="blurb">
        <inlinemediaobject><imageobject><imagedata fileref="images/note.png"></imagedata></imageobject>
        <textobject>
          <phrase>note</phrase>
        </textobject>
        </inlinemediaobject> Much like the BOOST_ACTIVE macro, BOOST_ACTIVE_M cannot
        be used if the type being qualified is dependent on a template argument.
        Similarly, if the specified act model is dependent on a template argument,
        BOOST_ACTIVE_M cannot be used. If either of these conditions is true, you
        must use the macro BOOST_ACTIVE_M_T instead.
      </para>
    </section>
    <section id="act.advanced_usage.overriding_a_concurrent_active_object_s_main_function">
      <title><link linkend="act.advanced_usage.overriding_a_concurrent_active_object_s_main_function">Overriding
      a Concurrent Active Object's Main Function</link></title>
      <para>
        Concurrent <literal>active</literal> objects execute associated operations
        in their respective thread. By default, the main function of this thread
        waits for a queue of function objects and executes them in first-in, first-out
        order. In certain situations, it may be beneficial to provide an alternative
        form of main which performs other operations in between queued calls, or
        which manages how it deals with its time-slices at a lower level.
      </para>
    </section>
  </section>
  <section id="act.concepts">
    <title><link linkend="act.concepts">Concepts</link></title>
    <section id="act.concepts.act_model">
      <title><link linkend="act.concepts.act_model">Act Model</link></title>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Act Model Requirements</phrase>
        </bridgehead>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Expression</entry><entry>Return Type</entry><entry>Pre/Post-Condition</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>M::param&lt; P &gt;::type</entry><entry>Converted parameter
              type. </entry><entry>The converted type of given parameter type which
              is used to store arguments which are passed when a function is signalled
              using M as an <literal>act model</literal>. </entry>
            </row>
            <row>
              <entry>M::active_impl&lt; T &gt;</entry><entry>A type which is a model
              of <literal>active impl</literal>. </entry><entry>Pre: T is a <emphasis>cv-unqualified</emphasis>
              type. Post: M::active_impl&lt; T &gt;::represented_type is T. </entry>
            </row>
            <row>
              <entry>M::action_impl&lt; T &gt;</entry><entry>A type which is a model
              of <literal>action impl</literal>. </entry><entry>Pre: T is a <emphasis>cv-unqualified</emphasis>
              type. Post: M::action_impl&lt; T &gt;::represented_type is T. </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <section id="act.concepts.act_model.active_implementation">
        <title><link linkend="act.concepts.act_model.active_implementation">Active
        Implementation</link></title>
        <informaltable frame="all">
          <bridgehead renderas="sect4">
            <phrase role="table-title">Active Implementation Requirements</phrase>
          </bridgehead>
          <tgroup cols="3">
            <tbody>
              <row>
                <entry>Expression</entry><entry>Return Type</entry><entry>Pre/Post-Condition</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
      <section id="act.concepts.act_model.action_implementation">
        <title><link linkend="act.concepts.act_model.action_implementation">Action
        Implementation</link></title>
        <informaltable frame="all">
          <bridgehead renderas="sect4">
            <phrase role="table-title">Action Implementation Requirements</phrase>
          </bridgehead>
          <tgroup cols="3">
            <tbody>
              <row>
                <entry>Expression</entry><entry>Return Type</entry><entry>Pre/Post-Condition</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
      <section id="act.concepts.act_model.function_package">
        <title><link linkend="act.concepts.act_model.function_package">Function Package</link></title>
        <informaltable frame="all">
          <bridgehead renderas="sect4">
            <phrase role="table-title">Function Package Requirements</phrase>
          </bridgehead>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Expression</entry><entry>Return Type</entry><entry>Pre/Post-Condition</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>M::stored_type</entry><entry>A nullary function object type.
                </entry><entry></entry>
              </row>
              <row>
                <entry>m.store()</entry><entry>M::stored_type</entry><entry></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
    </section>
    <section id="act.concepts.active_interface">
      <title><link linkend="act.concepts.active_interface">Active Interface</link></title>
      <para>
        <literal>Active interfaces</literal>
      </para>
    </section>
    <section id="act.concepts.active_type">
      <title><link linkend="act.concepts.active_type">Active Type</link></title>
      <para>
        <literal>Active types</literal> are a actually a family of concepts as opposed
        to a single concept on their own. More precisely, an <literal>active type</literal>
        is a type which has been qualified using one of the forms of <code><phrase
        role="identifier">BOOST_ACTIVE</phrase></code> or the corresponding <code><phrase
        role="identifier">add_active</phrase></code> metafunctions described in the
        Type Traits section of this documentation.
      </para>
    </section>
    <section id="act.concepts.algorithm_model">
      <title><link linkend="act.concepts.algorithm_model">Algorithm Model</link></title>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Algorithm Model Concept</phrase>
        </bridgehead>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Expression</entry><entry>Return Type</entry><entry>Pre/Post
              Condition</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>M::algo_model_tag</entry><entry>implementation-defined tag type</entry><entry>M::algo_model_tag
              is unique to that of all other algorithm models </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section id="act.concepts.atomic_type">
      <title><link linkend="act.concepts.atomic_type">Atomic Type</link></title>
    </section>
    <section id="act.concepts.concurrent_active_main">
      <title><link linkend="act.concepts.concurrent_active_main">Concurrent Active
      Main</link></title>
      <para>
        <literal>Concurrent Active Main</literal> types are used when overriding
        the main function of the thread that is used by an instantiation of a concurrent
        active type.
      </para>
    </section>
    <section id="act.concepts.polymorphic_algorithm">
      <title><link linkend="act.concepts.polymorphic_algorithm">Polymorphic Algorithm</link></title>
      <para>
        A <literal>polymorphic algorithm</literal> is an algorithm whose model of
        execution is able to be toggled on a
      </para>
    </section>
    <section id="act.concepts.parallel_safe_assignable">
      <title><link linkend="act.concepts.parallel_safe_assignable">Parallel-Safe
      Assignable</link></title>
      <para>
        There are two concepts used to describe the safety of copy-assignment operations
        of a given type in <literal>Boost.Act</literal> ; the <literal>basic parallel-safe
        assignable</literal> concept, and the <literal>strong parallel-safe assignable
        concept</literal>. When using certain algorithms in <literal>Boost.Act</literal>,
        labeled models of these concepts may perform better than is otherwise possible
        due to optimizations which rely on behavior as defined by these associated
        concepts.
      </para>
      <section id="act.concepts.parallel_safe_assignable.basic_parallel_safe_assignable">
        <title><link linkend="act.concepts.parallel_safe_assignable.basic_parallel_safe_assignable">Basic
        Parallel-Safe Assignable</link></title>
        <para>
          A type is considered <literal>basic parallel-safe assignable</literal>
          if its copy-assignment operation is a <literal>parallel-safe operation</literal>
          in cases where each thread is guaranteed to be performing an assignment
          to a different instance of that type.
        </para>
        <para>
          Types which are <literal>basic parallel-safe assignable</literal> may allow
          for certain optimizations when working with <literal>polymorphic algorithms</literal>.
          For instance, calling <code><phrase role="identifier">copy</phrase><phrase
          role="special">[</phrase>&nbsp;<phrase role="identifier">parallel_algo_model</phrase><phrase
          role="special">()</phrase>&nbsp;<phrase role="special">](</phrase>&nbsp;<phrase
          role="identifier">first1</phrase><phrase role="special">,</phrase>&nbsp;<phrase
          role="identifier">last1</phrase><phrase role="special">,</phrase>&nbsp;<phrase
          role="identifier">first2</phrase>&nbsp;<phrase role="special">)</phrase></code>
          where <code><phrase role="identifier">iterator_value_type</phrase><phrase
          role="special">&lt;</phrase>&nbsp;<phrase role="identifier">first1</phrase>&nbsp;<phrase
          role="special">&gt;::</phrase><phrase role="identifier">type</phrase></code>
          and <code><phrase role="identifier">iterator_value_type</phrase><phrase
          role="special">&lt;</phrase>&nbsp;<phrase role="identifier">first2</phrase>&nbsp;<phrase
          role="special">&gt;::</phrase><phrase role="identifier">type</phrase></code>
          are the same <code><phrase role="identifier">basic</phrase>&nbsp;<phrase
          role="identifier">parallel</phrase><phrase role="special">-</phrase><phrase
          role="identifier">safe</phrase>&nbsp;<phrase role="identifier">assignable</phrase></code>
          type will allow the execution to be split up into multiple threads, whereas
          if the type is not <literal>basic parallel-safe assignable</literal>, the
          algorithm will be run serially.
        </para>
        <para>
          Users may identify their types as being <literal>basic parallel-safe assignable</literal>
          by publically inheritting from <code><phrase role="identifier">basic_parallel_safe_assignable</phrase></code>
          or by specializing the <code><phrase role="identifier">is_basic_parallel_safe_assignable</phrase></code>
          template describe in the <literal>Type Traits</literal> section of this
          documentation.
        </para>
        <note>
          <para>
            By this definition, most types are <literal>basic parallel-safe assignable</literal>,
            particularly any types which have trivial copy-assignment operations,
            however, without the necessary compiler intrinsics this is impossible
            to detect automatically. Examples of types which would not be considered
            <literal>basic parallel-safe assignable</literal> include a hypothetical
            smart-pointer type which does not perform thread-safe reference counting.
          </para>
        </note>
      </section>
      <section id="act.concepts.parallel_safe_assignable.strong_parallel_safe_assignable">
        <title><link linkend="act.concepts.parallel_safe_assignable.strong_parallel_safe_assignable">Strong
        Parallel-Safe Assignable</link></title>
        <para>
          <emphasis role="bold">Refinement of:</emphasis>&nbsp;<literal>basic parallel-safe
          assignable</literal>
        </para>
        <para>
          A type is considered <literal>strong parallel-safe assignable</literal>
          if its copy-assignment operation is a <literal>parallel-safe operation</literal>
          regardless of the operand. Types which fall into this category include
          atomic types and types whose copy-assignment operation is entirely thread-safe
          (for instance, if it is performed while under a lock).
        </para>
        <para>
          Users may identify their types as being <literal>strong parallel-safe assignable</literal>
          by publically inheritting from <code><phrase role="identifier">strong_parallel_safe_assignable</phrase></code>
          or by specializing the <code><phrase role="identifier">is_strong_parallel_safe_assignable</phrase></code>
          template describe in the <literal>Type Traits</literal> section of this
          documentation. Note that if a type is labeled as being <literal>strong
          parallel-safe assignable</literal> through either of these techniques,
          applications of the <code><phrase role="identifier">is_basic_parallel_sage_assignable</phrase></code>
          metafunction will also automatically yield <code><phrase role="keyword">true</phrase></code>.
        </para>
      </section>
    </section>
    <section id="act.concepts.parallel_safe_operation">
      <title><link linkend="act.concepts.parallel_safe_operation">Parallel-Safe Operation</link></title>
      <para>
        A function is considered to be a <literal>parallel-safe operation</literal>
        if it may be safely executed by <code><phrase role="identifier">N</phrase></code>
        threads in parallel and have the same desired effect as if it were run in
        one thread <code><phrase role="identifier">N</phrase></code> times with the
        respective parameters.
      </para>
      <para>
        A function object is considered to be a <literal>parallel-safe operation</literal>
        if <code><phrase role="identifier">N</phrase></code> copies of it may be
        safely executed executed by <code><phrase role="identifier">N</phrase></code>
        threads in parallel and have the same desired effect as if the original function
        object were executed in one thread <code><phrase role="identifier">N</phrase></code>
        times with the respective parameters.
      </para>
    </section>
    <section id="act.concepts.worker_allocator">
      <title><link linkend="act.concepts.worker_allocator">Worker Allocator</link></title>
      <para>
        <literal>Worker allocators</literal> are used to spawn off additional threads
        of execution. In Boost.Act, <literal>worker allocators</literal> are used
        when instantiating the <literal>basic_concurrent_act_model</literal> template.
      </para>
      <para>
        In order to be considered a valid <literal>worker allocator</literal>, the
        following expressions must be well-formed and have the indicated effects
        (where <code><phrase role="identifier">TA</phrase></code> is the type in
        question and <code><phrase role="identifier">ta</phrase></code> is an instance
        of that type).
      </para>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Worker Allocator Requirements</phrase>
        </bridgehead>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Expression</entry><entry>Return Type</entry><entry>Pre/Post-Condition</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>X::worker</entry><entry></entry><entry>The corresponding worker
              type.</entry>
            </row>
            <row>
              <entry>a.allocate(f)</entry><entry>X::worker</entry><entry>A thread
              is allocated with <code><phrase role="identifier">f</phrase></code>
              executing as its main function. </entry>
            </row>
            <row>
              <entry>X()</entry><entry></entry><entry>Creates a default instance.
              Note: a destructor is assumed. </entry>
            </row>
            <row>
              <entry>X a(b);</entry><entry></entry><entry>Post: <code><phrase role="identifier">X</phrase><phrase
              role="special">(</phrase><phrase role="identifier">a</phrase><phrase
              role="special">)</phrase>&nbsp;<phrase role="special">==</phrase>&nbsp;<phrase
              role="identifier">b</phrase></code></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section id="act.concepts.worker">
      <title><link linkend="act.concepts.worker">Worker</link></title>
      <para>
        <literal>Worker allocators</literal> are used to spawn off additional threads
        of execution. In Boost.Act, <literal>worker allocators</literal> are used
        when instantiating the <literal>basic_concurrent_act_model</literal> template.
      </para>
      <para>
        In order to be considered a valid <literal>worker allocator</literal>, the
        following expressions must be well-formed and have the indicated effects
        (where <code><phrase role="identifier">TA</phrase></code> is the type in
        question and <code><phrase role="identifier">ta</phrase></code> is an instance
        of that type).
      </para>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Worker Requirements</phrase>
        </bridgehead>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Expression</entry><entry>Return Type</entry><entry>Pre/Post-Condition</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>W::allocator</entry><entry></entry><entry>The worker's allocator
              type.</entry>
            </row>
            <row>
              <entry>W w(a,f)</entry><entry></entry><entry>A worker is constructed
              with <code><phrase role="identifier">f</phrase></code> as its main
              function. </entry>
            </row>
            <row>
              <entry>w.join()</entry><entry>Not used</entry><entry>The current thread
              waits for <code><phrase role="identifier">w</phrase></code> to complete
              execution. </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
  </section>
  <section id="act.parallel_safety">
    <title><link linkend="act.parallel_safety">Parallel Safety</link></title>
    <section id="act.parallel_safety.defaults">
      <title><link linkend="act.parallel_safety.defaults">Defaults</link></title>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Default Parallel Safety Assumptions</phrase>
        </bridgehead>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operation</entry><entry>Safety</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Non-Modifying Overloaded Operators</entry><entry>Strong Parallel-Safe</entry>
            </row>
            <row>
              <entry>Modifying Overloaded Operators</entry><entry>No Safety</entry>
            </row>
            <row>
              <entry>Trivial Assignment Operator</entry><entry>Basic Parallel-Safe
              with respect to the left hand operand when detectable </entry>
            </row>
            <row>
              <entry>Trivial Destructor</entry><entry>Strong Parallel-Safe when detectable</entry>
            </row>
            <row>
              <entry>All Other Function Objects</entry><entry>No Safety</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        The default parallel-safety assumptions described above carry over for standard
        library function objects where applicable. For instance, <code><phrase role="special">::</phrase><phrase
        role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">less</phrase><phrase
        role="special">&lt;</phrase>&nbsp;<phrase role="keyword">int</phrase>&nbsp;<phrase
        role="special">&gt;</phrase></code> has a strong parallel-safe <code><phrase
        role="keyword">bool</phrase>&nbsp;<phrase role="keyword">operator</phrase>&nbsp;<phrase
        role="special">()(</phrase>&nbsp;<phrase role="keyword">int</phrase>&nbsp;<phrase
        role="keyword">const</phrase><phrase role="special">&amp;,</phrase>&nbsp;<phrase
        role="keyword">int</phrase>&nbsp;<phrase role="keyword">const</phrase><phrase
        role="special">&amp;</phrase>&nbsp;<phrase role="special">)</phrase>&nbsp;<phrase
        role="keyword">const</phrase></code>.
      </para>
    </section>
    <section id="act.parallel_safety.overriding_defaults">
      <title><link linkend="act.parallel_safety.overriding_defaults">Overriding Defaults</link></title>
    </section>
  </section>
  <section id="act.poly_algos">
    <title><link linkend="act.poly_algos"> Polymorphic Algorithms</link></title>
    <para>
      All algorithms in this section are compliant <literal>polymorphic algorithms</literal>.
      In order to simplify the following descriptions, any code which is common to
      all compliant <literal>polymorphic algorithms</literal> is assumed rather than
      explicitly written.
    </para>
    <section id="act.poly_algos.act_algos">
      <title><link linkend="act.poly_algos.act_algos"> Polymorphic Boost.Act Algorithms</link></title>
      <para>
        The algorithms in this section do not have corresponding algorithms in the
        C++ standard libraries.
      </para>
      <section id="act.poly_algos.act_algos.basic_for">
        <title><link linkend="act.poly_algos.act_algos.basic_for">Basic For</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">AssignmentType</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">PredicateType</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">StepType</phrase>
          <phrase role="special">&gt;</phrase>
  <emphasis>unspecified-type</emphasis> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">AssignmentType</phrase> <emphasis>assign</emphasis>
                              <phrase role="special">,</phrase> <phrase role="identifier">PredicateType</phrase> <emphasis>pred</emphasis>
                              <phrase role="special">,</phrase> <phrase role="identifier">StepType</phrase> <emphasis>step</emphasis>
                              <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">AssignmentType</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">PredicateType</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">StepType</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BodyType</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">BodyType</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">AssignmentType</phrase> <emphasis>assign</emphasis>
                      <phrase role="special">,</phrase> <phrase role="identifier">PredicateType</phrase> <emphasis>pred</emphasis>
                      <phrase role="special">,</phrase> <phrase role="identifier">StepType</phrase> <emphasis>step</emphasis>
                      <phrase role="special">,</phrase> <phrase role="identifier">BodyType</phrase> <emphasis>body</emphasis>
                      <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">basic_for</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: ToDo: Put for_var requirements
            here and add info about <emphasis>unspecified-type</emphasis>.
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Initializes internal variable <code><phrase role="identifier">i</phrase></code>
                  with <code><phrase role="identifier">assign</phrase><phrase role="special">()</phrase></code>
                  and calls <code><phrase role="identifier">body</phrase><phrase
                  role="special">(</phrase>&nbsp;<phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">)</phrase></code> followed by <code><phrase role="identifier">step</phrase><phrase
                  role="special">(</phrase>&nbsp;<phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">)</phrase></code> until <code><phrase role="identifier">pred</phrase><phrase
                  role="special">(</phrase>&nbsp;<phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">==</phrase>&nbsp;<phrase
                  role="keyword">false</phrase></code>. </entry><entry><emphasis>body</emphasis>.
                  </entry><entry>Exactly <code><phrase role="identifier">n</phrase></code>
                  calls to <code><phrase role="identifier">body</phrase></code>,
                  where <code><phrase role="identifier">n</phrase></code> is the
                  number of iterations which take place while <code><phrase role="identifier">pred</phrase><phrase
                  role="special">(</phrase>&nbsp;<phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">!=</phrase>&nbsp;<phrase
                  role="keyword">false</phrase></code>. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.act_algos.parallelize">
        <title><link linkend="act.poly_algos.act_algos.parallelize">Parallelize</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Function</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">Function</phrase> <phrase role="identifier">fun</phrase> <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">parallelize</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Creates <code><phrase role="identifier">N</phrase></code>
                  copies of binary function object <code><phrase role="identifier">fun</phrase></code>
                  including the original, then invokes each copy with the arguments
                  <code><phrase role="identifier">I</phrase></code> and <code><phrase
                  role="identifier">N</phrase></code>, where <code><phrase role="identifier">I</phrase></code>
                  is a unique identifier in the range [<code><phrase role="number">0</phrase></code>,<code><phrase
                  role="identifier">N</phrase></code>). Note that <code><phrase role="identifier">N</phrase></code>
                  must be greater than or equal to 1, implying that fun will always
                  logically be invoked at least one time regardless of the algorithm
                  model being used. The datatype of <code><phrase role="identifier">I</phrase></code>
                  and <code><phrase role="identifier">N</phrase></code> is an implementation-defined
                  integral type. </entry><entry><emphasis></emphasis> </entry><entry><code><phrase
                  role="identifier">N</phrase></code> total copies of <code><phrase
                  role="identifier">fun</phrase></code> are made and all executed
                  in their own thread prior to returning to the caller. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.act_algos.sections">
        <title><link linkend="act.poly_algos.act_algos.sections">Sections</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Function1</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">Function1</phrase> <phrase role="identifier">fun1</phrase> <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Function1</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Function2</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">Function1</phrase> <phrase role="identifier">fun1</phrase>
                  <phrase role="special">,</phrase> <phrase role="identifier">Function2</phrase> <phrase role="identifier">fun2</phrase>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="comment">// etc.
</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Function1</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Function2</phrase>
            <phrase role="special">...</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">FunctionN</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">Function1</phrase> <phrase role="identifier">fun1</phrase>
                  <phrase role="special">,</phrase> <phrase role="identifier">Function2</phrase> <phrase role="identifier">fun2</phrase>
                    <phrase role="special">...</phrase>
                  <phrase role="special">,</phrase> <phrase role="identifier">FunctionN</phrase> <phrase role="identifier">funN</phrase>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">sections</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Calls all function objects passed to sections in an implementation-specified
                  order. In particular, algorithm models are permitted to execute
                  the functions in parallel, as is the case with the parallel algorithm
                  model. </entry><entry><emphasis></emphasis> </entry><entry>Each
                  function object is called exactly once prior to returning to the
                  caller. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.act_algos.for_each_if">
        <title><link linkend="act.poly_algos.act_algos.for_each_if">For Each If</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Function</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">Function</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
                      <phrase role="special">,</phrase> <phrase role="identifier">Function</phrase> <emphasis>f</emphasis>
                      <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                      <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">for_each_if</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Applies <emphasis>f</emphasis> to the result of dereferencing
                  every iterator <code><phrase role="identifier">i</phrase></code>
                  in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) if <code><phrase
                  role="identifier">comp</phrase><phrase role="special">(</phrase>&nbsp;<phrase
                  role="special">*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">!=</phrase>&nbsp;<phrase
                  role="keyword">false</phrase></code>. </entry><entry><emphasis>f</emphasis>.
                  </entry><entry>Applies <code><phrase role="identifier">comp</phrase></code>
                  exactly <code><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>
                  times and applies <code><phrase role="identifier">f</phrase></code>
                  once for each element which satisfies <code><phrase role="identifier">comp</phrase></code>.
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
    </section>
    <section id="act.poly_algos.non_mod_algos">
      <title><link linkend="act.poly_algos.non_mod_algos"> Polymorphic Non Modifying
      Sequence Operations</link></title>
      <para>
        The following are polymorphic forms of the C++ algorithms found in <code><phrase
        role="special">&lt;</phrase><phrase role="identifier">algorithm</phrase><phrase
        role="special">&gt;</phrase></code> which are labled as &quot;Non modifying
        sequence operations&quot; in section 25.1 of the C++ standard.
      </para>
      <section id="act.poly_algos.non_mod_algos.for_each">
        <title><link linkend="act.poly_algos.non_mod_algos.for_each">For Each</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Function</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">Function</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
                      <phrase role="special">,</phrase> <phrase role="identifier">Function</phrase> <emphasis>f</emphasis>
                      <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">for_each</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Applies <emphasis>f</emphasis> to the result of dereferencing
                  every iterator in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>). </entry><entry><emphasis>f</emphasis>.
                  </entry><entry>Applies <emphasis>f</emphasis> exactly <emphasis>last
                  - first</emphasis> times. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
        <warning>
          <para>
            Unlike the standard C++ form of <literal>for_each</literal>, the polymorphic
            form of <literal>for_each</literal> does not impose any order of the
            execution of <code><phrase role="identifier">f</phrase></code> with respect
            to individual elements. If you wish, you may pass <code><phrase role="special">::</phrase><phrase
            role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
            role="identifier">act</phrase><phrase role="special">::</phrase><phrase
            role="identifier">ordered</phrase><phrase role="special">()</phrase></code>
            as an <literal>extended parameter</literal> in order to force execution
            to occur in order from <code><phrase role="identifier">first</phrase></code>
            to <code><phrase role="identifier">last</phrase></code>.
          </para>
        </warning>
      </section>
      <section id="act.poly_algos.non_mod_algos.find">
        <title><link linkend="act.poly_algos.non_mod_algos.find">Find</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis>
                           <phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
                           <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
                           <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">find</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">InputIterator</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis>
                           <phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
                           <phrase role="special">,</phrase> <phrase role="identifier">Predicate</phrase> <emphasis>pred</emphasis>
                           <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">find_if</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is <literal>EqualityComparable</literal> (C++ Standard: 20.1.1)
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Finds a value in a sequence. </entry><entry>The first iterator
                  <code><phrase role="identifier">i</phrase></code> in the range
                  [<code><phrase role="identifier">first</phrase></code>, <code><phrase
                  role="identifier">last</phrase></code>) for which the following
                  corresponding conditions hold: <code><phrase role="special">*</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">==</phrase>&nbsp;<phrase
                  role="identifier">value</phrase></code>, <code><phrase role="identifier">pred</phrase><phrase
                  role="special">(*</phrase><phrase role="identifier">i</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">!=</phrase>&nbsp;<phrase
                  role="keyword">false</phrase></code>. Returns <code><phrase role="identifier">last</phrase></code>
                  if no such iterator is found. </entry><entry>At most <code><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> applications of the corresponding
                  predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.non_mod_algos.find_end">
        <title><link linkend="act.poly_algos.non_mod_algos.find_end">Find End</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator2</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator1</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator1</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BinaryPredicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">find_end</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Finds a subsequence of equal values in a sequence. </entry><entry>The
                  last iterator <literal>i</literal> in the range such that for any
                  non-negative integer <literal>n</literal> &lt; <emphasis>(last2-first2)</emphasis>,
                  the following corresponding conditions hold: <code><phrase role="special">*(</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">+</phrase><phrase
                  role="identifier">n</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="special">*(</phrase><phrase
                  role="identifier">first2</phrase><phrase role="special">+</phrase><phrase
                  role="identifier">n</phrase><phrase role="special">)</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*(</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">+</phrase><phrase
                  role="identifier">n</phrase><phrase role="special">),</phrase>
                  <phrase role="special">*(</phrase><phrase role="identifier">first2</phrase><phrase
                  role="special">+</phrase><phrase role="identifier">n</phrase><phrase
                  role="special">))</phrase>&nbsp;<phrase role="special">!=</phrase>&nbsp;<phrase
                  role="keyword">false</phrase></code>. Returns <emphasis>last1</emphasis>
                  if no such iterator is found. </entry><entry>At most <emphasis>(last2
                  - first2) * (last1 - first1 - (last2 - first2) + 1)</emphasis>
                  applications of the corresponding predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.non_mod_algos.find_first">
        <title><link linkend="act.poly_algos.non_mod_algos.find_first">Find First</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator2</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator1</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>first1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>first2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator1</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>first1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>first2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BinaryPredicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">find_first</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Finds an element that matches one of a set of values. </entry><entry>The
                  first iterator <literal>i</literal> in the range ) such that for
                  some integer <literal>j</literal> in the range, the following conditions
                  hold: <code><phrase role="special">*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">==</phrase> <phrase role="special">*</phrase><phrase
                  role="identifier">j</phrase></code>, <code><phrase role="identifier">pred</phrase><phrase
                  role="special">(*</phrase><phrase role="identifier">i</phrase><phrase
                  role="special">,*</phrase><phrase role="identifier">j</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">!=</phrase>&nbsp;<phrase
                  role="keyword">false</phrase></code>. Returns <emphasis>last1</emphasis>
                  if no such iterator is found. </entry><entry>At most <emphasis>(last1
                  - first1) * (last2 - first2)</emphasis> applications of the corresponding
                  predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.non_mod_algos.adjacent_find">
        <title><link linkend="act.poly_algos.non_mod_algos.adjacent_find">Adjacent
        Find</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BinaryPredicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">adjacent_find</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Finds the first of two adjacent elements which satisfy the
                  specified binary predicate. </entry><entry>The first iterator
                  <literal>i</literal> such that both <literal>i</literal> and <literal>i</literal>
                  + 1 are in the range [<emphasis>first, last</emphasis>) for which
                  the following corresponding conditions hold: <code><phrase role="special">*</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">==</phrase>
                  <phrase role="special">(*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="number">1</phrase><phrase
                  role="special">)</phrase></code>, <code><phrase role="identifier">pred</phrase><phrase
                  role="special">(*</phrase><phrase role="identifier">i</phrase><phrase
                  role="special">,</phrase>&nbsp;<phrase role="special">*(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="number">1</phrase><phrase role="special">))</phrase>&nbsp;<phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  Returns <emphasis>last</emphasis> if no such iterator is found.
                  </entry><entry>Exactly <code><phrase role="identifier">find</phrase><phrase
                  role="special">(</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">,</phrase>&nbsp;<phrase role="identifier">last</phrase><phrase
                  role="special">,</phrase>&nbsp;<phrase role="identifier">value</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> applications of the corresponding
                  predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.non_mod_algos.count">
        <title><link linkend="act.poly_algos.non_mod_algos.count">Count</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="special">::</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator_difference</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">type</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis> <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">count</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">typename</phrase> <phrase role="special">::</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator_difference</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">InputIterator</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">type</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">Predicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">count_if</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <literal>T</literal>
            is EqualityComparable (C++ Standard: 20.1.1)
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Calculates the number of elements in a range which satisfy
                  the specified predicate. </entry><entry>Returns the number of iterators
                  <literal>i</literal> in the range[<emphasis>first, last</emphasis>)
                  for which the following corresponding conditions hold: <code><phrase
                  role="special">*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="identifier">value</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  </entry><entry>Exactly <code><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>
                  applications of the corresponding predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.non_mod_algos.mismatch">
        <title><link linkend="act.poly_algos.non_mod_algos.mismatch">Mismatch</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="special">::</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis>
               <phrase role="special">);</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="special">::</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">BinaryPredicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">mismatch</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>ToDo: Fill in. </entry><entry>A pair of iterators <literal>i</literal>
                  and <literal>j</literal> such that <code><phrase role="identifier">j</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="identifier">first2</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first1</phrase><phrase role="special">)</phrase></code>
                  and <literal>i</literal> is the first iterator in the range [<emphasis>first1</emphasis>,
                  <emphasis>last1</emphasis>) for which the following corresponding
                  conditions hold: <code><phrase role="special">!(</phrase><phrase
                  role="identifier">Ii</phrase>&nbsp;<phrase role="special">==</phrase>&nbsp;<phrase
                  role="special">*(</phrase><phrase role="identifier">first2</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first1</phrase><phrase role="special">)))</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">,</phrase>
                  <phrase role="special">*(</phrase><phrase role="identifier">first2</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">-</phrase><phrase
                  role="identifier">first1</phrase><phrase role="special">)))</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  Returns the pair <emphasis>last1</emphasis> and <code><phrase role="identifier">first2</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last1</phrase> <phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first1</phrase><phrase role="special">)</phrase></code>
                  if such an iterator <literal>i</literal> is not found. </entry><entry>At
                  most <code><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase></code>
                  applications of the corresponding predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.non_mod_algos.equal">
        <title><link linkend="act.poly_algos.non_mod_algos.equal">Equal</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">BinaryPredicate</phrase> <emphasis>pred</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">equal</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Checks the equality of two ranges based on a specified predicate.
                  </entry><entry><literal>true</literal> if for every iterator <literal>i</literal>
                  in the range [<emphasis>first1</emphasis>, <emphasis>last1</emphasis>)
                  the following corresponding conditions hold: <code><phrase role="special">*</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">==</phrase>&nbsp;<phrase
                  role="special">*(</phrase><phrase role="identifier">first2</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first1</phrase><phrase role="special">))</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">,</phrase>&nbsp;<phrase
                  role="special">*(</phrase><phrase role="identifier">first2</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first1</phrase><phrase role="special">)))</phrase>&nbsp;<phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  Otherwise, returns <code><phrase role="keyword">false</phrase></code>.
                  </entry><entry>At most <code><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase></code>
                  applications of the corresponding predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.non_mod_algos.search">
        <title><link linkend="act.poly_algos.non_mod_algos.search">Search</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator2</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator1</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator1</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BinaryPredicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">search</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Finds a subsequence of equal values in a sequence. </entry><entry>The
                  first iterator <code><phrase role="identifier">i</phrase></code>
                  in the range [<code><phrase role="identifier">first1</phrase></code>,
                  <code><phrase role="identifier">last1</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last2</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first2</phrase><phrase
                  role="special">)</phrase></code>) such that for any non-negative
                  integer <code><phrase role="identifier">n</phrase></code> less
                  than <code><phrase role="identifier">last2</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first2</phrase></code>
                  the following corresponding conditions hold: <code><phrase role="special">*(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="identifier">n</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="special">*(</phrase><phrase
                  role="identifier">first2</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="identifier">n</phrase><phrase role="special">)</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="identifier">n</phrase><phrase role="special">),</phrase>&nbsp;<phrase
                  role="special">*(</phrase><phrase role="identifier">first2</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="identifier">n</phrase><phrase
                  role="special">))</phrase>&nbsp;<phrase role="special">!=</phrase>&nbsp;<phrase
                  role="keyword">false</phrase></code>. Returns <code><phrase role="identifier">last1</phrase></code>
                  if no such iterator is found. </entry><entry>At most <code><phrase
                  role="special">(</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">*</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last2</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first2</phrase><phrase
                  role="special">)</phrase></code> applications of the corresponding
                  predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.non_mod_algos.search_n">
        <title><link linkend="act.poly_algos.non_mod_algos.search_n">Search N</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Size</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">Size</phrase> <emphasis>count</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Size</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">Size</phrase> <emphasis>count</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BinaryPredicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">search_n</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is EqualityComparable (C++ Standard: 20.1.1), type <code><phrase role="identifier">Size</phrase></code>
            is convertible to integral type (C++ Standard: 4.7, 12.3).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Finds a subsequence of equal values in a sequence. </entry><entry>The
                  first iterator <code><phrase role="identifier">i</phrase></code>
                  in the range [<code><phrase role="identifier">first1</phrase></code>,
                  <code><phrase role="identifier">last1</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">count</phrase></code>) such that for any non-negative
                  integer <code><phrase role="identifier">n</phrase></code> less
                  than <code><phrase role="identifier">count</phrase></code> the
                  following corresponding conditions hold: <code><phrase role="special">*(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="identifier">n</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="identifier">value</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="identifier">n</phrase><phrase role="special">),</phrase>&nbsp;<phrase
                  role="identifier">value</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  Returns <code><phrase role="identifier">last</phrase></code> if
                  no such iterator is found. </entry><entry>At most <code><phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">*</phrase>&nbsp;<phrase
                  role="identifier">count</phrase></code> applications of the corresponding
                  predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
    </section>
    <section id="act.poly_algos.polymorphic_mutating_sequence_operations">
      <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations">Polymorphic
      Mutating Sequence Operations</link></title>
      <para>
        The following are polymorphic forms of the C++ algorithms found in <code><phrase
        role="special">&lt;</phrase><phrase role="identifier">algorithm</phrase><phrase
        role="special">&gt;</phrase></code> which are labled as &quot;Mutating Sequence
        Operations&quot; in section 25.2 of the C++ standard.
      </para>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.copy">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.copy">Copy</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> result
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">copy</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: <code><phrase role="identifier">result</phrase></code>
            shall not be in the range [<code><phrase role="identifier">first</phrase></code>,
            <code><phrase role="identifier">last</phrase></code>).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Copies elements in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) into the
                  range [<code><phrase role="identifier">result</phrase></code>,
                  <code><phrase role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">))</phrase></code> starting from <code><phrase role="identifier">first</phrase></code>
                  and proceeding to <code><phrase role="identifier">last</phrase></code>.
                  For each non-negative integer <code><phrase role="identifier">n</phrase>&nbsp;<phrase
                  role="special">&lt;</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last</phrase><phrase role="special">-</phrase><phrase
                  role="identifier">first</phrase><phrase role="special">)</phrase></code>,
                  performs <code><phrase role="special">*(</phrase><phrase role="identifier">result</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="identifier">n</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">=</phrase>&nbsp;<phrase
                  role="special">*(</phrase><phrase role="identifier">first</phrase>
                  <phrase role="special">+</phrase>&nbsp;<phrase role="identifier">n</phrase><phrase
                  role="special">)</phrase></code>. </entry><entry><code><phrase
                  role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase></code> </entry><entry>Exactly <code><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> assignments. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.copy_backward">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.copy_backward">Copy
        Backward</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator2</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">BidirectionalIterator2</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">BidirectionalIterator1</phrase> <emphasis>first</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator1</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator2</phrase> result
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">copy_backward</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: <code><phrase role="identifier">result</phrase></code>
            shall not be in the range [<code><phrase role="identifier">first</phrase></code>,
            <code><phrase role="identifier">last</phrase></code>).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Copies elements in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) into the
                  range [<code><phrase role="identifier">result</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last</phrase> <phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase><phrase role="special">)</phrase></code>,
                  <code><phrase role="identifier">result</phrase></code>) starting
                  from <code><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="number">1</phrase></code>
                  and proceeding to <code><phrase role="identifier">first</phrase></code>.
                  For each positive integer <code><phrase role="identifier">n</phrase>&nbsp;<phrase
                  role="special">&lt;=</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase><phrase role="special">)</phrase></code>,
                  performs <code><phrase role="special">*(</phrase><phrase role="identifier">result</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="identifier">n</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">=</phrase>&nbsp;<phrase
                  role="special">*(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase> <phrase role="identifier">n</phrase><phrase
                  role="special">)</phrase></code>. </entry><entry><code><phrase
                  role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase></code> </entry><entry>Exactly <code><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> assignments. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.swap">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.swap">Swap</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>a</emphasis><phrase role="special">,</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>b</emphasis> <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">swap</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is <literal>Assignable</literal> (C++ Standard: 23.1).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Exchanges the values of <code><phrase role="identifier">a</phrase></code>
                  and <code><phrase role="identifier">b</phrase></code>. </entry><entry><emphasis></emphasis>
                  </entry><entry><emphasis></emphasis> </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.swap_ranges">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.swap_ranges">Swap
        Ranges</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator2</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator2</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator2</phrase> <emphasis>first2</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">swap_ranges</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: The two ranges [<code><phrase
            role="identifier">first</phrase></code>, <code><phrase role="identifier">last1</phrase></code>)
            and [<code><phrase role="identifier">first2</phrase></code>, <code><phrase
            role="identifier">first2</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
            role="special">(</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
            role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
            role="special">)</phrase></code>) shall not overlap.
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>For each non-negative integer <code><phrase role="identifier">n</phrase>&nbsp;<phrase
                  role="special">&lt;</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last1</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first1</phrase><phrase role="special">)</phrase></code>
                  performs: <code><phrase role="identifier">swap</phrase><phrase
                  role="special">(*(</phrase><phrase role="identifier">first1</phrase>
                  <phrase role="special">+</phrase>&nbsp;<phrase role="identifier">n</phrase><phrase
                  role="special">),</phrase>&nbsp;<phrase role="special">*(</phrase><phrase
                  role="identifier">first2</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="identifier">n</phrase><phrase role="special">))</phrase></code>.
                  </entry><entry><code><phrase role="identifier">first2</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last1</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first1</phrase><phrase role="special">)</phrase></code>.
                  </entry><entry>Exactly <code><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase></code>
                  swaps. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.iterator_swap">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.iterator_swap">Iterator
        Swap</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator2</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>a</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator1</phrase> <emphasis>b</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">iter_swap</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Exchanges the values pointed to by the two iteratos <code><phrase
                  role="identifier">a</phrase></code> and <code><phrase role="identifier">b</phrase></code>.
                  </entry><entry><emphasis></emphasis> </entry><entry><emphasis></emphasis>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.transform">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.transform">Transform</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">UnaryOperation</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis><phrase role="special">,</phrase> <phrase role="identifier">UnaryOperation</phrase> <emphasis>op</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryOperation</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BinaryOperation</phrase> <emphasis>binary_op</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">transform</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: <code><phrase role="identifier">op</phrase></code>
            and <code><phrase role="identifier">binary_op</phrase></code> shall not
            have any side effects.
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Assigns through every iterator <code><phrase role="identifier">i</phrase></code>
                  in the range [<code><phrase role="identifier">result</phrase></code>,
                  <code><phrase role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase> <phrase role="identifier">first1</phrase><phrase
                  role="special">))</phrase>&nbsp;<phrase role="identifier">a</phrase>&nbsp;<phrase
                  role="keyword">new</phrase>&nbsp;<phrase role="identifier">corresponding</phrase>&nbsp;<phrase
                  role="identifier">value</phrase>&nbsp;<phrase role="identifier">equal</phrase>&nbsp;<phrase
                  role="identifier">to</phrase>&nbsp;</code>op(*(first1 + (i - result)))<code>&nbsp;<phrase
                  role="keyword">or</phrase> </code>binary_op(*(first1 + (i - result),
                  *first2 + (i - result)))`. </entry><entry><code><phrase role="identifier">result</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last1</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first1</phrase><phrase role="special">)</phrase></code>.
                  </entry><entry>Exactly <code><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase></code>
                  applications of <code><phrase role="identifier">op</phrase></code>
                  or <code><phrase role="identifier">binary_op</phrase></code>.
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.replace">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.replace">Replace</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>old_value</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>new_value</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">replace</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Predicate</phrase> <emphasis>pred</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>new_value</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">replace_if</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is <literal>Assignable</literal> (C++ Standard: 23.1) (and, for <code><phrase
            role="identifier">replace</phrase><phrase role="special">()</phrase></code>,
            <literal>EqualityComparable</literal> (C++ Standard: 20.1.1)).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Substitutes elements referred by the iterator <code><phrase
                  role="identifier">i</phrase></code> in the range [<code><phrase
                  role="identifier">first</phrase></code>, <code><phrase role="identifier">last</phrase></code>)
                  with <code><phrase role="identifier">new_value</phrase></code>,
                  when the following corresponding conditions hold: <code><phrase
                  role="special">*</phrase><phrase role="identifier">i</phrase>
                  <phrase role="special">==</phrase>&nbsp;<phrase role="identifier">old_value</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  </entry><entry><emphasis></emphasis> </entry><entry>Exactly <code><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> applications of the corresponding
                  predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.replace_copy">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.replace_copy">Replace
        Copy</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>old_value</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>new_value</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">replace_copy</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Iterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">Iterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Iterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">Predicate</phrase> <emphasis>pred</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>new_value</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">replace_copy_if</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is <literal>Assignable</literal> (C++ Standard: 23.1) (and, for <code><phrase
            role="identifier">replace_copy</phrase><phrase role="special">()</phrase></code>,
            <literal>EqualityComparable</literal> (C++ Standard: 20.1.1)). The ranges
            [<code><phrase role="identifier">first</phrase></code>, <code><phrase
            role="identifier">last</phrase></code>) and [<code><phrase role="identifier">result</phrase></code>,
            <code><phrase role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
            role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
            role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
            role="special">)</phrase></code>) shall not overlap.
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Assigns to every iterator <code><phrase role="identifier">i</phrase></code>
                  in the range [<code><phrase role="identifier">result</phrase></code>,
                  <code><phrase role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase> <phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase></code>) either <code><phrase role="identifier">new_value</phrase></code>
                  or <code><phrase role="special">*(</phrase><phrase role="identifier">first</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">result</phrase><phrase role="special">))</phrase></code>
                  depending on whether the following corresponding conditions hold:
                  <code><phrase role="special">*(</phrase><phrase role="identifier">first</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">result</phrase><phrase role="special">))</phrase>&nbsp;<phrase
                  role="special">==</phrase> <phrase role="identifier">old_value</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*(</phrase><phrase
                  role="identifier">first</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">result</phrase><phrase
                  role="special">)))</phrase>&nbsp;<phrase role="special">!=</phrase>&nbsp;<phrase
                  role="keyword">false</phrase></code>. </entry><entry>`result +
                  (last - first). </entry><entry>Exactly <code><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>
                  applications of the corresponding predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.fill">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.fill">Fill</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">fill</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Size</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Size</phrase> <emphasis>n</emphasis>
                  <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">fill_n</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is <literal>Assignable</literal> (C++ Standard: 23.1), <code><phrase
            role="identifier">Size</phrase></code> is convertible to an integral
            type (C++ Standard: 4.7, 12.3).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Assigns <code><phrase role="identifier">value</phrase></code>
                  thriugh all iterators in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) or [<code><phrase
                  role="identifier">first</phrase></code>, <code><phrase role="identifier">first</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="identifier">n</phrase></code>).
                  </entry><entry><emphasis></emphasis> </entry><entry>Exactly <code><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> (or <code><phrase role="identifier">n</phrase></code>)
                  assignments. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.generate">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.generate">Generate</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Generator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Generator</phrase> <emphasis>gen</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">generate</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Size</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Generator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Size</phrase> <emphasis>n</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Generator</phrase> <emphasis>gen</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">generate_n</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: <code><phrase role="identifier">gen</phrase></code>
            takes no arguments, <code><phrase role="identifier">Size</phrase></code>
            is convertible to an integral type (C++ Standard: 4.7, 12.3).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Invokes the function object <code><phrase role="identifier">gen</phrase></code>
                  and assigns the return value of <code><phrase role="identifier">gen</phrase></code>
                  through all the iterators in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) or [<code><phrase
                  role="identifier">first</phrase></code>, <code><phrase role="identifier">first</phrase>&nbsp;<phrase
                  role="special">+</phrase> <phrase role="identifier">n</phrase></code>).
                  </entry><entry><emphasis></emphasis> </entry><entry>Exactly <code><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> (or <code><phrase role="identifier">n</phrase></code>)
                  invocations of <code><phrase role="identifier">gen</phrase></code>
                  and assignments. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.remove">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.remove">Remove</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis>
                             <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                             <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
                             <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">remove</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis>
                             <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                             <phrase role="special">,</phrase> <phrase role="identifier">Predicate</phrase> <emphasis>pred</emphasis>
                             <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">remove_if</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is <literal>EqualityComparable</literal> (C++ Standard: 20.1.1).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Eliminates all the elements referred to by iterator <code><phrase
                  role="identifier">i</phrase></code> in the range [<code><phrase
                  role="identifier">first</phrase></code>, <code><phrase role="identifier">last</phrase></code>)
                  for which the following corresponding conditions hold: <code><phrase
                  role="special">*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="identifier">value</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  </entry><entry>The end of the resulting range. </entry><entry>Exactly
                  <code><phrase role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> applications of the corresponding
                  predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.remove_copy">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.remove_copy">Remove
        Copy</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">remove_copy</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Predicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">remove_copy_if</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is <literal>EqualityComparable</literal> (C++ Standard: 20.1.1). The
            ranges [<code><phrase role="identifier">first</phrase></code>, <code><phrase
            role="identifier">last</phrase></code>) and [<code><phrase role="identifier">result</phrase></code>,
            <code><phrase role="identifier">result</phrase><phrase role="special">+(</phrase><phrase
            role="identifier">last</phrase><phrase role="special">-</phrase><phrase
            role="identifier">first</phrase><phrase role="special">)</phrase></code>)
            shall not overlap.
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Copies all the elements referred to by the iterator <code><phrase
                  role="identifier">i</phrase></code> in the range [<code><phrase
                  role="identifier">first</phrase></code>, <code><phrase role="identifier">last</phrase></code>)
                  for which the following corresponding conditions do not hold:
                  <code><phrase role="special">*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">==</phrase> <phrase role="identifier">value</phrase></code>,
                  <code><phrase role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  </entry><entry>The end of the resulting range. </entry><entry>Exactly
                  <code><phrase role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> applications of the corresponding
                  predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.unique">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.unique">Unique</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis>
                             <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                             <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis>
                             <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                             <phrase role="special">,</phrase> <phrase role="identifier">BinaryPredicate</phrase> <emphasis>pred</emphasis>
                             <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">unique</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Eliminates all but the first element from every consecutive
                  group of equal elements referred to by the iterator <code><phrase
                  role="identifier">i</phrase></code> in the range [<code><phrase
                  role="identifier">first</phrase></code>, <code><phrase role="identifier">last</phrase></code>)
                  for which the following corresponding conditions hold: <code><phrase
                  role="special">*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="special">*(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="number">1</phrase><phrase role="special">)</phrase></code>
                  or <code><phrase role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">,</phrase>
                  <phrase role="special">*(</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="number">1</phrase><phrase
                  role="special">))</phrase>&nbsp;<phrase role="special">!=</phrase>&nbsp;<phrase
                  role="keyword">false</phrase></code>. </entry><entry>The end of
                  the resulting range. </entry><entry>If the range <code><phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase></code> is not empty, exactly <code><phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="number">1</phrase></code> applications of the corresponding
                  predicate, otherwise no application of the predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.unique_copy">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.unique_copy">Unique
        Copy</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BinaryPredicate</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis><phrase role="special">,</phrase> <phrase role="identifier">BinaryPredicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">unique_copy</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: The ranges [<code><phrase
            role="identifier">first</phrase></code>,<code><phrase role="identifier">last</phrase></code>)
            and [<code><phrase role="identifier">result</phrase></code>, <code><phrase
            role="identifier">result</phrase><phrase role="special">+(</phrase><phrase
            role="identifier">last</phrase><phrase role="special">-</phrase><phrase
            role="identifier">first</phrase><phrase role="special">)</phrase></code>)
            shall not overlap.
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Copies only the first element from every consecutive group
                  of equal elements referred to by the iterator <code><phrase role="identifier">i</phrase></code>
                  in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) for which
                  the following corresponding conditions hold: <code><phrase role="special">*</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">==</phrase>&nbsp;<phrase
                  role="special">*(</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="number">1</phrase><phrase
                  role="special">)</phrase></code> or <code><phrase role="identifier">pred</phrase><phrase
                  role="special">(*</phrase><phrase role="identifier">i</phrase><phrase
                  role="special">,</phrase>&nbsp;<phrase role="special">*(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="number">1</phrase><phrase role="special">))</phrase> <phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  </entry><entry>The end of the resulting range. </entry><entry>Exactly
                  <code><phrase role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> applications of the corresponding
                  predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.rotate">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.rotate">Rotate</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>middle</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">rotate</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: [<code><phrase role="identifier">first</phrase></code>,<code><phrase
            role="identifier">middle</phrase></code>) and [<code><phrase role="identifier">middle</phrase></code>,
            <code><phrase role="identifier">last</phrase></code>) are valid ranges.
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>For each non-negative integer <code><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">&lt;</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase><phrase role="special">)</phrase></code>,
                  places the element from the position <code><phrase role="identifier">first</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="identifier">i</phrase></code>
                  into position <code><phrase role="identifier">first</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">middle</phrase><phrase
                  role="special">))</phrase>&nbsp;<phrase role="special">%</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase> <phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase></code>. </entry><entry><emphasis></emphasis>
                  </entry><entry>At most <code><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>
                  swaps. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.rotate_copy">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.rotate_copy">Rotate
        Copy</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>middle</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis><phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">rotate_copy</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: The ranges [<code><phrase
            role="identifier">first</phrase></code>,<code><phrase role="identifier">last</phrase></code>)
            and [<code><phrase role="identifier">result</phrase></code>, <code><phrase
            role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
            role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
            role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
            role="special">)</phrase></code>) shall not overlap.
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>For each non-negative integer <code><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">&lt;</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase><phrase role="special">)</phrase></code>,
                  places the element from the position <code><phrase role="identifier">first</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="identifier">i</phrase></code>
                  into position <code><phrase role="identifier">first</phrase>&nbsp;<phrase
                  role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">middle</phrase><phrase
                  role="special">))</phrase>&nbsp;<phrase role="special">%</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase> <phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase></code>. </entry><entry><code><phrase
                  role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase></code>. </entry><entry>Exactly <code><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> assignments. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.random_shuffle">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.random_shuffle">Random
        Shuffle</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomNumberGenerator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomNumberGenerator</phrase><phrase role="special">&amp;</phrase> <emphasis>rand</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">random_shuffle</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Shuffles the elements in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) with uniform
                  distribution. </entry><entry><emphasis></emphasis> </entry><entry>Exactly
                  <code><phrase role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="number">1</phrase></code> swaps. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.partition">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.partition">Partition</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">BidirectionalIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>first</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">Predicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">partition</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Places all the elements in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) that satisfy
                  <code><phrase role="identifier">pred</phrase></code> before all
                  the elements that do not satisfy it. </entry><entry>An iterator
                  <code><phrase role="identifier">i</phrase></code> such that for
                  any iterator <code><phrase role="identifier">j</phrase></code>
                  in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">i</phrase></code>), <code><phrase
                  role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">j</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>,
                  and for any iterator <code><phrase role="identifier">k</phrase></code>
                  in the range [<code><phrase role="identifier">i</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>), <code><phrase
                  role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">j</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  </entry><entry>At most <code><phrase role="special">(</phrase><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase><phrase role="special">)/</phrase><phrase
                  role="number">2</phrase></code> swaps. Exactly <code><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>
                  applications of the predicate. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_mutating_sequence_operations.stable_partition">
        <title><link linkend="act.poly_algos.polymorphic_mutating_sequence_operations.stable_partition">Stable
        Partition</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Predicate</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">BidirectionalIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>first</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">Predicate</phrase> <emphasis>pred</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">stable_partition</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Places all the elements in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) that satisfy
                  <code><phrase role="identifier">pred</phrase></code> before all
                  the elements that do not satisfy it. </entry><entry>An iterator
                  <code><phrase role="identifier">i</phrase></code> such that for
                  any iterator <code><phrase role="identifier">j</phrase></code>
                  in the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">i</phrase></code>), <code><phrase
                  role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">j</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">!=</phrase>&nbsp;<phrase role="keyword">false</phrase></code>,
                  and for any iterator <code><phrase role="identifier">k</phrase></code>
                  in the range [<code><phrase role="identifier">i</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>), <code><phrase
                  role="identifier">pred</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">j</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">==</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                  The relative order of the elements in both groups is preserved.
                  </entry><entry>At most <code><phrase role="special">(</phrase><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">*</phrase>&nbsp;<phrase role="identifier">log</phrase><phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase></code> swaps, but only linear number
                  of swaps if there is enough extra memory. Exactly <code><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase></code> applications of the predicate.
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
    </section>
    <section id="act.poly_algos.polymorphic_sorting_and_related_operations">
      <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations">Polymorphic
      Sorting and Related Operations</link></title>
      <para>
        The following are polymorphic forms of the C++ algorithms found in <code><phrase
        role="special">&lt;</phrase><phrase role="identifier">algorithm</phrase><phrase
        role="special">&gt;</phrase></code> which are labled as &quot;Sorting and
        related operations&quot; in section 25.3 of the C++ standard.
      </para>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations">Polymorphic
        Sorting Operations</link></title>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations.sort">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations.sort">Sort</link></title>
          
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">sort</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Sorts the elements in the range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>). </entry><entry><emphasis></emphasis>
                    </entry><entry>Approximately <code><phrase role="identifier">N</phrase>&nbsp;<phrase
                    role="identifier">log</phrase>&nbsp;<phrase role="identifier">N</phrase></code>
                    (where <code><phrase role="identifier">N</phrase>&nbsp;<phrase
                    role="special">==</phrase>&nbsp;<phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>)
                    comparisons on the average. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations.stable_sort">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations.stable_sort">Stable
          Sort</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">stable_sort</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Sorts the elements in the range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>), preserving
                    the relative order of equivalent elements. </entry><entry><emphasis></emphasis>
                    </entry><entry>At most <code><phrase role="identifier">N</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">log</phrase>&nbsp;<phrase
                    role="identifier">N</phrase><phrase role="special">)^</phrase><phrase
                    role="number">2</phrase></code> (where <code><phrase role="identifier">N</phrase>&nbsp;<phrase
                    role="special">==</phrase>&nbsp;<phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>)
                    comparisons; if enough extra memory is available, it is <code><phrase
                    role="identifier">N</phrase>&nbsp;<phrase role="identifier">log</phrase>&nbsp;<phrase
                    role="identifier">N</phrase></code>. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations.partial_sort">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations.partial_sort">Partial
          Sort</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>middle</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>middle</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">partial_sort</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Places the first <code><phrase role="identifier">middle</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>
                    sorted elements from the range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>) into the
                    range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">middle</phrase></code>). The
                    rest of the elements in the range [<code><phrase role="identifier">middle</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>) are place
                    in an unspecified order. </entry><entry><emphasis></emphasis>
                    </entry><entry>Approximately <code><phrase role="special">(</phrase><phrase
                    role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="identifier">first</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">*</phrase>&nbsp;<phrase role="identifier">log</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">middle</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                    role="special">)</phrase></code> comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations.partial_sort_copy">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_sorting_operations.partial_sort_copy">Partial
          Sort Copy</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">RandomAccessIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>result_first</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>result_last</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">RandomAccessIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>result_first</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>result_last</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">partial_sort_copy</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Places the first <code><phrase role="identifier">min</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                    role="special">,</phrase>&nbsp;<phrase role="identifier">result_last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">result_first</phrase><phrase
                    role="special">)</phrase></code> sorted elements into the range
                    [<code><phrase role="identifier">result_first</phrase></code>,
                    <code><phrase role="identifier">result_first</phrase>&nbsp;<phrase
                    role="special">+</phrase>&nbsp;<phrase role="identifier">min</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                    role="special">,</phrase> <phrase role="identifier">result_last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">result_first</phrase><phrase
                    role="special">)</phrase></code>). </entry><entry>The smaller
                    of: <code><phrase role="identifier">result_last</phrase></code>
                    or <code><phrase role="identifier">result_first</phrase>&nbsp;<phrase
                    role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                    role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="identifier">first</phrase><phrase role="special">)</phrase></code>.
                    </entry><entry>Approximately <code><phrase role="special">(</phrase><phrase
                    role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="identifier">first</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">*</phrase>&nbsp;<phrase role="identifier">log</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">min</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                    role="special">,</phrase>&nbsp;<phrase role="identifier">result_last</phrase>&nbsp;<phrase
                    role="special">-</phrase> <phrase role="identifier">result_first</phrase><phrase
                    role="special">))</phrase></code> comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.nth_element">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.nth_element">Nth
        Element</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>nth</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>nth</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">nth_element</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>After <code><phrase role="identifier">nth_element</phrase></code>
                  executes, the element in the position pointed to by <code><phrase
                  role="identifier">nth</phrase></code> is the element that would
                  be in that position if the whole range were sorted. Also for any
                  iterator <code><phrase role="identifier">i</phrase></code> in the
                  range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">nth</phrase></code>) and any iterator
                  <code><phrase role="identifier">j</phrase></code> in the range
                  [<code><phrase role="identifier">nth</phrase></code>, <code><phrase
                  role="identifier">last</phrase></code>) it holds that: <code><phrase
                  role="special">!(*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">&gt;</phrase>&nbsp;<phrase role="special">*</phrase><phrase
                  role="identifier">j</phrase><phrase role="special">)</phrase></code>
                  or <code><phrase role="identifier">comp</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">j</phrase><phrase role="special">,</phrase>&nbsp;<phrase
                  role="special">*</phrase><phrase role="identifier">i</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">==</phrase>
                  <phrase role="keyword">false</phrase></code>. </entry><entry><emphasis></emphasis>
                  </entry><entry>Linear on average </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search">Polymorphic
        Binary Search</link></title>
        <para>
          The algorithms in this section assume the sequence being searched are ordered
          according to the associated explicit or implicit comparison function. They
          operate on non-random access iterators minimizing the number of comparisons,
          which will be logarithmic for all types of iterators. For random access
          iterators, these algorithms take a logarithmic number of steps through
          range. For non-random access iterators they take a linear number of steps.
        </para>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search.lower_bound">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search.lower_bound">Lower
          Bound</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: For the first form, Type
              <code><phrase role="identifier">T</phrase></code> is <literal>LessThanComparabe</literal>
              (C++ Standard: 20.1.2)
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Finds the first position into which <code><phrase role="identifier">value</phrase></code>
                    can be inserted without violating the ordering. </entry><entry>The
                    furthermost iterator <code><phrase role="identifier">i</phrase></code>
                    in the range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>) such that
                    for any iterator <code><phrase role="identifier">j</phrase></code>
                    in the range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">i</phrase></code>) the following
                    corresponding conditions hold: <code><phrase role="special">*</phrase><phrase
                    role="identifier">j</phrase>&nbsp;<phrase role="special">&lt;</phrase>&nbsp;<phrase
                    role="identifier">value</phrase></code> or <code><phrase role="identifier">comp</phrase><phrase
                    role="special">(*</phrase><phrase role="identifier">j</phrase><phrase
                    role="special">,</phrase>&nbsp;<phrase role="identifier">value</phrase><phrase
                    role="special">)</phrase>&nbsp;<phrase role="special">!=</phrase>&nbsp;<phrase
                    role="keyword">false</phrase></code>. </entry><entry>At most
                    <code><phrase role="identifier">log</phrase><phrase role="special">(</phrase><phrase
                    role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="identifier">first</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">+</phrase>&nbsp;<phrase role="number">1</phrase></code>
                    comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search.upper_bound">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search.upper_bound">Upper
          Bound</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">ForwardIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: For the first form, Type
              <code><phrase role="identifier">T</phrase></code> is <literal>LessThanComparabe</literal>
              (C++ Standard: 20.1.2)
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Finds the first position into which <code><phrase role="identifier">value</phrase></code>
                    can be inserted without violating the ordering. </entry><entry>The
                    furthermost iterator <code><phrase role="identifier">i</phrase></code>
                    in the range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>) such that
                    for any iterator <code><phrase role="identifier">j</phrase></code>
                    in the range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">i</phrase></code>) the following
                    corresponding conditions hold: <code><phrase role="special">!(</phrase><phrase
                    role="identifier">value</phrase>&nbsp;<phrase role="special">&lt;</phrase>&nbsp;<phrase
                    role="special">*</phrase><phrase role="identifier">j</phrase><phrase
                    role="special">)</phrase></code> or <code><phrase role="identifier">comp</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">value</phrase><phrase
                    role="special">,</phrase>&nbsp;<phrase role="special">*</phrase><phrase
                    role="identifier">j</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">==</phrase>&nbsp;<phrase role="keyword">false</phrase></code>.
                    </entry><entry>At most <code><phrase role="identifier">log</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                    role="special">)</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                    role="number">1</phrase></code> comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search.equal_range">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search.equal_range">Equal
          Range</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="special">::</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="special">::</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <phrase role="special">&gt;</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
               <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">equal_range</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: For the first form, Type
              <code><phrase role="identifier">T</phrase></code> is <literal>LessThanComparabe</literal>
              (C++ Standard: 20.1.2)
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Finds the largest subrange [<code><phrase role="identifier">i</phrase></code>,
                    <code><phrase role="identifier">j</phrase></code>) such that
                    <code><phrase role="identifier">value</phrase></code> can be
                    inserted at any iterator <code><phrase role="identifier">k</phrase></code>
                    within that subrange without violating the ordering. <code><phrase
                    role="identifier">k</phrase></code> satisfies the corresponding
                    conditions: <code><phrase role="special">!(*</phrase><phrase
                    role="identifier">k</phrase>&nbsp;<phrase role="special">&lt;</phrase>&nbsp;<phrase
                    role="identifier">value</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">&amp;&amp;</phrase>&nbsp;<phrase role="special">!(</phrase><phrase
                    role="identifier">value</phrase>&nbsp;<phrase role="special">&lt;</phrase>&nbsp;<phrase
                    role="special">*</phrase><phrase role="identifier">k</phrase><phrase
                    role="special">)</phrase></code> or `comp(*k, value) <literal>=
                    false &amp;&amp; comp(value, *k) =</literal> false. </entry><entry>A
                    pair of iterators representing the range [<code><phrase role="identifier">i</phrase></code>,
                    <code><phrase role="identifier">j</phrase></code>). </entry><entry>At
                    most <code><phrase role="number">2</phrase>&nbsp;<phrase role="special">*</phrase>&nbsp;<phrase
                    role="identifier">log</phrase><phrase role="special">(</phrase><phrase
                    role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="identifier">first</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">+</phrase>&nbsp;<phrase role="number">1</phrase></code>
                    comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search.binary_search">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_binary_search.binary_search">Binary
          Search</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ForwardIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>first</emphasis><phrase role="special">,</phrase> <phrase role="identifier">ForwardIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>value</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">binary_search</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: For the first form, Type
              <code><phrase role="identifier">T</phrase></code> is <literal>LessThanComparabe</literal>
              (C++ Standard: 20.1.2)
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Determines if there exists an element in the range with
                    the value of <code><phrase role="identifier">value</phrase></code>.
                    </entry><entry><code><phrase role="keyword">true</phrase></code>
                    if there is an iterator <code><phrase role="identifier">i</phrase></code>
                    in the range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>) that satisfies
                    the corresponding conditions: <code><phrase role="special">!(*</phrase><phrase
                    role="identifier">i</phrase>&nbsp;<phrase role="special">&lt;</phrase>&nbsp;<phrase
                    role="identifier">value</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">&amp;&amp;</phrase>&nbsp;<phrase role="special">!(</phrase><phrase
                    role="identifier">value</phrase>&nbsp;<phrase role="special">&lt;</phrase>&nbsp;<phrase
                    role="special">*</phrase><phrase role="identifier">i</phrase><phrase
                    role="special">)</phrase></code> or <code><phrase role="identifier">comp</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">value</phrase><phrase
                    role="special">,</phrase>&nbsp;<phrase role="special">*</phrase><phrase
                    role="identifier">i</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">==</phrase>&nbsp;<phrase role="keyword">false</phrase>&nbsp;<phrase
                    role="special">&amp;&amp;</phrase>&nbsp;<phrase role="identifier">comp</phrase><phrase
                    role="special">(*</phrase><phrase role="identifier">i</phrase><phrase
                    role="special">,</phrase>&nbsp;<phrase role="identifier">value</phrase><phrase
                    role="special">)</phrase>&nbsp;<phrase role="special">==</phrase>&nbsp;<phrase
                    role="keyword">false</phrase></code>. </entry><entry>At most
                    <code><phrase role="identifier">log</phrase><phrase role="special">(</phrase><phrase
                    role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="identifier">first</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">+</phrase>&nbsp;<phrase role="number">2</phrase></code>
                    comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.merge">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.merge">Merge</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">merge</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Merges two sorted ranges [<code><phrase role="identifier">first1</phrase></code>,
                  <code><phrase role="identifier">last1</phrase></code>) and [<code><phrase
                  role="identifier">first2</phrase></code>, <code><phrase role="identifier">last2</phrase></code>)
                  into the range [<code><phrase role="identifier">result</phrase></code>,
                  <code><phrase role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last2</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first2</phrase><phrase
                  role="special">)</phrase></code>). The resulting range shall not
                  overlap with either of the original ranges. The range will be sorted
                  in non-decreasing order according to the ordering defined by <code><phrase
                  role="identifier">comp</phrase></code>; that is, for every iterator
                  <code><phrase role="identifier">i</phrase></code> in [<code><phrase
                  role="identifier">first</phrase></code>, <code><phrase role="identifier">last</phrase></code>)
                  other than <code><phrase role="identifier">first</phrase></code>,
                  the condition <code><phrase role="special">*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">&lt;</phrase>&nbsp;<phrase role="special">*(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="number">1</phrase><phrase role="special">)</phrase></code>
                  or <code><phrase role="identifier">comp</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">,</phrase>&nbsp;<phrase
                  role="special">*(</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="number">1</phrase><phrase
                  role="special">))</phrase></code> will be <code><phrase role="keyword">false</phrase></code>.
                  For equivalent elements in the two ranges, the elements from the
                  first range always precede the elements from the second. </entry><entry><code><phrase
                  role="identifier">result</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase></code>last2 - first2)`. </entry><entry>At
                  most <code><phrase role="special">(</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                  role="special">(</phrase></code>last2 - first2) - 1` comparisons.
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.inplace_merge">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.inplace_merge">Inplace
        Merge</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>middle</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>middle</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">inplace_merge</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Merges two sorted ranges [<code><phrase role="identifier">first1</phrase></code>,
                  <code><phrase role="identifier">middle</phrase></code>) and [<code><phrase
                  role="identifier">middle</phrase></code>, <code><phrase role="identifier">last</phrase></code>),
                  putting the result of the merge into the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>). The resulting
                  range will be sorted in non-decreasing order according to the ordering
                  defined by <code><phrase role="identifier">comp</phrase></code>;
                  that is, for every iterator <code><phrase role="identifier">i</phrase></code>
                  in [<code><phrase role="identifier">first</phrase></code>, <code><phrase
                  role="identifier">last</phrase></code>) other than <code><phrase
                  role="identifier">first</phrase></code>, the condition <code><phrase
                  role="special">*</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">&lt;</phrase>&nbsp;<phrase role="special">*(</phrase><phrase
                  role="identifier">i</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="number">1</phrase><phrase role="special">)</phrase></code>
                  or <code><phrase role="identifier">comp</phrase><phrase role="special">(*</phrase><phrase
                  role="identifier">i</phrase><phrase role="special">,</phrase>&nbsp;<phrase
                  role="special">*(</phrase><phrase role="identifier">i</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="number">1</phrase><phrase
                  role="special">))</phrase></code> will be <code><phrase role="keyword">false</phrase></code>.
                  For equivalent elements in the two ranges, the elements from the
                  first range always precede the elements from the second. </entry><entry><emphasis></emphasis>
                  </entry><entry>When enough additional memory is available, <code><phrase
                  role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                  role="special">)</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="number">1</phrase></code> comparisons. If no additional memory
                  is available, an algorithm with complexity <code><phrase role="identifier">N</phrase>&nbsp;<phrase
                  role="identifier">log</phrase>&nbsp;<phrase role="identifier">N</phrase></code>
                  may be used (where <code><phrase role="identifier">N</phrase></code>
                  is equal to <code><phrase role="identifier">last</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>).
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures">Polymorphic
        Set Operations on Sorted Structures</link></title>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.includes">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.includes">Includes</link></title>
          
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">includes</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Checks if all of the values in one range are all contained
                    in another. </entry><entry><code><phrase role="keyword">true</phrase></code>
                    if every element in the range [<code><phrase role="identifier">first2</phrase></code>,
                    <code><phrase role="identifier">last2</phrase></code>) is contained
                    in the range [<code><phrase role="identifier">first1</phrase></code>,
                    <code><phrase role="identifier">last1</phrase></code>). Returns
                    <code><phrase role="keyword">false</phrase></code> otherwise.
                    </entry><entry>At most <code><phrase role="number">2</phrase>&nbsp;<phrase
                    role="special">*</phrase>&nbsp;<phrase role="special">((</phrase><phrase
                    role="identifier">last1</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="identifier">first1</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                    role="special">+</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                    role="identifier">last2</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="identifier">first2</phrase><phrase role="special">))</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="number">1</phrase></code>
                    comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.set_union">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.set_union">Set
          Union</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">set_union</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: The resulting range shall
              not overlap with either of the original ranges.
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Constructs a sorted union of the elements from the two
                    ranges; that is, the set of elements that are present in one
                    or both of the ranges. If an element is present in both ranges,
                    the one from the first range is copied. </entry><entry>The end
                    of the constructed range. </entry><entry>At most <code><phrase
                    role="number">2</phrase>&nbsp;<phrase role="special">*</phrase>&nbsp;<phrase
                    role="special">((</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
                    role="special">)</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                    role="special">(</phrase><phrase role="identifier">last2</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first2</phrase><phrase
                    role="special">))</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="number">1</phrase></code> comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.set_intersection">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.set_intersection">Set
          Intersection</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">set_intersection</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: The resulting range shall
              not overlap with either of the original ranges.
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Constructs a sorted intersection of the elements from
                    the two ranges; that is, the set of elements that are present
                    in both of the ranges. If an element is present in both ranges,
                    the one from the first range is copied. </entry><entry>The end
                    of the constructed range. </entry><entry>At most <code><phrase
                    role="number">2</phrase>&nbsp;<phrase role="special">*</phrase>&nbsp;<phrase
                    role="special">((</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
                    role="special">)</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                    role="special">(</phrase><phrase role="identifier">last2</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first2</phrase><phrase
                    role="special">))</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="number">1</phrase></code> comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.set_difference">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.set_difference">Set
          Difference</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">set_difference</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: The resulting range shall
              not overlap with either of the original ranges.
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Copies the elements of the range [<code><phrase role="identifier">first1</phrase></code>,
                    <code><phrase role="identifier">last1</phrase></code>) which
                    are not present in the range [<code><phrase role="identifier">first2</phrase></code>,
                    <code><phrase role="identifier">last2</phrase></code>) to the
                    range beginning at <code><phrase role="identifier">result</phrase></code>.
                    The elements in the constructed range are sorted. </entry><entry>The
                    end of the constructed range. </entry><entry>At most <code><phrase
                    role="number">2</phrase>&nbsp;<phrase role="special">*</phrase>&nbsp;<phrase
                    role="special">((</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
                    role="special">)</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                    role="special">(</phrase><phrase role="identifier">last2</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first2</phrase><phrase
                    role="special">))</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="number">1</phrase></code> comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.set_symmetric_difference">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_set_operations_on_sorted_structures.set_symmetric_difference">Set
          Symmetric Difference</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator2</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">OutputIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="identifier">OutputIterator</phrase>
    <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
               <phrase role="special">,</phrase> <phrase role="identifier">OutputIterator</phrase> <emphasis>result</emphasis><phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
               <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">set_symmetric_distance</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: The resulting range shall
              not overlap with either of the original ranges.
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Copies the elements of the range [<code><phrase role="identifier">first1</phrase></code>,
                    <code><phrase role="identifier">last1</phrase></code>) which
                    are not present in the range [<code><phrase role="identifier">first2</phrase></code>,
                    <code><phrase role="identifier">last2</phrase></code>), and the
                    elements of the range [<code><phrase role="identifier">first2</phrase></code>,
                    <code><phrase role="identifier">last2</phrase></code>) which
                    are not present in the range [<code><phrase role="identifier">first1</phrase></code>,
                    <code><phrase role="identifier">last1</phrase></code>) to the
                    range beginning at <code><phrase role="identifier">result</phrase></code>.
                    The elements in the constructed range are sorted. </entry><entry>The
                    end of the constructed range. </entry><entry>At most <code><phrase
                    role="number">2</phrase>&nbsp;<phrase role="special">*</phrase>&nbsp;<phrase
                    role="special">((</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
                    role="special">)</phrase>&nbsp;<phrase role="special">+</phrase>&nbsp;<phrase
                    role="special">(</phrase><phrase role="identifier">last2</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first2</phrase><phrase
                    role="special">))</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="number">1</phrase></code> comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations">Polymorphic
        Heap Operations</link></title>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations.push_heap">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations.push_heap">Push
          Heap</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">push_heap</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: The range [<code><phrase
              role="identifier">first</phrase></code>, <code><phrase role="identifier">last</phrase>&nbsp;<phrase
              role="special">-</phrase>&nbsp;<phrase role="number">1</phrase></code>)
              shall be a valid heap.
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Places the value in the location <code><phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="number">1</phrase></code>
                    into the resulting heap [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>). </entry><entry><emphasis></emphasis>
                    </entry><entry>At most <code><phrase role="identifier">log</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                    role="special">)</phrase></code> comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations.pop_heap">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations.pop_heap">Pop
          Heap</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">pop_heap</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: The range [<code><phrase
              role="identifier">first</phrase></code>, <code><phrase role="identifier">last</phrase>&nbsp;<phrase
              role="special">-</phrase>&nbsp;<phrase role="number">1</phrase></code>)
              shall be a valid heap.
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Swaps the value in the location <code><phrase role="identifier">first</phrase></code>
                    with the value in the location <code><phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase> <phrase role="number">1</phrase></code>
                    and makes [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="number">1</phrase></code>) into a heap. </entry><entry><emphasis></emphasis>
                    </entry><entry>At most <code><phrase role="number">2</phrase>&nbsp;<phrase
                    role="special">*</phrase>&nbsp;<phrase role="identifier">log</phrase><phrase
                    role="special">(</phrase><phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase><phrase
                    role="special">)</phrase></code> comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations.make_heap">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations.make_heap">Make
          Heap</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">make_heap</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Constructs a heap out of the range [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>). </entry><entry><emphasis></emphasis>
                    </entry><entry>At most <code><phrase role="number">3</phrase>&nbsp;<phrase
                    role="special">*</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                    role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                    role="identifier">first</phrase><phrase role="special">)</phrase></code>
                    comparisons. </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
        <section id="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations.sort_heap">
          <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.polymorphic_heap_operations.sort_heap">Sort
          Heap</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">RandomAccessIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">RandomAccessIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">sort_heap</phrase><phrase role="special">;</phrase>
</programlisting>
          <para>
            <para>
              <emphasis role="bold">Requires</emphasis>: The range [<code><phrase
              role="identifier">first</phrase></code>, <code><phrase role="identifier">last</phrase>&nbsp;<phrase
              role="special">-</phrase>&nbsp;<phrase role="number">1</phrase></code>)
              shall be a valid heap.
            </para>
            <informaltable frame="all">
              <bridgehead renderas="sect4">
              </bridgehead>
              <tgroup cols="3">
                <thead>
                  <row>
                    <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Sorts the elements in the heap [<code><phrase role="identifier">first</phrase></code>,
                    <code><phrase role="identifier">last</phrase></code>). This operation
                    is not guaranteed to be stable. </entry><entry><emphasis></emphasis>
                    </entry><entry>At most <code><phrase role="identifier">N</phrase>&nbsp;<phrase
                    role="identifier">log</phrase>&nbsp;<phrase role="identifier">N</phrase></code>
                    comparisons (where <code><phrase role="identifier">N</phrase>&nbsp;<phrase
                    role="special">==</phrase>&nbsp;<phrase role="identifier">last</phrase>&nbsp;<phrase
                    role="special">-</phrase>&nbsp;<phrase role="identifier">first</phrase></code>).
                    </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </para>
        </section>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.minimum">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.minimum">Minimum</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>a</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>b</emphasis> <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>a</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>b</emphasis>
                      <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                      <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">min</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is <literal>LessThanComparable</literal> (C++ Standard: 20.1.2) and
            <literal>CopyConstructible</literal> (C++ Standard: 20.1.3).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Determines the smaller of the two arguments. </entry><entry>The
                  smaller value, or the first value if the arguments are equivalent.
                  </entry><entry><emphasis></emphasis> </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.maximum">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.maximum">Maximum</link></title>
        
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>a</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>b</emphasis> <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
  
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>a</emphasis><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase role="special">&amp;</phrase> <emphasis>b</emphasis>
                      <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                      <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">max</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <para>
            <emphasis role="bold">Requires</emphasis>: Type <code><phrase role="identifier">T</phrase></code>
            is <literal>LessThanComparable</literal> (C++ Standard: 20.1.2) and
            <literal>CopyConstructible</literal> (C++ Standard: 20.1.3).
          </para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Determines the smaller of the two arguments. </entry><entry>The
                  larger value, or the first value if the arguments are equivalent.
                  </entry><entry><emphasis></emphasis> </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.lexicographical_compare">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.lexicographical_compare">Lexicographical
        Compare</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">InputIterator1</phrase>
          <phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase>
          <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>first1</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator1</phrase> <emphasis>last1</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>first2</emphasis><phrase role="special">,</phrase> <phrase role="identifier">InputIterator2</phrase> <emphasis>last2</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">lexicographical_compare</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Determines the smaller of the two ranges. If two sequences
                  have the same number of elements and their corresponding elements
                  are equivalent, then neither sequence is lexicographically less
                  than the other. If one sequence is a prefix of the other, then
                  the shorter sequence is lexicographically less than the longer
                  sequence. Otherwise, the lexicographical comparison of the sequences
                  yields the same result as the comparison of the first corresponding
                  pair of elements that are not equivalent. </entry><entry><code><phrase
                  role="keyword">true</phrase></code> if the sequence of elements
                  defined by the range [<code><phrase role="identifier">first1</phrase></code>,
                  <code><phrase role="identifier">last1</phrase></code>) is lexicographically
                  less than the sequence of elements defined by the range [<code><phrase
                  role="identifier">first2</phrase></code>, <code><phrase role="identifier">last2</phrase></code>).
                  Returns <code><phrase role="keyword">false</phrase></code> otherwise.
                  </entry><entry>At most <code><phrase role="identifier">min</phrase><phrase
                  role="special">((</phrase><phrase role="identifier">last1</phrase>&nbsp;<phrase
                  role="special">-</phrase>&nbsp;<phrase role="identifier">first1</phrase><phrase
                  role="special">),</phrase>&nbsp;<phrase role="special">(</phrase><phrase
                  role="identifier">last2</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first2</phrase><phrase role="special">))</phrase></code>
                  applications of the corresponding comparison. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.next_permutation">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.next_permutation">Next
        Permutation</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">next_permutation</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Takes a sequence defined by the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) and transforms
                  it into the next permutation. The next permutation is found by
                  assuming that the set of all permutations is lexicographically
                  sorted with respect to <code><phrase role="keyword">operator</phrase><phrase
                  role="special">&lt;</phrase></code> or <code><phrase role="identifier">comp</phrase></code>.
                  </entry><entry>If a next permutation exists, it returns <code><phrase
                  role="keyword">true</phrase></code>. Otherwise, it transforms the
                  sequence into the smallest permutation, that is, the ascendingly
                  sorted one, and returns <code><phrase role="keyword">false</phrase></code>.
                  </entry><entry>At most <code><phrase role="special">(</phrase><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">/</phrase>&nbsp;<phrase role="number">2</phrase></code>
                  swaps. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
      <section id="act.poly_algos.polymorphic_sorting_and_related_operations.previous_permutation">
        <title><link linkend="act.poly_algos.polymorphic_sorting_and_related_operations.previous_permutation">Previous
        Permutation</link></title> 
<programlisting>
<phrase role="keyword">struct</phrase> <emphasis>unspecified-name</emphasis>
<phrase role="special">{</phrase>
  <phrase role="comment">/* Standard polymorpic algorithm requirements */</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">BidirectionalIterator</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Compare</phrase> <phrase role="special">&gt;</phrase>
  <phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">()(</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>first</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">BidirectionalIterator</phrase> <emphasis>last</emphasis>
                  <phrase role="special">,</phrase> <phrase role="identifier">Compare</phrase> <emphasis>comp</emphasis>
                  <phrase role="special">)</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">prev_permutation</phrase><phrase role="special">;</phrase>
</programlisting>
        <para>
          <informaltable frame="all">
            <bridgehead renderas="sect4">
            </bridgehead>
            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Effects</entry><entry>Returns</entry><entry>Complexity</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Takes a sequence defined by the range [<code><phrase role="identifier">first</phrase></code>,
                  <code><phrase role="identifier">last</phrase></code>) and transforms
                  it into the previous permutation. The previous permutation is found
                  by assuming that the set of all permutations is lexicographically
                  sorted with respect to <code><phrase role="keyword">operator</phrase><phrase
                  role="special">&lt;</phrase></code> or <code><phrase role="identifier">comp</phrase></code>.
                  </entry><entry>If a previous permutation exists, it returns <code><phrase
                  role="keyword">true</phrase></code>. Otherwise, it transforms the
                  sequence into the largest permutation, that is, the descendingly
                  sorted one, and returns <code><phrase role="keyword">false</phrase></code>.
                  </entry><entry>At most <code><phrase role="special">(</phrase><phrase
                  role="identifier">last</phrase>&nbsp;<phrase role="special">-</phrase>&nbsp;<phrase
                  role="identifier">first</phrase><phrase role="special">)</phrase>&nbsp;<phrase
                  role="special">/</phrase>&nbsp;<phrase role="number">2</phrase></code>
                  swaps. </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>
    </section>
  </section>
  <section id="act.functional">
    <title><link linkend="act.functional">Functional</link></title>
    <section id="act.functional.parallel_ranges_function">
      <title><link linkend="act.functional.parallel_ranges_function">Parallel Ranges
      Function</link></title>
    </section>
  </section>
  <section id="act.type_traits">
    <title><link linkend="act.type_traits">Type Traits</link></title>
    <section id="act.type_traits.add_active">
      <title><link linkend="act.type_traits.add_active">add_active</link></title>
      
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ActModel</phrase> <phrase role="special">=</phrase> <phrase role="identifier">default_act_model</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">add_active</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ActModel</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">add_active_no_default</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> The <literal>active</literal> qualified
          form of <code><phrase role="identifier">T</phrase></code>, using <code><phrase
          role="identifier">ActModel</phrase></code> as an <literal>act model</literal>.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">add_active</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code> or <code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">add_active_no_default</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code> respectively.
        </para>
      </para>
      <note>
        <para>
          The &quot;no_default&quot; form of <literal>add_active</literal> is used
          when the coder would rather not bring in the entire default act model definition,
          usually for reasons of compile time optimization.
        </para>
      </note>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Examples of add_active</phrase>
        </bridgehead>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Expression</entry><entry>ResultType</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><code><phrase role="identifier">add_active</phrase><phrase role="special">&lt;</phrase><phrase
              role="keyword">int</phrase><phrase role="special">&gt;::</phrase><phrase
              role="identifier">type</phrase></code></entry><entry><code><phrase
              role="identifier">BOOST_ACTIVE</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">))</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">add_active</phrase><phrase role="special">&lt;</phrase><phrase
              role="keyword">int</phrase><phrase role="special">,</phrase> <phrase
              role="identifier">concurrent_act_model</phrase> <phrase role="special">&gt;::</phrase><phrase
              role="identifier">type</phrase></code> </entry><entry><code><phrase
              role="identifier">BOOST_ACTIVE_M</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">),(</phrase><phrase
              role="identifier">concurrent_act_model</phrase><phrase role="special">))</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">add_active</phrase><phrase role="special">&lt;</phrase>
              <phrase role="identifier">BOOST_ACTIVE</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">))&gt;::</phrase><phrase
              role="identifier">type</phrase></code> </entry><entry><code><phrase
              role="identifier">BOOST_ACTIVE</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">))</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">add_active</phrase><phrase role="special">&lt;</phrase>
              <phrase role="identifier">BOOST_ACTIVE</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">),</phrase> <phrase
              role="special">(</phrase><phrase role="identifier">immediate_act_model</phrase><phrase
              role="special">)</phrase> <phrase role="special">),</phrase><phrase
              role="identifier">concurrent_act_model</phrase><phrase role="special">&gt;::</phrase><phrase
              role="identifier">type</phrase></code> </entry><entry><code><phrase
              role="identifier">BOOST_ACTIVE_M</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">),(</phrase><phrase
              role="identifier">concurrent_act_model</phrase><phrase role="special">))</phrase></code></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section id="act.type_traits.add_atomic">
      <title><link linkend="act.type_traits.add_atomic">add_atomic</link></title>
      
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">ActModel</phrase> <phrase role="special">=</phrase> <phrase role="identifier">default_act_model</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">add_atomic</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> The <literal>atomic</literal> qualified
          form of <code><phrase role="identifier">T</phrase></code>.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">add_atomic</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code>
        </para>
      </para>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Examples of add_active</phrase>
        </bridgehead>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Expression</entry><entry>ResultType</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><code><phrase role="identifier">add_atomic</phrase><phrase role="special">&lt;</phrase><phrase
              role="keyword">int</phrase><phrase role="special">&gt;::</phrase><phrase
              role="identifier">type</phrase></code></entry><entry><code><phrase
              role="identifier">BOOST_ATOMIC</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">))</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">add_atomic</phrase><phrase role="special">&lt;</phrase><phrase
              role="identifier">BOOST_ATOMIC</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">))&gt;::</phrase><phrase
              role="identifier">type</phrase></code></entry><entry><code><phrase
              role="identifier">BOOST_ATOMIC</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">))</phrase></code></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section id="act.type_traits.has_parallel_safe_assign">
      <title><link linkend="act.type_traits.has_parallel_safe_assign">has_parallel_safe_assign</link></title>
      
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">has_parallel_safe_assign</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">bool</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> A <literal>Boost.MPL</literal>&nbsp;<literal>integral
          constant</literal> type representing <code><phrase role="keyword">true</phrase></code>
          if <code><phrase role="identifier">T</phrase></code> is identifiable as
          having a parallel-safe copy-assignment operation or if the type has <code><phrase
          role="identifier">parallel_safe_assign</phrase></code> as a direct or indirect
          public base, <code><phrase role="keyword">false</phrase></code> otherwise.
          A type is considered to have a parallel-safe assignment operation if a
          unary or binary function object type which assigns one instance of <code><phrase
          role="identifier">T</phrase></code> to another can be considered <literal>parallel
          safe</literal>.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">has_parallel_safe_assign</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code>
        </para>
      </para>
      <note>
        <para>
          <literal>scalar</literal> types and <literal>P.O.D.</literal> types are
          automatically considered to be <literal>parallel safe assignable</literal>
          if the necessary compiler intrinsics are present.
        </para>
      </note>
      <variablelist>
        <title>Examples of has_paralle_safe_assign</title> <varlistentry><term></term>
        <listitem>
          Given: 
<programlisting>
<phrase role="keyword">struct</phrase> <phrase role="identifier">a</phrase> <phrase role="special">{</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">mem</phrase><phrase role="special">;</phrase> <phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">b</phrase> <phrase role="special">:</phrase> <phrase role="identifier">parallel_safe_assignable</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">int</phrase> <phrase role="identifier">mem</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">b</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">=(</phrase> <phrase role="identifier">b</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">){</phrase> <phrase role="keyword">return</phrase> <phrase role="special">*</phrase><phrase role="keyword">this</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">c</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">int</phrase> <phrase role="identifier">mem</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">c</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase> <phrase role="special">=(</phrase> <phrase role="identifier">c</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="special">){</phrase> <phrase role="keyword">return</phrase> <phrase role="special">*</phrase><phrase role="keyword">this</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">has_parallel_safe_assign</phrase><phrase
          role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase
          role="special">&gt;::</phrase><phrase role="identifier">value</phrase></code>
          is an integral constant expression that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">has_parallel_safe_assign</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">a</phrase><phrase
          role="special">&gt;::</phrase><phrase role="identifier">value</phrase></code>
          is an integral constant expression that evaluates to <code><phrase role="keyword">true</phrase></code>
          with the necessary compile intrinsics.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">has_parallel_safe_assign</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">b</phrase><phrase
          role="special">&gt;::</phrase><phrase role="identifier">value</phrase></code>
          is an integral constant expression that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">has_parallel_safe_assign</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">c</phrase><phrase
          role="special">&gt;::</phrase><phrase role="identifier">value</phrase></code>
          is an integral constant expression that evaluates to <code><phrase role="keyword">false</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">has_parallel_safe_assign</phrase><phrase
          role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase
          role="special">&gt;::</phrase><phrase role="identifier">value_type</phrase></code>
          is the type <code><phrase role="keyword">bool</phrase></code>.
        </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="act.type_traits.is_act_model">
      <title><link linkend="act.type_traits.is_act_model">is_act_model</link></title>
      
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">is_act_model</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">bool</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> A <literal>Boost.MPL</literal>&nbsp;<literal>integral
          constant</literal> type representing <code><phrase role="keyword">true</phrase></code>
          if <code><phrase role="identifier">T</phrase></code> has the type <code><phrase
          role="identifier">act_model</phrase></code> as a direct or indirect public
          base, <code><phrase role="keyword">false</phrase></code> otherwise.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">is_act_model</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code>
        </para>
      </para>
      <variablelist>
        <title>Examples of is_act_model</title> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_act_model</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">concurrent_act_model</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_act_model</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">immediate_act_model</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_act_model</phrase><phrase role="special">&lt;</phrase><phrase
          role="keyword">int</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">false</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_act_model</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">T</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value_type</phrase></code> is the type <code><phrase
          role="keyword">bool</phrase></code>.
        </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="act.type_traits.is_active">
      <title><link linkend="act.type_traits.is_active">is_active</link></title> 
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">is_active</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">bool</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> A <literal>Boost.MPL</literal>&nbsp;<literal>integral
          constant</literal> type representing <code><phrase role="keyword">true</phrase></code>
          if <code><phrase role="identifier">T</phrase></code> is an active-qualified
          type, <code><phrase role="keyword">false</phrase></code> otherwise.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">is_active</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code>
        </para>
      </para>
      <variablelist>
        <title>Examples of is_active</title> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_active</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">BOOST_ACTIVE</phrase><phrase role="special">((</phrase><phrase
          role="keyword">int</phrase><phrase role="special">))&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_active</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">BOOST_ACTIVE_M</phrase><phrase role="special">((</phrase><phrase
          role="keyword">int</phrase><phrase role="special">),(</phrase><phrase role="identifier">immediate_act_model</phrase><phrase
          role="special">))&gt;::</phrase><phrase role="identifier">value</phrase></code>
          is an integral constant expression that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_active</phrase><phrase role="special">&lt;</phrase><phrase
          role="keyword">int</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">false</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_active</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">T</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value_type</phrase></code> is the type <code><phrase
          role="keyword">bool</phrase></code>.
        </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="act.type_traits.is_atomic">
      <title><link linkend="act.type_traits.is_atomic">is_atomic</link></title> 
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">is_atomic</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">bool</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> A <literal>Boost.MPL</literal>&nbsp;<literal>integral
          constant</literal> type representing <code><phrase role="keyword">true</phrase></code>
          if <code><phrase role="identifier">T</phrase></code> is an atomic-qualified
          type, <code><phrase role="keyword">false</phrase></code> otherwise.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">is_atomic</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code>
        </para>
      </para>
      <variablelist>
        <title>Examples of is_atomic</title> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_atomic</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">BOOST_ATOMIC</phrase><phrase role="special">((</phrase><phrase
          role="keyword">int</phrase><phrase role="special">))&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_atomic</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">BOOST_ATOMIC_M</phrase><phrase role="special">((</phrase><phrase
          role="keyword">int</phrase><phrase role="special">),(</phrase><phrase role="identifier">immediate_act_model</phrase><phrase
          role="special">))&gt;::</phrase><phrase role="identifier">value</phrase></code>
          is an integral constant expression that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_atomic</phrase><phrase role="special">&lt;</phrase><phrase
          role="keyword">int</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">false</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_atomic</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">T</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value_type</phrase></code> is the type <code><phrase
          role="keyword">bool</phrase></code>.
        </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="act.type_traits.is_algo_model">
      <title><link linkend="act.type_traits.is_algo_model">is_algo_model</link></title>
      
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">is_algo_model</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">bool</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> A <literal>Boost.MPL</literal>&nbsp;<literal>integral
          constant</literal> type representing <code><phrase role="keyword">true</phrase></code>
          if <code><phrase role="identifier">T</phrase></code> has the type <code><phrase
          role="identifier">algo_model</phrase></code> as a direct or indirect public
          base, <code><phrase role="keyword">false</phrase></code> otherwise.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">is_algo_model</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code>
        </para>
      </para>
      <variablelist>
        <title>Examples of is_algo_model</title> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_algo_model</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">parallel_algo_model</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_algo_model</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">serial_algo_model</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_algo_model</phrase><phrase role="special">&lt;</phrase><phrase
          role="keyword">int</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">false</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_algo_model</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">T</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value_type</phrase></code> is the type <code><phrase
          role="keyword">bool</phrase></code>.
        </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="act.type_traits.is_parallel_safe">
      <title><link linkend="act.type_traits.is_parallel_safe">is_parallel_safe</link></title>
      
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">is_parallel_safe</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">is_algo_model</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">bool</phrase> <phrase role="identifier">value_type</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> A <literal>Boost.MPL</literal>&nbsp;<literal>integral
          constant</literal> type representing <code><phrase role="keyword">true</phrase></code>
          if <code><phrase role="identifier">T</phrase></code> is a type which has
          <code><phrase role="identifier">parallel_safe</phrase></code> as a direct
          or indirect public base or if the template has been appropriately specialized,
          <code><phrase role="keyword">false</phrase></code> otherwise.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">is_parallel_safe</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code>
        </para>
      </para>
      <note>
        <para>
          In future releases of <literal>Boost.Act</literal>, this metafunction will
          be replaced with one that operates more similarly to <literal>result_of</literal>,
          since operands to <code><phrase role="keyword">operator</phrase>&nbsp;<phrase
          role="special">()</phrase></code> may control whether or not the operation
          is safe to be executed in parallel.
        </para>
      </note>
      <variablelist>
        <title>Examples of is_parallel_safe</title> <varlistentry><term></term>
        <listitem>
          Given: 
<programlisting>
<phrase role="keyword">struct</phrase> <phrase role="identifier">a</phrase> <phrase role="special">:</phrase> <phrase role="identifier">parallel_safe</phrase> <phrase role="special">{};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">b</phrase> <phrase role="special">{};</phrase></programlisting>
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_parallel_safe</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">a</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">true</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_parallel_safe</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">b</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">false</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_parallel_safe</phrase><phrase role="special">&lt;</phrase><phrase
          role="keyword">int</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value</phrase></code> is an integral constant expression
          that evaluates to <code><phrase role="keyword">false</phrase></code>.
        </listitem>
        </varlistentry> <varlistentry><term></term>
        <listitem>
          <code><phrase role="identifier">is_parallel_safe</phrase><phrase role="special">&lt;</phrase><phrase
          role="identifier">T</phrase><phrase role="special">&gt;::</phrase><phrase
          role="identifier">value_type</phrase></code> is the type <code><phrase
          role="keyword">bool</phrase></code>.
        </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="act.type_traits.remove_active">
      <title><link linkend="act.type_traits.remove_active">remove_active</link></title>
      
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">remove_active</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> The <literal>active</literal> unqualified
          form of <code><phrase role="identifier">T</phrase></code>.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">remove_active</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code>
        </para>
      </para>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Examples of remove_active</phrase>
        </bridgehead>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Expression</entry><entry>ResultType</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><code><phrase role="identifier">remove_active</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">BOOST_ACTIVE</phrase><phrase
              role="special">((</phrase><phrase role="keyword">int</phrase><phrase
              role="special">))&gt;::</phrase><phrase role="identifier">type</phrase></code></entry><entry><code><phrase
              role="keyword">int</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">remove_active</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">BOOST_ACTIVE_M</phrase><phrase
              role="special">((</phrase><phrase role="keyword">int</phrase><phrase
              role="special">),(</phrase><phrase role="identifier">parallel_act_model</phrase><phrase
              role="special">))&gt;::</phrase><phrase role="identifier">type</phrase></code></entry><entry><code><phrase
              role="keyword">int</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">remove_active</phrase><phrase
              role="special">&lt;</phrase><phrase role="keyword">const</phrase>&nbsp;<phrase
              role="identifier">BOOST_ACTIVE</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">))&gt;::</phrase><phrase
              role="identifier">type</phrase></code></entry><entry><code><phrase
              role="keyword">const</phrase>&nbsp;<phrase role="keyword">int</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">remove_active</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">BOOST_ACTIVE</phrase><phrase
              role="special">((</phrase><phrase role="keyword">const</phrase>&nbsp;<phrase
              role="keyword">int</phrase><phrase role="special">))&gt;::</phrase><phrase
              role="identifier">type</phrase></code></entry><entry><code><phrase
              role="keyword">const</phrase>&nbsp;<phrase role="keyword">int</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">remove_active</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">BOOST_ACTIVE</phrase><phrase
              role="special">((</phrase><phrase role="keyword">int</phrase><phrase
              role="special">))*&gt;::</phrase><phrase role="identifier">type</phrase></code></entry><entry><code><phrase
              role="identifier">BOOST_ACTIVE</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">))*</phrase></code></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section id="act.type_traits.remove_atomic">
      <title><link linkend="act.type_traits.remove_atomic">remove_atomic</link></title>
      
<programlisting>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase> <phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">remove_atomic</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <emphasis>unspecified-type</emphasis> <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        <para>
          <emphasis role="bold">type:</emphasis> The <literal>atomic</literal> unqualified
          form of <code><phrase role="identifier">T</phrase></code>.
        </para>
        <para>
          <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
          role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
          role="special">/</phrase><phrase role="identifier">act</phrase><phrase
          role="special">/</phrase><phrase role="identifier">type_traits</phrase><phrase
          role="special">/</phrase><phrase role="identifier">remove_atomic</phrase><phrase
          role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
          role="special">&gt;</phrase></code>
        </para>
      </para>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Examples of remove_atomic</phrase>
        </bridgehead>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Expression</entry><entry>ResultType</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><code><phrase role="identifier">remove_atomic</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">BOOST_ATOMIC</phrase><phrase
              role="special">((</phrase><phrase role="keyword">int</phrase><phrase
              role="special">))&gt;::</phrase><phrase role="identifier">type</phrase></code></entry><entry><code><phrase
              role="keyword">int</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">remove_atomic</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">BOOST_ATOMIC_M</phrase><phrase
              role="special">((</phrase><phrase role="keyword">int</phrase><phrase
              role="special">),(</phrase><phrase role="identifier">parallel_act_model</phrase><phrase
              role="special">))&gt;::</phrase><phrase role="identifier">type</phrase></code></entry><entry><code><phrase
              role="keyword">int</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">remove_atomic</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">BOOST_ATOMIC</phrase><phrase
              role="special">((</phrase><phrase role="keyword">const</phrase>&nbsp;<phrase
              role="keyword">int</phrase><phrase role="special">))&gt;::</phrase><phrase
              role="identifier">type</phrase></code></entry><entry><code><phrase
              role="keyword">const</phrase>&nbsp;<phrase role="keyword">int</phrase></code></entry>
            </row>
            <row>
              <entry><code><phrase role="identifier">remove_atomic</phrase><phrase
              role="special">&lt;</phrase><phrase role="identifier">BOOST_ATOMIC</phrase><phrase
              role="special">((</phrase><phrase role="keyword">int</phrase><phrase
              role="special">))&amp;&gt;::</phrase><phrase role="identifier">type</phrase></code></entry><entry><code><phrase
              role="identifier">BOOST_ATOMIC</phrase><phrase role="special">((</phrase><phrase
              role="keyword">int</phrase><phrase role="special">))&amp;</phrase></code></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
  </section>
  <section id="act.configuration">
    <title><link linkend="act.configuration">Configuration</link></title>
    <para>
      <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
      role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
      role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase
      role="identifier">config</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase
      role="special">&gt;</phrase></code>
    </para>
    <para>
      The configuration information described in the following sections may be accessed
      by including the header file mentioned above or individually through the header
      files as noted below.
    </para>
    <section id="act.configuration.checking_parallel_support">
      <title><link linkend="act.configuration.checking_parallel_support">Checking
      Parallel Support</link></title>
      <para>
        <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
        role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
        role="special">/</phrase><phrase role="identifier">config</phrase><phrase
        role="special">/</phrase><phrase role="identifier">has_parallel_support</phrase><phrase
        role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
      </para>
    </section>
    <section id="act.configuration.default_algorithm_model">
      <title><link linkend="act.configuration.default_algorithm_model">Default Algorithm
      Model</link></title>
      <para>
        <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
        role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
        role="special">/</phrase><phrase role="identifier">config</phrase><phrase
        role="special">/</phrase><phrase role="identifier">default_algo_model</phrase><phrase
        role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
      </para>
      <note>
        <para>
          Do not confuse this header or macro with those required for accessing the
          definition of the default <literal>algorithm model</literal>. See the default
          act model section for more details.
        </para>
      </note>
    </section>
    <section id="act.configuration.default_act_model">
      <title><link linkend="act.configuration.default_act_model">Default Act Model</link></title>
      <para>
        <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
        role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
        role="special">/</phrase><phrase role="identifier">config</phrase><phrase
        role="special">/</phrase><phrase role="identifier">default_act_model</phrase><phrase
        role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
      </para>
      <note>
        <para>
          Do not confuse this header or macro with those required for accessing the
          definition of the default <literal>act model</literal>. See the default
          act model section for more details.
        </para>
      </note>
    </section>
    <section id="act.configuration.maximum_number_of_call_parameters">
      <title><link linkend="act.configuration.maximum_number_of_call_parameters">Maximum
      Number of Call Parameters</link></title>
      <para>
        <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
        role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
        role="special">/</phrase><phrase role="identifier">config</phrase><phrase
        role="special">/</phrase><phrase role="identifier">max_call_params</phrase><phrase
        role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
      </para>
      <para>
        <emphasis role="bold">Macro:</emphasis>&nbsp;<code><phrase role="identifier">BOOST_ACT_MAX_PARAMS</phrase></code>
      </para>
      <para>
        The <code><phrase role="identifier">BOOST_ACT_MAX_PARAMS</phrase></code>
        macro holds the maximum number of parameters that an asynchronous function
        object or queued function object may have when explicitly passing arguments
        through either <code><phrase role="identifier">queue_function</phrase></code>
        or the constructor of an <code><phrase role="identifier">action</phrase></code>.
        By default, <code><phrase role="identifier">BOOST_ACT_MAX_PARAMS</phrase></code>
        is defined to 10, although this is adjustable by defining <code><phrase role="identifier">BOOST_ACT_MAX_PARAMS</phrase></code>
        to another value in all translation units prior to using any <literal>Boost.Act</literal>
        header files.
      </para>
    </section>
  </section>
  <section id="act.common_act_models">
    <title><link linkend="act.common_act_models">Common Act Models</link></title>
    <para>
      <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
      role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
      role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase
      role="identifier">common_act_models</phrase><phrase role="special">.</phrase><phrase
      role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
    </para>
    <para>
      The <literal>act models</literal> documented in this section are included with
      <literal>Boost.Act</literal>. In order to gain access to these <literal>algorithm
      models</literal> you may either include the header mentioned above, or you
      may include act models on an individual basis through the headers mentioned
      in their corresponding section.
    </para>
    <section id="act.common_act_models.concurrent_act_model">
      <title><link linkend="act.common_act_models.concurrent_act_model">Concurrent
      Act Model</link></title>
      <para>
        <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
        role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
        role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase
        role="identifier">common_act_models</phrase><phrase role="special">/</phrase><phrase
        role="identifier">concurrent_act_model</phrase><phrase role="special">.</phrase><phrase
        role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
      </para>
    </section>
    <section id="act.common_act_models.immediate_act_model">
      <title><link linkend="act.common_act_models.immediate_act_model">Immediate
      Act Model</link></title>
      <para>
        <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
        role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
        role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase
        role="identifier">common_act_models</phrase><phrase role="special">/</phrase><phrase
        role="identifier">immediate_act_model</phrase><phrase role="special">.</phrase><phrase
        role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
      </para>
    </section>
    <section id="act.common_act_models.lazy_act_model">
      <title><link linkend="act.common_act_models.lazy_act_model">Lazy Act Model</link></title>
      <important>
        <para>
          The lazy act model has been delayed until after everything else has been
          completed.
        </para>
      </important>
    </section>
    <section id="act.common_act_models.concurrent_lazy_act_model">
      <title><link linkend="act.common_act_models.concurrent_lazy_act_model">Concurrent
      Lazy Act Model</link></title>
      <important>
        <para>
          The concurrent lazy act model has been delayed until after everything else
          has been completed.
        </para>
      </important>
    </section>
  </section>
  <section id="act.common_algorithm_models">
    <title><link linkend="act.common_algorithm_models">Common Algorithm Models</link></title>
    <para>
      <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
      role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
      role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase
      role="identifier">common_algo_models</phrase><phrase role="special">.</phrase><phrase
      role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
    </para>
    <para>
      The <literal>act models</literal> documented in this section are included with
      <literal>Boost.Act</literal>. In order to gain access to these <literal>algorithm
      models</literal> you may either include the header mentioned above, or you
      may include algorithms models on an individual basis through the headers mentioned
      in their corresponding section.
    </para>
    <section id="act.common_algorithm_models.parallel_algorithm_model">
      <title><link linkend="act.common_algorithm_models.parallel_algorithm_model">Parallel
      Algorithm Model</link></title>
      <para>
        <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
        role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
        role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase
        role="identifier">common_algo_models</phrase><phrase role="special">/</phrase><phrase
        role="identifier">parallel_algo_model</phrase><phrase role="special">.</phrase><phrase
        role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
      </para>
      <para>
        The <literal>parallel algorithm model</literal> is an <literal>algorithm
        model</literal> which attempts to execute <literal>polymorphic algorithms</literal>
        in parallel when it can be determined that it is safe to do so, otherwise,
        they will execute serially.
      </para>
      <para>
        Identifying types as being safe for parallel execution is done through the
        use of type traits. In particular, often times a function object or other
        type must be identified as <literal>parallel safe</literal> in order for
        it to be used safely by an algorithm which splits execution up into multiple
        threads.
      </para>
      <para>
        The following is a list of algorithms whose operands must support expressions
        that are identifiable as being <literal>parallel safe</literal> if they are
        to be executed in parallel. Keep in mind that it is safe to call such algorithms
        without parallel safe arguments, however execution will be performed serially.
      </para>
      <informaltable frame="all">
        <bridgehead renderas="sect4">
          <phrase role="table-title">Parallel Execution Requirements</phrase>
        </bridgehead>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Algorithm</entry><entry>Requirements for Parallel Execution</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry> for_each , for_each_if </entry><entry><code><phrase role="identifier">f</phrase><phrase
              role="special">(*</phrase><phrase role="identifier">i</phrase><phrase
              role="special">)</phrase></code> must be parallel-safe (where <code><phrase
              role="identifier">i</phrase></code> is an iterator in the range [<code><phrase
              role="identifier">first</phrase></code>, <code><phrase role="identifier">last</phrase></code>)).
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <important>
        <para>
          The <literal>parallel algorithm</literal> model is currently implemented
          using <ulink url="http://www.OpenMP.org">OpenMP</ulink>. To check if your
          compiler supports OpenMP and to see which flags are needed during compilation
          to enable it, refer to the compiler setup section of documentation. If
          you do not enable OpenMP for your compiler, all <literal>polymorphic algorithms</literal>
          executed with the <literal>parallel algorithm model</literal> will always
          run serially.
        </para>
      </important>
      <section id="act.common_algorithm_models.parallel_algorithm_model.extended_parameters">
        <title><link linkend="act.common_algorithm_models.parallel_algorithm_model.extended_parameters">Extended
        Parameters</link></title>
      </section>
    </section>
    <section id="act.common_algorithm_models.serial_algorithm_model">
      <title><link linkend="act.common_algorithm_models.serial_algorithm_model">Serial
      Algorithm Model</link></title>
      <para>
        <emphasis role="bold">Header:</emphasis>&nbsp;<code><phrase role="preprocessor">#include</phrase>&nbsp;<phrase
        role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase
        role="special">/</phrase><phrase role="identifier">act</phrase><phrase role="special">/</phrase><phrase
        role="identifier">common_algo_models</phrase><phrase role="special">/</phrase><phrase
        role="identifier">serial_algo_model</phrase><phrase role="special">.</phrase><phrase
        role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>
      </para>
    </section>
  </section>
  <section id="act.rationale">
    <title><link linkend="act.rationale">Rationale</link></title>
    <para>
      Boost.Act is a fairly large library and makes some controversial design decisions.
      This section is provided to briefly describe the rationale behind some of these
      decisions.
    </para>
    <section id="act.rationale.policy_based_design">
      <title><link linkend="act.rationale.policy_based_design">Policy-Based Design</link></title>
      <para>
        Boost.Act offers programmers customizability through two kinds of policies
        which control algorithm execution and active qualification implementation.
        These policies allow one to adjust whether algorithms run in parallel when
        possible or always serially, and allow one to adjust whether active types
        create their own thread or operate in the master thread. Default policies
        used can be overriden at a global level or individually at points of instantiation.
        The reason this may be considered controversial is that some may argue that
        the use of policies here adds needless complexity at little gain. <emphasis>In
        short, why not just use the STL in cases where algorithms need to be run
        serially and why not just not use active objects in places where you do not
        need your object to exist in its own thread?</emphasis>
      </para>
      <para>
        The reasons for choosing policies stem mostly from the fact that they provide
        an easy way to switch execution models for arbitrary amounts of code with
        very few changes to the code using the library. Reasons one may wish to switch
        policies at the call-site range from reasons of optimization to reasons of
        debugging. In terms of optimization, using active objects and parallel algorithms
        may have a negative impact on performance in single-core systems, therefore
        the ability to toggle the execution model by merely changing the default
        policy used allows a programmer to target both single-core and multicore
        processors by simply rebuilding after changing the policy being used. In
        theory, using policies which target single-core sytems can be optimized to
        the same code as a project which avoided the abstraction entirely.
      </para>
      <para>
        As an example of switching policies for debugging, single-threaded algorithms
        can often be more simple to debug than multi-threaded algorithms. If a bug
        is narrowed down to a single algorithm which runs in parallel, one may easily
        switch execution for that call to be serial, making it much easier to step
        through in order to find the problem. This also helps in figuring out if
        certain unwanted behavior is being caused by multi-threading issues or if
        there is a more simple logical problem which exists at a higher-level in
        the algorithm's design.
      </para>
    </section>
    <section id="act.rationale.actions_vs__futures">
      <title><link linkend="act.rationale.actions_vs__futures">Actions vs. Futures</link></title>
      <para>
        Another fairly controversial design decision is the absence of futures, or
        at least futures as they are commonly known. Rather than returning futures
        from asynchronous function calls and function calls queued on active objects,
        <literal>actions</literal> are yielded which represent the running function
        and provide an indirect interface to an instance of the active qualified
        form of the return type. This choice was made for a variety of reasons. First
        and foremost, this allows a programmer to work with the results of such function
        calls without losing concurrency by default, as functions upon them are queued
        rather than performed immediately after implicitly or explicitly forcing
        the function to complete. The traditional blocking form of futures, while
        can potentially be implemented in such a way that is [slightly] more optimized
        for single-core processors, implies an unnecessary loss of concurrency and
        becomes less efficient if multiple cores are available. Still, the traditional
        behavior of futures can be forced through actions by simply copying the active
        result to an active-unqualified form of the result type using <literal>inactive_value</literal>,
        forcing a wait for the function to complete. This gives actions of Boost.Act
        a superset of the functionality provided by futures meaning that those who
        wish to use actions in a future-like manner may do so.
      </para>
    </section>
  </section>
  <section id="act.future_direction">
    <title><link linkend="act.future_direction">Future Direction</link></title>
  </section>
  <section id="act.acknowledgements">
    <title><link linkend="act.acknowledgements">Acknowledgements</link></title>
    <para>
      Placeholder section
    </para>
  </section>
  <section id="act.development_status">
    <title><link linkend="act.development_status">Development status</link></title>
    <para>
      This section details most of the features planned for the first official completed
      release of Boost.Act along with their current stage of implementation in the
      library.
    </para>
    <informaltable frame="all">
      <bridgehead renderas="sect4">
        <phrase role="table-title">Development status</phrase>
      </bridgehead>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Feature</entry><entry>Progress</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>General design</entry><entry>100%</entry>
          </row>
          <row>
            <entry>Act model concept</entry><entry>100%</entry>
          </row>
          <row>
            <entry>Immediate act model</entry><entry>95%</entry>
          </row>
          <row>
            <entry>Concurrent act model</entry><entry>50% (missing overridable main
            , thread allocator , no special cases for void actions yet ) </entry>
          </row>
          <row>
            <entry>Lazy act model</entry><entry>0% (possibly will be left out in
            first official 100% release )</entry>
          </row>
          <row>
            <entry>Parallel-safe concept</entry><entry>100%</entry>
          </row>
          <row>
            <entry>Parallel-safe concept</entry><entry>100%</entry>
          </row>
          <row>
            <entry>Algorithm model concept</entry><entry>100%</entry>
          </row>
          <row>
            <entry>Serial algorithm model</entry><entry>100%</entry>
          </row>
          <row>
            <entry>Parallel algorithm model</entry><entry>100% (Implemented with
            OpenMP)</entry>
          </row>
          <row>
            <entry>Dynamic STL algorithms</entry><entry>10% (6 algorithms implemented;
            many stubs in-place ) </entry>
          </row>
          <row>
            <entry>Polymorphic algorithm macro</entry><entry>90% (allows for easily
            creating even complex, overloaded polymorphic algorithms with a series
            of macros; needs to be updated and exposed to the user ) </entry>
          </row>
          <row>
            <entry>Active object framework</entry><entry>90%</entry>
          </row>
          <row>
            <entry>Active qualifier</entry><entry>100%</entry>
          </row>
          <row>
            <entry>Action framework</entry><entry>90%</entry>
          </row>
          <row>
            <entry>Atomic framework</entry><entry>90% (most framework setup, missing
            proper return types, scalar types fully implemented using OpenMP if supported
            </entry>
          </row>
          <row>
            <entry>Type traits</entry><entry>40%</entry>
          </row>
          <row>
            <entry>Max call parameter toggle</entry><entry>100%</entry>
          </row>
          <row>
            <entry>Portability</entry><entry>Compilation and limited testing working
            in VC++ 8.0, Intel 9.1, and MinGW </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </section>
</article>
