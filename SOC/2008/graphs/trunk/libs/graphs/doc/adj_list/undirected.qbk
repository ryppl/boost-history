
[def __undirected_graph__ [^undirected_graph]]
[def __VertexLabel__ [^VertexLabel]]
[def __EdgeLabel__ [^EdgeLabel]]
[def __VertexStore__ [^VertexStore]]
[def __EdgeStore__ [^EdgeStore]]

[section `undirected_graph`]

 #include <boost/graphs/adjacency_list/undirected_graph.hpp>

 namespace boost {
 namespace graphs {
 namespace adjacency_list {

     template <
        __ObjectType__ __VertexLabel__ = none,
        __ObjectType__ __EdgeLabel__ = none,
        __VertexStoreSelector__ __VertexStore__ = vertex_list<>,
        __EdgeStoreSelector__ __EdgeStore__ = edge_list<>>
    requires __MoveConstructible__<__VertexLabel__>
          && __MoveConstructible__<__EdgeLabel__>
    undirected_graph;

 } } }

The __undirected_graph__ data structure is an adjacency list implementation of undirected
graphs. Its basic structure is shown in [link fig_1 Figure 1].

[figure fig_1 images/graph/undirected.png
    [*Figure 1. Components of an undirected graph]
]

* The /vertex store/ is a container that stores vertices (vertex labels and incident
edges) of the graph.
* The /property store/ is a container that stores edge labels and the edges endpoints.
The type of the property store's implementation is determined entirely by the type of
the vertex store.
* The /incidence store/ is a per-vertex container that stores "edge pairs" a descriptor
to the opposite endpoint and the edge label.

[note *Impementation* The reason that the `PropertyStore` references the endpoints is
to provide constant-time access to the endpoints of an edge during edge iteration. It
is possible (and feasible) to create a simpler version of the __undirected_graph__ who's
property store does not contain back references, but neither would it provide edge
iteration.]

[note *Implementation* When the edge property is none, the property store should be
compressed, eliminating the required storage space. Property descriptors could probably
be `typedef`'d as integer values (or GUID's if the graph is expected to exceed 2^32
edges. This has specialization has not been implemented.]

[heading Template Parameters and Requirements]
The following base requirements apply to the template parameters of the __undirected_graph__.

[table
[[Parameter] [Description]]
[[__ObjectType__ __VertexLabel__]
 [Data associated with each vertex. This defaults to `none`.]]
[[__ObjectType__ __EdgeLabel__]
 [Data associated with each edge. This defaults to `none`.]]
[[__VertexStoreSelector__ __VertexStore__]
 [The vertex store selector. This defaults to `vertex_list<>`.]]
[[__EdgeStoreSelector__ __EdgeStore__]
 [The edge store selector. This defaults to `edge_list<>`.]]
]

The default __undirected_graph__ type defines a very basic graph with unlabeled
vertices and edges that supports efficient, runtime setup and teardown - the
addition and removal of vertices after construction.

The __VertexLabel__ and __EdgeLabel__ are required to be __MoveConstructible__,
which is a common requirement for the types contained by standard containers.

[note *Design* Are these not also required to be __DefaultConstructible__?]

[heading Associated Types]
The __undirected_graph__ defines the following associated types as part of its
public interface.

[table
[[Type name] [Description]]
[[`G::vertex_label`] [The same as `VertexLabel`.]]
[[`G::edge_label`] [The same as `EdgeLabel`.]]
[[`G::vertex_descriptor`] [The representative type of vertices.]]
[[`G::edge_descriptor`] [The representative type of edges.]]
[[`G::vertices_size_type`] [The unsigned integral type of the number of vertices.]]
[[`G::edges_size_type`] [The unsigned integral type of the total number of edges.]]
[[`G::incident_edges_size_type`]
 [The unsigned integral type of the number of edges incident to a vertex.]]

[[`G::vertex_iterator`] [An iterator type for the vertices in the graph.]]
[[`G::vertex_range`] [A range of vertex iterators.]]
[[`G::edge_iterator`] [An iterator type for all edges in the graph.]]
[[`G::edge_range`] [A range of edge iterators.]]
[[`G::incident_edge_iterator`] [An iterator type for the edges incident to a vertex.]]
[[`G::incident_edge_range`] [A range of incident edge iterators.]]
[[`G::adjacent_vertex_iterator`] [An iterator type for the vertices adjacent to a given vertex.]]
[[`G::adjacent_vertex_range`] [A range of adjacent vertex iterators.]]
]

The following associated types define the types of the components selected by
the __VertexStore__ and __EdgeStore__ template parameters. These types are provided
only for documentary purposes. They are not (currently) part of the public interface
of the __undirected_graph__ class.

[table
[[Type name] [Description]]
[[`G::vertex_store`] [The type of the vertex container.]]
[[`G::proeprty_store`] [The type of the property container.]]
[[`G::incidence_store`] [The type of the incident edge container for each vertex.]]
]

[heading Constructors and Destructor]

 undirected_graph::undirected_graph()
 undirected_graph::undirected_graph(undirected_graph const& g)
 undirected_graph::undirected_graph(undirected_graph&& g)
 ~undirected_graph::undirected_graph()

The usual cadre of constructors and descructors that make graphs __Regular__. The
undirected graph class supports default, copy, and move construction.

[table
[[Parameters] [Description]]
[[`undirected_graph const& g`] [The graph being copied.]]
[[`undirected_graph&& g`] [The graph being moved.]]
]

[variablelist
[[Complexity]
 [Default and move construction is O(1). Copy assignment is O(V + E) for all
  kinds of graphs.]]
 [[Notes]
  [After moving, the graph `g` will be empty, having been cleared during the
   `move` operation.]]
]

[heading Operators]

 undirected_graph& undirected_graph::operator=(undirected_graph const& g)
 undirected_graph& undirected_graph::operator=(undirected_graph&& g)

Copy or move assign the vertices and edges of the graph `g` to this graph.

[table
[[Parameters] [Description]]
[[`undirected_graph const& g`] [The graph being copied.]]
[[`undirected_graph&& g`] [The graph being moved.]]
[[`return`] [The object being assigned (i.e., `*this`).]]
]

[variablelist
[[Complexity]
 [Move assignment is O(1). Copy assignment is O(V + E) for all kinds of graphs.]]
]

 vertex_label&          undirected_graph::operator[](vertex_descriptor v)
 vertex_label const&    undirected_graph::operator[](vertex_descriptor v) const

Return the label associated with the given vertex. This operation is only available
for graphs with labeled vertices.

[table
[[Parameters] [Description]]
[[`vertex_descriptor v`] [The vertex whose label is being accessed.]]
[[`return`] [The label associated with the vertex described by `v`.]]
]

[variablelist
[[Constraints] [Only available for `__LabeledVertexGraph__<G>` or `__MappedVertexGraph__<G>`.]]
[[Complexity] [Property access is O(1).]]
]

 edge_label&        undirected_graph::operator[](edge_descriptor e)
 edge_label const&  undirected_graph::operator[](edge_descriptor e) const

Return the label associated with the given edge. This operation is only available
for graphs with labeled edges.

[table
[[Parameters] [Description]]
[[`edge_descriptor e`] [The edge whose label is being accessed.]]
[[`return`]  [The label associated with the edge described by `e`.]]
]

[variablelist
[[Constraints] [Only available for `__LabeledEdgeGraph__<G>`.]]
[[Complexity] [Property access is O(1).]]
]

[heading Adding Vertices]

 vertex_descriptor add_vertex()

Add an unlabeled vertex to the graph, returning the descriptor.

[variablelist
[[Constraints]
 [This operation is defined only if this graph models `__UnlabeledEdgeGraph__<G>`.]]
[[Complexity] [Unlabeled vertex addition is O(1).]]
]

 vertex_descriptor add_vertex(vertex_label const& l)

Add a vertex with the label `l` to the graph, returning the descriptor.

[variablelist
[[Constraints]
 [This operation is defined only if this graph models`__LabeledEdgeGraph__<G>`.]]
[[Specializations]
 [If `__UniqueAssociativeContainer__<G::vertex_store>` and the graph already contains
  a vertex associated with the label `l`, a new vertex is not added and the returned
  descriptor references the existing vertex.]]
[[Complexity]
 [For `__Sequence__<G::vertex_store>` and `__HashedAssociativeContainer__<G::vertex_store>`,
  vertex addition is O(1). For `__SortedAssociativeContainer__<G::vertex_store>`, this
  operation is O(lg V).]]
]

 vertex_descriptor add_vertex(vertex_key const& k, vertex_label const& l)

Add a vertex to the map with the label `l` and associate it with the key `k`, returning
the descriptor.

[variablelist
[[Constraints] [Only available for `__LabeledEdgeGraph__<G>`.]]
[[Specializations]
 [If `__UniqueAssociativeContainer__<G::vertex_store>` and the graph already contains
  a vertex associated with the key `k`, a new vertex is not added and the  returned
  descriptor references the existing vertex.]]
[[Complexity]
 [For `__Sequence__<G::vertex_store>` and `__HashedAssociativeContainer__<G::vertex_store>`,
  vertex addition is /O(1)/. For `__SortedAssociativeContainer__<G::vertex_store>`, this
  operation is /O(lg V)/.]]
]

[heading Accessing Vertices]

 vertex_descriptor vertex(vertex_label const& l) const

Return a descriptor for a vertex with the label `l`. If no such vertex exists, return
a null descriptor.

[variablelist
[[Constraints] [Only available for `__LabeledVertexGraph__<G>`.]]
[[Specializations]
 [If `__HasMultiEdges__<G>`, this will return a descriptor to the first vertex found
  with the label `l`.]]
[[Complexity for `__HashedAssociativeContainer__<G::vertex_store>`] [O(1)]]
]

 vertex_descriptor vertex(vertex_key const& k) const

Return a descriptor for a vertex associated with the key `k`. If no such vertex exists,
return a null descriptor.

[variablelist
[[Constraints] [Only available for `__MappedVertexGraph__<G>`.]]
[[Specializations]
 [If `__HasMultiEdges__<G>`, this will return a descriptor to the first vertex found
  with the key `k`.]]
[[Complexity]
 [For `__HashedAssociativeContainer__<G::vertex_store>`, this operations is O(1).
  For `__SortedAssociativeContainer__<G::vertex_store>`, this operation is O(lg V).
  For `__Sequence__<G::vertex_store>`, this operation is O(V)]]
]

[heading Removing Vertices]

 void remove_vertex(vertex_descriptor v)
 void remove_vertex(vertex_label const& l)
 void remove_vertex(vertex_key const& k)

Remove the given vertex or the vertex uniquely identified by the given label or
key. All edges incident to the vertex are removed prior to the removal of the
vertex.  The label and key overloads are equivalent to `remove_vertex(vertex(x))`
where `x` is either the label or the key.

/Restrictions:/ This operation not supported by vertex stores with unstable remove
operations (i.e., `vertex_vector`).

/Complexity:/

[heading Adding Edges]

 void add_edge(vertex_descriptor u, vertex_descriptor v)
 void add_edge(vertex_label const& p, vertex_label const& q)
 void add_edge(vertex_key const& x, vertex_key const& y)

 

[heading Accessing Edges]

 edge_descriptor edge(vertex_descriptor u, vertex_descriptor v)
 edge_descriptor edge(vertex_label const& p, vertex_label const& q)
 edge_descriptor edge(vertex_key const& x, vertex_key const& y)

Return a descriptor for the edge connecting the two vertices u and v. If no such
edge exists, the returned descriptor is `null`.

[heading Removing Edges]

 void remove_edge(edge_descriptor e);

Remove only the edge represented by the descriptor `e`.

 void remove_edges(vertex_descriptor u, vertex_descriptor v)
 void remove_edges(vertex_label const& p, vertex_label const& q)
 void remove_edges(vertex_key const& x, vertex_key const& y)

Remove all edges connective vertices u and v.

 void remove_edges(vertex_descriptor v)
 void remove_edges(vertex_label const& l)
 void remove_edges(vertex_key const& k)

Remove all edges incident to the vertex v.

[heading Size and Degree]

 vertices_size_type num_vertices() const

 edges_size_type num_edges() const

 incident_edges_size_type degree(vertex_descriptor v) const
 incident_edges_size_type degree(vertex_label const& l) const
 incident_edges_size_type degree(vertex_key const& k) const

Return the degree of (number of incident edges to) the vertex v.

[heading Iteration]

 vertex_iterator begin_vertices() const
 vertex_iterator end_vertices() const
 vertex_range vertices() const

Return iterators or an iterator range over the vertices of the graph.

 edge_iterator begin_edges() const
 edge_iterator end_edges() const
 edge_range edges() const

Return iterators or an iterator range over the edges of the graph.

 incident_edge_iterator begin_incident_edges(vertex_descriptor v) const
 incident_edge_iterator end_incident_edges(vertex_descriptor v) const
 incident_edge_range incident_edges(vertex_descriptor v) const

[heading Miscellaneous]

 undirected_graph& swap(undirected_graph&& g)

Swap this graph with `g` in constant time. Return a reference to this graph.

 undirected_graph& clear()

Remove all edges and verties from the graph in O(V + E

[endsect]
