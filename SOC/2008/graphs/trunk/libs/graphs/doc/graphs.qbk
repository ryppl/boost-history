[library Boost.Graph
    [quickbook 1.3]
    [authors [Sutton, Andrew]]
    [copyright 2008 Andrew Sutton]
    [category graph]
    [id graph]
    [dirname graph]
    [purpose
        Graph data structures and algorithms.
    ]
    [license
            Distributed under the Boost Software License, Version 1.0.
            (See accompanying file LICENSE_1_0.txt or copy at
            [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[include macros.qbk]

[/ Standard concepts /]
[def __ObjectType__ [^ObjectType]]
[def __DefaultConstructible__ [^DefaultConstructible]]
[def __CopyConstructible__ [^CopyConstructible]]
[def __MoveConstructible__ [^MoveConstructible]]
[def __LessThanComparable__ [^LessThanComparable]]
[def __Semiregular__ [^Semiregular]]
[def __Regular__ [^Regular]]
[def __EquivalenceRelation__ [^EquivalenceRelation]]
[def __StrictWeakOrder__ [^StrictWeakOrder]]
[def __SignedIntegralLike__ [^SignedIntegralLike]]
[def __UnsignedIntegralLike__ [^UnsignedIntegralLike]]
[def __HashFunction__ [^HashFunction]]
[def __Hashable__ [^Hashable]]
[def __Allocator__ [^Allocator]]

[/ Containers /]
[def __Container__ [^Container]]
[def __Sequence__ [^Sequence]]
[def __FrontInsertionSequence__ [^FrontInsertionSequence]]
[def __BackInsertionSequence__ [^BackInsertionSequence]]
[def __AssociativeContainer__ [^AssociativeContainer]]
[def __SimpleAssociativeContainer__ [^SimpleAssociativeContainer]]
[def __PairAssociativeContainer__ [^PairAssociativeContainer]]
[def __SortedAssociativeContainer__ [^SortedAssociativeContainer]]
[def __HashedAssociativeContainer__ [^HashedAssociativeContainer]]
[def __UniqueAssociativeContainer__ [^UniqueAssociativeContainer]]
[def __MultipleAssociativeContainer__ [^MultipleAssociativeContainer]]

[/ Iterators and Ranges /]
[def __ForwardIterator__ [^ForwardIterator]]
[def __BidirectionalIterator__ [^BidirectionalIterator]]
[def __RandomAccessIterator__ [^RandomAccessIterator]]
[def __ForwardRange__ [^ForwardRange]]
[def __BidirectionalRange__ [^BidirectionalRange]]
[def __RandomAccessRange__ [^RandomAccessRange]]

[/ Tons and tons of graph concepts /]
[def __Descriptor__ [link boost_graph.graph_concepts.descriptor [^Descriptor]]]
[def __Graph__ [^Graph]]
[def __UnlabeledVertexGraph__ [^UnlabeledVertexGraph]]
[def __LabeledVertexGraph__ [^LabeledVertexGraph]]
[def __MappedVertexGraph__ [^MappedVertexGraph]]
[def __UniqueLabeledVertexGraph__ [^UniqueLabeledVertexGraph]]
[def __UniqueMappedVertexGraph__ [^UniqueMappedVertexGraph]]
[def __HasSortedLabels__ [^HasSortedLabels]]
[def __HasSortedKeys__ [^HasSortedKeys]]
[def __HasHashedLabels__ [^HasHashedLabels]]
[def __HasHashedKeys__ [^HasHashedKeys]]
[def __UnlabeledEdgeGraph__ [^UnlabeledEdgeGraph]]
[def __LabeledEdgeGraph__ [^LabeledEdgeGraph]]
[def __HasUniqueEdges__ [^HasUniqueEdges]]
[def __HasMultiEdges__ [^HasMultiEdges]]
[def __HasLoopEdges__ [^HasLoopEdges]]
[def __HasUndirectedEdges__ [^HasUndirectedEdges]]
[def __HasDirectedEdges__ [^HasDirectedEdges]]
[def __HasFindEdge__ [^HasFindEdge]]
[def __HasAddEdge__ [^HasAddEdge]]
[def __HasAddUnlabeledEdge__ [^HasAddUnlabeledEdge]]
[def __HasAddLabeledEdge__ [^HasAddLabeledEdge]]
[def __HasAddUniqueUnlabeledEdge__ [^HasAddUniqueUnlabeledEdge]]
[def __HasAddUniqueLabeledEdge__ [^HasAddUniqueLabeledEdge]]
[def __HasRemoveEdge__ [^HasRemoveEdge]]
[def __HasAddVertex__ [^HasAddVertex]]
[def __HasAddUnlabeledVertex__ [^HasUnlabeledVertex]]
[def __HasAddLabeledVertex__ [^HasAddLabeledVertex]]
[def __HasAddMappedVertex__ [^HasAddMappedVertex]]
[def __HasAddUniqueLabeledVertex__ [^HasAddUniqueLabeledVertex]]
[def __HasAddUniqueMappedVertex__ [^HasAddUniqueMappedVertex]]
[def __HasRemoveVertex__ [^HasRemoveVertex]]
[def __VertexListGraph__ [^VertexListGraph]]
[def __EdgeListGraph__ [^EdgeListGraph]]
[def __ConstructibleVertexGraph__ [^ConstructibleVertexGraph]]
[def __ConstructibleEdgeGraph__ [^ConstructibleEdgeGraph]]
[def __ConstructibleGraph__ [^ConstructibleGraph]]
[def __MutableVertexGraph__ [^MutableVertexGraph]]
[def __MutableEdgeGraph__ [^MutableEdgeGraph]]
[def __MutableGraph__ [^MutableGraph]]
[def __UndirectedGraph__ [^UndirectedGraph]]
[def __OutDirectedGraph__ [^OutDirectedGraph]]
[def __InDirectedGraph__ [^InDirectedGraph]]
[def __DirectedGraph__ [^DirectedGraph]]
[def __IncidenceGraph__ [^IncidenceGraph]]
[def __AdjacencyGraph__ [^AdjacencyGraph]]
[def __Multigraph__ [^Multigraph]]
[def __AdjacencyMatrix__ [^AdjancencyMatrix]]
[def __IncidenceMatrix__ [^IncidenceMatrix]]

[section Introduction]
The goal of this Google Summer of Code project was to attempt a redesign of the
interfaces of the Boost Graph Library to improve usability and to modernize some
of the implementation with respect to a) newer libraries, b) newer C++ programming
conventions and idioms, and c) new C++0x features (whatever was available in GCC
during development).

The design of the graph library is based on four major components: descriptors,
property maps, data structures and algoriths. Briefly, descriptors are representatives
of vertices and edges in graph implementations. Property maps abstract the reading
and writing of properties of vertices and edges. Generic graph data structures define
families of related implementations of the structure and storage of vertices and edges.
Generic graph algorithms implement common operations on different kinds of graphs.

As this is not currently intended to be a formal programming guide, but more of
a "Getting to Know What's Here" document, discussion on the design and approaches
to the library are woven throughout.

See the "Programmer's Guide" for a brief tour of the library.
[endsect]

[include guide.qbk]

[include concepts.qbk]

[section Graph Types]
Unlike the previous version of the BGL, this library's take on graph types is that
more is better. Rather than parameterize all structural aspects of a graph data
structure's implementation, we created new graph types specific to the data structure.
This allows us to provide a rich set of graph implementations whose parameters reflect
those implementation options. Moreover, this allows developers to create custom graph
implementations that optimize certain operations or have built-in properties that
enable other operations.

Graph data structures are organized by their implementation structure (list or matrix)
and then by the features they offer. There are three kinds of graph types considered
in this library:

* ['Undirected] - An edge connects two vertices, there is no source or target vertex.
* ['Directed] - An edge is directed from a source vertex to a target vertex.
    * ['Unidirectional] - The graph only contains outward directed edges.
    * ['Bidirectional] - The graph contains both inward and outward directed edges.

[note At this time, the library provides only undirected and bidirectional adjacency
lists, and the directed graph implementation is bidirectional only.]

The generic graph implementations rely heavily on an abstraction known as /descriptors/.
A descriptor is an opaque reference or representative of an object that is contained
by another (such as a vertex or an edge). Descriptors can be thought of as a weak
form of /iterator/ or (better yet) a /flyweight/ object. They differ in two respects:

* A descriptor is not an iterator because a) it cannot be dereferenced to access
the referenced object and b) it has no traversal semantics (increment, decrement).
* A descriptor is not a flyweight because it does not act as a standin for the
object it describes.
* Unlike iterators and flyweights, a descriptors type is not dependant upon the
value type of its container. A descriptor into a vector of integers is the same type
as a descriptor into a vector of strings.
* A descriptors can only be used by the object that contains the object being represented,
and can be converted to and from iterators in constant time.
* A descriptor is like pointers in that they are Regular, LessThanComparable, and
Hashable, meaning that it can be used as a key for all standard associative
containers.

The interfaces of all graph types return and operate on vertex and edge descriptors.

[include adj_list.qbk]
[include adj_matrix.qbk]
[endsect]

[section Algorithms]
The approach to algorithm design varies slightly from that of the BGL also. Rather
than simply providing a single, heavily parameterized algorithm, this library treats
encapsulates each algorithm in a "module", consisting of a core set of algorithms and
an outer interface where appropriate. The inner core of each algorithm is typically
heavily parameterized, but does not provide any default vaues for those parameters.
The interface provides simpler means of accessing the core algorithm by providing
defaults, overloads, and alternative functions. This design is typified by the search
core, which implements breadth- and depth-first seaarches.

As before, the graph algorithms are designed to use the visitor pattern to allow
users to build custom actions into a predefined algorithm. This approach is extended,
where appropriate, to include strategy parameters. A strategy parameter provides
a means of modifying the behavior of an algorithm at specific points in the algorithm,
called control points. Strategies typically return some boolean value to decide
whether or not an action should be taken.

[section Search Algorithms]
[include algo/search.qbk]
[endsect]

[section Shortest Path Algorithms]
Not implemented.
[endsect]

[section Minimum Spanning Tree Algorithms]
[endsect]
Not implemented.
[endsect]

[section Details]
[include descriptors.qbk]
[endsect]

[section Post-Mortem]
What's good and bad about this implementation, and what's left to be done.
[endsect]