[/ Boost.SpatialIndex - Tutorials ]
[/ Copyright 2008 Federico J. Fernandez ]
[/ Distributed under the Boost Software License, Version 1.0. (See]
[/ accompanying file LICENSE_1_0.txt or copy at ]
[/ http://www.boost.org/LICENSE_1_0.txt) ]
[/ See http://www.boost.org/ for latest version. ]

[section:tutorials Tutorials]

[section:tutorial1 Tutorial - Basic usage]

This tutorial describes the basic usage of the Spatial Indexes. We won't use an specific index to
show the basic usage of  the library. Next tutorials will address specifc index types.

In this tutorial an empty item is created (a quadtree in this example) and some points are added.
Then we perform two searches and finally some points are removed.

We will follow the first test of our test suite, test/simple_test.cpp

The first step is to create the index. We have to choose which index we'll use. In this case
we will select the quadtree.

Now that we have chosen our index type, we have to carefully look the constructor. Altough a
generic interface is defined (in spatial_index.hpp), each index type has its own creation parameters. 

Let's see the quadtree's constructor:

``
/// quadtree constructor
spatial_index(const geometry::box<Point> &b,
              const unsigned int M)
	         : i_(b, M)

``

As we can see we need to define the bounding rectangle of the indexed space and the maximum number of
elements for each node. A general useful number for this maxium could be 8, but you could see a 
detailed comparison with different values in the Performance comparison section.

We define a Boost Geometry proposal box (0,0) x (20,20) for the test:

``
geometry::box<geometry::point_xy<double> > b(
    geometry::point_xy<double>(0.0, 0.0),
    geometry::point_xy<double>(20.0, 20.0));
``

Now we can define our index, using b as our bounding box and 8 elements of data
per node. The first template parameter of the spatial index interface is
the type of point. In this case we use the default point of the geometry proposal
(point_xy<double>) and as the value_type an iterator to an vector of strings. This
is to show that you can have your own container with the data and only store in
the index the corresponding pointer, avoiding unnecessary dependency.

``
typedef geometry::point_xy<double> point_type;
typedef std::vector<std::string>::iterator value_type;

boost::spatial_index::spatial_index<point_type, value_type,
      boost::spatial_index::quadtree<point_type, value_type> > q(b, 8);
``

Let's populate it with some points (and some data that we have preloaded in the 
vector called data, string "test0" to "test5"):

``
std::vector<std::string>::iterator it = data.begin();

q.insert(geometry::point_xy<double>(1.0,1.0), it++);
q.insert(geometry::point_xy<double>(2.0,1.0), it++);
q.insert(geometry::point_xy<double>(5.0,5.0), it++);
q.insert(geometry::point_xy<double>(1.0,6.0), it++);
q.insert(geometry::point_xy<double>(9.0,9.0), it++);
q.insert(geometry::point_xy<double>(9.0,8.0), it++);
``

And because all of this is about searching spatial data, let's try some searches:

``
it1 = q.find(geometry::point_xy<double>(9.0,9.0));
``

Of course the string "test4" is returned.

We can also do some "rectangle" queries, to return every point that it's inside the
box:

``
geometry::box<geometry::point_xy<double> > query_box(
    geometry::point_xy<double>(0.0, 0.0),
    geometry::point_xy<double>(5.0, 5.0));
std::deque< std::vector<std::string>::iterator > d = q.find(query_box);
``

We get the strings "test0", "test1" and "test2".

Finally, we can remove some points:

``
q.remove(geometry::point_xy<double>(9.0,9.0));
``

[section:tutorial2 Tutorial - rtree particularities]

In this tutorial we want to show how could change the previous tutorial with
the use of an rtree. As it's a different structure the creation parameters are
not the same, and we also have some other features in the insertion and
deletion algorithms.

First, let's see the constructor of the rtree:

``
spatial_index(const unsigned int m, const unsigned int M):i_(m, M)
``

In this case we have also two parameters, but none of them is a box because a 
bounding box is not needed for this structure. We have two integers that are
low and high bounds for the number of elements in a node.

The great difference of the structure is that the rtree allows insertion of
not only points, but rectangles. This adds a lot of flexibility because
any shape could have a minimum bounding rectangle (MB) that could 
be inserted into the index to represent the actual geometrical object.

Then the insertion method is overloaded to support geometry proposal's boxes:

``
hvoid insert(const geometry::box<Point> &e, const Value & v);
``

A complete example showing the basic usage of the rtree could be found in
test/simple_test_rtree.cpp.


[section:tutorial3 Tutorial - Using your own point structure]

As we have seen in the first tutorial, the data structure is
a template parameter and we don't impose any requeriments over it, so it could be
belong to any type. We have shown an example where an iterator to a STL
container is used.

As the title of this section suggests, it's also possible to use your own 
point structure. We follow the approach used by the geometry library proposal.
They define a point concept that your structure must fulfill to be able to be used
with the library.

The most important methods are the get<N> methods for each coordinate. You could
easly get them inheriting from boost::tuple for example. Besides that an enum called
"coordinate_count" should be declared setting the number of dimensions of the point.

You also have to define a typedef defining the coordinate type. 

Finally, there are some strategy traits that are used for the algorithms of the geometry
library. For the Spatial Index it's ok to leave them as defaults because we don't use them,
but if you want to use your point structure with the geometry library proposal you should
do it.

Let's see an example structure (taken from test/custom_point_test.cpp):

``
struct my_2d_point: boost::tuple < float, float >
{
  typedef float coordinate_type;
  enum { coordinate_count = 2 };

  my_2d_point(void)
  {
    get<0>() = 0.0;
    get<1>() = 0.0;
  }

  my_2d_point(float x, float y)
  {
    get<0>() = x;
    get<1>() = y;
  }

  bool operator<(const my_2d_point & o) const
  {
    return get<0> () <o. get <0> ();
  }

  // Because the geometry::point concept shares the "get" methods with 
  // boost::tuple, no more methods are needed.
};


// point traits as in the geometry library proposal
namespace geometry
{
  template <> 
  struct strategy_traits < my_2d_point, my_2d_point >
  {
    typedef strategy::distance::pythagoras < my_2d_point, my_2d_point > 
      point_distance;
    typedef strategy::not_implemented point_segment_distance;
    typedef strategy::not_implemented area;
    typedef strategy::not_implemented within;
    typedef strategy::not_implemented centroid;
    typedef strategy::not_implemented envelope;
  };

  template <> struct wkt_traits < my_2d_point >
  {
    typedef impl::wkt::stream_point < my_2d_point > stream_type;
  };
}                               // namespace geometry
``


[endsect]
