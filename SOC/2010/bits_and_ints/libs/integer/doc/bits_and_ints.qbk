[section:bits_and_ints Bits and Ints]

[section Overview]
The intent of this library is to extend Boost.Integer with fast integer algorithms and utilities. 
The motivation for this library is to provide integer algorithms and utilities optimized by doing binary manipulations so that it uses less CPU cycles, memory access and conditional branches. This library contains some classical integer algorithms such as population count, reversing bits, sign extension and bit interleaving.
This library can be included via	[@../../../../boost/integer/bits_and_ints.hpp <boost/integer/bits_and_ints.hpp>].
[endsect]

[section Absolute Value in Compile-Time ]
The static metafunctions defined on [@../../../../boost/integer/static_abs.hpp <boost/integer/static_abs.hpp>] 
calculates the absolute value of integral constants.

`mpl::abs<>` version returns the absolute value of a `mpl::integral_c<>`
and the `static_abs<>` version returns the absolute value from an integral value.

[section Synopsis]

	template <typename IC>
	struct mpl::abs : mpl::integral_c<``['implementation-defined]``,``['implementation-defined]``> {}; 
	
	template <typename T, T Value>
	struct static_abs : mpl::abs< mpl::integral_c<T, Value> > {}; 
	
[endsect]

*[*Requires: ] `T` must be an integral type. `IC` a `mpl::integral_c<>` type.

*[*Results: ] The member `value ` in `mpl::abs<>` will be the absolute value of `IC::value`.
In `static_abs<>`, `value` will be the absolute value of `Value`.

[endsect]

[section:bit_utils Binary Utilities]
The header [@../../../../boost/integer/bit_utils.hpp <boost/integer/bit_utils.hpp>] cotains some metafunctions to handle binary data.
All the metafunctions have an member varible named `value` where will be the result.

[section Synopsis]

	namespace boost
	{
	
	namespace mpl {

	template <typename IC, unsigned char pos>
	struct set_bit : integral_c<typename IC::value_type, ``['implementation-defined]``> {};

	template <typename IC, unsigned char pos>
	struct clear_bit : integral_c<typename IC::value_type, ``['implementation-defined]``> {};

	template <typename IC, unsigned char pos>
	struct flip_bit : integral_c<typename IC::value_type, ``['implementation-defined]``> {};

	template <typename IC, unsigned char pos>
	struct test_bit : bool_<``['implementation-defined]``> {};
	
	} // mpl
	
	// Compile-time version
		
	// Sets the bit `pos' in data
	template <typename T, T data, unsigned char pos>
	struct static_set_bit : mpl::set_bit<mpl::integral_c<T, data>, pos> {};
		
	// Clear the bit `pos' in data
	template <typename T, T data, unsigned char pos>
	struct static_clear_bit : mpl::clear_bit<mpl::integral_c<T, data>, pos> {};

	// If the bit `pos' is 1 then it will be 0 if not the bit will be 1
	template <typename T, T data, unsigned char pos>
	struct static_flip_bit : mpl::flip_bit<mpl::integral_c<T, data>, pos> {};

	// Test if the bit in `pos' positon is set or not
	template <typename T, T data, unsigned char pos>
	struct static_test_bit : mpl::test_bit<mpl::integral_c<T, data>, pos> {};

	// Runtime version
	template <typename T>
	inline T set_bit(T data, unsigned char pos);

	template <typename T>
	inline T clear_bit(T data, unsigned char pos);

	template <typename T>
	inline T flip_bit(T data, unsigned char pos);
		
	template <typename T>
	inline bool test_bit(T data, unsigned char pos);
		
	} // boost

[endsect]

[section Template Class `static_set_bit<>` and `mpl::set_bit`]
Sets the bit `pos` active in `value`.

*[*Requires: ] `pos` must be smaller than the size (in bits) of `Type` for `static_set_bit<>` and smaller than IC::value_type
	for `mpl::static_set_bit<>`.
	
*[*Remarks: ] 
	* `T` must be an integral type.
	
	* `IC` must be a `mpl::integral_c<>` type.

*[*Example:]

	BOOST_STATIC_ASSERT((set_bit<int, 100, 0>::value == 101));

[endsect]
	
[section Template Class `mpl::clear_bit<>` and `static_clear_bit<>`]
Sets the bit `pos` inactive in `data`.


*[*Requires: ] `pos` must be smaller than the size (in bits) of `Type` for `static_clear_bit<>` and smaller than IC::value_type
	for `mpl::static_clear_bit<>`.
	
*[*Remarks: ]
	* `T` must be an integral type.
		
	* `IC` must be a `mpl::integral_c<>` type. 
	
*[*Example:]

	BOOST_STATIC_ASSERT((clear_bit<int, 3, 1>::value == 1));

[endsect]

[section Template Class `mpl::test_bit` and `static_test_bit<>`]
Test if the bit `pos` in `data` is active or not.


*[*Requires: ] `pos` must be smaller than the size (in bits) of `Type` for `static_test_bit<>` and smaller than IC::value_type
	for `mpl::static_test_bit<>`.
	
*[*Remarks: ] 
	* `T` must be an integral type. 
	
	* `IC` must be a `mpl::integral_c<>` type.
	
*[*Example:]

	BOOST_STATIC_ASSERT((test_bit<int, 3982, 11>::value == true));

[endsect]

[section Template Class `mpl::flip_bit<>` and `static_flip_bit<>`]
Invert the value of the bit `pos` in `data`

*[*Requires: ] `pos` must be smaller than the size (in bits) of `Type` for `static_flip_bit<>` and smaller than IC::value_type
	for `mpl::static_flip_bit<>`.
	
*[*Remarks: ]
	* `T` must be an integral type.
	
	* `IC` must be a `mpl::integral_c<>` type. 

*[*Example:]

	BOOST_STATIC_ASSERT((flip_bit<int, 10, 2>::value == 14	));

[endsect]

[section Runtime version]

For all runtime functions, all remarks and requirement are equals to the `static_`-prefixed version.

[endsect]
[endsect]

[section Bit Iterleaving]
Interleaved bits (aka Morton numbers) [@http://en.wikipedia.org/wiki/Morton_number_(number_theory)] are useful for linearizing 2D integer coordinates, 
so x and y are combined into a single number that can be compared easily and has the property 
that a number is usually close to another if their x and y values are close.
These functions are defined in the header [@../../../../boost/integer/interleave.hpp <boost/integer/interleave.hpp>].

[section Synopsis]
``
T2 interleave(T1 x, T1 y);

std::pair<T1, T1> uninterleave(T2 number);
``
[endsect]


*[*Requires: ] `T1` and `T2` must be integral types. Additionally, `T1` must have 8, 16 or 32 bits and `T2` must have
16, 32 or 64 bits. For these functions `T2` have the double of bits wich `T1` have.

[*Returns: ] `interleave` function returns `x` and `y` interleaved. `x` will be in the even bits and `y` will be on odd positions, so the return type have the double of bits than the paramter's type. 

`uninterleave` returns an `std::pair<>` where in the member `first` will be the integral represented in the even positions of `number` and in the `second`
member will be the integral represented in the odd positions of `number`.

[section Examples]

``
#include <boost/integer/interleave.hpp>
#include <utility>
#include <iostream>

using namespace std;
using namespace boost;

int main()
{
	uint_t<64>::exact inter = interleave<32>(0x10, 0x0e);
	
	cout << "interleaved number: ";
	cout << hex << inter << endl;

	pair<uint8_t, uint8_t> uninter = uninterleave<16>(inter);
	
	uint8_t a = uninter.first, b = uninter.second;

	cout << "uninterleaved number: ";
	cout << hex << unsigned(a) << " " << unsigned(b) << endl; 
}
``

[endsect]
[endsect]

[section:bit_reversal Bit Reversal]
The bit reversal functions reverts the bits of integral types.

[section Non-Member Function `bit_reversal`]
The run-time version can be included via [@../../../../boost/integer/bit_reversal.hpp <boost/integer/bit_reversal.hpp>].

	template <typename T>
	inline T bit_reversal(T data);
   
*[*Parameters:]

[table
	[[Parameter][Description]]
	[[`data`][ The data to be reversed. The type of data *must* be an integral type and it's size *must* be 8, 16, 32 or 64-bits, otherwise, bit_reversal(data) will result in an error. ]]
]
	
*[*Requires: ] `T` must be an integral type.

*[*Returns: ] `data` with its bits reversed.

[endsect]

[section Template Class `mpl::bit_reversal<>`]
The MPL version can be included via [@../../../../boost/integer/static_bit_reversal.hpp <boost/integer/static_bit_reversal.hpp>].
The result will be in `value` member.
	
	template <typename IC>
	struct mpl::bit_reversal : mpl::integral_c<typename IC::value_type, ``['implementation-defined]``> {};

*[*Template Parameters]

[table
	[[Parameter][Description]]
	[[`IC`][ A `mpl::integral_c<>` type wich holds an integral constant to be reversed. ]]
]

*[*Requires: ] `IC` must be an `mpl::integral_c<>` type.

[endsect]

[section Template Class `static_bit_reversal<>`]
The compile-time version can be included via [@../../../../boost/integer/static_bit_reversal.hpp <boost/integer/static_bit_reversal.hpp>].
The result will be in `value` member.
	
	template <typename T, T Value>
	struct static_bit_reversal : mpl::bit_reversal< mpl::integral_c<T, Value> > {};

*[*Template Parameters]

[table
	[[Parameter][Description]]
	[[`T`][ The data type. ]]
	[[`Value`][ The data to be reversed. ]]
]

*[*Requires: ] `T` must be an integral type.

[endsect]

[section Examples]
*[*Run-time version]
``
#include <boost/integer/bit_reversal.hpp>
#include <iostream>

int main()
{
	BOOST_ASSERT((boost::bit_reversal(0x55) == 0xAA));
}
``
	
*[*Compile-time version]
``	
#include <boost/integer/static_bit_reversal.hpp>
#include <iostream>

int main()
{	
	BOOST_STATIC_ASSERT((boost::static_bit_reversal<uint16_t, 0x30A5>::value == 0xA50C));
}
``
	
[endsect]
[endsect]

[section Clear Least Bit Set]
Clears least significant 1 bit in an integral. The `clear_least_bit_set()` function is defined on [@../../../../boost/integer/clear_least_bit_set.hpp <boost/integer/clear_least_bit_set.hpp>].

[section Synopsis]

	template <typename T>
	T clear_least_bit_set(T value);
	
	template <typename IC>
	struct mpl::clear_least_bit_set mpl::integral_c<typename IC::value_type, ``['implementation-defined]``> {};
	
	template <typename T, T Value>
	struct static_clear_least_bit_set : mpl::clear_least_bit_set< mpl::integral_c<T, Value> > {};

[endsect]

*[*Requires: ] `T` must be an integral type. `IC` must be an `mpl::integral_c<>` type. 

*[*Returns: ] `value` with it's least significant active bit disactivated.

[endsect]

[section Count Leading Zeros]
The `count_trailing_zeros` function counts the number of consecutive 0's from the most significant bit of an integral value.
The function is defined on [@../../../../boost/integer/count_leading_zeros.hpp <boost/integer/count_leading_zeros.hpp>].

[section Synopsis]
	
	inline int count_leading_zeros(uintmax_t value);
	
[endsect]

*[*Remarks: ] If `value` is 0, the result is undefined.
*[*Returns: ] For the runtime version, the number of consecutive zeros from the least significant bit.

[endsect]

[section Count Trailing Zeros]
The `count_trailing_zeros` function and metafunctions counts the number of consecutive 0's from the least significant bit of an integral value.
The runtime function is defined on [@../../../../boost/integer/count_trailing_zeros.hpp <boost/integer/count_trailing_zeros.hpp>] and
the compile-time metafunctions are defined on [@../../../../boost/integer/static_count_trailing_zeros.hpp <boost/integer/static_count_trailing_zeros.hpp>]

[section Synopsis]
	
	int count_trailing_zeros(uintmax_t value);
	
	template <typename IC>
	struct mpl::count_trailing_zeros : mpl::integral_c<typename IC::value_type, ``['implementation-defined]``> {};
	
	template <uintmax_t Value> 
	struct static_count_trailing_zeros : mpl::count_trailing_zeros< mpl::integral_c<uintmax_t, Value> > {};
	
[endsect]

*[*Remarks: ] If `value` is 0, the result is undefined.
*[*Requires: ] For the `mpl::count_trailing_zeros<>` version, `IC` must be an mpl::integral_c<> type. 
*[*Returns: ] For the runtime version, the number of consecutive zeros from the least significant bit. 
In the compile-time versions, the number of consecutive zeros in the `value` static member.

[endsect]

[section Find First One String of a Given Length]
The header file [@../../../../boost/integer/find_first_one_string.hpp <boost/integer/find_first_one_string.hpp>] defines
`find_first_one_string` function wich returns the index of start position of a consecutive string of ones with 
at least a given length.

[section Synopsis]
	template <typename T, typename Policy>
	int find_first_one_string(T value, unsigned size, const Policy& pol);
	
	template <typename T>
	int find_first_one_string(T value, unsigned size);
[endsect]

*[*Remarks: ] `size` must be greater than 0 and less than the size in bits of the type `T`. If this constraint is not met,
a `math::policies::domain_error` is raised.
*[*Returns: ] The index of the first string of ones with at least `size` length, if this string is not found,
-1 is returned. The index starts at most significant bit (0). The least significant bit is size of `T` in bits minus one. 

[section Examples]
``
#include <iostream>
#include <boost/assert.hpp>
#include <boost/integer/find_first_one_string.hpp>

int main()
{
	using namespace boost;
	
	//           v    
	// 1111 0000 1111 1111 0000 0000 0000 0000
	BOOST_ASSERT((find_first_one_string(0xF0FF0000u, 6) == 8));
	
	// Not found a string of consecutive ones with legth at least 20
	BOOST_ASSERT((find_first_one_string(0xF0FF0000u, 20) == -1));
	
	//                                      v  
	// 0000 0000 0000 0000 0000 0000 0000 0010
	BOOST_ASSERT((find_first_one_string(0x00000002u, 1) == 30));

	//                                      v  
	// 0000 0000 0000 0000 0000 0000 0000 0011
	BOOST_ASSERT((find_first_one_string(0x00000003u, 1) == 30));

	//                                       v  
	// 0000 0000 0000 0000 0000 0000 0000 0001
	BOOST_ASSERT((find_first_one_string(0x00000001u, 1) == 31));
	
	//                      v
	// 0001 0010 0011 0100 0111 0000 0000 0010
	BOOST_ASSERT((find_first_one_string(0x12347002u, 3) == 17));
}
``
[endsect]

[endsect]

[section Greatest Common Divisor ]
The header file [@../../../../boost/integer/static_gcd.hpp <boost/integer/static_gcd.hpp>] defines `mpl::gcd<>` 
metafunction wich calculates the greatest common divisor of two given `mpl::integral_c<>`.

[section Synopsis]

	template <typename ICT1, typename ICT2>
	struct mpl::gcd : mpl::integral_c<typename ICT1::value_type, ``['implementation-defined]``> {}; 
	
[endsect]

*[*Requires: ] `ICT1` and `ICT2` must be `mpl::integral_c<>` types.

*[*Results: ] The member `value ` will be the greatest commom divisor from `IC1` and `IC2`.

[endsect]

[section Integer Logarithm Base 2 (ilog2 function) ]
The header file [@../../../../boost/integer/ilog2.hpp <boost/integer/ilog2.hpp>] defines `ilog2` 
function wich calculates the logarithm in base two of a given integral value.

[section Synopsis]

	template <typename T>
	inline T ilog2(T value);
	
	template <typename T, typename Policy>
	inline T ilog2(T value, const Policy& pol);
	
[endsect]

*[*Remarks: ] If `value` is 0, an `math::policy::undefined_result_error` is raised, see section Examples for more information.
*[*Requires: ] `T` to be an integral type.
*[*Returns: ] The integer logarithm in base 2 of `value` rounded down or -1 if `value` is equal to 0.
*[*Throws: ] `ilog2` raises an `undeterminate_result_error` if `value` is 0, and by default do not throw anything, but is 
possible to change the behavior using Boost Math's policies. See section Examples.

[section Examples]

[@../../../../libs/integer/example/ilog2_policy_test.cpp `ilog2` policy example]

``
#define BOOST_TEST_MAIN
#include <cerrno>
#include <iostream>
#include <stdexcept>
#include <boost/test/included/unit_test.hpp>
#include <boost/integer/ilog2.hpp>

namespace boost { namespace math { namespace policies {

template <class T>
T user_indeterminate_result_error(const char* function, const char* message, const T& val)
{
	std::cout << "User Error on function: " << function 
		<< " with message: " << message << std::endl;
	
	(void)val;
	
	// Returning a custom value
	return -2;
}

} } }
	
BOOST_AUTO_TEST_CASE( test )
{
	// Checking default behavior
	BOOST_CHECK_EQUAL(boost::ilog2(0u), -1);
	
	using namespace boost::math::policies;
	policy< indeterminate_result_error<throw_on_error> > throw_pol;
	policy< indeterminate_result_error<errno_on_error> > errno_pol;
	policy< indeterminate_result_error<ignore_error> >   ignore_pol;
	policy< indeterminate_result_error<user_error> >     user_pol;
	
	
	// Checking throw_on_error policy
	BOOST_CHECK_THROW(boost::ilog2(0u, throw_pol) , std::domain_error);
	
	// Checking errno_on_error policy
	errno = 0;
	boost::ilog2(0u, errno_pol);
	BOOST_CHECK_EQUAL(errno, EDOM);
	
	// Checking ignore_error policy
	BOOST_CHECK_EQUAL(boost::ilog2(0u, ignore_pol), -1);
	
	// Checking user_error policy
	BOOST_CHECK_EQUAL(boost::ilog2(0u, user_pol), -2);
}
``

[endsect] 

[endsect]

[section `is_integral_constant<>` metafunction ]
The header file [@../../../../boost/integer/is_integral_constant.hpp <boost/integer/is_integral_constant.hpp>] defines 
`is_integral_constant<>` static metafunction wich verifies if an given template parameter is or not a `mpl::integral_c<>`.

[section Synopsis]

	template <typename IC>
	struct is_integral_constant : and_<``['implementation-defined]``> {};
	
[endsect]

*[*Results: ] 
	* If `IC` is a `mpl::integral_c<>` type, `is_integral_constant<IC>` will inherit from `mpl::true_`
	* If `IC` is not a `mpl::integral_c<>` type, `is_integral_constant<IC>` will inherit from `mpl::false_`

[endsect]

[section Least Common Multiple ]
This header defines mpl::lcm<> metafunction wich calculates the 
 least common multiple from two given `mpl::integral_c<>`.
 
This static metafunction is defined on [@../../../../boost/integer/static_lcm.hpp <boost/integer/static_lcm.hpp>].

[section Synopsis]

	template <typename ICT1, typename ICT2>
	struct mpl::lcm : integral_c<typename ICT1::value_type, ``['implementation-defined]``> {}; 
	
[endsect]

*[*Requires: ] `ICT1` and `ICT2` must be `mpl::integral_c<>` types.

*[*Results: ] The member `value ` will be the least common multiple from `IC1` and `IC2`.

[endsect]

[section Population Count (count bits set)]
Population Count (pop count) is the number of active bits in an integral. The `pop_count()` function is defined
under the header [@../../../../boost/integer/pop_count.hpp <boost/integer/pop_count.hpp>].

[section Synopsis]

	int pop_count(uintmax_t value);
	
	template <uintmax_t Value>
	struct static_pop_count { static const int value = ``['implementation-defined]``; };
	
	template <typename IC>
	struct mpl::pop_count : mpl::integral_c<typename IC::value_type, static_pop_count<IC::value>::value> {};

[endsect]

*[*Requires: ] `IC` must be an `mpl::integral_c<>` type.
*[*Returns: ] The number of bits set in `value`. For the compile-time versions, the result will be on member `value`.

[endsect]

[section Rotate Shifts]
The header [@../../../../boost/integer/rotate.hpp <boost/integer/rotate.hpp>] defines Rotating shifts 
or [@http://en.wikipedia.org/wiki/Circular_shift Circular shifts] functions.

[section Synopsis]
	inline T rotate_left(T value, unsigned length);
	inline T rotate_right(T value, unsigned length);
[endsect]

*[*Requires: ] `T` to be an integral type.
*[*Remarks: ] `length` must be less than the size in bits of `T`.
*[*Returns: ] `value` rotated `length` bits to the left or to right.

[section Examples]
[@../../../../libs/integer/example/rotate_example.cpp Rotate functions example]

``
#include <boost/assert.hpp>
#include <boost/integer/rotate.hpp>

int main()
{
	using boost::rotate_left;
	using boost::rotate_right;
	
	BOOST_ASSERT((rotate_left(0xABCDEF12u, 24) == 0x12ABCDEFu));
	BOOST_ASSERT((rotate_left(0x12345678u,  4) == 0x23456781u));
	BOOST_ASSERT((rotate_left(0x0FF00000u,  6) == 0xFC000003u));
	BOOST_ASSERT((rotate_left(0x00000000u, 31) == 0x00000000u));
	BOOST_ASSERT((rotate_left(0xF0F0F0F0u,  4) == 0x0F0F0F0Fu));
	
	BOOST_ASSERT((rotate_right(0xABCDEF12u,  8) == 0x12ABCDEFu));
	BOOST_ASSERT((rotate_right(0x0000000Fu,  1) == 0x80000007u));
	BOOST_ASSERT((rotate_right(0xFF00FF00u,  8) == 0x00FF00FFu));
	BOOST_ASSERT((rotate_right(0xAABBCCDDu, 16) == 0xCCDDAABBu));
	BOOST_ASSERT((rotate_right(0xFFFFFFFFu, 31) == 0xFFFFFFFFu));
}
``
[endsect] 

[endsect]

[section Round to Power of 2 functions]
This function rounds up and down positive integral values to the next power of 2.
The `ceil_pow2` function rounds up and `floor_pow2` function rounds down.
These functions are defined on [@../../../../boost/integer/round_pow2.hpp <boost/integer/round_pow2.hpp>]

[section Synopsis]

	T ceil_pow2(T value);
	T floor_pow2(T value);
	
[endsect]

*[*Requires: ] `T` must be an integral type and `value` must be positive. If `value` is negative, the result is
undefined.

*[*Returns: ] 
	* `ceil_pow2()` returns `value` rounded [*up] to the lesser power of two greater than or equal to `value. 
	
	* `floor_pow2()` returns `value` rounded [*down] to the greater power of two lesser or equal `value`.

[endsect]

[section Safe Average]
Given two integer values x and y, the (floor of the) average normally would be computed by `(x+y)/2` unfortunately, 
this can yield incorrect results due to overflow. Safe average ensures that no overflow will happen even if `(x+y)` 
overflows the range of T. 
The runtime version is defined on [@../../../../boost/integer/safe_avg.hpp <boost/integer/safe_avg.hpp>] and
the compile-time metafunctions are defined on [@../../../../boost/integer/static_safe_avg.hpp <boost/integer/static_safe_avg.hpp>]

[section Synopsis]
	
	template <typename T>
	T safe_avg(T x, T y);
	
	template <typename ICT1, typename ICT2>
	struct mpl::safe_avg : mpl::integral_c<typename ICT1::value_type, ``['implementation-defined]``> {};
	
	template <typename T, T Value1, T Value2>
	struct static_safe_avg : mpl::safe_avg< T, mpl::integral_c<T, Value1>, mpl::integral_c<T, Value1> > {};
	
[endsect]

*[*Requires: ] For the `mpl::safe_avg<>` version, both `ICT1` and `ICT2` must be mpl::integral_c<> types.
For the `static_safe_avg<>` and the runtime version, `T` must be an integral type.

*[*Returns: ] The average of the sum between two integrals rounded down. Overflow is ensured to not happen.

[endsect]

[section:same_sign Same Sign]
These functions check if wheter the sign of two integers are equal.

[section Non-Member Function `same_sign`]
The run-time version can be included via [@../../../../boost/integer/same_sign.hpp <boost/integer/same_sign.hpp>]. 
For valid types T, the function `bit_reversal` will be:

	template <typename T>
	inline bool same_sign(T first, T second);
   
*[*Parameters:]

[table
	[[Parameter][Description]]
	[[`first`, `second`][ The two integral values to be compared. The type of data *must* be an integral type. `first` and `second` must have the same type. ]]
]

*[*Returns: ] `false` if the signs of first and second are different or `true` if the signs are equal

*[*Remarks: ] `T` must be an integral type.

[endsect]

[section Template Class `mpl::same_sign<>`]
The MPL version can be included via [@../../../../boost/integer/static_same_sign.hpp <boost/integer/static_same_sign.hpp>].
The result will be in `value` member.
	
	template <typename IC1, typename IC2>
	struct mpl::same_sign : mpl::bool_<``['implementation-defined]``> {};

*[*Template Parameters:]

[table
	[[Parameter][Description]]
	[[`IC1`, `IC2`][ The two `mpl::integral_c<>` to be compared. ]]
]

*[*Requires: ] `IC1` and `IC2` must be `mpl::integral_c<>` types.

[endsect]

[section Template Class `static_same_sign<>`]
The compile-time version can be included via [@../../../../boost/integer/static_same_sign.hpp <boost/integer/static_same_sign.hpp>].
The result will be in `value` member.
	
	template <typename T, T Value1, T Value2>
	struct static_same_sign : mpl::same_sign< mpl::integral_c<T, Value1>, mpl::integral_c<T, Value2> > {};

*[*Template Parameters:]

[table
	[[Parameter][Description]]
	[[`T`][ The data type. ]]
	[[`Value1`, `Value2`][ The two integral values to be compared. ]]
]

*[*Requires: ] `T` must be an integral type.

[endsect]

[section Examples]
*[*Run-time version:]
``
#include <boost/integer/same_sign.hpp>
#include <iostream>

int main()
{
	int first = -1, second = -2, third = 1;
	
	BOOST_ASSERT((boost::same_sign(first, second) == true));
	BOOST_ASSERT((boost::same_sign(first, third) == false));
	BOOST_ASSERT((boost::same_sign(0, 1) == false));
}
``	
*[*Compile-time version:]

``
#include <boost/integer/same_sign.hpp>
#include <iostream>

int main()
{
	BOOST_STATIC_ASSERT((boost::static_same_sign<int, 2, 10>::value));
	BOOST_STATIC_ASSERT((!boost::static_same_sign<int, 10, -2>::value));
	BOOST_STATIC_ASSERT((!boost::static_same_sign<int, 1, 0>::value));
}
``

[endsect]
[endsect]

[section:sign_extend Sign Extending]

Sign extension is automatic for built-in types, such as chars and ints. But suppose you have a signed two's complement number, x, that is stored 
using only b bits. Moreover, suppose you want to convert x to an int, which has more than b bits. A simple copy will work if x is positive, but if
negative, the sign must be extended. For example, if we have only 4 bits to store a number, then -3 is represented as 1101 in binary. If we have
8 bits, then -3 is 11111101. The most-significant bit of the 4-bit representation is replicated sinistrally to fill in the destination when we
convert to a representation with more bits; this is sign extending. More about sign extending on [@http://en.wikipedia.org/wiki/Sign_extension]

[section Non-Member Function Template `sign_extend`]
The run-time version can be included via [@../../../../boost/integer/sign_extend.hpp <boost/integer/sign_extend.hpp>].

	template <typename T>
	Type sign_extend(T data, std::size_t bits);

*[*Requires: ] `bits` must be smaller than the size, in bits, of `T` and `T` must be an integral type.

*[*Parameters:]

[table
	[[Parameter][Description]]
	[[`data`][ The data to be extended. ]]
	[[`bits`][ The amount of bits in wich data is represented. ]]
]

*[*Returns: ] `data` sign-extended to `sizeof(T)` bytes.

[endsect]

[section Template Class `mpl::sign_extend<>`]
The MPL version can be included via [@../../../../boost/integer/static_sign_extend.hpp <boost/integer/static_sign_extend.hpp>].
The result will be in `value` member.

	template<typename IC, std::size_t Bits>
	struct mpl::sign_extend : mpl::integral_c<typename IC::value_type, ``['implementation-defined]``> {};
	

*[*Requires: ] `IC` must a `mpl::integral_c<>` type. `Bits` must be smaller than the size in bits of `IC::value_type`.

*[*Template Parameters:]

[table
	[[Parameter][Description]]
	[[`IC`][ A `mpl::integral_c<>` type. ]]
	[[`Bits`][ The amount of bits in wich data is represented. ]]
]

[endsect]

[section Template Class `static_sign_extend<>`]
The compile-time version can be included via [@../../../../boost/integer/static_sign_extend.hpp <boost/integer/static_sign_extend.hpp>].
The result will be in `value` member.

	template<typename T, T Value, std::size_t Bits>
	struct static_sign_extend : mpl::sign_extend< mpl::integral_c<T, Value>, Bits> {};
	

*[*Requires: ] `Bits` must be smaller than the size, in bits, of `T` and `T` must be an integral type.

*[*Template Parameters:]

[table
	[[Parameter][Description]]
	[[`T`][ The data type. ]]
	[[`Value`][ The data to be extended. ]]
	[[`Bits`][ The amount of bits in wich data is represented. ]]
]
[endsect]

[section Examples]
*[*Run-time version]
``	
#include <boost/integer/sign_extend.hpp>
#include <iostream>

int main()
{
	// data is represented in 24-bits
	int data = 0xFFFFFF; // -1 in 24-bits

	BOOST_ASSERT((boost::sign_extend(data, 24) == -1));
}
``

*[*Compile-time version]
``	
#include <boost/integer/static_sign_extend.hpp>
#include <iostream>

int main()
{
	// 0xFFFFF is -1 in 20-bits
	BOOST_STATIC_ASSERT((boost::static_sign_extend<int, 0xFFFFF, 20>::value == -1));
}
``
	
[endsect]
[endsect]

[section:sign Sign section]
The `sign` function checks the sign of integrals.

[section Non-Member Function `sign`]
The run-time version can be included via [@../../../../boost/integer/sign.hpp <boost/integer/sign.hpp>]. 

	template <typename T>
	int sign(T data);
   
*[*Parameters:]

[table
	[[Parameter][Description]]
	[[`data`][ The data to be checked. The type of data *must* be an integral otherwise, sign(data) will result in an error. ]]
]

*[*Returns:]

[table
	[[Value][Description]]
	[[`-1`][ `data` is negative. ]]
	[[`0`][ `data` is equal to zero. ]]
	[[`1`][ `data` is positive. ]]
]

*[*Requires: ] `T` must be an integral type.

[endsect]

[section Static Functions `mpl::sign` and `static_sign`]
The compile-time versions can be included via [@../../../../boost/integer/static_sign.hpp <boost/integer/static_sign.hpp>]. 

	template <typename IC>
	struct mpl::sign : mpl::integral_c<int, ``['implementation-defined]``> {};
	
	template <template T, T Value>
	struct static_same_sign : mpl::sign< mpl::integral_c<T, Value> > {};
	
[table
	[[Parameter][Description]]
	[[`IC`][ A `mpl::integral_c<>` type. ]]
	[[`T`][ The value type. Must be an integral type. ]]
	[[`Value`][ The value to be checked. ]]
]

*[*Requires: ] `T` to be an integral type and `IC` to be an `mpl::integral_c<>` type.

[endsect]

[section Examples]
*[*Run-time version:]

``
#include <boost/integer/sign.hpp>
#include <iostream>

int main()
{
	int first = -100, second = 340, third = 0;
	
	BOOST_ASSERT((boost::sign(first) == -1));
	
	BOOST_ASSERT((boost::sign(second) == 1));
	
	BOOST_ASSERT((boost::sign(third) == 0));
}
``
	
[endsect]
[endsect]

[section (Integral) Square Root]
The header file [@../../../../boost/integer/isqrt.hpp <boost/integer/isqrt.hpp>] defines `isqrt` 
functions wich computes the integral part of square root of integral values.

[section Synopsis]
	int isqrt(uint8_t value);
	int isqrt(uint16_t value);
	int isqrt(uint32_t value);
[endsect]

*[*Returns: ] The square root of `value` rounded down.

[endsect]

[section Swap without a temporary (in-place) ]
The header file [@../../../../boost/integer/swap_in_place.hpp <boost/integer/swap_in_place.hpp>] defines `swap_in_place` 
function wich swaps 2 integral values without using a temporary variable.

[section Synopsis]

	template <typename T>
	inline void swap_in_place(T& x, T& y);
	
[endsect]

*[*Requires: ] `T` must be an integral type.

*[*Returns: ] Nothing. `x` will have the value of `y` and `y` will have the `x` value.

[endsect]

[section Transfer of Sign (isign) functions ]
isign or transfer of sign function is defined by:
``
 	isign(x, y) =
 		abs(x), if y is greater than or equal 0,
		-abs(x), if y is less than 0
``

The runtime functions are defined on [@../../../../boost/integer/isign.hpp <boost/integer/isign.hpp>] and the
static metafunctions are defined on [@../../../../boost/integer/static_isign.hpp <boost/integer/static_isign.hpp>]

[section Synopsis]

	template <typename T>
	T isign(T x, T y);
	
	template <typename IC1, typename IC2>
	struct mpl::isign mpl::integral_c<typename IC1::value_type, ``['implementation-defined]``> {};
	
	template <typename T, T Value1, T Value2>
	struct static_isign : mpl::isign< mpl::integral_c<T, Value1>, mpl::integral_c<T, Value2> > {};
	
[endsect]

*[*Requires: ] `T` must be an integral type. Both `IC1` and `IC2` must be `mpl::integral_c<>` types.
*[*Returns: ] 
	* Runtime version: returns `abs(x)` if `y` is greater than or equal 0 and `-abs(x)` if `y` is negative. 
	
	* MPL version: the member `value` will be `abs(IC1::value)` if `IC2` holds an value greater than or 
	equal 0, or `-abs(IC1::value)` if `IC2` holds a negative value.

	* `static_isign<T, Value1, Value2>::value` will be `abs(Value1)` if Value2 is greater than or equal 0, or 
	`-abs(Value1)` if Value2 is negative.

[endsect]

[endsect]