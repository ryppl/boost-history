[/
Copyright (c) 2010 Brian Bartman

Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[c++]
[section:bits_mask bits_mask]
[h3 Description]
The `bits_mask` template provides an extention to the `low_bits_mask` template,
by incorporating an `Offset` with the template. The `offest` is always relative
to the right most bit, or bit 0. For a basic view of how `bits_mask` works
consider the following examples:

``
typedef bits_mask<int, 10, 3> mask;
// mask::value has the following binary value
// 0000 0000  0000 0000  0001 1100  0000 0000
``
For simplicity there is a defualt parameter for `Width` giving it a value
of `1`. This makes writing of normally left or right shift masks simple and 
staticly checkable. For example,

``
// If one would need to create a mask for checking the 11th bit within an
// integer it can be done simple with the following mask
typedef bits_mask<int,11> mask;
// this creates a mask at the 11th bit within an integer.
``

[h3 Header File Information]
``
#include <boost/integer/bits_mask.hpp>
``

[h3 Template Signature]
`bits_mask` has the following template signature:
``
namespace boost {
template <typename T, unsigned int Offset, unsigned int Width = 1u > struct bits_mask;
}
``

[h3 Bit Mask Hierarchy]
`bits_mask` inherits from `integral_mask`.


[h3 Template Parameters]
[table
    [[Parameter][Description]]
    [[`T`][ Is an integral type which the mask is to be created over. ]]
    [[`Offset`][ This is the number of bits from the least significant bit to the first bit being used to compose the mask.
Another way to think of this is the amount that the mask has been shifted to the left (using the left shift operator). ]]
    [[`Width`][ This is the width of the mask in bits. `Width` has a default
value of `1u` so that `bits_mask` can be easily used to create boolean flags 
by providing only an `Offset` to the bit.]]
]

[h3 Preconditions]
[table
    [
        [Precondition]
        [Description]
        [Enforcement]
    ]
    [
        [ ]
        [ `T` must be an integral type. ]
        [ This is only a documented precondition. It is not enforced. ]
    ]
    [
        [ `(Offset + Width) <= ( bit_width<T>::value )`]
        [ The `Width + Offset` must be less then or equal to the number of bits
within the integral type `T`  ]
        [ Enforced by static assert. ]
    ]
    [
        [ Valid range for mask width is > 0.]
        [ The `Width` of a mask must not be zero. Because `Width` is of
`std::size_t` it can not be negative.]
        [ Enforced by domain of template parameter and by static assert. ]
    ]
]


[h3 Interface]
`bits_mask` Compile time interface. Assume that `N` is of type
`bits_mask<unsigned int,4,1>` the type supplied here is only for example.

[table
    [[Operation][Description]]
    [[`N::value`][Returns the `value` associated with `N`. ]]
    [[`N::value_type`][Returns `T` which is the type associated with `value` inside `N`. ]]
    [[`N::type`][ Returns the current types type. ]]
    [[`N::width`][ Returns the integral value associated with the `width` template parameter. ]]
    [[`N::offset`][ Returns the integral value associated with the `Offset` template parameter. ]]
    [[`operator T()`][ Run time support function. All this function does is
return the value associated with the type.]]
]


[h3 Examples]
Examples and use cases related to the `bits_mask` template.

Example:

Single bit mask using the default parameter for width.
``
typedef bits_mask< int, 0 > mask;
// mask in this case has the following value
// 0000 0000  0000 0000  0000 0000  0000 0001

int some_bit_value = 0xdeadbeef;

// now testing to see if the zero bit is set in some_bit_value
if(some_bit_value & mask() ) {
    ...
    true case
    ...
} else {
    ...
    false case
    ...
}
``

Here is another case where the `bits_mask` template is used used similar to a
bit field. The goal in this case would be to extract a single value from
within an integral storage type, which may be storing one or more values.

``
typedef bits_mask<int,10,3> mask;
// binary value of mask
// 0000 0000  0000 0000  0001 1111  1111 1000

// this will then be used to retrieve a value within an integer.
int some_bit_value = 0xdeadbeef;
// binary value of some_bit_value
// 1101 1110  1010 1011  1011 1110  1110 1111

// now to extract the value from within some_bit_value
int new_int_value = ( some_bit_value & mask() ) >> mask::offset;

// basic operations taking place.
// 1101 1110  1010 1011  1011 1110  1110 1111 <- some_bit_value
// 0000 0000  0000 0000  0001 1111  1111 1000 <- mask::value

// preforming bitwise and operator.

// 0000 0000  0000 0000  0001 1110  1110 1000 <- result of bitwise and operator
// preform right shift operation.
// 0000 0000  0000 0000  0000 0011  1101 1101 <- value of new_int_value. 
``


The implicit cast operator allows for simplicity, clarity of code. In the
above example `mask()` could be replaced with `mask::value` to achieve the same
result. The same applies to all other bitwise operators.

[endsect]

