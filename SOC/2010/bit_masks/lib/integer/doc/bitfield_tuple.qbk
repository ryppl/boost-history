[c++]

[section:bft bitfield_tuple]

[section:desc Description]
This is a type which provides access to bitfields stored within integers
or other integral types (see future work, for extensions). This is a pseudo
variadic type. It currently only takes up to 10 parameters but I will be 
extending that to be adjustable via macro similar to the MPL. Each of the 
template parameters must be supplied as either a storage template or a 
member template. For example, if one wanted to declare a bitfield_tuple
that was the size of one byte and contained two boolean bitfields and 
two integers they would do the following,
``   
#include <boost/integer/bitfield_tuple.hpp>
#include <boost/assert.hpp>
struct bool_one;
struct bool_two;
struct int_one;
struct int_two;

typedef bitfield_tuple<
    storage<char>,
    member<bool,bool_one,1>,
    member<bool,bool_two,1>,
    member<int,int_one,2>,
    member<int,int_two,2>
>                       example_type;

int main() {
    example_type temp;
    temp.get<bool_one>() = false; // assigns false to the first bitfield.
    temp.get<bool_two>() = true;  // assigns false to the second bitfield.
    temp.get<2>()        = -1;    // assigns -1 to the first integer 
                                  // bitfield.

    BOOST_ASSERT(( temp.get<2>()  == -1 )); // this passes the assert and 
                                            // does not exit the program
    BOOST_ASSERT(( temp.get<int_one>()  == -1 )); // this passes the assert and 
                                                  // does not exit the program
}
``
Within the above example the template `bitfield_tuple` is specified using 
multiple other templates which are used to describe different fields and
the internal type in which the bitfields will reside. In the above example
`storage<char>` means that the internal storage type used will be type
`char`. The template member is used to specify a bitfield within the tuple.
For instance, looking at `member<bool,bool_one,1>`, the first parameter is
used to describe the type which the stored value will be returned as. The second
parameter, `bool_one`, is a name type which can be used to retrieve the a 
bitfield from with in the `bitfield_tuple`. The third and final parameter is
the width of the a bitfield in bits, the template `member<bool,bool_one,1>` will
have a width of one.


The goal of a bitfield tuple is to provide a method for constructing bitfields
which is not subject to packing restrictions of structs or classes, while
providing an interface simlar to that of a struct or class which contains
bitfields. For instance if a user wanted to create a struct or class which
was similar to `example_type` in the above example they would write the 
following,
``
struct foo {
    bool bool_one:1;
    bool bool_two:1;
    int int_one:2;
    int int_two:2;
};
``
There is a problem with `struct foo`, it is not one which is so simple to see.
`struct foo` has a `sizeof` 4 bytes, while `example_type` is storing its data
within in a single byte. One can imagine the problems that arise from creating 
a `union` of `struct foo` with a `char` type.
[endsect]

[section:interface_overview Interface Overview]

[section:interface_summary Overview]
There are two main sections to the interface of a `bitfield_tuple`. The first
part of a `bitfield_tuple`'s interface is how its specified and how those 
specifications effect its behavior and composition. The second part of the
interface is the runtime portion of the interface.

[h4 Template Interface]
For all but one of the types used to specify a `bitfield_tuple`'s template 
parameters, order does matter, the one type which is not part of the implicit
ordering of a `bitfield_tuples` composition is the `storage<>` type. For more
information on the storage type as it relates to ordering please see
documentation relating to the `storage` template. Basically the template
parameters which are of type `flag` and `member` increment the `get` function
accessor's index by 1. (meaning that if one was to construct a bitfield tuple 
using a flag followed by a `filler`, followed by a `member`, than the index for
the `flag` would be 0 and the index for the `member` would be 1 because `filler`
doesn't have a value associated with it).

[h4 Runtime Support Interface]
The runtime interface of a `bitfield_tuple` is composed of the basic tuple 
interface, that being it is default and copy constructible, and provids the
regular `get` funtions which a tuple does. The two main difference between
the boost.tuple and the `bitfield_tuple` are as follows: First, the 
`bitfield_tuple` doesn't return references to its data members it has to return
a proxy to them. Second, the bitfield_tuple provides an additional `get`
function which uses a name or empty struct to access internal data elements (the
`bitfield_tuple` still provides the regular `get<Index>()` by index function as
boost.tuple).

[endsect]

[section:interface_preconditions Preconditions]
The following is a list of documented and/or enforeced preconditions for
constructing a `bitfield_tuple`. All of the preconditions will be noted as
either being documentation only or enfocred. For documentation only
preconditions please treat them as recomended usage of a `bitfield_tuple`, if
you do not follow the documentation only preconditions the `bitfield_tuple` may
not behave as you intend. All enforced preconditions if violated will result
in compilation failure normally resulting from a static assertion or look up
failure.


[note The following are preconditions for using the `bitfield_tuple` template 
and not preconditions for calling member functions, operators or constructor.
For preconditions on functions, constructors, and operators please see each 
function's, constructor's, or operator's individual documentation. ]
[endsect]

[section:interface_template Template Parameter Interface]
The following are different templates which one may use to aid in the
construction of a `bitfield_tuple`. All templates which are supplied to
`bitfield_tuple` have no actual definition, and are simply used to associate
template parameters together and associate a perticular meaning with them.

[section:filler `filler`]
[h4 Description]
Filler specifies a number of empty bits to be ignored. Another good way to think
about this is as bit padding, it adds the number of bits in padding when
specified. From an implementation stand point it adds `Bits` to the starting
the next starting position of the next bitfield specified in the template
parameter list.

[h4 Template Signature]
`template <std::size_t Bits> struct filler;`

[h4 Header file Locaton]
This header file is included with the <boost/integer/bitfield_tuple.hpp> header
file.
``
#include <boost/integer/details/bft/filler.hpp>
``
[h4 Example]
``

``
[endsect]



[section:flag `flag`]
[h4 Description]
`flag` is used to specify a boolean member of width one. For example,
``
struct red;

typedef bitfield_tuple<
    flag<red>
>           bitfield_tuple_1;


typedef btifield_tuple<
    member<bool,red,1>
>           bitfield_tuple_2;
``
the types `bitfield_tuple_1` and `bitfield_tuple_2` specify the same internal 
structure for their data. `flag<red>` has the same affect on a `bitfield_tuple`
as `member<bool,red,1>` would have.


[h4 Template Signature]
`template <typename Name> struct flag;`

[h4 Header file Locaton]
This header file is included with the <boost/integer/bitfield_tuple.hpp> header
file.
``
#include <boost/integer/details/bft/flag.hpp>
``
[h4 Example]
``
``
[endsect]


[section:bit_align `bit_align`]
[h4 Description]
Adjusts the next `member` or `flag` template inside of the `bitfield_tuple`'s
template parameter to a multiple of the `AlignTo` parameter. If the current
next position is a multiple of `AlignTo` then no adjustment will be made.

[note Calling `bit_align<8>` more then once in a row will have the same effect
as calling `bit_align<8>` once. ]


[h4 Template Signature]
`template <std::size_t AlignTo> struct bit_align;`

[h4 Header file Locaton]
This header file is included with the <boost/integer/bitfield_tuple.hpp> header
file.
``
#include <boost/integer/details/bft/align.hpp>
``
[h4 Example]
``
``
[endsect]

[section:member `member`]
[h4 Description]
`member` us used for specifying different bitfields within a `bitfield_tuple`.
[table
    [[template Parameter][Explanation]]
    [
        [`ReturnType`]
        [The type that the value is to be returnd from the get function as.You 
may supply a signed type for a member but please note that a singed bit will be
stored within the width you specify, so if you don't need negative values you
shouldn't store them.]
    ]
    [
        [`NameType`]
        [This is a type which is associated with the bitfield which is
represented by this member template. All names supplied to a `bitfield_tuple`
can only be used one per `bitfield_tuple`. The is enforced as a precondition.]
    ]
    [
        [`Width`]
        [The number of bits you would like associated with the field represented
by the `member` template.]
    ]
]

[h4 Template Signature]
`template <typename ReturnType, typename NameType, std::size_t Width>
struct member;`

[h4 Header file Locaton]
This header file is included with the <boost/integer/bitfield_tuple.hpp> header
file.
``
#include <boost/integer/details/bft/member.hpp>
``
[h4 Example]
``
``
[endsect]

[section:storage `storage`]
[h4 Description]
The `storage` template is optional (you don't have to have one in the template
parameter list of a `bitfield_tuple`). You may use it to specify that type you 
would like your bitfields to be stored within. If you don't specify a storage
type using the `storage` parameter a type will be selected for you which can
hold all of your bitfields. The deduced type will be unsigned and one off the
following types from within <boost/cstdint.hpp>, uint_least8_t, uint_least16_t,
uint_least32_t or if you have long long support enabled, uint_least64_t. You can
use boost.integer endian to specify your storage type as one which is different
from your current machine and the `bitfield_tuple` will store the data values
in the endianness specified as well as return and accept values in the
endianness of your native machine.

[h4 Template Signature]
`template <typename StorageType> struct storage;`

[h4 Header file Locaton]
This header file is included with the <boost/integer/bitfield_tuple.hpp> header
file.
``
#include <boost/integer/details/bft/storage.hpp>
``
[h4 Example]
``
``
[endsect]

[endsect]

[section:interface_reference Reference]
Regular interface documentation for a `bitfield_tuple`. This include information
about the public interface for the `bitfield_tuple` type.


[h5 Typedefs]
In the following table please note that `N` represents a `bitfield_tuple` type.
[table
    [
        [Member]
        [Type]
        [Description]
    ]
    [
        [`N::members`]
        [`mpl::vector<>`]
        [ The `members` vector contains `bitfield_elements` which are used to 
describe bitfields specified by the user. The reason that members is public
is to make the deduction of return types possible. Ff one would like to store
the proxy reference type from `bitfield_tuple` or return a reference to that
type members makes this possible. This is also used for implementing the
boost.fusion extension of the `bitfield_tuple`. There are additional 
meta-functions which can be used for getting the return type of a get function
which are covered in the implementation documentation.]
    ]
    [
        [`N::storage_type`]
        [integral or integral-like type]
        [ This is either the type specified by the user in the `storage`
parameter or the deducd type which is supplied by the `bitfield_tuple` in the
event that a user does not supply a `storage` parameter. For additional
infomration on which types are used when a type is deduced, see the documentation
for the `storage` type. ]
    ]
    [
        [`N::bits_used`]
        [`mpl::size_t<>`]
        [ This value is the number of bits the bitfield tuple is using. This is
also the would be the starting bit of the next bitfield relative to the 0 bit
of the storage type. ]
    ]

]

[h5 Constructors]
[table
    [
        [Name]
        [Constructor Signature]
        [Exception Safty]
        [Description]
    ]
    [
        [ Value Constructor ]
        [ `explicit bitfield_tuple(storage_type x = 0)` ]
        [ No Throw ]
        [ This constructor acts as both a default constructor and allows for
construction over the storage type. This constructor is one way of giving
a `bitfield_tuple` an initial value. ]
    ]
    [
        [ Copy Constructor ]
        [ `bitfield_tuple( bitfield_tuple const& x )` ]
        [ No Throw ]
        [ Copies the value from `x` into the current `bitfield_tuple`. ]
    ]
]

[h5 Operators]

[table
    [
        [Name]
        [Signature]
        [Exception Safty]
        [Description]
    ]
    [
        [Value Assignment Operator]
        [`bitfield_tuple const& operator=( storage_type const&)`]
        [ No Throw ]
        [Assigns a new value to the internal storage of the `bitfield_tuple`.]
    ]
    [
        [Copy Assignment Operator]
        [`bitfield_tuple const& operator=( bitfield_tuple const&)`]
        [ No Throw ]
        [Assigns a new value to the internal storage of the `bitfield_tuple`.]
    ]
]
[endsect]

[section:interface_implementation Implementation Reference]
The implementation reference includes information about different functions,
meta-functions and macros which are internally used to support this type.
There are a few items within the implementation reference which will provide
additional insight to the construction of a `bitfield_tuple` as well as 
some more obscure tools which the user may need under very specific
circumstances.
[endsect]

[endsect]

[section:endianness_and_bitfield_order Endianness And Bitfield Ordering]

[section:endianness Endianness]
[endsect]

[section:Bitfield_order Bitfield Storage Order]
[endsect]

[endsect]

[section:tutorial Tutorials and Examples]
[endsect]

[section:basic_use_cases Basic Use Cases]
Use Cases
[endsect]

[section:rationale Rationale]
Rationale
[endsect]


[endsect]

