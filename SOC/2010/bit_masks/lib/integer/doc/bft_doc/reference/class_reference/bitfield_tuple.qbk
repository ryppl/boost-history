[/
Copyright (c) 2010 Brian Bartman

Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]
[section `bitfield_tuple` and `bitfield_reference`]
[h4 `bitfield_tuple` interface]
There are two main sections to the interface of a `bitfield_tuple`. The first
part of a `bitfield_tuple`'s interface is how its specified and how those 
specifications effect its behavior and composition. The second part of the
interface is the runtime portion of the interface.

[h4 Template Interface]
For all but one of the types used to specify a `bitfield_tuple`'s template 
parameters, order does matter, the one type which is not part of the implicit
ordering of a `bitfield_tuples` composition is the `storage<>` type. For more
information on the storage type as it relates to ordering please see
documentation relating to the `storage` template. Basically the template
parameters which are of type `flag` and `member` increment the `get` function
accessor's index by 1. (meaning that if one was to construct a bitfield tuple 
using a flag followed by a `filler`, followed by a `member`, than the index for
the `flag` would be 0 and the index for the `member` would be 1 because `filler`
doesn't have a value associated with it).

[h4 Runtime Support Interface]
The runtime interface of a `bitfield_tuple` is composed of the basic tuple 
interface, that being it is default and copy constructible, and provids the
regular `get` funtions which a tuple does. The two main difference between
the boost.tuple and the `bitfield_tuple` are as follows: First, the 
`bitfield_tuple` doesn't return references to its data members it has to return
a proxy to them. Second, the bitfield_tuple provides an additional `get`
function which uses a name or empty struct to access internal data elements (the
`bitfield_tuple` still provides the regular `get<Index>()` by index function as
boost.tuple).

[h5 Include Files]

Header file:
``
#include <boost/bitfield_tuple.hpp>
``
Forward declaration file:
``
#include <boost/bitfield_tuple_fwd.hpp>
``

[h5 Template Signature]
``
tempate <typename... Args> struct bitfield_tuple;
``
For additional information on creating specilizations over the 
`bitfield_tuple`'s implementation documentation reguarding macros.

[h5 types]
`N` is used to represent a `bitfield_tuple`.

[table
    [
        [Type]
        [Description]
    ]
    [
        [`N::members`]
        [ This is an boost.mpl sequence, specifically `mpl::vector`. `members`
holds the information about the different member within the bitfield_tuple. The
only reason this is part of the public interface is so that the fusion sequence
can be made to work correctly. One should never have to use the `members` type
directly, however, if you must the elements contained within are of type
`bitfeild_element` mentioned more in the implementation section.]
    ]
    [
        [`N::storage_type`]
        [ The integral type being used to store bitfields within the 
`bitfield_tuple`. For more information about how this type is either deduced or
supplied see the `struct storage` section of the class reference documentation.]
    ]
    [
        [`N::bits_used`]
        [ The number of bits offset by the fields supplied by the user. Bits
used is of type `mpl::size_t<M>` where `M` is the sum of the bits use by all
bitfields and filler bits within the `bitfield_tuple`. This is also the index of
of the first bit of the next bitfield that would be added into the 
`bitfield_tuple`. ]
    ]
]

[h5 Template Members]
The `bitfield_reference` type is responsible for acting as the proxy reference
type into the storage of a `bitfield_tuple`, This works similar to the proxy 
reference type supplied by `std::vector<bool>` specilization. 

[note If one wishes to work with the reference direcrly please not that the
`const`'ness of the `BitfieldElement` template parameter is used to specify if
reference type is a const or non const type. This is due to construction of the
structure which is repsonsible to extracting or storing data within each
bitfield.]

[note The `bitfieldElement` type is also used to specify the bitfield to 
retrieve and store data within.]

[table
    [
        [Name]
        [Signature]
        [Description]
    ]
    [
        [`bitfield_reference`]
        [`N::template <typename BitfieldElement> bitfield_reference;`]
        [ This is the proxy reference type use to create a fake reference to
a bitfield within the bitfield_tuple.]
    ]
]

[h5 `bitfield_reference` Internal Types]
`ref` refers to a `bitfield_reference` type
[table
    [
        [Type]
        [Description]
    ]
    [
        [`ref::return_type`]
        [The return type specified by the user, via either a member or flag
parameter.]
    ]
    [
        [`ref::storage_t`]
        [The storage type with the same `const` ness as the `BitfieldElement` 
template parameter.]
    ]
    [
        [`ref::field_type`]
        [ The `boost::integer::bitfield` that relates to the data you are
storing within the integral value. This is the type which does the actual 
retrieval and storage of data into and from the `bitfield_tuple`. ]
    ]
]

[h5 bitfield_reference constructors]
[table
    [
        [Name]
        [Constructor Signature]
        [Exception Safty]
        [Description]
    ]
    [
        [Reference Constructor]
        [ `explicit bitfield_reference(storage_t& field)`]
        [ TBD ]
        [ Just like a reference the bitfield_reference is constrctible over the
type it references. ]
    ]
    [
        [Copy Constructor]
        [ `bitfield_reference( bitfield_reference const& x)`]
        [ TBD ]
        [ Copy makes a copy of the reference inside of `x`. ]
    ]
]

[h5 bitfield_reference operators]
[table
    [
        [Name]
        [Signature]
        [Exception Safty]
        [Description]
    ]
    [
        [Implicit Conversion Operator]
        [ `inline operator return_type() const`]
        [ TBD ]
        [ Allows the `bitfield_reference` type to be treated as though it is the
`return_type`. ]
    ]
    [
        [Assignment Operator]
        [ `bitfield_reference const& operator=(return_type const& rhs)`]
        [ TBD ]
        [ takes the value `rhs` and stores its value in the corrosponding 
bitfield in the storage of the `bitfield_tuple`.]
    ]
]




[h5 Constructors]
[table
    [
        [Name]
        [Constructor Signature]
        [Exception Safty]
        [Description]
    ]
    [
        [ Value Constructor ]
        [ `explicit bitfield_tuple(storage_type x = 0)` ]
        [ No Throw ]
        [ This constructor acts as both a default constructor and allows for
construction over the storage type. This constructor is one way of giving
a `bitfield_tuple` an initial value. ]
    ]
    [
        [ Copy Constructor ]
        [ `bitfield_tuple( bitfield_tuple const& x )` ]
        [ No Throw ]
        [ Copies the value from `x` into the current `bitfield_tuple`. ]
    ]
]

[h5 Operators]
[table
    [
        [Name]
        [Signature]
        [Exception Safty]
        [Description]
    ]
    [
        [Value Assignment Operator]
        [`bitfield_tuple const& operator=( storage_type const&)`]
        [ No Throw ]
        [Assigns a new value to the internal storage of the `bitfield_tuple`.]
    ]
    [
        [Copy Assignment Operator]
        [`bitfield_tuple const& operator=( bitfield_tuple const&)`]
        [ No Throw ]
        [Assigns a new value to the internal storage of the `bitfield_tuple`.]
    ]
]

[h5 Member functions]
[note All of the `bitfield_reference` types returned by the `get` functions 
listed below are deduced at compile time so they are ommited for clarity. ]

[table 
    [
        [Signature]
        [Description]
    ]
    [
        [`storage_type data( ) const`]
        [This returns a copy of the internal storage from within a bitfield
tuple.]
    ]
    [
        [ `template <typename Name>` [~ `bitfield_reference` type] `get()`]
        [ Returns a reference type corrisponding to the field stored with `Name`
specified in the template parameters.]
    ]
    [
        [ `template <typename Name>` [~ `bitfield_reference` type] `get() const`]
        [ Const version of the above function. ]
    ]
    [
        [ `template <std::size_t Index>` [~ `bitfield_reference` type] `get()`]
        [ This is the same as the boost.tuple get function. The only difference
is that it returns a proxy reference type.]
    ]
    [
        [ `template <std::size_t Index>` [~ `bitfield_reference` type] `get() const`]
        [ Const version of the above function.]
    ]
]

[h5 Preconditions on the `bitfield_tuple` template]
The following is a list of documented and/or enforeced preconditions for
constructing a `bitfield_tuple`. All of the preconditions will be noted as
either being documentation only or enfocred. For documentation only
preconditions please treat them as recomended usage of a `bitfield_tuple`, if
you do not follow the documentation only preconditions the `bitfield_tuple` may
not behave as you intend. All enforced preconditions if violated will result
in compilation failure normally resulting from a static assertion, look up
failure or an error message generated by `#error`.

[table
    [
        [Precondition]
        [Description]
        [Enfocement]
    ]
    [
        [The storage policy must not be specified more then once within the 
template parameters of bitfield_tuple template.]
        [ Don't supply multiple `storage<>` parameters to the `bitfield_tuple`.]
        [ Enforced by static assert ]
    ]
    [
        [A member or flag can not have the same name type as another member or
flag]
        [ Don't supply `memeber<int,red,1>` and `flag<red>` to the same
`bitfield_tuple` template. ]
        [ Enforced by static assert ]
    ]
    [
        [ A `member` can not have a width of 0. ]
        [ `member<int,red,0>` will result in an error. ]
        [ Enforced by static assert ]
    ]
    [
        [ The width of a member can not exceed the width, in bits, of its return
type.]
        [ `member<int,red,33>` will result in an error. ]
        [ Enforced by static assert ]
    ]
    [
        [The total width of the sum of all bit fields must not exceed the bit 
width of the storage type.]
        [ `bitfield_tuple<member<int,red,20>, member<int,blue,21>, storage<int> > bft`
Will result in an error. Please see documentation for storage type for behavior
when a storage type is not specified by the user as this behavior still applies
in that situation. ]
        [ Enforced by Static Assert ]
    ]
    [
        [ `BOOST_BFT_PARAM_COUNT` must not exceed 50. ]
        [ Don't set the `BOOST_BFT_PARAM_COUNT` to a value higher then 50. This
is because the `mpl::vector` doesn't support more then 50 parameters. Please see
documentation `BOOST_BFT_PARAM_COUNT` under macro reference section for 
additional information regarding the `BOOST_BFT_PARAM_COUNT` macro. ]
        [ Enforced macro macro error message. ]
    ]
    [
        [ Don't set `BOOST_MPL_LIMIT_VECTOR_SIZE` to be less then
`BOOST_BFT_PARAM_COUNT`.]
        [ If `BOOST_MPL_LIMIT_VECTOR_SIZE` is set and `BOOST_BFT_PARAM_COUNT` is set
and  `BOOST_MPL_LIMIT_VECTOR_SIZE` < `BOOST_BFT_PARAM_COUNT` is true, it is impossible
for the `bitfield_tuple` to store all of its parameters inside of the `mpl::vector`.]
        [ Enforced by macro error message. ]
    ]
]

[endsect]
