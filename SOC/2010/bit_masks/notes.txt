This is used for keeping track of different ideas about different possible
interfaces or implementation of bit masks.



The bit_masks should be combinable (i.e. use recursive template), to allow for
a combination of different masks to compose one mask.

The bit_mask type is going to have an integral_c base class, which is going to
hold the data which would make up the mask itself.

Notes for later creating a test suite:
The mask type will be one of the following built in data types OR one of the
data types supplied by the boost.integer library.
List to follow:
char
unsigned char
short
unsigned short
long
unsigned long
int
unsigned int
long long
unsigned long long


integer types from boost integer:

int_least8_t
int_least16_t
int_least32_t
uint_least8_t
uint_least16_t
uint_least32_t


The following types are available only if, after including <boost/cstdint.hpp>,
the macro BOOST_NO_INT64_T is not defined:

int_least64_t
uint_least64_t

The following fastest minimum-width integer types are provided for all platforms:

int_fast8_t
int_fast16_t
int_fast32_t
uint_fast8_t
uint_fast16_t
uint_fast32_t

The following types are available only if, after including <boost/cstdint.hpp>,
the macro BOOST_NO_INT64_T is not defined:

int_fast64_t
uint_fast64_t





Interface Idea:
All interface idea's need to be able to work with recursive templates.
Also note that Andrew says that the beginning of this function is not
actually going to be a meta function so don't try to make it one. 


Referencing bits inside a mask is right to left where right starts at 0 and left
is the last index 

Simple interface:

specify width of mask or type which the mask is going to be applied to,
the offset in bits which a mask will begin, and the width the mask in bits.

E.x. if some one would want to use the bit masks to specify a sub net mask
this would be ideal for doing that.

// starting at the 8th bit so picking done by index similar to an array.
bit_mask<int, 7, 24>


Integral Constant Specialization:

Provide a Specialization of bit_mask which will take an integral constant
from boost::mpl and create a bit mask from that.


Specification of a mask through offsets and widths:

Provide a mask which will take a combination of "pairs"* of offsets and widths.
*NOT std::pair just some data that comes int 2's.

A valid example of something like this would look like the following:
// mask type followed by masks.
bit_mask< int, mask<0,2>, mask<13,2> ... etc ... >



NOTE for future Developement:
Making Dynamic Bit masks instead of static.
Possibly making this into a meta function instead of using this by itself.



For the bit_mask tuple look at the interface used inside the stl's tuple
that is the goal for that psudo-data structure (psudo-data structure as it isn't
really intended to be instanced and doesn't store any actual data, just ICEs
(Integral Constant Expressions NOT Internal Compiler Errors.)).


------- Interface Ides for test, set, clear and flip ---------


Thoughts from standard bitset's set member function.

What it does is take size_t, bool and if bool is true it sets all bits in the
expression. So it would be best to have meta-functions (one which specializes on
true) to do the exact same thing for a bit_mask on compile time.




Compile time interface only.

For operations on masks which are compile and runtime try what Andrew suggested:
Functors for the different operations so the following would work for 
compile time.



                    Compile time set_bit meta-function

// this would need to have a specialization for SetAll where set all is = to true.
the setting of all bits is simply a shift to the right or left = to the width of
the mask in bits then calling the ~ operator on the thing.


// assuming T is some mask type.
template <typename T, unsigned int N, bool SetAll = false >
struct set_bit
    :integral_mask< T::value_type, T::value > // <--- this will do all of the internal 
    // work as far as keeping types + value etc...
{ };


                    Compile time test_bit meta-function

This meta function should take one mask and an integral value and check to see
of the bit value at the position indicated by the integral value is set or not.
This meta-function will evaluate to true or false if the bit is or isn't false.

template <typename T, unsigned int N>
struct test_mask_bit;

                    Compile time flip_bit meta-function
Intent is to specify either a single bit or all bits to be fliped. This meta-function
will require one specilization as wll for std::numeric_limits<unsigned int>::max.

template <typename T, unsigned int N = std::numeric_limits<unsigned int>::max >
struct flip_mask_bit;



                    Compile time clear_bit meta-function

The intent of this function would be for clearing of a single bit or all bits 
from within a mask. This would also require a specilization for
std::numeric_limits< unsigned int>::max.


template <typename T, unsigned int N = std::numeric_limits<unsigned int>::max>
struct clear_mask_bit;


compile time + runtime interface.

These are functors which provide runtime support for preforming regular masking
operations with complie time composed masks. The reasoning behind creating functions
which create a mask on compile time and that mask would then be applied to some
integral type T at a later time.



                Compile + run time set interface.
template <typename T, unsigned int Offset>
struct set_single_bit {
    T operator()(T x);
};

template <typename T, unsigned int FromIndex, unsigned int ToIndex>
struct set_bit_range {
    T operator()(T x);
};

template <typename T>
struct set_all_bits {
    T operator()(T x);
};

template <typename T, typename bit_mask>
struct set_selected {
    T opeator()(T x);
};


                Compile + run time test interface.
                Compile + run time flip interface.

                Compile + run time clear interface.

clear one, clear many, clear all, clear selected

Create masks based on T, and the index of the bit to clear
and clear the bit at location Offset.

template <typename T, unsigned int Offset>
struct clear_single_bit {
    T operator()(T x);
};

template <typename T, unsigned int FromIndex, unsigned int ToIndex>
struct clear_bit_range {
    T operator()(T x);
};

template <typename T>
struct clear_all_bits {
    T operator()(T x);
};

template <typename T, typename bit_mask>
struct clear_selected {
    T opeator()(T x);
};



runtime only interface.


        runtime test
This will throw a domain error if N is greater then the bit_width of T.
single bit test.
template <typename T>
bool test(T bits, size_t N);

range test + test all
template <typename T>
bool test(T bits, size_t from, size_t to);


        runtime set
This will throw a domain error if N is greater then the bit_width of T.

single bit set.
template <typename T>
T set(T bits, size_t N);

set range + set all
template <typename T>
T set(T bits, size_t from, size_t to);


        runtime clear
This will throw a domain error if N is greater then the bit_width of T.

clear a single bit.
template <typename T>
T clear(T bits, size_t N);

range clear + clear all.
template <typename T>
T clear(T bits, size_t from, size_t to);

        runtime flip
This will throw a domain error if N is greater then the bit_width of T.

single bit flip.
template <typename T>
T flip(T bits, size_t N);

range flip + flip all.
template <typanem T>
T flip(T bits, size_t from, size_t to);


