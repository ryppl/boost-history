This is used for keeping track of different ideas about different possible
interfaces or implementation of bit masks.



The bit_masks should be combinable (i.e. use recursive template), to allow for
a combination of different masks to compose one mask.

The bit_mask type is going to have an integral_c base class, which is going to
hold the data which would make up the mask itself.

Notes for later creating a test suite:
The mask type will be one of the following built in data types OR one of the
data types supplied by the boost.integer library.
List to follow:
char
unsigned char
short
unsigned short
long
unsigned long
int
unsigned int
long long
unsigned long long


integer types from boost integer:

int_least8_t
int_least16_t
int_least32_t
uint_least8_t
uint_least16_t
uint_least32_t


The following types are available only if, after including <boost/cstdint.hpp>,
the macro BOOST_NO_INT64_T is not defined:

int_least64_t
uint_least64_t

The following fastest minimum-width integer types are provided for all platforms:

int_fast8_t
int_fast16_t
int_fast32_t
uint_fast8_t
uint_fast16_t
uint_fast32_t

The following types are available only if, after including <boost/cstdint.hpp>,
the macro BOOST_NO_INT64_T is not defined:

int_fast64_t
uint_fast64_t





Interface Idea:
All interface idea's need to be able to work with recursive templates.
Also note that Andrew says that the beginning of this function is not
actually going to be a meta function so don't try to make it one. 


Referencing bits inside a mask is right to left where right starts at 0 and left
is the last index 

Simple interface:

specify width of mask or type which the mask is going to be applied to,
the offset in bits which a mask will begin, and the width the mask in bits.

E.x. if some one would want to use the bit masks to specify a sub net mask
this would be ideal for doing that.

// starting at the 8th bit so picking done by index similar to an array.
bit_mask<int, 7, 24>


Integral Constant Specialization:

Provide a Specialization of bit_mask which will take an integral constant
from boost::mpl and create a bit mask from that.


Specification of a mask through offsets and widths:

Provide a mask which will take a combination of "pairs"* of offsets and widths.
*NOT std::pair just some data that comes int 2's.

A valid example of something like this would look like the following:
// mask type followed by masks.
bit_mask< int, mask<0,2>, mask<13,2> ... etc ... >



NOTE for future Developement:
Making Dynamic Bit masks instead of static.
Possibly making this into a meta function instead of using this by itself.



For the bit_mask tuple look at the interface used inside the stl's tuple
that is the goal for that psudo-data structure (psudo-data structure as it isn't
really intended to be instanced and doesn't store any actual data, just ICEs
(Integral Constant Expressions NOT Internal Compiler Errors.)).


------- Interface Ides for test, set, clear and flip ---------


Thoughts from standard bitset's set member function.

What it does is take size_t, bool and if bool is true it sets all bits in the
expression. So it would be best to have meta-functions (one which specializes on
true) to do the exact same thing for a bit_mask on compile time.




Compile time interface only.

For operations on masks try what Andrew suggested:
Functors for the different operations so the following would work for 
compile time.



                    Compile time set_bit meta-function

// this would need to have a specialization for SetAll where set all is = to true.
the setting of all bits is simply a shift to the right or left = to the width of
the mask in bits then calling the ~ operator on the thing.


// assuming T is some mask type.
template <typename T, unsigned int N, bool SetAll = false >
struct set_bit
    :integral_mask< T::value_type, T::value >// <--- this will do all of the internal 
    // work as far as keeping types + value etc...
{ };


                    Compile time test_bit meta-function

This meta function should take one mask and an integral value and check to see
of the bit value at the position indicated by the integral value is set or not.
This meta-function will evaluate to true or false if the bit is or isn't false.

template <typename T, unsigned int N>
struct test_bit
    :integral_constant< bool, (T::value & (low_bits<T::value_type,1>::value << N) >
{ };


                    Compile time flip_bit meta-function

template <typename T, unsigned int N = std::numeric_limits<unsigned int>::max >
struct flip_bits

compile time + runtime interface.


runtime only interface.

