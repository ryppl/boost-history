TODO From Email Responses
--------------------------------------------------------------------------------

1) create element metafunction for returning the return type of a field.
2) Create a get free function which takes a bitfield_tuple.
3) Change bit_align to align.
4) Change filler to padding.

5) Documentation for align -
"Ensures the offset of the next bit field is divisible by the supplied value."

-> 6) consider renaming member to field or bitfield
7) Move bitfield_tuple into namespace bitfields.

--------------------------------------------------------------------------------
List of TODO's throughout the bitfield_tuple

1) template_expansion_macros.hpp
    b) MAYBE: Rename some of the internal use only macros so they don't
    get confused with macros for external use.


2) reference_builder.hpp


3) proxy_reference_policy.hpp
    a)  Create the custom member.
    b)  Create documentation for how to create your own policy.
    c)  This may need additional documentation however it looks good currently.


4)  pointer_parsing_meta_functions.hpp
    a) typedef mpl::if_c<(4<sizeof(void*)),uint64_t,uint32_t>::type ptr_mask_type
        I   )   Add support for 16 bit systems. Eventually.


5)  pointer_packing_policy.hpp
6)  name_lookup.hpp
7)  make_bitfield_tuple.hpp
8)  bitfield_tuple_impl.hpp


9)  bft_element.hpp
    a) change name to bitfield_element.hpp - eventually.


10) arg_parse_impl.hpp
    b)  Implement the specialization for custom members.
        I   )   This could be more of a pain, however it seems quite simple
                after implementing the pointer stuff.

12) bitfield_iterator.hpp - Fusion Extension
    A)  Add OR remove const functions. Fusion may be a non const only
        thing. Other option is to make a const iterator but that could be more
        complex then I'm willing to deal with at the moment.
 

14) bitfield_tuple.hpp
15) Remove old pointer plus bits stuff


Test file review
1)  variadic_sequence_testing.cpp

    a)  Replicate this test all the way up to 50 at intervals of 10.
    b)  Switch to using <boost/detail/lightweight_test.hpp> framework.
    c)  Add test to test the limit of the bitfield_tuple so that I can be
        assured that the limit is working correctly.
    d)  remove testing from the end of file name.

2)  to_string_testing.cpp
    a) Remove this its not part of bitfield_tuple any more.

3)  template_expansion_marco_test.cpp
    a)  Make this an actual test to make sure that everything is correctly
        getting expanded.
    b)  Find a better way to test this.
    c)  remove test from name.
    d)  Change to using the <boost/detail/lightweight_test.hpp> framework.

4)  reference_builder_test.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  test the rest of the reference builder functions
        I   )   Name exists
        II  )   find_by_element_name
        III )   find_by_element_index
        IV  )   make_reference_type_by_name <-- Maybe, if its actually being 
                used then I'll make a test for it other wise its going to be
                removed.
        V   )   enable_if_reference_type_by_index
        VI  )   get_reference_type_by_name
        VII )   get_reference_type_by_index

5)  pointer_parsing_meta_function_test.cpp
    a)  Remove test from name.
    c)  Other then name this is pretty complete.

6)  pointer_member_test.cpp
    a)  remove test from name.
    b)  This test is incomplete because the implementation isn't completed yet.
    c)  I need a macro which will tell me if the test is 32 bit or 64 bit
        Currently the _LP64 should only work for GCC however I need a more
        universal one.

7)  name_accessor_test.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

8)  make_bft_testing.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  

9)  make_bft_testing.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  This may need additional test to make sure that the macros are correctly
        generating the code for the correct number of valid parameters.

10) get_interface_test.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  Need to do more const interface testing.

11) fusion_iterator_testing.cpp
    a)  remove testing from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  Not sure just how I should test the iterator. This may be good as it
        however that doesn't mean that it should just stay as is. Look into
        other fusion iterator tests.

12) fusion_integration_testing.cpp
    a)  remove testing from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

13) flag_test.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

14) filler_test.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

15) deduced_storage_type_test.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

16) deduced_storage_type_long_long_test.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  Maybe merge this with the other storage type.

17) custom_member_test.cpp
    a)  remove test from name.
    b)  Implement before testing this.

18) bitfield_tuple_test.hpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  remove previous dependency on test_list_type.hpp

19) align_test.cpp
    a)  remove test from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

20) fails_on_64_bit.cpp
    a) Move the contents into boost_endian_integration_test.cpp

21) Remove the ppb_testing folder and tests from the jam file.

                        TO BE ADDED TO TESTS SECTION
    Test which need to be created as a result of modifications or additions!
--------------------------------------------------------------------------------
1)  !DONE! Add interface test for the interface macros. !DONE!
2)  interface meta-function test suite.
3)  Create additional tests for count leading and trailing zero meta-functions.
4)  Create compile failure test for pointer member mask being 0.
5)  Create compile failure test for pointer member mask not being same size as
    pointer.
6)  Create compile Failure test for custom member mask being 0.

--------------------------------------------------------------------------------


                  THINGS TO CREATE EXTERNAL DOCUMENTATION FOR
--------------------------------------------------------------------------------

inside of file <boost/integer/bitfield_tuple/interface_meta_functions.hpp>
1) template <typename BitfieldTuple, typename Name>
   struct name_exists;

2) template <typename BitfieldTuple, typename Name>
   struct find_by_element_name;

3) template <typename BitfieldTuple, std::size_t Index>
   struct find_by_element_index;

4) template <typename BitfieldTuple, typename Name>
   struct get_proxy_reference_type_by_name;

5) template <typename BitfieldTuple, std::size_t Index>
   struct get_proxy_reference_type_by_index;

no particular file yet.
6) How to make your own custom policy (After I finish the pointer/custom stuff)


General Topic
Make note of the issue with retrieving a proxy reference type in a 
const scope and how to deal with it if they wish to create their own 
proxy reference type OR if they wish to actually return the proxy
reference type.

--------------------------------------------------------------------------------


This is used for keeping track of different ideas about different possible
interfaces or implementation of bit masks.



The bit_masks should be combinable (i.e. use recursive template), to allow for
a combination of different masks to compose one mask.

The bit_mask type is going to have an integral_c base class, which is going to
hold the data which would make up the mask itself.

Notes for later creating a test suite:
The mask type will be one of the following built in data types OR one of the
data types supplied by the boost.integer library.
List to follow:
char
unsigned char
short
unsigned short
long
unsigned long
int
unsigned int
long long
unsigned long long


integer types from boost integer:

int_least8_t
int_least16_t
int_least32_t
uint_least8_t
uint_least16_t
uint_least32_t


The following types are available only if, after including <boost/cstdint.hpp>,
the macro BOOST_NO_INT64_T is not defined:

int_least64_t
uint_least64_t

The following fastest minimum-width integer types are provided for all platforms:

int_fast8_t
int_fast16_t
int_fast32_t
uint_fast8_t
uint_fast16_t
uint_fast32_t

The following types are available only if, after including <boost/cstdint.hpp>,
the macro BOOST_NO_INT64_T is not defined:

int_fast64_t
uint_fast64_t





Interface Idea:
All interface idea's need to be able to work with recursive templates.
Also note that Andrew says that the beginning of this function is not
actually going to be a meta function so don't try to make it one. 


Referencing bits inside a mask is right to left where right starts at 0 and left
is the last index 

Simple interface:

specify width of mask or type which the mask is going to be applied to,
the offset in bits which a mask will begin, and the width the mask in bits.

E.x. if some one would want to use the bit masks to specify a sub net mask
this would be ideal for doing that.

// starting at the 8th bit so picking done by index similar to an array.
bit_mask<int, 7, 24>


Integral Constant Specialization:

Provide a Specialization of bit_mask which will take an integral constant
from boost::mpl and create a bit mask from that.


Specification of a mask through offsets and widths:

Provide a mask which will take a combination of "pairs"* of offsets and widths.
*NOT std::pair just some data that comes int 2's.

A valid example of something like this would look like the following:
// mask type followed by masks.
bit_mask< int, mask<0,2>, mask<13,2> ... etc ... >



NOTE for future Developement:
Making Dynamic Bit masks instead of static.
Possibly making this into a meta function instead of using this by itself.



For the bit_mask tuple look at the interface used inside the stl's tuple
that is the goal for that psudo-data structure (psudo-data structure as it isn't
really intended to be instanced and doesn't store any actual data, just ICEs
(Integral Constant Expressions NOT Internal Compiler Errors.)).


------- Interface Ides for test, set, clear and flip ---------


Thoughts from standard bitset's set member function.

What it does is take size_t, bool and if bool is true it sets all bits in the
expression. So it would be best to have meta-functions (one which specializes on
true) to do the exact same thing for a bit_mask on compile time.




Compile time interface only.

For operations on masks which are compile and runtime try what Andrew suggested:
Functors for the different operations so the following would work for 
compile time.



                    Compile time set_bit meta-function

// this would need to have a specialization for SetAll where set all is = to true.
the setting of all bits is simply a shift to the right or left = to the width of
the mask in bits then calling the ~ operator on the thing.


// assuming T is some mask type.
template <typename T, unsigned int N, bool SetAll = false >
struct set_bit
    :integral_mask< T::value_type, T::value > // <--- this will do all of the internal 
    // work as far as keeping types + value etc...
{ };


                    Compile time test_bit meta-function

This meta function should take one mask and an integral value and check to see
of the bit value at the position indicated by the integral value is set or not.
This meta-function will evaluate to true or false if the bit is or isn't false.

template <typename T, unsigned int N>
struct test_mask_bit;

                    Compile time flip_bit meta-function
Intent is to specify either a single bit or all bits to be fliped. This meta-function
will require one specilization as wll for std::numeric_limits<unsigned int>::max.

template <typename T, unsigned int N = std::numeric_limits<unsigned int>::max >
struct flip_mask_bit;



                    Compile time clear_bit meta-function

The intent of this function would be for clearing of a single bit or all bits 
from within a mask. This would also require a specilization for
std::numeric_limits< unsigned int>::max.


template <typename T, unsigned int N = std::numeric_limits<unsigned int>::max>
struct clear_mask_bit;


compile time + runtime interface.

These are functors which provide runtime support for preforming regular masking
operations with complie time composed masks. The reasoning behind creating functions
which create a mask on compile time and that mask would then be applied to some
integral type T at a later time.



                Compile + run time set interface.
template <typename T, unsigned int Offset>
struct set_single_bit {
    T operator()(T x);
};

template <typename T, unsigned int FromIndex, unsigned int ToIndex>
struct set_bit_range {
    T operator()(T x);
};

template <typename T>
struct set_all_bits {
    T operator()(T x);
};

template <typename T, typename bit_mask>
struct set_selected {
    T opeator()(T x);
};


                Compile + run time test interface.
                Compile + run time flip interface.

                Compile + run time clear interface.

clear one, clear many, clear all, clear selected

Create masks based on T, and the index of the bit to clear
and clear the bit at location Offset.

template <typename T, unsigned int Offset>
struct clear_single_bit {
    T operator()(T x);
};

template <typename T, unsigned int FromIndex, unsigned int ToIndex>
struct clear_bit_range {
    T operator()(T x);
};

template <typename T>
struct clear_all_bits {
    T operator()(T x);
};

template <typename T, typename bit_mask>
struct clear_selected {
    T opeator()(T x);
};



runtime only interface.


        runtime test
single bit test.
template <typename T>
bool test(T bits, size_t N);

range test + test all
template <typename T>
bool test(T bits, size_t from, size_t to);


        runtime set

single bit set.
template <typename T>
T set(T bits, size_t N);

set range + set all
template <typename T>
T set(T bits, size_t from, size_t to);


        runtime clear

clear a single bit.
template <typename T>
T clear(T bits, size_t N);

range clear + clear all.
template <typename T>
T clear(T bits, size_t from, size_t to);

        runtime flip
single bit flip.
template <typename T>
T flip(T bits, size_t N);

range flip + flip all.
template <typanem T>
T flip(T bits, size_t from, size_t to);


