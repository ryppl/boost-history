TODO From Email Responses
--------------------------------------------------------------------------------

1) create element metafunction for returning the return type of a field.
2) Create a get free function which takes a bitfield_tuple.

5) Documentation for align -
    "Ensures the offset of the next bit field is divisible by the supplied value."

-> 6) consider renaming member to field or bitfield
--------------------------------------------------------------------------------
List of TODO's throughout the bitfield_tuple

1) template_expansion_macros.hpp
2) reference_builder.hpp
3) proxy_reference_policy.hpp

4)  pointer_parsing_meta_functions.hpp

5)  pointer_packing_policy.hpp
6)  name_lookup.hpp
7)  make_bitfield_tuple.hpp
8)  bitfield_tuple_impl.hpp
9)  bitfield_element.hpp
10) arg_parse_impl.hpp

12) bitfield_iterator.hpp - Fusion Extension
 

14) bitfield_tuple.hpp
15) Remove old pointer plus bits stuff
16) interface_meta_functions.hpp



--------------------------------------------------------------------------------
                                Test File Review
--------------------------------------------------------------------------------
1)  variadic_sequence_testing.cpp

3)  template_expansion_marco_test.cpp
    a)  Make this an actual test to make sure that everything is correctly
        getting expanded.
    b)  Find a better way to test this.
    d)  Change to using the <boost/detail/lightweight_test.hpp> framework.



4)  reference_builder_test.cpp
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

*) interface_meta_function_test.cpp

5)  pointer_parsing_meta_function_test.cpp

6)  pointer_member_test.cpp
    a)  .
    b)  This test is incomplete because the implementation isn't completed yet.
    c)  I need a macro which will tell me if the test is 32 bit or 64 bit
        Currently the _LP64 should only work for GCC however I need a more
        universal one.

7)  name_accessor_test.cpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

8)  make_bft_testing.cpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

9)  make_bft_testing.cpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  This may need additional test to make sure that the macros are correctly
        generating the code for the correct number of valid parameters.

10) get_interface_test.cpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  Need to do more const interface testing.

11) fusion_iterator_testing.cpp
    a)  remove testing from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  Not sure just how I should test the iterator. This may be good as it
        however that doesn't mean that it should just stay as is. Look into
        other fusion iterator tests.
*)  bitfield_iterator.hpp
    - Make sure that this works in const situation.

12) fusion_integration_testing.cpp
    a)  remove testing from name.
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

13) flag_test.cpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

14) filler_test.cpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

15) deduced_storage_type_test.cpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

16) deduced_storage_type_long_long_test.cpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  Maybe merge this with the other storage type.

17) custom_member_test.cpp
    a)  .
    b)  Implement before testing this.

18) bitfield_tuple_test.hpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.
    c)  remove previous dependency on test_list_type.hpp

19) align_test.cpp
    a)  .
    b)  Change to using the <boost/detail/lightweight_test.hpp> framework.

20) fails_on_64_bit.cpp
    a) Move the contents into boost_endian_integration_test.cpp

21) Remove the ppb_testing folder and tests from the jam file.

                        TO BE ADDED TO TESTS SECTION
    Test which need to be created as a result of modifications or additions!
--------------------------------------------------------------------------------
1)  !DONE! Add interface test for the interface macros. !DONE!
    2)  interface meta-function test suite.
3)  Create additional tests for count leading and trailing zero meta-functions.
4)  Create compile failure test for pointer member mask being 0.
5)  Create compile failure test for pointer member mask not being same size as
    pointer.
6)  Create compile Failure test for custom member mask being 0.
7)  Create test for element and element_n
8)  Create test for get_free_function.
9)  Create compile failure test for find_by_element_name name does not exist.
10) Create compile failure test for find_by_element_index index does not exist.
11) Create compile failure test for get_proxy_reference_type_by_name name does
    not exist.
12) Create compile failure test for get_proxy_reference_type_by_index index does
    not exist.


--------------------------------------------------------------------------------


                  THINGS TO CREATE EXTERNAL DOCUMENTATION FOR
--------------------------------------------------------------------------------

inside of file <boost/integer/bitfield_tuple/interface_meta_functions.hpp>
1) template <typename BitfieldTuple, typename Name>
   struct name_exists;

2) template <typename BitfieldTuple, typename Name>
   struct find_by_element_name;

3) template <typename BitfieldTuple, std::size_t Index>
   struct find_by_element_index;

4) template <typename BitfieldTuple, typename Name>
   struct get_proxy_reference_type_by_name;

5) template <typename BitfieldTuple, std::size_t Index>
   struct get_proxy_reference_type_by_index;

no particular file yet.
6) How to make your own custom policy (After I finish the pointer/custom stuff)


General Topic
Make note of the issue with retrieving a proxy reference type in a 
const scope and how to deal with it if they wish to create their own 
proxy reference type OR if they wish to actually return the proxy
reference type.


*) Update documentation for filler -> padding 
*) update documentation for bit_align -> align
*)  Create documentation for how to create your own policy.
*)  proxy_reference_policy may need additional documentation however it looks
    good currently.
--------------------------------------------------------------------------------

