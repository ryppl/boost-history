[/==============================================================================
    Copyright (C) 2001-2010 Joel de Guzman
    Copyright (C) 2001-2005 Dan Marsden
    Copyright (C) 2001-2010 Thomas Heller

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section Extending Actors]

[link phoenix.reference.concept.actor Actors] are one of the main parts of the
library, and one of the many customization points. The default actor implementation
provides several perator() overloads which deal with the evaluation of expressions.

For some uses cases this might not be enough. For convenience it is thinkable to
provide custom member functions which generate new expressions. An example is
the [link phoenix.reference.modules.statement.if__statement if_ Statement] which
provides an additional else member. With this the actual phoenix expression
becomes more expressive.

Another szenario is to give actors the semantics of a certain well known interface
or concept. This tutorial like section will provide information on how to implement
a custom actor which is usable as if it where a [@http://www.sgi.com/tech/stl/Container.html STL Container].

[heading Requirements]

Let's repeat what we want to have:

[table
	[[Expression] [Semantics]]
	[[`a.begin()`] [Returns an iterator pointing to the first element in the container.]]
	[[`a.end()`] [Returns an iterator pointing one past the last element in the container.]]
	[[`a.size()`] [Returns the size of the container, that is, its number of elements.]]
	[[`a.max_size()`] [Returns the largest size that this container can ever have.]]
	[[`a.empty()`] [Equivalent to a.size() == 0. (But possibly faster.)]]
	[[`a.swap(b)`] [Equivalent to swap(a,b)]]
]

Additionally, we want all the operator() overloads of the regular actor.

[heading The `container_actor`]

The first version of our `container_actor` interface to show the general
principle. This will be continually be extended. For the sake of simplicity,
every member function generator will return [link phoenix.reference.modules.core.nothing `nothing`]
at first.

	template <typename Expr>
	struct container_actor
		: actor<Expr>
	{
		typedef actor<Expr> base_type;
		typedef container_actor<Expr> that_type;
		
		container_actor( base_type const& base )
			: base_type( base ) {}

		compose<null_actor>::result_type const begin() { return nothing; }
		compose<null_actor>::result_type const end() { return nothing; }
		compose<null_actor>::result_type const size() { return nothing; }
		compose<null_actor>::result_type const max_size() { return nothing; }
		compose<null_actor>::result_type const empty() { return nothing; }

		// note that swap is the only function needing another container.
		template <typename OtherExpr>
		compose<null_actor>::result_type const swap( actor<OtherExpr> const& ) { return nothing; }
	};

[heading Using the new actor]

Although the member function do nothing right now, we want to test if we can use
our new actor.

First, lets create a generator which wraps the `container_actor` around any other
expression:
	
   template <typename Expr>
	container_actor<Expr> const
	container( actor<Expr> const& expr )
	{
		return expr;
	}

Now lets test this:

	std::vector<int> v;
	v.push_back(0);
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);

	(container(arg1).begin())(v);

Granted, this is not really elegant and not really practical (we coud have just
used phoenix::begin(v) from the [link phoenix.reference.modules.stl.algorithm Phoenix Algorithm Module], 
but we can do better.

Let's have a [link phoenix.reference.modules.core.arguments Argument placeholder]
which is usable as if it was a STL container:

	template <typename N>
	struct make_container_argument : compose_ex<argument, container_actor, N> {};

	typedef make_container_argument<boost::mpl::int_<0> > make_con1;
	make_con1::type const con1 = make_con1()(boost::mpl::int_<0>());
	// and so on ...

The above code now changes to:

	std::vector<int> v;
	v.push_back(0);
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);

	(con1.size())(v);

Wow, that was easy!

[heading Adding live to our actor]

This one will be actually even easier.

First, we define a [link pheonix.reference.modules.function Lazy function] which
evaluates the expression we want to implement.
Following is the implementation of the size function:

	struct size_impl
	{
		// result_of protocol:
		template <typename Sig>
		struct result;

		template <typename This, typename Container>
		struct result<This(Container)>
		{
			// Note, remove reference here, because Container can be anything
			typedef typename boost::remove_reference<Container>::type container_type;

			// The result will be size_type
			typedef typename container_type::size_type type;
		};

		template <typename Container>
		typename result<size_impl(Container const&)>::type
		operator()(Container const& container) const
		{
			return container.size();
		}
	};

Good, this was the first part. The second part will be, to implement the size member
function of `container_actor`:
	
	template <typename Expr>
	struct container_actor
		: actor<Expr>
	{
		typedef actor<Expr> base_type;
		typedef container_actor<Expr> that_type;
		
		container_actor( base_type const& base )
			: base_type( base ) {}

		typename result_of::function<size_impl, that_type>::type const
		size()
		{
			function<size_impl> const f = size_impl();
			return f(*this);
		}
	
		// the rest ...
	};

It is left as exercise to the user to implement the missing parts by resuing
functions from the [link phoenix.reference.modules.stl.algorithm Phoenix Algorithm Module]
(The impatient take a look here: [@../../example/container_actor.cpp container_actor.cpp]).

[endsect]
