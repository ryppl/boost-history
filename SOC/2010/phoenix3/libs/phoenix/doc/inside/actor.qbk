[/==============================================================================
    Copyright (C) 2001-2010 Joel de Guzman
    Copyright (C) 2001-2005 Dan Marsden
    Copyright (C) 2001-2010 Thomas Heller

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section:actor Actors in Detail]

[heading Actor Concept]

The main concept is the `Actor`. An `Actor` is a model of the __PFO__ concept
(that can accept 0 to N arguments (where N is a predefined maximum).

An `Actor` contains a valid Phoenix Expression, a call to one of the function
call operator overloads, starts the evaluation process.

[note You can set `PHOENIX_LIMIT`, the predefined maximum arity an
actor can take. By default, `PHOENIX_LIMIT` is set to 10.]

[heading `actor`]

The `actor` template class models the `Actor` concept:

    template <typename Expr>
    struct actor
    {
        template <typename Sig>
        struct result;

        typename result_of::actor<Expr>::type
        operator()() const;

        template <typename T0>
        typename result_of::actor<Expr, T0 &>::type
        operator()(T0& _0) const;

        template <typename T0>
        typename result_of::actor<Expr, T0 const &>::type
        operator()(T0 const & _0) const;

        //...
    };

[table Actor Concept Requirements
    [
     [Expression]
     [Semantics]
    ]
    [
     [`actor(arg0, arg1, ..., argN)`]
     [Function call operators to start the evaluation]
    ]
    [
     [`boost::result_of<Actor<Expr>(Arg0, Arg1, ..., ArgN)>::type`]
     [Result of the evaluation]
    ]
    [
     [`result_of::actor<Expr, Arg0, Arg1, ..., ArgN>::type`]
     [Result of the evaluation]
    ]
]

[heading Function Call Operators]

There are 2*N function call operators for 0 to N arguments (N == `PHOENIX_LIMIT`).
The actor class accepts the arguments and forwards the arguments to the default
evaluation action.

Additionally, there exist function call operators accepting permutations of const
and non-const references. These operators are created for all N <=
`PHOENIX_PERFECT_FORWARD_LIMIT` (which defaults to 3).

[def [$http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm]

[note *Forwarding Function Problem*

    There is a known issue with current C++ called the "__forwarding__".
    The problem is that given an arbitrary function `F`, using current C++
    language rules, one cannot create a forwarding function `FF` that
    transparently assumes the arguments of `F`.
]

[heading Context]

On an actor function call, before calling the evaluation function, the actor created a *context*.
This context consists of an `Environment` and an `Action` part. These contain all information
necessary to evaluate the given expression.

[table Context Concept Requirements
    [
     [Expression]
     [Semantics]
    ]
    [
     [`result_of::context<Env, Actions>::type`]
     [Type of a Context]
    ]
    [
     [`context(e, a)`]
     [A Context containing environment `e` and actions `a`]
    ]
    [
     [`result_of::env<Context>::type`]
     [Type of the contained Environment]
    ]
    [
     [`env(ctx)`]
     [The environment]
    ]
    [
     [`result_of::actions<Context>::type`]
     [Type of the contained Actions]
    ]
    [
     [`actions(ctx)`]
     [The actions]
    ]
]

[heading Environment]

[heading Actions]

[heading `evaluator`]

[heading `result_of::actor`]

[endsect]
