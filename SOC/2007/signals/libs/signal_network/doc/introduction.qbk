[section:introduction Introduction]

[section:dataflow Dataflow programming in C++]

[@http://en.wikipedia.org/wiki/Dataflow_language Dataflow languages] provide a programming paradigm
based on interconnected /components/ which process passing /data/.  In general,
this conceptually models data as something that originates from a source, flows through
a number of processing components that manipulate it (e.g., by changing it, duplicating, etc.),
and arrives at some final destination.  As such, the dataflow paradigm is most suitable when developing
applications that are themselves focused on the "flow" of data.

Perhaps the most readily available examples of a
dataflow-oriented applications come from the realm of [@http://en.wikipedia.org/wiki/Signal_processing
signal processing], e.g. a video signal processor which perhaps starts with a video input,
modifies it through a number of processing components (video filters), and finally
outputs it to a video display.

[heading A motivating example]

Let's take a simple real-time camera-input-displayed-on-the-screen application.  Suppose there are three
parts to the application - getting each image frame from the camera, processing the image in some way,
and displaying it on the screen. To see how we might arrive at a dataflow-oriented implementation
of this application, let's first begin with an imperative approach.  Such an implementation might
be structured as follows:

[$dataflow1.png]

Basically, the main program loop is a series of instructions which does this particular job.
If you wanted to be a little bit more object oriented, you could encapsulate all this functionality
into an Image class and just call the methods that do the right thing from the main program loop,
which would give you an object-oriented imperative solution.

However, let's take this a step further in the dataflow direction.  Video input libraries often provide callback
functionality which will deliver a video stream as a sequence of image frames given at the appropriate frame rate.
With this in mind, we do the following:

# implement a function which takes an image as input.
 # the function first invokes the image processing library function that modifies the image as appropriate
 # the function then invokes the GUI library function that displays the image
# register the function as a callback with the camera library
# the main program loop can relax and have some coffee.

The situation now looks something like this:

[$dataflow2.png]

So now, the image library is acting as a data/signal generator - it
generates images at a certain frame rate.  And the function we implemented seems to be
a signal consumer which can take an image, process it, and display it on the screen.  

This now employs the basic elements of the dataflow paradigm, but we could take it even further.
Instead of just having two components, one image signal generator and one signal consumer, how about this:

# implement a component which accepts an input image signal, modifies the image as appropriate, and then outputs
a signal with the modified image
# implement a component which receives an imput image signal and displays it on the screen
# connect the camera library input stream to the first component
# connect the first component to the second component
# the main program loop can relax and have some tea, or even take a nap.

The big picture now looks like the following:

[$dataflow3.png]

[heading Advantages]

There are already many programming paradigms supported by C++ (either directly or through
additional libraries), so let's examine what the advantages of the the dataflow paradigm might be.

First of all, [*dataflow programming is not exclusive of other techniques], so adopting the dataflow paradigm
does not hinder the use of other approaches.  In fact, in C++ it can't - since the components
themselves need to be implemented somehow, and we can't recursively define them
forever as finer and finer dataflow diagrams, the dataflow paradigm relies on other
programming techniques to do the underlying work.  Also, dataflow can only be a part of a complete
application implementation.  You can always "extend your fingers" from other parts of the program in order
to insert data into the dataflow, catch it on the other end, probe and adjust the components, etc.
You can think of it as working with electronic components and changing the connections, turning knobs,
flipping switches, or hanging over a circuit board and tinkering with it using, say, a multimeter and a
5V lead (just do it with care).

Second, [*dataflow promotes some good programming practices].  When developing processing components,
we have only the incoming data to deal with - with no requirements on where it is coming from.  Hence,
the developed components tend to be quite versatile and reusable.  In the above example, the image
processing component can be used with any image data generator - there is nothing inside the component
that says "get the image from the camera", or "get the image from this type of data source (where the
type is either a base class or a concept)".  It just does it's thing, no matter where the data is coming
from.

Third, when used in the right context, [*dataflow programming makes development and maintenance
very intuitive].  In the image processing example, say you don't want to process the image any more. You can
just connect the camera signal directly to the screen display and cut out
the image processing component.  Someone gives you a new video signal generator component you'd like to use as input
instead of the camera?  Just plug it in. Literally.

Fourth, [*dataflow-oriented programs can be divided between threads, processors, or computers more easily],
because the data dependencies are much more visible.  In the image processing example, say you have
the display on a different computer. You can just pass the connection to it through a network socket.
With the data flow clearly specified, it is much easier to distribute the work either manually or
even automatically (although the Signal Network library at the moment offers no such automatic functionality).

Finally, [*we are not to far from the advantages of a [@http://en.wikipedia.org/wiki/Visual_programming_language
visual programming language]], since the components and the connections have a natural graphical representation.
With a visaul development environment, programming becomes as easy as connecting components with connections
(again, the Signal Network library provides no visual programming functionality).

[heading Go with the flow?]

If you are interested in exploring the dataflow concept further, see

* generic approach to dataflow in C++.
* using Boost.Signals as a data transport mechanism.

[endsect][/dataflow]

[section:generic_dataflow A generic approach to dataflow]

[note A lot of the ideas in this section have come from discussions with Tobias Schwinger and Douglas Gregor,
whom I thank sincerely for their continuing help and suggestions.]

The Signal Network library started as a way to facilitate dataflow programming by
providing components and connections which allow large-scale use of Boost.Signals as a mechanism to
model the transfer of data between processing components.  However, during the planning, design and development
of the library, it became apparent that

* there are a lot of good ways to move data around, Boost.Signals being one of them
* there are generic properties of dataflow programs which do not depend on the data transport mechanism,
  and can be used to develop mechanism-independent dataflow code.

Hence, the Signal Network library is planned to be redesigned into a generic dataflow library (probably called
Dataflow), and offer individual mechanism-specific modules (the Signal Network library being one of them).

The design of the Dataflow library might look something like this:

[xinclude dataflow_table.xml]

The layers are a bottom-up hierarchy, with dependencies only on layers underneath.
The /support/ layer provides the necessary generic traits and functions required for generic code to work with mechanism-specific
components.  Each type of mechanism or component must specialize the elements of the support layer to work with the mechanism\/component.
The /connect/ layer provides the generic connect free function, which is then used by the /operators/ and
the envisioned /blueprint/ layer.  Each mechanism might have its own /mechanism-specific/ layer, on top of which a mechanism-specific
/component/ can be implemented.  As long as the support layer is implemented for the mechanism/component, the component should
work seamlesly with the rest of the dataflow library.

Essentially, the support layer is a very minimal layer implementing a generic and extensible intrusive directed graph
framework.  The blueprint layer could be implemented as a BGL graph over a hierarchy of classes with a common interface
(implemented using a base class with virtual methods) which provides serialization, instantiation, and (if applicable)
execution capability for an entire network.

[heading The different data transport mechanisms]

To explore the concept of generic dataflow in C++ further, let us take a step back and examine where the flow of data
happens in C++.  Rather informally, we can divide things as follows:

* on one hand, there is /data/ (variables, objects, etc...)
* on the other, there are /computational components/ (functions, methods, etc...)

Data can then be processed by the computational
components by applying the components to the data in some appropriate way.
There are several ways of providing data to the computational components:

* by placing it in a location where the component will read it
* by passing it as a parameter in a call
* (a combination of the above) by passing the location of the data as a parameter in a call

Similarly, there are several ways of getting data out of a computation component

* the component makes a function call that carries the data as a parameter
* the component places a value somewhere where it can be read
* the component returns it as a return value

Another important thing to note is that there is a separation between providing the data to a component, and invoking the
component.  In some cases, the two happen simoultaneously (when the data is passed and returned
via a function call), while in others invoking the computational component
can happen separately from providing the data (at least from a modeling perspective).
An example of the latter is a computational component which uses data stored in a particular location.
We can place the data in that location much before invoking the computational component.

The Signal Network library relies on moving the data via function parameters and return values.
Here, the Boost.Signals library is used to model these individual data channels which couple
the data transfer and the computational component invocation.  This is one possible dataflow-oriented
approach.

There is another approach, proposed by Tobias Schwinger, in which the computational components are
connected by "pins". Here, the data is communicated by
placing it in locations where the components will read it, and reading it
from locations where the components write them.  Also, rather than the components
activating each other, the network itself activates the components manually in an optimized
order/way.

Each of these approaches has different properties.  In the signal-based approach, the knowledge of the
network is local - each component knows about where its signals are going, but it knows nothing
of where the signals arriving at its own slots are coming from.  Unless we record how the network was
constructed, there is no "big picture" of what the complete network looks like.  Similarly,
the network is executed autonomously - the components invoke one another when appropriate, and
no external control mechanism is required.

In the pin-based approach, the situation is reversed.  There is a "big picture" of what the complete
network looks like, and the network control mechanism uses this information to decide when a component
should be invoked and to manage the data shared between the components via pins.  Global
knowledge of the network can be used for better optimization, serialization, etc.  However, it may
come at the price of some intrusiveness to the computation components.

[heading What's happening here for Google Summer of Code?]

Even though these the signal-based approach and pin-based approach are sufficiently different, they aim for the same goal:
a dataflow-oriented approach using the C++ language.  It is possible that an application
designed in a dataflow-oriented way could be implemented using either of the approaches,
that one approaches could be convertible to the other, or that using both approaches
simoultaneously is in fact the best solution.  Even though investigating the relationships
between these two frameworks, or implementing both, would be outside the scope of this
Google Summer of Code project, I believe it is worthwhile to keep the connections in
mind while designing and implementing the Signal Network library.

To this end, I have started implementing a very simple framework that is based on
phoenix2 actors, and uses straight pointers to indicate the flow of
data.  This is somewhat related to the pin-based approach (but much simpler and without the support for things
like buffer/pin management which Tobias has envisioned), so it is helping me see what tends to be similar accross
data transport mechanisms, and what tends to be different.  This additional framework, as well as the generic
Dataflow layers, will be committed to the repository shortly (mid-July), after I get a chance to integrate everything
in a joint design.

[endsect]

[section:signals Boost.Signals as a data transport mechanism]

Boost.Signals is an excellent building block for dataflow networks, as it provides support for
all of the essential elements - data transport through parameters and return values, combining
return values from multiple signal calls, component invocation, and reconfigurability through connection
and disconnection.

The Signal Network library uses Boost.Signals as the data transport mechanism in dataflow networks.
In addition, it provides two major elements that facilitate the building of large signals-based dataflow
networks:

* The __connect__ function and its associated operators which can be used to easily connect different kinds of components.
* A number of generic and specific components which can be extended and customized for use in particular dataflow networks.

[endsect]

[section:use When to use]

While the [link signal_network.introduction.dataflow dataflow] section hopefully convinced you
that there are circumstances in which a dataflow approach is useful, please keep in mind that
there are many circumstances in which this is not the case.

First, a dataflow approach really only makes sense when the underlying task is
really about the flow of data through the components that process it.  If you can't sketch a concise
data flow diagram which truly represents the application, the dataflow approach might not be the best option.
For example, if you are implementing a complicated algorithm which is really about the sequence of
instructions that need to be executed on the data (rather than the data going through well-defined and
self-contained processing components), you probably should't use the Signal Network library.
If you are working on an audio or video processing application, maybe you should.

Second, using signals as the underlying data transport mechanism makes the Signal Network library
inherently a run-time contraption.  Every signal sent results in a function call, and if the processing
components are so minute that the cost of the function calls overtakes the cost of the processing,
using the Signal Network library will cause a significant performance hit.

To sum up, consider using the Signal Network library when:

* The application can be modeled well through the flow of data; and
* The cost of the processing shadows the cost of the function calls that transport the data.

[endsect]

[section:fusion Signal Network and Boost.Fusion]

The components in the Signal Network library are implemented using __fusion__.  To use the
Signal Network library, you might benefit from the following if you're not familiar with fusion.

[heading Fused vs. unfused]
A simple C++ function object might look something like this:

    struct f
    {
        int operator()(int arg1, int &arg2, const std::string &arg3)
        {
            ...
        }
    }

The thing to note here is that there are three arguments (of types `int`, `int &`, and `const std::string &`
respectively), and that when the function object is invoked, they are passed separately:

    int x;
    std::string s;
    f()(1, x, s);
    
In the terminology of __fusion__, this function object is /unfused/.  This is in contrast to a /fused/
fuction object, which might look like this:

    struct fused_f
    {
        int operator()(fusion::vector<int, int &, const std::string &> &args)
        {
            ...
        }
    }

Basically, the difference is that the three arguments from the unfused version are now sent in a single
fusion container.  The benefit is that no matter how many "unfused" arguments there are, there is
always a single "fused" argument.  Hence, writing templates that deal with a variable number of arguments
becomes a lot simpler.

[heading Signal Network provides both fused and unfused components]

While writing the generic components provided in the Signal Network library benefits from using
__fusion__, your particular use case might not.  For this reason, every component provided
by the Signal Network library:

* can receive both fused and unfused signals
* has both a version that sends fused signals and a version that sends unfused signals.

The type of sent signal is provided as a template argument to the class, and the default value can be set
by defining `SIGNAL_NETWORK_DEFAULT_OUT` to either `unfused` or `fused` before including a sinal
network component.

For example,

    signals::storage<int (int, int &, const std::string &>), signals::unfused> unfused_storage;
    signals::storage<int (int, int &, const std::string &>), signals::fused> fused_storage;

In the above case, `unfused_storage` is similar to `f` above, and can be used as a slot
for signals which carry regular, unfused arguments.
On the other hand, `fused_storage` acts as a function object similar to `fused_f` above.
Hence, it can be used as a slot for signals which carry a fusion container as an argument.

[endsect][/fusion]

[section:namespace Namespace use]

Currently, everything in the Signal Network library is located in the `boost::signals` namespace.
All of the examples shown are assuming the use of

    using namespace boost;

[endsect]

[section:start Quick Start]

[note You may want to read the [link signal_network.introduction.namespace Namespace Use] and
[link signal_network.introduction.fusion Signal Network and Boost.Fusion] sections first.]

The Sigal Network library provides many common building block components for a
signal network.  The most basic is __storage__, which
can be used to store a value received through a signal, send it on, and/or retreive it.

By default, components in the library use `operator()` to receive a signal.
For example, __storage__ objects can receive
signals through [memberref boost::signals::storage::operator()(void) operator()()].
Upon receiving this signal, they will output their stored value through another signal.

The value stored inside a __storage__ object
can be retrieved via the [memberref boost::signals::storage::at() at()] method.

Using a few __storage__ objects, it is easy to
create a network using [funcref boost::signal_network::operator>>=() operator>>=]:
	
[table storage class use example
    [[fused][unfused]]
    [[[test_storage_fused]][[test_storage_unfused]]]
]

[heading Creating your own signal receiver (slot)]

The easiest way to create your own signal receiver which can be used with the Signal Network
library is to create a class with `operator()` of the signal signature you wish to receive.

For example, consider the signature `void()`.  This is the signature
of a function that returns void and takes no arguments.
A class that can receive signals of such a signature would be
defined as follows:

    class SignalVoidCounter
    #ifdef SIGNAL_NETWORK_TRACKABLE
        // Two base signals implementations are supported currently
        // (Boost.Signals by Doug Gregor and the
        // thread_safe_signals version under implementation by Frank Mori Hess).
        // SIGNAL_NETWORK_TRACKABLE is defined if you are using Boost.Signals
        // - in this case, we want to make our component trackable so that
        // it gets disconnected automatically when this object is destroyed.
        : public boost::signals::trackable
    #endif
    {
        volatile int cnt;
    public:
        SignalVoidCounter() : cnt(0) {}
        void operator()()
        {
            cnt++; // whenever a void() signal is received, increase the counter
        }
        int GetCount()
        {
            return cnt;
        }
    }; // end class SignalVoidCounter

The above class does something really simple - it receives signals of signature `void()`, and counts
how many it has received. While this functionality is actually covered by the library component __counter__,
it's a good introductory example.

If you read the section about [link signal_network.introduction.fusion Boost.Fusion], you will find out that the Signal Network
library works with both /fused/ and /unfused/ signals.  If you wanted the above to work with fused signals,
all you would need to do is add or substitute the following `operator()`:

    void operator()(const fusion::vector<> &)
    {
        cnt++; // whenever a void() signal is received, increase the counter
    }

You can now introduce this component into a signal network:

[table storage class use example
    [[fused][unfused]]
    [[``
        SignalVoidCounter counter;
        signals::storage<void()> storage;
        
        storage >>= counter;
        for (int i=0; i<33; i++)
            storage();
        
        assert(counter.GetCount());
    ``][``
        SignalVoidCounter counter;
        signals::storage<void(), signals::unfused> storage;
        
        storage >>= counter;
        for (int i=0; i<33; i++)
            storage();
        
        assert(counter.GetCount());
    ``]]
]

To proceed, you may want to look at

* Provided Signal Network library [link signal_network.components components].
* Creating your own in/out components using the __filter__ class.
* Using the [link signal_network.connections connection operators] to make connections.

[endsect][/start]

[endsect][/introduction]
