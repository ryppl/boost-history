[section Concepts]

[/To explore generic dataflow in C++, let us begin by examining where the flow of
data happens in C++.  Rather informally, we can divide things as follows:

* on one hand, there is data (variables, objects, etc...)
* on the other, there are computational elements (functions, methods, etc...)

Data can then be processed by the computational
elements by applying the elements to the data in some appropriate way.
There are several ways of providing data to the computational elements:

* by placing it in a location where the computational element will read it
* by passing it as a parameter in a call
* (a combination of the above) by passing the location of the data as a
parameter in a call

Similarly, there are several ways of getting data out of a computational element:

* the element makes a function call that carries the data as a parameter
* the element places a value somewhere where it can be read
* the element returns it as a return value

With the above in mind, let's informally introduce a few concepts related to dataflow
programming:]

[heading Mechanisms]

There are many different environments that offer dataflow-related functionality.
For example, [BoostSignals] offers transfer of data through function calls,
while [VTK] offers a number of classes which are meant to be connected in
a pipline (e.g., starting with the data source, manipulating it, and
finally displaying it on the screen).

[BoostSignals] and [VTK] are examples of different /mechanisms/ - particular
environments each offering their own, independent way of doing dataflow.
In the Dataflow library, everything is keyed through a mechanism type
tag, allowing different mechanisms to be specified independently, and
allowing a single component to support muliple mechanisms.

[heading Ports]

The fundamental point of data production or consumption is called a /port/.
Two complementary ports that produce / consume the same type of data (using
the same type of mechanism) can typically be connected/disconnected, or data
can be extracted from one port to another.

Depending on the data-transport mechanism used, a producer could be anything
that produces / provides data:  a POD variable, an object of a class type, or
a function that returns a value.  Similarly, a consumer could be anything
that consumes data - a function that takes an argument, a functor, etc.

Ports are captured more formally by the [PortConcept] concept.

[heading Components]

A /component/ is the fundamental data processing element of a dataflow
network.  It can have multiple ports, for example a video filter component
might have one consumer port (consuming video to be processed) and one
producer port (producing filtered video).

Typically, a component is embedded in a class, and the different [PortConcept]s
are accessible either through the class directly, or through its member
functions and variables.

[heading Proxies]

It is often the case that a component delegates its [PortConcept]
functionality to some other element.  For example, a
class that is a [DataflowSignals] component might delegate its
[ProducerPortConcept] functionality to a member boost::signal.  It can
do so by declaring itself a [ProxyProducerPortConcept] for the boost::signal.

[heading Port Operations]

To establish a flow of data in a dataflow program, we typically /connect/
producers and consumers using some type of /connection/. In C++, this is usually
done through a pointer-like mechanism.  For example, a boost::signal can be used
by a producer to dissiminate data to multiple consumers which have been
connected to the signal. Or, a consumer class might have a pointer to a variable
which it collects data from.

Operations between two ports such as /connect/, /connect_only/, /disconnect/,
and /extract/ are captured by the [BinaryOperable] concept.  Operations
on a single port such as /disconnect_all/ are covered by the [UnaryOperable]
concept.

[/
[heading Push and pull]

Components can be further categorized according to where the connection lies,
and what it points to.  If the producer contains the connection(s) which point
to the consumer(s) (say, a `boost::signal<void (int)>`), the producer is called a
/push producer/.  If the consumer contains the connection(s) which point to the
producer(s), the consumer is called a /pull consumer/.  A connection
between a push producer and a (non-pull) consumer is a /push connection/,
and a connection between a pull consumer and a (non-push) producer is a
/pull connection/.

Sometimes things get a little fuzzy - for example, a function
call can be used to transmit data through the arguments from the caller to the
callee.  However, the callee can transmit data back to the caller by returning
it.  Hence, an object which contains a boost::signal could be both a push
producer (which sends data through the signal argument) and a pull consumer
(which receives data through the signal return type).  If both directions
are being used to transmit data, a connection like this is called a /push and
pull connection/.

It is also possible that the producer points to the consumer and vice versa.
In this case, the connection is called a /bidirectional connection/.]

[heading Invocation]

Another important thing to note is that there is a separation between providing
the data to a component, and invoking the component.  In some cases, the two
happen simoultaneously (when the data is passed and returned via a function
call), while in others invoking the computational element can happen
separately from providing the data (at least from a modeling perspective).
An example of the latter is a consumer which uses data stored in
a particular location. We can place the data in that location much before
invoking the consumer.

We will call /invoking/ a component (producer or consumer) the action of
causing it to consume data from connected producers, and producing data
for connected consumers.

Invocation is captured more formally by the [InvocableConcept] concept.

[/An invocation is /forwarding/
if it causes the invoked producer to also invoke the consumer, or if it causes
the invoked consumer to invoke the producer.]


[section Mechanism]

[endsect][/mechanism]

[include port_concepts.qbk]

[section:binaryoperable BinaryOperable (Connectable, OnlyConnectable, Disconnectable, Extractable) ]

A [ProducerPortConcept] `P` and [ConsumerPortConcept] `C` are /BinaryOperable/
for a binary operation `O`, and mechanism `M`, if the implementation of
the binary operation `O` has been specialized for `M`, `P`, and `C`.

In this case,

* If `O` is operations::connect, `P` and `C` are [ConnectableConcept]
* If `O` is operations::connect_only, `P` and `C` are [OnlyConnectableConcept]
* If `O` is operations::disconnect, `P` and `C` are [DisconnectableConcept]
* If `O` is operations::extract, `P` and `C` are [ExtractableConcept]

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[P] [A [ProducerPortConcept] type.]]
    [[C] [A [ConsumerPortConcept] type.
     [footnote `P` and `C` are [ConnectableConcept]]
    [[p] [An object of type P.]]
    [[c] [An object of type C.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Connect]
        [`binary_operation<operations::connect, M>(p,c)`]
        [Any type]
        [
            Creates a lasting connection between the `p` and `c`.
        ]
    ]
    [
        [OnlyConnect]
        [`binary_operation<operations::connect_only, M>(p,c)`]
        [Any type]
        [
            Discards any lasting connections stored by `p` or `c`,
            and creates a lasting connection between `p` and `c`.
            Note that `p` or `c` could still be connected to other ports,
            as long as these connections are not stored in `p` or `c`.
        ]
    ]
    [
        [Disconnect]
        [`binary_operation<operations::disconnect, M>(p,c)`]
        [Any type]
        [
            Discards any existing connection between `p` and `c`.
        ]
    ]
    [
        [Extract]
        [`binary_operation<operations::extract, M>(p,c)`]
        [Any type]
        [
            Perfoms a one time transfer of data from `p` to `c`.
        ]
    ]
]

[endsect][/binaryoperable]

[section:unaryoperable UnnaryOperable (AllDisconnectable) ]

A [PortConcept] `P` is /UnnaryOperable/
for a unary operation `O`, and mechanism `M`, if the implementation of
the unnary operation `O` has been specialized for `M` and `P`

In this case,

* If `O` is operations::disconnect_all, `P` is [AllDisconnectable]

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[P] [A [PortConcept] type.]]
    [[p] [An object of type P.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Disconnect All]
        [`unnary_operation<operations::disconnect_all, M>(p)`]
        [Any type]
        [
            Destroys any connections stored by `p`.  
        ]
    ]
]

[endsect][/unaryoperable]

[section:componentoperable ComponentOperable (Invocable) ]

A [ComponentConcept] `P` is /ComponentOperable/
for a component operation `O`, and mechanism `M`, if the implementation of
the component operation `O` has been specialized for `M` and `P`

In this case,

* If `O` is operations::invoke, `P` is [Invocable]

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[C] [A [ComponentConcept] type.]]
    [[c] [An object of type P.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Invoke]
        [`component_operation<operations::invoke, M>(p)`]
        [Any type]
        [
            Invokes `c` - this typically causes a component to consume its
            input data and produce its output data as appropriate.  
        ]
    ]
]

[endsect][/unaryoperable]

[endsect][/concepts]