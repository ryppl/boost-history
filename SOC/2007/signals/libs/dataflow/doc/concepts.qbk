[section Concepts]

[/To explore generic dataflow in C++, let us begin by examining where the flow of
data happens in C++.  Rather informally, we can divide things as follows:

* on one hand, there is data (variables, objects, etc...)
* on the other, there are computational elements (functions, methods, etc...)

Data can then be processed by the computational
elements by applying the elements to the data in some appropriate way.
There are several ways of providing data to the computational elements:

* by placing it in a location where the computational element will read it
* by passing it as a parameter in a call
* (a combination of the above) by passing the location of the data as a
parameter in a call

Similarly, there are several ways of getting data out of a computational element:

* the element makes a function call that carries the data as a parameter
* the element places a value somewhere where it can be read
* the element returns it as a return value

With the above in mind, let's informally introduce a few concepts related to dataflow
programming:]

[heading Mechanisms]

There are many different environments that offer dataflow-related functionality.
For example, [BoostSignals] offers transfer of data through function calls,
while [VTK] offers a number of classes which are meant to be connected in
a pipline (e.g., starting with the data source, manipulating it, and
finally displaying it on the screen).

[BoostSignals] and [VTK] are examples of different /mechanisms/ - particular
environments each offering their own, independent way of doing dataflow.
In the Dataflow library, everything is keyed through a mechanism typename
tag, allowing different mechanisms to be specified independently, and
allowing a single component to support muliple mechanisms.

[heading Components]

We will call the fundamental processing elements of a dataflow program
/components/.  A component can have a number of connectable interfaces
(inputs\/outputs), which have two categories:

* /producers/, which produce data; and
* /consumers/, which consume data.

Depending on the data-transport mechanism used, a producer could be anything
that produces / provides data:  a POD variable, an object of a class type, or
a function that returns a value.  Similarly, a consumer could be anything
that consumes data - a function that takes an argument, a functor, etc.

Producers and consumers are captured more formally by the [ProducerConcept]
and [ConsumerConcept] concepts.  There is no concept directly corresponding to
a component, because a component is a more abstract notion - i.e., a component
is whatever makes sense for the application design.  Typically, though, a
component is embedded in a class, and the different [ProducerConcept]s
and [ConsumerConcept]s are accessible either through the class
directly, or through its member functions and variables.

[heading Proxies]

It is often the case that a component delegates its [ProducerConcept] or
[ConsumerConcept] functionality to some other element.  For example, a
class that is a [DataflowSignals] component might delegate its
[ProducerConcept] functionality to a member boost::signal.  It can
do so by declaring itself a [ProxyProducerConcept] for the boost::signal.

[heading Connections]

To establish a flow of data in a dataflow program, we typically /connect/
producers and consumers using some type of /connection/. In C++, this is usually
done through a pointer-like mechanism.  For example, a boost::signal can be used
by a producer to dissiminate data to multiple consumers which have been
connected to the signal. Or, a consumer class might have a pointer to a variable
which it collects data from.

Connectability is captured more formally by the [ConnectableConcept] concept.


[/
[heading Push and pull]

Components can be further categorized according to where the connection lies,
and what it points to.  If the producer contains the connection(s) which point
to the consumer(s) (say, a `boost::signal<void (int)>`), the producer is called a
/push producer/.  If the consumer contains the connection(s) which point to the
producer(s), the consumer is called a /pull consumer/.  A connection
between a push producer and a (non-pull) consumer is a /push connection/,
and a connection between a pull consumer and a (non-push) producer is a
/pull connection/.

Sometimes things get a little fuzzy - for example, a function
call can be used to transmit data through the arguments from the caller to the
callee.  However, the callee can transmit data back to the caller by returning
it.  Hence, an object which contains a boost::signal could be both a push
producer (which sends data through the signal argument) and a pull consumer
(which receives data through the signal return type).  If both directions
are being used to transmit data, a connection like this is called a /push and
pull connection/.

It is also possible that the producer points to the consumer and vice versa.
In this case, the connection is called a /bidirectional connection/.]

[heading Invocation]

Another important thing to note is that there is a separation between providing
the data to a component, and invoking the component.  In some cases, the two
happen simoultaneously (when the data is passed and returned via a function
call), while in others invoking the computational element can happen
separately from providing the data (at least from a modeling perspective).
An example of the latter is a consumer which uses data stored in
a particular location. We can place the data in that location much before
invoking the consumer.

We will call /invoking/ a component (producer or consumer) the action of
causing it to consume data from connected producers, and producing data
for connected consumers.

Invocation is captured more formally by the [InvocableConcept] concept.

[/An invocation is /forwarding/
if it causes the invoked producer to also invoke the consumer, or if it causes
the invoked consumer to invoke the producer.]


[section Mechanism]

[endsect][/mechanism]

[include producer_concepts.qbk]

[include consumer_concepts.qbk]

[section Invocable]

A type `T` is /invocable/ if it can be invoked to consume its inputs and/or
produce its outputs.

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[C] [An [InvocableConcept] type.]]
    [[c] [An object of type `P`.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Invocation]
        [`invoke(c)`
         [footnote `namespace boost::dataflow`,
         `namespace boost::signals`, `namespace boost::phoenix`]]
        [Any type]
        [
            *Semantics:* The component consumes data from connected producers,
            and makes produced data available to connected consumers.
            [footnote: This does not imply that it invokes any connected
            producers or consumers.].
        ]
    ]
    [
        [Invocable]
        [`is_invocable<P>::type`
         [footnote `namespace boost::dataflow`]]
        [mpl::true_ or boost::true_type]
        [
            *Semantics:* A trait encapsulating adherence to the
            [InvocableConcept] concept.
        ]
    ]
]

[endsect][/invocable]

[section Connectable]

A [ProducerConcept] `P` and [ConsumerConcept] `C` are /connectable/ if they
can be connected via the `connect` function.  Typically, this means that
they use the same underlying data transport mechanism, and produce / consume
the same data type.

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[P] [A [ProducerConcept] type.]]
    [[C] [A [ConsumerConcept] type.
     [footnote `P` and `C` are [ConnectableConcept]]
    [[p] [An object of type P.]]
    [[c] [An object of type C.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Connect]
        [`connect(p,c)`]
        [Any type]
        [
            *Semantics:* Creates a permanent connection between the producer
            and consumer.
            [footnote: This does not (yet) specify what happens to other
            existing connections out of `p` of into `c`.  They may or may
            not get modified of erased.].
        ]
    ]
[/    [
        [Compatible]
        [`mpl::has_key<consumed_types_of<C>::type, produced_type_of<P>::type>`]
        [`mpl::true_`]
        [
            *Semantics:* In order for two components to be connectable,
            the produced type must be an element of the consumed types.
        ]
    ] ]
]

[endsect][/connectable]

[section OnlyConnectable]

A [ProducerConcept] `P` and [ConsumerConcept] `C` are /connectable/ if they
can be connected via the `connect` function.  Typically, this means that
they use the same underlying data transport mechanism, and produce / consume
the same data type.

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[P] [A [ProducerConcept] type.]]
    [[C] [A [ConsumerConcept] type.
     [footnote `P` and `C` are [ConnectableConcept]]
    [[p] [An object of type P.]]
    [[c] [An object of type C.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Connect]
        [`connect(p,c)`]
        [Any type]
        [
            *Semantics:* Creates a permanent connection between the producer
            and consumer.
            [footnote: This does not (yet) specify what happens to other
            existing connections out of `p` of into `c`.  They may or may
            not get modified of erased.].
        ]
    ]
[/    [
        [Compatible]
        [`mpl::has_key<consumed_types_of<C>::type, produced_type_of<P>::type>`]
        [`mpl::true_`]
        [
            *Semantics:* In order for two components to be connectable,
            the produced type must be an element of the consumed types.
        ]
    ] ]
]

[endsect][/onlyconnectable]

[endsect][/concepts]