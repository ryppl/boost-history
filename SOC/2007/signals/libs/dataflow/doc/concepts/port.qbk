[section PortCategory]

A [PortCategoryConcept] designates a category of port in the Dataflow library.
The library currently defines two [PortCategoryConcept]s:

* `boost::dataflow::ports::producer`, and
* `boost::dataflow::ports::consumer`.

For a higher-level overview of the concepts, see the [concepts] introduction.

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[PC] [A [PortCategoryConcept] type.]]
]

[heading Requirements]

[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Opposite PortCategory]
        [`PC::complement`]
        [[PortCategoryConcept] type]
        [
            The complementing [PortCategoryConcept] of `PC`, meaning that it
            is possible to make connections between [PortConcept]s of
            [PortCategoryConcept] `PC` and [PortConcept]s of
            [PortCategoryConcept] `PC::complement`.
        ]
    ]
]

[heading Header]

The types, templates, and functions shown here are declared in the following
files:

```
    #include <boost/dataflow/support/port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[endsect][/portcategory]

[section PortTraits]

A ['[PortTraitsConcept]] specifies the traits of a [PortConcept].

[heading Notation]
[variablelist
    [[PT] [A PortTraits type.]]
    [[P] [A [PortConcept] type with port traits `PC`.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Mechanism]
        [`PT::mechanism`]
        [any type]
        [[MechanismConcept] type tag.]
    ]
    [
        [Port Category]
        [`PT::port_category`]
        [[PortCategoryConcept] type]
        [The category of the port]
    ]
    [
        [Port Concept]
        [`PT::port_concept`]
        [`concepts::port`, `concepts::keyed_port`]
        [The most refined producer concept that `P` satisfies.]
    ]
]

[heading Header]
The types, templates, and functions shown here are declared in the following
files:

```
    #include <boost/dataflow/support/port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[heading Notes]

[heading Examples]

The following code defines a port traits type for vtk_algorithm_output,
and associates it with this type. It is a part of
the [vtk_example example showing how to provide a VTK support layer].

[vtk_algorithm_output_producer]

[endsect][/porttraits]


[section:port Port (ProducerPort, ConsumerPort)]

A type `P` is a ['[PortConcept]] for a mechanism `M` and port category `PC`
if it specifies a [PortTraitsConcept] for that mechanism and port category.

In that case,

* If `PC` is `ports::producer`, then `P` is a [ProducerPortConcept]
* If `PC` If `ports::consumer`, then `P` is a [ConsumerPortConcept]

[heading Refinements]


[heading Notation]
The following expressions are used in this document:

[variablelist
    [[`P`] [A Port type.]]
    [[`M`] [A [MechanismConcept] type.]]
    [[`PC`] [A [PortCategoryConcept] type.]]
    [[`p`] [An object of type `P`]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Port Traits]
        [`port_traits_of<M, PC, P>::type`]
        [Any [PortTraitsConcept] type]
        [
            The [PortTraitsConcept] of the port.
        ]
    ]
    [
        [IsPort Trait]
        [`is_port<M, PC, P>::type`]
        [Boolean metafunction that evaluates to true]
        [
            A trait encapsulating adherence to the Port
            concept.
        ]
    ]
    [
        [Get Port]
        [`get_port<M,PC>()`]
        [`get_port_result_type<M,PC,P>::type`]
        [
            Returns the underlying port object.  With regular ports,
            this is typically a reference to `p`.  With [ProxyPortConcept]
            objects, it is typically the proxied port object.
        ]
    ]
]

[heading Header]
The types, templates, and functions shown here are declared in the following
files:

```
    #include <boost/dataflow/support/port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[heading Notes]

There is an intrusive as well as a non-intrusive way to register the
[PortTraitsConcept] of a type `P`, thereby making it a [PortConcept].

Non-intrusive registration is done by providing a specialization of
the `port_traits_of` template (either directly, or through the provided
macros DATAFLOW_PORT_TRAITS and DATAFLOW_PORT_TRAITS_ENABLE_IF).

Intrusive registration can be done by providing
a `P::port_traits` member type, which can be either a [PortTraitsConcept]
type, or an MPL sequence of [PortTraitsConcept] types. Alternatively,
the Dataflow library provides a convenience class
`port` which you can inherit instead of declaring the member type.

The below examples illustrate the avaliable registration methods.

[heading Examples]

All of the below examples use the following [MechanismConcept] and
[PortTraitsConcept] types:

[port_registration_example_prep]

[heading Intrusive registration]

Intrusive registration is the easiest, but assumes you can modify the
[PortConcept]:

[port_registration_example_intrusive]

[heading Non-intrusive registration]

Non-intrusive registration is done by specializing the `port_traits_of`
template.  Since the `port_traits_of` template is keyed by [MechanismConcept]
and [PortCategoryConcept], this is rather verbose:

[port_registration_example_non_intrusive]

To make things simpler, the Dataflow library provides a macro for non-intrusive
registration (the macro also performs a static check on the
[PortTraitsConcept]).

[port_registration_example_non_intrusive_macro]

[heading Non-intrusive mass registration]

The `port_traits_of` template has an Enable template parameter for use with
`boost::enable_if`.  Hence, we can register a number of types at the same time:

[port_registration_example_non_intrusive_enable_if]

And again, there is a convenient macro:

[port_registration_example_non_intrusive_enable_if_macro]

[heading Tests]

With the above registrations, the following tests pass:

[port_registration_check_example]

[endsect][/port]

[section ProxyPortTraits]


[endsect][/proxyporttraits]

[section ProxyPort]

A type `PP` is a ['[ProxyPortConcept]] for a mechanism `M` and port category `PC`
if it specifies a [ProxyPortTraitsConcept] for that mechanism and port category.

If the proxied port type is a valid
[PortConcept], then 'PP' satisfies the [PortConcept] requirements
in the same way.

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[PP] [A ProxyPort type.]]
    [[pp] [An object of type `PP`]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Proxy Port Traits]
        [`proxy_port_traits_of<PP>::type`]
        [[ProxyPortTraitsConcept] type.]
        [
            The traits of the proxy port.
        ]
    ]
]

[heading Header]
The types, templates, and functions shown here are declared in the following
files:

```
    #include <boost/dataflow/support/proxy_port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[heading Notes]

[heading Examples]

[endsect][/proxyport]

[section KeyedPort]
[endsect][/keyed_port]
