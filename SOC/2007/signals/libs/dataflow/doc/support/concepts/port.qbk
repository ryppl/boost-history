[section PortCategory]

A [PortCategory] designates a category of port in the Dataflow library.
The library currently defines two [PortCategory]s:

* `boost::dataflow::ports::producer`, and
* `boost::dataflow::ports::consumer`.

For a higher-level overview of the concepts, see the [concepts] introduction.

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[PC] [A [PortCategory] type.]]
]

[heading Requirements]

[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Complementing PortCategory]
        [`PC::complement`]
        [[PortCategory] type]
        [
            The complementing [PortCategory] of `PC`, meaning that it
            is possible to make connections between [Port]s of
            [PortCategory] `PC` and [Port]s of
            [PortCategory] `PC::complement`.
        ]
    ]
    [
        [Is PortCategory Trait]
        [[^[is_port_category]<T>::type]]
        [Boolean MPL Metafunction that evaulates to true]
        [
            Trait encapsulating adherence to the [PortCategory] concept.
        ]
    ]
]

[heading Header]

The types, templates, and functions shown here are declared in the following
files:

```
    #include <boost/dataflow/support/port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[endsect][/portcategory]

[section:port Port, PortTraits]

A ['[Port]] is the fundamental point of data production or consumption.
In order for a type `P` to satisfy the [Port] concept requirements,
a [PortTraits] type (specifying the traits of the port)
must be registered for the port.  Registration can be
performed in multiple ways (see the examples below).

[Port] concept
requirements are always relative to a particular [Tag], so a type
can be a [Port] for multiple [Tag]s.

[heading Port Refinements]

* [KeyedPort]
* [ComplementedPort]

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[`T`] [A [Tag] type. If omitted, `T` defaults to [default_tag].]]
    [[`PC`] [A [PortCategory] type.]]
    [[`P`] [A Port type, for [Tag] `T`.]]
    [[`PT`] [[PortTraits] of `P` for `T`.]]
    [[`p`] [An object of type `P`]]
]

[heading Port Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Port Traits]
        [[^[traits_of]<P, T>::type]]
        [`PT`]
        [
            The [PortTraits] of the port.
        ]
    ]
    [
        [IsPort Trait]
        [[^[is_port]<P, T>::type]]
        [Boolean metafunction that evaluates to true]
        [
            A trait encapsulating adherence to the Port
            concept.
        ]
    ]
    [
        [Get Default Port]
        [`get_default_port<D,M,T>(p)`]
        [p]
        [
            Returns the port object.
        ]
    ]
]

[heading PortTraits Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Port Category]
        [`PT::category`]
        [[PortCategory] type]
        [The category of the port]
    ]
    [
        [Port ]
        [`PT::concept`]
        [`concepts::port`, `concepts::keyed_port`, `concepts::complemented_port`]
        [The most refined producer concept that `P` satisfies.]
    ]
    [
        [Tag]
        [`PT::tag`]
        [any type]
        [[Tag] type tag.]
    ]
]

[heading Header]
The types, templates, and functions shown here are declared in the following
files:

```
    #include <boost/dataflow/support/port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[heading Models]
* [port]
* [port_traits]

[heading Notes]

There is an intrusive as well as a non-intrusive way to register the
[PortTraits] of a type `P`, thereby making it a [Port].

Non-intrusive registration is typically done by providing a specialization of
the [register_traits] template (either directly, or through the provided
macros [DATAFLOW_TRAITS] and [DATAFLOW_TRAITS_ENABLE_IF]).  This will
specialize [traits_of] for all cv-qualified versions of type `P`.
If cv-qualified versions of type `P` should have different [PortTraits]s,
[traits_of] should be specialized directly.

Intrusive registration can be done by providing
a `P::port_traits` member type, which can be either a [PortTraits]
type, or an MPL sequence of [PortTraits] types. Alternatively,
the Dataflow library provides a convenience class
`port` which you can inherit instead of declaring the member type.  This
provides the additional benefit of using the free functions in the
`boost::dataflow` namespace using ADL.

The below examples illustrate the avaliable registration methods.

[heading Examples]

All of the below examples use the following [Tag] and
[PortTraits] types:

[port_registration_example_prep]

[heading Intrusive registration]

Intrusive registration is the easiest, but assumes you can modify the
[Port]:

[port_registration_example_intrusive]

[heading Non-intrusive registration]

Non-intrusive registration is done by specializing the `register_traits`
template.  Since the `register_traits` template is keyed by [Tag]
and [PortCategory], this is rather verbose:

[port_registration_example_non_intrusive]

To make things simpler, the Dataflow library provides a macro for non-intrusive
registration (the macro also performs a static check on the
[PortTraits]).

[port_registration_example_non_intrusive_macro]

[heading Non-intrusive mass registration]

The [register_traits] template has an Enable template parameter for use with
`boost::enable_if`.  Hence, we can register a number of types at the same time:

[port_registration_example_non_intrusive_enable_if]

And again, there is a convenient macro:

[port_registration_example_non_intrusive_enable_if_macro]

[heading Tests]

With the above registrations, the following tests pass:

[port_registration_check_example]

[endsect][/port]


[section:complementedport ComplementedPort, ComplementedPortTraits]

A ComplementedPort `P` is a [Port] s.t. whenever it is
[BinaryOperable] with another [Port] `P2`, `P2` is
a particular type - `P`'s complement type.

[ComplementedPort]s are useful in situations where [Port] types
are [BinaryOperable] in a one-to-one fashion (a pair of [Port] types
are each other's port complements), or in a one-to-many fashion (a number
of [Port] types have the same complement port).  An example of the
latter is [DataflowSignals], where any `signal` of signature `T` has
a complement port of type `function<T>`, and can therefore model
[ComplementedPort], but `function<T>` is cannot because there are many `signal`
types to which it can be connected.

The traits of a [ComplementedPort] are captured by the
[ComplementedPortTraits], which refines the [PortTraits] with
an additional member type specifying the complement port type.

[heading ComplementedPort Refines]
* [Port]

[heading ComplementedPortTraits Refines]
* [PortTraits]

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[`T`] [A [Tag] type. If omitted, `T` defaults to [default_tag].]]
    [[`PC`] [A [PortCategory] type.]]
    [[`P`] [A [ComplementedPort] type, for [Tag] `T`.]]
    [[`PT`] [[ComplementedPortTraits] of `P` for `T`.]]
]

[heading ComplementedPort Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Port Traits]
        [`traits_of<M, PC, P>::type`]
        [`PT`]
        [
            The [ComplementedPortTraits] of the port.
        ]
    ]
]

[heading ComplementedPortTraits Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Complement Port Type]
        [`PT::complement_port_type`]
        [Any [Port] type]
        [
            The complement port type of `P`.  If `P` is 
            [BinaryOperable] with another port type `P2`, then `P2` must
            be `PT::complement_port_type`.
        ]
    ]
]

[heading Models]

* [complemented_port_traits]

[endsect]

[section:vectorport VectorPort, VectorPortTraits]

A [VectorPort] type `VP` is a [Port] that is composed of a number of
sub-[Port]s.

[heading VectorPort Refines]
* [Port]
* [PortVector]

[heading VectorPortTraits Refines]
* [PortTraits]
* [PortVectorTraits]


[endsect][/vectorport]

[section:keyedport KeyedPort, KeyedPortTraits]

A [KeyedPort] type `KP` is a [VectorPort] whose sub-[Port]s are accessible
by key.  Whenever a binary operation is performed between a [Port] of type `P`
and `KP`, it is forwarded to the binary operation between `P` and the 
sub-[Port] in `KP` keyed by the [PortTraits] of `P`.

[heading KeyedPort Refines]
* [VectorPort]

[heading VectorPortTraits Refines]
* [VectorPortTraits]

[endsect][/keyed_port]

[section ProxyPort, ProxyPortTraits]

A type `PP` is a ['[ProxyPort]] for a mechanism `M` and port category `PC`
if it specifies a [ProxyPortTraits] for that mechanism and port category.

If the proxied port type is a valid
[Port], then 'PP' satisfies the [Port] requirements
in the same way.

[heading Notation]
The following expressions are used in this document:

[variablelist
    [[PP] [A ProxyPort type.]]
    [[pp] [An object of type `PP`]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Semantics]]
    [
        [Proxy Port Traits]
        [`proxy_traits_of<PP>::type`]
        [[ProxyPortTraits] type.]
        [
            The traits of the proxy port.
        ]
    ]
]

[heading Header]
The types, templates, and functions shown here are declared in the following
files:

```
    #include <boost/dataflow/support/proxy_port.hpp> // or
    #include <boost/dataflow/support.hpp>
```

[heading Notes]

[heading Examples]

[endsect][/proxyport]

