[section Concepts]

[/To explore generic dataflow in C++, let us begin by examining where the flow of
data happens in C++.  Rather informally, we can divide things as follows:

* on one hand, there is data (variables, objects, etc...)
* on the other, there are computational elements (functions, methods, etc...)

Data can then be processed by the computational
elements by applying the elements to the data in some appropriate way.
There are several ways of providing data to the computational elements:

* by placing it in a location where the computational element will read it
* by passing it as a parameter in a call
* (a combination of the above) by passing the location of the data as a
parameter in a call

Similarly, there are several ways of getting data out of a computational element:

* the element makes a function call that carries the data as a parameter
* the element places a value somewhere where it can be read
* the element returns it as a return value

With the above in mind, let's informally introduce a few concepts related to dataflow
programming:]

[heading Mechanisms]

There are many different ways of transferring data in a dataflow detwork.
For example, [BoostSignals] offers transfer of data through function calls,
while [VTK] offers a number of classes which are meant to be connected in
a pipline (e.g., starting with the data source, manipulating it, and
finally displaying it on the screen).

[BoostSignals] and [VTK] are examples of different /mechanisms/ - particular
ways of performing data transfer.  A particular dataflow framework and/or its
Dataflow library support layer might use one or more mechanisms in its
implementation.

In the Dataflow library, most port related class templates are keyed through
a [Tag] type tag.  For example, the [DataflowSignals] layer
uses two mechanisms for its ports and related operations - one mechanism
is used for lasting connections between a `signal` and a `function`, while
another is used for one-time extractions of data.

[heading Ports]

The fundamental point of data production or consumption is called a /port/.
Two complementary ports that produce / consume the same type of data (using
the same type of mechanism) can typically be connected/disconnected, or data
can be extracted from one port to another.

Depending on the data-transport mechanism used, a producer port could be anything
that produces / provides data:  a POD variable, an object of a class type, or
a function that returns a value.  Similarly, a consumer port could be anything
that consumes data - a function that takes an argument, a functor, etc.

Ports are captured more formally by the [Port] concept.

[heading Components]

A /component/ is the fundamental data processing element of a dataflow
network.  It can have multiple ports, for example a video filter component
might have one consumer port (consuming video to be processed) and one
producer port (producing filtered video).

Typically, a component is embedded in a class, and the different [Port]s
are accessible either through the class directly, or through its member
functions and variables.

The Dataflow library also offers a [Component] concept, which is
intented to provide compile-time introspection and other operations.

[heading Proxies]

It is often the case that a port delegates its [Port]
functionality to some other element.  For example, a
class that is a [DataflowSignals] component might delegate its
producer [Port] functionality to a member boost::signal.  It can
do so by declaring itself a [ProxyProducerPort] for the boost::signal.

[heading Port Operations]

To establish a flow of data in a dataflow program, we typically /connect/
producers and consumers using some type of /connection/. In C++, this is usually
done through a pointer-like mechanism.  For example, a boost::signal can be used
by a producer to dissiminate data to multiple consumers which have been
connected to the signal. Or, a consumer class might have a pointer to a variable
which it collects data from.

Operations between two ports such as /connect/, /connect_only/, /disconnect/,
and /extract/ are captured by the [BinaryOperable] concept.  Operations
on a single port such as /disconnect_all/ are covered by the [UnaryOperable]
concept.

[/
[heading Push and pull]

Components can be further categorized according to where the connection lies,
and what it points to.  If the producer contains the connection(s) which point
to the consumer(s) (say, a `boost::signal<void (int)>`), the producer is called a
/push producer/.  If the consumer contains the connection(s) which point to the
producer(s), the consumer is called a /pull consumer/.  A connection
between a push producer and a (non-pull) consumer is a /push connection/,
and a connection between a pull consumer and a (non-push) producer is a
/pull connection/.

Sometimes things get a little fuzzy - for example, a function
call can be used to transmit data through the arguments from the caller to the
callee.  However, the callee can transmit data back to the caller by returning
it.  Hence, an object which contains a boost::signal could be both a push
producer (which sends data through the signal argument) and a pull consumer
(which receives data through the signal return type).  If both directions
are being used to transmit data, a connection like this is called a /push and
pull connection/.

It is also possible that the producer points to the consumer and vice versa.
In this case, the connection is called a /bidirectional connection/.]

[heading Invocation]

[/Another important thing to note is that there is a separation between providing
the data to a component, and invoking the component.  In some cases, the two
happen simultaneously (when the data is passed and returned via a function
call), while in others invoking the computational element can happen
separately from providing the data (at least from a modeling perspective).
An example of the latter is a consumer which uses data stored in
a particular location. We can place the data in that location much before
invoking the consumer.]

We will call /invoking/ a component (producer or consumer) the action of
causing it to consume data from connected producers, and producing data
for connected consumers.

Invocation is captured more formally by the [Invocable] concept.

[include general.qbk]

[section Port related]

[section Mechanism]

[note The Mechanism concept currently has no requirements.]

A Mechanism type is used to specify the mechanism when specializing or invoking
port-related Dataflow templates.  Each mechanism therefore has a corresponding
type tag.

[heading Examples]

The following code declares the [VTK] mechanism tag - it is a part of
the [vtk_example example showing how to provide a VTK support layer].

[vtk_tag]

[endsect][/mechanism]


[include port.qbk]

[include binary_operable.qbk]

[include unary_operable.qbk]

[endsect] [/port related]

[section Component related]

[include component.qbk]

[endsect][/component related]

[endsect][/concepts]
