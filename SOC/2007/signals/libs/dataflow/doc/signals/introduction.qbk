[section Introduction]

The [DataflowSignals] layer provides dataflow functionality based on function
calls - which is one of the fundamental ways of dataflow in C++ (the caller
can send data to the callee through parameters, and the callee can send
data back through return values or modified parameters).  If
you're not familiar with dataflow programming, you might want to read the
general [link dataflow.introduction general Dataflow library introduction].

For its data transport mechanism, [DataflowSignals] uses [BoostSignals]
which can be used to make lasting dataflow connections
based on function calls.  [DataflowSignals] provides the following
to facilitate signals-based dataflow networks:

* A number of useful general-purpose [components], and building blocks for
  implementing new components.
* Various [signals_freefunctions] for connecting and using components.

[section Quick Start]

[heading Signals and Functions]

The basic buliding blocks of [DataflowSignals] communication are
[boost_signal], serving as a producer of signals, and [boost_function],
serving as a consumer of signals.  A [boost_signal] can be permanently
connected to anything that can be pointed to by a [boost_function].

Here is a simple example that illustrates this:
[signal_function_connect]

If you are familiar with [BoostSignals], will notice that the [^connect]
free function is something new - it is provided by [DataflowSignals].
[DataflowSignals] offers other utilities that make connection making easier,
like the [bind_mem_fn] function which binds a member function to an object:

[signal_mem_fn_connect]

[heading Components]

In [DataflowSignals], [boost_signal] and [boost_function] are considered
['ports] (fundamental points of data production or consumption). 
Ports can be grouped together into components,
which serve as fundamental data processing elements with one or more inputs
and outputs (ports).

The typical incarnation of a component is a class, with one or more
[boost_signal]s as producer ports and any member function as a potential
consumer port.  While you can implement such classes any way you like, and use
functionality described above to connect signals of one object to member functions
of another, [DataflowSignals] offers some facilities that make things easier.

Here is a simple example that uses the [filter] and [consumer] classes, which
serve as a foundation for [DataflowSignals] components.  [filter] is best for
components that have an output signal, and [consumer] for components that only
have signal inputs.

[component_component_example]

[heading Chaining and Operators]

The above components either produce ([^producer_component]) or consume
([^consumer_component]) signals.  Let's see a
filter example which does both - and at the same time let's introduce connection
operators which make chaining of filters easier:

[component_component_component_example]

[heading Provided Components]

[DataflowSignals] provides many common building block components for a
signal-based dataflow network.  The most basic is [storage], which
can be used to store a value received through a signal, send it on, 
and/or retrieve it.

For example, when a [storage] object receives a signal through its `operator()`
(i.e., its `operator()` gets called), it will store the value of the arguments,
and depending on its state it might forward the signal onward.  When the
[storage] object's `send()` function is called (or the object is invoked via
the [invoke] function), the stored values will be sent to any connected
consumers.

The value stored inside a [storage] object
can be retrieved via the [memberref boost::signals::storage::at() at()] method.

Using a few [storage] objects, it is easy to
create a simple network:
	
[test_storage_unfused]

[/[heading Creating your own signal receiver (slot)]

The easiest way to create your own signal receiver which can be used with the
[DataflowSignals] library is to create a class with `operator()` of the signal
signature you wish to receive.

For example, consider the signature `void()`.  This is the signature
of a function that returns void and takes no arguments.
A class that can receive signals of such a signature would be
defined as follows:

[signal_void_counter]

The above class does something really simple - it receives signals of
signature `void()`, and counts how many it has received. While this
functionality is actually covered by the library component [counter],
it's a good introductory example.

You can now introduce this component into a signal network:

[signal_void_counter_main]

If you read the section about [link dataflow.introduction.fusion Boost.Fusion],
you will find out that the [DataflowSignals] library works with both
/fused/ and /unfused/ signals.  If you wanted the above to work with
fused signals, all you would need to do is add or substitute the following
`operator()`:

[fused_signal_void_counter]
[fused_signal_void_counter_main]]

To proceed, you may want to look at

* Some motivating [link dataflow.signals.introduction.examples examples].
* A [signals_tutorial] on several topics.
* Provided [DataflowSignals] layer [components].

[endsect][/start]

[include examples.qbk]

[include tutorial.qbk]

[section:fusion DataflowSignals and Boost.Fusion]

The [components] in the [DataflowSignals] layer are implemented using [fusion].
To use the [components], you don't need to know anything about [fusion], 
but for some advanced uses you might benefit from taking advantage of the fact
that [fusion] is under the hood.

If you're not familiar with fusion, here are a few basic concepts you might find
helpful in the context of [DataflowSignals]:

[heading Fused vs. unfused]
A simple C++ function object might look something like this:

    struct f
    {
        int operator()(int arg1, int &arg2, const std::string &arg3)
        {
            ...
        }
    }

The thing to note here is that there are three arguments (of types `int`, `int &`, and `const std::string &`
respectively), and that when the function object is invoked, they are passed separately:

    int x;
    std::string s;
    f()(1, x, s);
    
In the terminology of [fusion], this function object is /unfused/.  This is in contrast to a /fused/
fuction object, which might look like this:

    struct fused_f
    {
        int operator()(fusion::vector<int, int &, const std::string &> &args)
        {
            ...
        }
    }

Basically, the difference is that the three arguments from the unfused version are now sent in a single
fusion container.  The benefit is that no matter how many "unfused" arguments there are, there is
always a single "fused" argument.  Hence, writing templates that deal with a variable number of arguments
becomes a lot simpler.

[heading [DataflowSignals] provides both fused and unfused components]

While writing the generic components provided in the [DataflowSignals] module benefits from using
[fusion], your particular use case might not.  For this reason, every component provided
by the [DataflowSignals] module:

* can receive both fused and unfused signals
* has both a version that sends fused signals and a version that sends unfused signals.

The type of sent signal is provided as a template argument to the class, with
the default value being `unfused`.

For example,

    signals::storage<int (int, int &, const std::string &>), signals::unfused> unfused_storage;
    signals::storage<int (int, int &, const std::string &>)> unfused_storage_by_default;
    signals::storage<int (int, int &, const std::string &>), signals::fused> fused_storage;

In the above case, `unfused_storage` is similar to `f` above, and can be used as a slot
for signals which carry regular, unfused arguments.
On the other hand, `fused_storage` acts as a function object similar to `fused_f` above.
Hence, it can be used as a slot for signals which carry a fusion container as an argument.

[heading Examples mostly show unfused versions]

The examples shown in this documentation are mostly focused on the unfused
versions of the components, since a user starting with the library
is most likely to be using the library with unfused components.
In the vast majority of cases, when all of the
components used are library-provided components, the fused and unfused examples
are identical except for the specifications that the components should be fused
or unfused.

The biggest differences come into play when the examples
include user-implemented components - implementing a fused component can
be slightly (or greatly) different from implementing an unfused component.
In these situations, the documentation should state the differences in code
when using fused components.

[endsect][/fusion]


[endsect][/introduction]
