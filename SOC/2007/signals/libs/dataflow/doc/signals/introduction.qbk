[section Introduction]

[/The Signal Network library relies on moving the data via function parameters and return values.
Here, the Boost.Signals library is used to model these individual data channels which couple
the data transfer and the computational component invocation.  This is one possible dataflow-oriented
approach.

Each of these approaches has different properties.  In the signal-based approach, the knowledge of the
network is local - each component knows about where its signals are going, but it knows nothing
of where the signals arriving at its own slots are coming from.  Unless we record how the network was
constructed, there is no "big picture" of what the complete network looks like.  Similarly,
the network is executed autonomously - the components invoke one another when appropriate, and
no external control mechanism is required.]


[BoostSignals] is an excellent building block for dataflow networks,
as it provides support for all of the essential elements -
data transport through parameters and return values, combining
return values from multiple signal calls, component invocation,
and reconfigurability through connection and disconnection.

The [DataflowSignals] module uses [BoostSignals] as
the data transport mechanism in dataflow networks.
In addition, it provides two major contributions that facilitate the
building of large signals-based dataflow networks:

* Support for a number of types of components (functors, filters,
  member function slot selection), which can be used with
  the generic Dataflow functionality - such as the [connect] function and its
  associated operators which can be
  used to easily connect different kinds of components.
* A number of generic and specific components which can be extended
  and customized for use in particular dataflow networks.

[section Quick Start]

[DataflowSignals] provides many common building block components for a
signal-based dataflow network.  The most basic is [storage], which
can be used to store a value received through a signal, send it on, 
and/or retrieve it.

By default, components in the library use `operator()` to receive a signal.
For example, when a [storage] object receives a signal through its `operator()`
(i.e., its `operator()` gets called), it will store the value of the arguments,
and depending on its state it might forward the signal onward.  When the
[storage] object's `send()` function is called (or the object is invoked via
the `invoke()` function), the stored values will be sent to any connected
consumers.

The value stored inside a [storage] object
can be retrieved via the [memberref boost::signals::storage::at() at()] method.

Using a few [storage] objects, it is easy to
create a simple network using
[funcref boost::dataflow::operator>>=() operator>>=]:
	
[test_storage_unfused]

[heading Creating your own signal receiver (slot)]

The easiest way to create your own signal receiver which can be used with the
[DataflowSignals] library is to create a class with `operator()` of the signal
signature you wish to receive.

For example, consider the signature `void()`.  This is the signature
of a function that returns void and takes no arguments.
A class that can receive signals of such a signature would be
defined as follows:

[signal_void_counter]

The above class does something really simple - it receives signals of
signature `void()`, and counts how many it has received. While this
functionality is actually covered by the library component [counter],
it's a good introductory example.

You can now introduce this component into a signal network:

[signal_void_counter_main]

If you read the section about [link dataflow.introduction.fusion Boost.Fusion],
you will find out that the [DataflowSignals] library works with both
/fused/ and /unfused/ signals.  If you wanted the above to work with
fused signals, all you would need to do is add or substitute the following
`operator()`:

[fused_signal_void_counter]
[fused_signal_void_counter_main]

To proceed, you may want to look at

* Provided [DataflowSignals] module [link dataflow.components components].
* Creating your own in/out components using the [filter] class.
* Using the [link dataflow.connections connection operators] to make connections.

[endsect][/start]

[section Examples]

[section:pull Pull-based networks]

The [DataflowSignals] module was built with push-based networks in
mind (the data producer sends data through a signal), but it can also
be used for pull-based networks (the data consumer requests data through
a signal).

For example, the following component requests a value through a signal,
and returns twice the value:

[test_pull_classes]

This class can be connected using the usual [operators]:

[test_pull_unfused]

[endsect][/pull]

[section:disconnect Disconnecting]

Connections can be terminated in two ways.  One is through the "trackable"
mechanism of Boost.Signals, which will automatically destroy connections
to a trackable object when the object is destroyed.  The other
way is through the disconnect_all_slots method of the signal sender.

[test_disconnect_unfused]

[endsect][/disconnect]

[section:multiple_different Multiple slots of different signatures]

It is simple to have an object provide multiple slots through operator() functions
of different signatures.  The following class does so through providing unary slots
of different types:

[test_multi_type_classes]

[/The following class, on the other hand, uses slots of different number of arguments:

[test_multi_type_classes]]

In such cases, where the operator() functions differ in their signature,
standard connection operators will work out the correct connection:

[test_multi_args_unfused]

[endsect][/multiple_different]

[section:multiple_same Multiple inputs of the same signature]

In some cases, a class may want to receive multiple signals of the same
signature.  [/For example, the following class can receive a void() signal
through its inherited operator() function, as well as through the
operator() function of member "other":

[test_same_type_class1]

For example, the following class could receive void() signals both
through operator() and through AltInput:

[test_same_type_classes]

The following example shows how to connect signals to all of the above slots.
For the class Signal2VoidInputs, this is accomplished using the
slot_selector function:

[test_same_type_unfused]

[endsect][/multiple_same]

[section:multi_out Multiple outputs]

Multiple outputs can be achieved by introducing additional signals in the class.

[test_multi_out_unfused]

The example uses the following classes:

[test_multi_out_classes]

[endsect][/multi_out]

[endsect][/examples]

[section:fusion DataflowSignals and Boost.Fusion]

The components in the [DataflowSignals] module are implemented using [fusion].  To use the
[DataflowSignals] module, you might benefit from the following if you're not familiar with fusion.

[heading Fused vs. unfused]
A simple C++ function object might look something like this:

    struct f
    {
        int operator()(int arg1, int &arg2, const std::string &arg3)
        {
            ...
        }
    }

The thing to note here is that there are three arguments (of types `int`, `int &`, and `const std::string &`
respectively), and that when the function object is invoked, they are passed separately:

    int x;
    std::string s;
    f()(1, x, s);
    
In the terminology of [fusion], this function object is /unfused/.  This is in contrast to a /fused/
fuction object, which might look like this:

    struct fused_f
    {
        int operator()(fusion::vector<int, int &, const std::string &> &args)
        {
            ...
        }
    }

Basically, the difference is that the three arguments from the unfused version are now sent in a single
fusion container.  The benefit is that no matter how many "unfused" arguments there are, there is
always a single "fused" argument.  Hence, writing templates that deal with a variable number of arguments
becomes a lot simpler.

[heading [DataflowSignals] provides both fused and unfused components]

While writing the generic components provided in the [DataflowSignals] module benefits from using
[fusion], your particular use case might not.  For this reason, every component provided
by the [DataflowSignals] module:

* can receive both fused and unfused signals
* has both a version that sends fused signals and a version that sends unfused signals.

The type of sent signal is provided as a template argument to the class, with
the default value being `unfused`.

For example,

    signals::storage<int (int, int &, const std::string &>), signals::unfused> unfused_storage;
    signals::storage<int (int, int &, const std::string &>)> unfused_storage_by_default;
    signals::storage<int (int, int &, const std::string &>), signals::fused> fused_storage;

In the above case, `unfused_storage` is similar to `f` above, and can be used as a slot
for signals which carry regular, unfused arguments.
On the other hand, `fused_storage` acts as a function object similar to `fused_f` above.
Hence, it can be used as a slot for signals which carry a fusion container as an argument.

[heading Examples mostly show unfused versions]

The examples shown in this documentation are mostly focused on the unfused
versions of the components, since a user starting with the library
is most likely to be using the library with unfused components.
In the vast majority of cases, when all of the
components used are library-provided components, the fused and unfused examples
are identical except for the specifications that the components should be fused
or unfused.

The biggest differences come into play when the examples
include user-implemented components - implementing a fused component can
be slightly (or greatly) different from implementing an unfused component.
In these situations, the documentation should state the differences in code
when using fused components.

[endsect][/fusion]


[endsect][/introduction]
