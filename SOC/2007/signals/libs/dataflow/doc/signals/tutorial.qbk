[section Tutorial]

[section:pull Pull-based networks]

In [DataflowSignals], we have signal producers and signal consumers.
But note that the flow of data can go in both directions.  The caller (signal
producer) could be considered the data producer if it supplies data in the
provided arguments.  On the other hand, the callee (signal consumer) could be
considered the data producer if it returns data either in the return value or
through one of the parameters.

Most of the examples in this documentation focus on the former case, where
the signal producer is the data producer (this could also be called
a push-based network).  Here we will present an example of the latter case,
where the signal consumer is the data producer (i.e., a pull-based network).

The following component requests a value through a signal,
and returns twice the value:

[test_pull_classes]

This class can be connected using the usual [operators]:

[test_pull_unfused]

The [^value_at_slot<0>] member function returns a [boost_function] pointing to
the [^at<0>] member function of [storage].  Because we initalized [^generator]
with a value of [^1.0f], that is what [^at<0>] will return.  [^doubler] will
double that value and return [^2.0f].

[endsect][/pull]

[section:disconnect Disconnecting]

There are two ways to disconnect signals in [DataflowSignals].  One is the
[disconnect_all] function, which can be applied to any component based on
[filter], and will disconnect everything connected to the default output signal
of that component (it will not disconnect anything connected to the consumer
ports of that component).
The other way involves storing the [BoostSignals] connection object,
which is returned by the [connect] function.

Here is an example showing both:

[test_disconnect_unfused]

[endsect][/disconnect]

[section:multiple_different Multiple slots of different signatures]

It is simple to have an object provide multiple signal consumer ports through
operator() functions of different signatures.
Here is an example:

[test_multi_type_classes]

[/The following class, on the other hand, uses slots of different number of arguments:

[test_multi_type_classes]]

In such cases, where the operator() functions differ in their signature,
standard connection operators will work out the correct connection:

[test_multi_type_unfused]

[endsect][/disconnect]

[section:multiple_same Multiple inputs of the same signature]

In some cases, a class may want to receive multiple signals of the same
signature. For example, the following class could receive void() signals both
through operator() and through AltInput:

[test_same_type_classes]

The following example shows how to connect signals to all of the above slots.
For the class Signal2VoidInputs, this is accomplished using the
[bind_mem_fn] function:

[test_same_type_unfused]

[endsect][/multiple_same]

[section:multi_out Multiple outputs]

The use of multiple outputs (signal producers) is not yet fully integrated
with the [filter] class.  Ideally, the [filter] class should allow you to
specify more than one signal output signature, but that feature is not available
yet.

In the meantime, multiple outputs can be achieved by introducing additional
signals in the class:

[test_multi_out_classes]

You can then connect the signal directly:

[test_multi_out_unfused]

[endsect][/multi_out]

[section:filterconsumercomponents Implementing new components using filter and consumer classes]

The easiest way to implement new [DataflowSignals] components is to inherit
[filter] or [consumer] classes.  Inherit the [filter] class when your component
needs an output, and the [consumer] class when you only need inputs.

Here is an example of simple classes which inherit [filter] or [consumer]:

[test_filter_classes]

With the components implemented, we can use them with the usual
[signals_freefunctions].

[test_filter_unfused]

[/The type of the output signal (in the above example, `signals::unfused`)
is specified as the second template parameter.
There are three options:

* `signals::unfused` provides an unfused output signal named `out`.
* `signals::output::fused` provides a fused output signal named `fused_out`.
* `signals::combined` provides an unfused output signal named `out`,
  and a fused adapter for the signal named `fused_out`.
  This is useful for components which wish to use fusion internally but output
  an unfused signal.

A component developed on top of the [filter] class can then be used in the
appropriate network.  Here is an example which uses the class defined above:

[test_filter_fused] ]

[endsect]

[section Threading]

[DataflowSignals] can be used in multi-threaded environments.  If you do so,
it is recommended you use [ThreadSafeSignals] rather than
[BoostSignals]. [ThreadSafeSignals] can be installed as a drop-in replacement
for [BoostSignals], but to use it with [DataflowSignals], you currently
need to use the following `#define`s before including any [DataflowSignals]
or [ThreadSafeSignals]/[BoostSignals] headers:

    #define signalslib signals
    #define signals signals

This will cause [ThreadSafeSignals] to use the `boost::signals` namespace, rather
than the `boost::signalslib` namespace it uses by default.

[heading Provided components]

[DataflowSignals] provides some components specifically intended for
multi-threaded applications.  These are:

* [mutex] (provides mutexing locking on incoming signals)
* [condition] (notifies a threading condition whenever a signal is received)
* [timed_generator] (periodically generates signals in its own thread)

The documentation pages for each of these components provide more information.

[heading Example of Creating a New Threadpool Component]

Here is an example of developing a new component specifically intended for
threading.  The component makes use of the [Threadpool] library by
Oliver Kowalke.  We will call it `async_component`.

The purpose of the component is to make a signal call asynchronous.  Instead
of the consumer component processing the signal immediately, the signal call
will be added to a thread pool and processed later.  `async_component` is
a class template, templated on the threadpool type, and the type of the
underlying component that will process the asynchronous signal.

Let's begin with the use code that this component will allow us to use.  The
three examples provided are:

* mixing synchronous and asynchronous signals
* assigning priorities to tasks / signals
* using asynchronous signals for cyclic networks

[heading mixing synchronous and asynchronous signals]

Our
first example will be just a simple network that involves both synchronous
and asynchronous filters.  The filters will use a simple function that
performs an increment:

[threadpool_component_example_use_inc_fn]

Here is the simple example:

[threadpool_component_example_use_simple]

And a sample output of a run (output contains `adding task` whenever a new
task has been added to the pool):

[pre
adding task
adding task
filter: 1
filter: 2
filter: 3
filter: 1
adding task
filter: 2
]

[heading assigning priorities to tasks / signals]

The second example involves a priority pool that allows us to specify the
priority of a task.  This example and the next will use the following filter
component, which just prints some texts, waits a little, and forwards the signal.
This example only uses the text printing capability of the component:

[threadpool_component_example_use_printer]

The example uses the priorities to enforce an order of execution that prints
a particular message:

[threadpool_component_example_use_priority]

The output is:

[pre
adding task
adding task
adding task
adding task
Hello
<>
World
!
]

[heading using asynchronous signals for cyclic networks]

The final example demonstrates the use of a threadpool and asynchronous signals
to allow cyclic networks.  The following example induces a cycle consisting
of `ticker1`, `ticker2`, and `ticker3`.

[threadpool_component_example_use_cyclic]

[pre
adding task
tick 1...
adding task
tick 2...
adding task
tick 3...
adding task
tick 1...
adding task
tick 2...
adding task
]

[heading async_component implementation]

Finally, for those interested, here is the implementation of the
`async_component` class template.  Since it operates on an underlying
component, the implementation is not trivial.  Nonetheless, the [DataflowSignals]
building blocks still allow the implementation to be rather concise, considering
that:

* `async_component` can be used on a numer of underlying components, regardless
    of signal signature.
* `async_component` works with both priority and non-priority thread pools.

[threadpool_component_example_implementation]

[endsect]

[endsect][/tutorial]
