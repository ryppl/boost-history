[section Rationale]

[heading Naming conventions]

* I encountered the term /dataflow/ after starting this library.  Although
  the information I can find about dataflow as
  a programming paradigm seems to be a little sub-par,
  it seems like the right name for this programming paradigm.
  As a part of developing this library and doing the accompanying research I
  can work on improving the information that is out there (on Wikipedia, etc.)
* I chose /component/ to refer to a processing element of a dataflow network,
  because the term has no prior (to my knowledge) C++ meaning.
* In differentiating ports that output data from those that input data,
  I originally thought about using "input"
  and "output".  However, I realized that "input" and "output"
  switch depending on perspective - from the perspective
  of a port, it is "output" if it outputs data, but from the perspective
  of a corresponding connection, that same port is the
  "input".  A better choice seemed to be /producer/ and /consumer/ as they don't
  suffer from the same problem.

[heading Implementation choices]

* Among various tag dispatch conventions, I chose to go with functor templates
  because of relative simplicity as well as integration with boost::result_of.
  Using a function might be another good alternative (as suggested
  [@http://www.boost.org/more/generic_programming.html#tag_dispatching here]),
  but might be problematic where the result type is not fixed (and in the
  future all of the operations will probably be modified to return a value
  where appropriate.
* Port operations (as parts of [BinaryOperable] and
  [UnaryOperable] concepts) have been rolled into a single class
  template with the operation selected by type because all of these operations
  share [ProxyPort] and (for [BinaryOperable]) [KeyedPort] 
  resolution.  [ComponentOperable] operations have been implemented
  the same way for consistency.
  
[endsect]
  
 