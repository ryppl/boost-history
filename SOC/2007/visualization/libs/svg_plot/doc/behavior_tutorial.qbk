[section:behavior Behavior]
[section:behavior_limits Numerical Limits]
All limits that are dealt with are double precision floating-point limits. 
Limits are detected when data is added to the plot by the call to the `plot()` method.

Currently, the line interpolation algorithms do not take limits into account,
so behavior may  be incorrect for such plots as `1 / x`.

Data at the limits are drawn as a circle with
`_stroke_color = lightgray` and `_fill_color = whitesmoke`.
This will become customizable.

[h4 NaN]
Any double precision floating-point numbers that return a nonzero value for the
function `_isnan(double)` is considered to be a NaN value. When plotted, the
number will appear in the user-defined coordinates as 0.

[h4 Infinity]

Any double precision floating point number that is equal to either of the 
following is considered to be Infinity:

  std::numeric_limits<double>::max()
  std::numeric_limits<double>::infinity()

When plotted, these values will appear at the *top* of your plot window.
If the plot window is not turned on,
these points will appear at the top of the graph.

[h4 Negative Infinity]

Any double precision floating point number that is equal to either of the 
following is considered to be Negative Infinity:

  std::numeric_limits<double>::min()
  -std::numeric_limits<double>::infinity()
  std::numeric_limits<double>::denorm_min()

When plotted, these values will appear at the *bottom* of your plot window.
If the plot window is not turned on,
these points will appear at the bottom of the graph.

Here is an example of numeric limits handling in action:

[$images/2d_limit.png] [\TODO this file is missing!]
[endsect] [/section:numerical_limits]

[section:behavior_stylesheets Stylesheets]
Stylesheets currently have only a single way of being used with the program: they are parsed by the `svg` class, and if the stylesheet parses correctly, they are loaded directly into the SVG file. I recognize that it may also be desired to link to an external stylesheet, but this presents a few problems.

* Both of the files now need to be transported with the produced document.
* Any user-provided function object that is used to convert between image formats now suddenly needs to be able to load the image format from an external source.

When the image converter portion of the project is completed, the image format function object will not be forced to deal with CSS. This is primarily a practical matter, and keeps simple an already difficult task. This will not preclude a method that extracts appropriate data from the CSS file and calls the appropriate functions. For example, if the user provides the following:

  #Background
  {
    fill : #FFF;
    stroke : #041010 ; 
  }

why shouldn't 

  my_plot.background_color(black);
  my_plot.background_border_color(svg_color(4, 16, 16));

be called?

[caution Please note that the language that is accepted by the parser is actually stricter than the real CSS standard allows for. Following GSoC, the parser will be reimplemented to reflect the parser suggested by the CSS standard. All identifiers (class, ID, or otherwise), must be the *one and only* identifier on the line. The following is not accepted:

  rect, circle
  {
    fill : #00FF00;
    stroke : #000000;
  }


But the following is:

``
rect
{
  fill : #00FF00;
  stroke : #00FF00;
}

circle
{
  fill : #00FF00;
  stroke : #00FF00;
}
``

None of the power of CSS is compromised (I believe), but it becomes more verbose.
] [/caution]

[endsect] [/section:behavior_stylesheets]
[endsect] [/section:behavior Behavior]
