This is the todo list for the Bigint project.

The project is divided into 2 parts - 'base' and 'extra features'. Base contains everything that has to be done anyway.
Extra features contain features that will possibly be done if the time permits. Some of extra features obviously will not
make it to the SoC deadline or perhaps even never.

When the 'base' part will be near completion, the extra features list will be sorted by priority, now it is in random order.

Base part.

Feature name									Deadline		Status
------------									--------		------
1. Bigint interface (header)					21 May			Awaiting resolution
2. GMP implementation							21 May			In progress
3. Correctness tests							7 June			N/A
4. Documentation								21 June			N/A
5. Performance tests							7 July			N/A
4. Interface for storage						14 July			N/A
5. Storage implementation						14 July			N/A
6. Default implementation						30 July			N/A

Note that perhaps some features will be completed before the deadline and probably some features will not make the deadline,
and instead be finished several days later. So the list is by no means static.

Detailed information.

1. Bigint interface (header)

+ conversion from string with different bases (2-36, use 26 letters + 10 digits)
Status: implemented

+ investigate Infinite Precision Integer for Library Technical Report 2 Draft by M.Kronenburg@inter.nl.net
Status: investigated, did not like the design decision, did not find anything useful apart from that
Jeffs opinion: be careful, the way in which the library uses inheritance is dead on arrival

+ wide string support
Status: implemented ctors, wstr function and proper << >> for streams (including different output/input flags (hex/oct/dec))

+ uint64_t / int64_t - is it possible to implement 4 ctors (int/uint + same for 64 bit) to make it always work?
Status: compiles ok on msvc and gcc

+ safe bool conversion
Status: implemented

+ extend implementation interface for efficient operator!() and safe bool
Status: implemented

* make sure it works on a wide range of compilers (test framework setup is needed)
Status: made some setup, it works for me but: 1. linking gmp is done via a hack, 2. not sure it works for others :/

+ converting to/from string - there was a suggestion to use static functions
My opinion: performance wise it is the same if compiler has NRVO support, and ctors/member functions are more convenient
Status: leaving it as is for now. Changing it later it trivial anyway.

+ make the bigint typedef depend on the available implementations (choose the most advanced instead of default one)
My opinion: seems worthwhile
Status: implemented

+ remove warnings for both MSVC and GCC
Status: all non-GMP-implementation-specific warnings were fixed

2. GMP implementation

+ conversion from string with different bases (2-36, use 26 letters + 10 digits)
Status: implemented

+ wide string support
Status: implemented conversion to both strings and wide strings

+ revise bigint->string conversion, it is not standard-compliant (std::string is not required to be contiguous)
Status: fixed

+ proper 64-bit support for converting to bigint (implement one of suggestions given for the request at gmp devlist)
Status: implemented

+ proper lshift, rshift and pow functions (work in case of large exponents/bit counts)
Status: implemented

+ bug fix: problems with unit tests (not all of can_convert_to pass)
Status: fixed

+ proper converting to numbers (including 64-bit)
Status: implemented

+ check semantics of bitwise and shift operations for negative numbers
Status: investigated, bitwise and shift operations behave as if numbers were 2-complement (as expected).

+ what if there is not enough memory for the request - what happens then? Investigate.
Status: investigated. abort() is called in this case. The solution for this is complex - read below.

- remove warnings for both MSVC and GCC
Status: needs fixing

3. Correctness tests

+ test all ctors for numbers
Status: implemented

- test all ctors for strings (various bases - 2, 9, 18, 27, 36)
Status: needs implementing

- test copy construction and assignment
Status: needs implementing

- test basic arithmetics and modulo (both op= and op) - bigint op/= bigint, bigint op/= number, number op bigint
Status: needs implementing

- test bit arithmetics - bigint op/= bigint, bigint op/= number, number op bigint (except << and >>)
Status: needs implementing

- test increment/decrement (postfix/prefix)
Status: needs implementing

- test unary operators (+, -, ~) - don't forget to check that -0 == 0
Status: needs implementing

- test bool conversion and operator!
Status: needs implementing

- test string conversion (various bases - 2, 9, 18, 27, 36)
Status: needs implementing

- test can_convert_to (char, short, int, int64 - both signed and unsigned, boundary cases)
Status: needs implementing

- test to_number (char, short, int, int64 - both signed and unsigned, boundary cases)
Status: needs implementing

- test comparison operators
Status: needs implementing

- test abs, pow, ldiv, sqrt
Status: needs implementing

- test stream input/output
Status: needs implementing

- test serialization
Status: needs implementing

-----------------------------------------------

Problem: GMP calls abort() when failing to allocate memory.

Solution: GMP allocates memory in various places - mainly temporary storage and limb allocation. I don't know for now if limb
allocation will be a problem (because if an extra feature "make GMP work with arbitrary storage strategy" is implemented,
all limb allocation will be done by bigint library). Temporary storage allocation is a problem. Just providing own allocation
functions to GMP and having them throw an exception is not a generic solution, because GMP is not exception safe. However, it
may be a solution IF own allocation is performed - depends on where allocations are done - needs further investigation.

Alternatively, only parts of GMP that actually are thread safe may be rewritten (if they do not include system layer (mpn), of
course).

-----------------------------------------------
Extra features:

- expression templates for base class (should be done so that this does not affect any implementation)
- advanced algorithms for default implementation
- make GMP work with arbitrary storage strategy (and perhaps enforce supporting arbitrary strategy in future implementations)
- getting several bits from an integer (say, 7 bits from 4859-th one). Perhaps, assigning several bits.
- conversion from/to floating point (float, double, long double)
