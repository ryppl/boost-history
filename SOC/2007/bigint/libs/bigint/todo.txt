This is the todo list for the Bigint project.

The project is divided into 2 parts - 'base' and 'extra features'. Base contains everything that has to be done anyway.
Extra features contain features that will possibly be done if the time permits. Some of extra features obviously will not
make it to the SoC deadline or perhaps even never.

When the 'base' part will be near completion, the extra features list will be sorted by priority, now it is in random order.

Base part.

Feature name									Deadline		Status
------------									--------		------
1. Bigint interface (header)					21 May			Awaiting resolution
2. GMP implementation							21 May			Awaiting resolution
3. Correctness tests							7 June			In progress
4. Documentation								21 June			In progress
5. Performance tests							7 July			In progress
6. Interface for storage						14 July			In progress
7. Storage implementation						14 July			In progress
8. Default implementation						30 July			Awaiting resolution
9. Advanced algorithms							N/A				In progress

Note that perhaps some features will be completed before the deadline and probably some features will not make the deadline,
and instead be finished several days later. So the list is by no means static.

Detailed information.

1. Bigint interface (header)

+ conversion from string with different bases (2-36, use 26 letters + 10 digits)
Status: implemented

+ investigate Infinite Precision Integer for Library Technical Report 2 Draft by M.Kronenburg@inter.nl.net
Status: investigated, did not like the design decision, did not find anything useful apart from that
Jeffs opinion: be careful, the way in which the library uses inheritance is dead on arrival

+ wide string support
Status: implemented ctors, wstr function and proper << >> for streams (including different output/input flags (hex/oct/dec))

+ uint64_t / int64_t - is it possible to implement 4 ctors (int/uint + same for 64 bit) to make it always work?
Status: compiles ok on msvc and gcc

+ safe bool conversion
Status: implemented

+ extend implementation interface for efficient operator!() and safe bool
Status: implemented

+ converting to/from string - there was a suggestion to use static functions
My opinion: performance wise it is the same if compiler has NRVO support, and ctors/member functions are more convenient
Status: leaving it as is for now. Changing it later it trivial anyway.

+ make the bigint typedef depend on the available implementations (choose the most advanced instead of default one)
My opinion: seems worthwhile
Status: implemented

+ remove warnings for both MSVC and GCC
Status: all non-GMP-implementation-specific warnings were fixed

* make sure it works on a wide range of compilers (test framework setup is needed)
Status: made some setup, it works for me but: 1. linking gmp is done via a hack, 2. not sure it works for others :/

+ stream output support: What modifiers do we need to support? Flags (skipws, etc.)?
Status: investigated. showpos ('+' for positive numbers), showbase, oct/dec/hex, uppercase, width, adjust, thousands separators

+ stream output support with all needed modifiers and other things
Status: implemented

+ stream input support: What modifiers do we need to support? Flags (skipws, etc.)?
Status: investigated. oct/dec/hex, skipws, correctly handle (check) separators, set bad state on invalid input, etc.

+ stream input support with all needed modifiers and other things
Status: implemented

2. GMP implementation

+ conversion from string with different bases (2-36, use 26 letters + 10 digits)
Status: implemented

+ wide string support
Status: implemented conversion to both strings and wide strings

+ revise bigint->string conversion, it is not standard-compliant (std::string is not required to be contiguous)
Status: fixed

+ proper 64-bit support for converting to bigint (implement one of suggestions given for the request at gmp devlist)
Status: implemented

+ proper lshift, rshift and pow functions (work in case of large exponents/bit counts)
Status: implemented

+ bug fix: problems with unit tests (not all of can_convert_to pass)
Status: fixed

+ proper converting to numbers (including 64-bit)
Status: implemented

+ check semantics of bitwise and shift operations for negative numbers
Status: investigated, bitwise and shift operations behave as if numbers were 2-complement (as expected).

+ what if there is not enough memory for the request - what happens then? Investigate.
Status: investigated. abort() is called in this case. The solution for this is complex - read below.

+ fix bug in wstr() - sometimes mpz_sizeinbase returns slightly bigger size
Status: fixed

+ fix bug in to_number() - fails for 64-bit integers
Status: fixed

+ fix bug in can_convert_to() - fails for boundary case (-2^63-1) for boost::int64_t
Status: fixed

+ fix division and remainder to truncating ones
Status: fixed

+ remove warnings for both MSVC and GCC
Status: fixed

3. Correctness tests

+ test all ctors for numbers
Status: implemented

+ test all ctors for strings (various bases - 2, 9, 18, 27, 36)
Status: implemented (merged with "test string conversion")

+ test string conversion (various bases - 2, 9, 18, 27, 36)
Status: implemented (merged with "test all ctors for strings")

+ test can_convert_to (char, short, int, int64 - both signed and unsigned, boundary cases)
Status: implemented

+ test to_number (char, short, int, int64 - both signed and unsigned, boundary cases)
Status: implemented

* test copy construction and assignment
Status: it's all over the place, no additional test needed

+ test basic arithmetics and modulo (both op= and op) - bigint op/= bigint, bigint op/= number, number op bigint
Status: implemented

+ test comparison operators
Status: implemented

+ test bit arithmetics - bigint op/= bigint, bigint op/= number, number op bigint (except << and >>)
Status: implemented

+ test increment/decrement (postfix/prefix)
Status: implemented

+ test unary operators (+, -, ~) - don't forget to check that -0 == 0
Status: implemented

+ test bool conversion and operator!
Status: implemented

+ test stream input/output
Status: implemented

+ test serialization
Status: implemented

+ test abs, pow, ldiv, sqrt
Status: implemented

* Is it possible to test cases when bigint must cause illegal operations (division by zero, sqrt(negative number))?
Status: investigated; there is no portable way

+ fix number_conversion test for gcc
Status: fixed

+ fix stream test for gcc (locale name)
Status: fixed

4. Documentation

- do we have to change the current behaviour for string conversions for bases outside [2, 36]?
Status: needs investigating & implementing

- provide accurate information for 'Performance' table

5. Performance tests

6. Interface for storage

- refactor
Status: needs implementing

- do we need push_back?
Status: needs investigation

- perhaps move bool negative to storage?
Status: needs investigation

7. Storage implementation

+ implement stack based fixed capacity storage; add corresponding tests
Status: implemented

- implement all functionality for vector-based interface as set by interface requirements
Status: needs implementing

8. Default implementation

+ conversion from string with different bases (2-36, use 26 letters + 10 digits)
Status: implemented

+ wide string support
Status: implemented conversion to both strings and wide strings

+ proper 64-bit support for converting to bigint
Status: implemented

+ proper converting to numbers (including 64-bit)
Status: implemented

+ comparison operators
Status: implemented

+ abs function
Status: implemented

+ unary operators (+, -, ~, ++, --)
Status: implemented

+ linear arithmetic operators (+, -)
Status: implemented

+ bitwise operators (&, |, ^)
Status: implemented

+ multiplication (*)
Status: implemented

+ bitwise shifts (<<, >>)
Status: implemented

+ pow function
Status: implemented

+ sqrt function
Status: implemented

+ division (/, %, div function)
Status: implemented

+ make implementation parametrizable by config structure, make a default structure
Status: implemented

+ add limb=unsigned char, limb=unsigned short tests
Status: implemented

+ fix bug with bitwise operations for negative numbers
Status: fixed

+ optimize string conversion
Status: implemented; 6x speedup for fibonacci(10^6)

9. Advanced algorithms

- check modmul with either existing test or some other way
Status: needs checking

- perhaps support FFT with 3 primes for base = 2^32?
Status: needs investigation

- faster division algorithm (divide&conquer?)
Status: needs implementing

- faster number->string conversion
Status: needs implementing

-----------------------------------------------

Problem: GMP calls abort() when failing to allocate memory.

Solution: GMP allocates memory in various places - mainly temporary storage and limb allocation. I don't know for now if limb
allocation will be a problem (because if an extra feature "make GMP work with arbitrary storage strategy" is implemented,
all limb allocation will be done by bigint library). Temporary storage allocation is a problem. Just providing own allocation
functions to GMP and having them throw an exception is not a generic solution, because GMP is not exception safe. However, it
may be a solution IF own allocation is performed - depends on where allocations are done - needs further investigation.

Alternatively, only parts of GMP that actually are not exception safe may be rewritten (if they do not include system layer
(mpn), of course).

28.07.07. Further research showed that limb allocation in system layer (mpn) occurs for multiplication (Toom-3 and FFT),
string <-> number conversions, division, sqrt, and perhaps somewhere else :(

-----------------------------------------------
Extra features:

- expression templates for base class (should be done so that this does not affect any implementation)
- advanced algorithms for default implementation
- make GMP work with arbitrary storage strategy (and perhaps enforce supporting arbitrary strategy in future implementations)
- getting several bits from an integer (say, 7 bits from 4859-th one). Perhaps, assigning several bits.
- conversion from/to floating point (float, double, long double)
- other styles of division (for now there's only truncating; floor and/or ceil perhaps?) & modulo
- bigint relies on the presence of boost::uint64_t and therefore will not compile if there's no 64-bit integer support
