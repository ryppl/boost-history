/* Boost bigint_simple_test.cpp test file
 *
 * Copyright 2007 Arseny Kapoulkine
 *
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or
 * copy at http://www.boost.org/LICENSE_1_0.txt)
 */

#include <boost/test/included/test_exec_monitor.hpp>

#include <boost/bigint/bigint.hpp>

#include <sstream>

#pragma comment(lib, "libgmp-3.lib")

void test()
{
	using boost::bigint;

	bigint d = 1;
	d += 4;

	d = d + 4;
	d = d + bigint(4);

	bigint a = bigint("13849832498234928394234");
	bigint b = bigint("86150167501765071605765");

	bigint c = a + b;

	BOOST_CHECK_EQUAL(c++, bigint("99999999999999999999999"));
	BOOST_CHECK_EQUAL(c, bigint("100000000000000000000000"));
	
	b %= a;
	
	BOOST_CHECK_EQUAL(!(a / b), false);
	BOOST_CHECK(a);

	BOOST_CHECK_EQUAL(a * b, bigint("42258228219342334666689684483132205000478474"));
	BOOST_CHECK_EQUAL(!(a / b), false);
	BOOST_CHECK_EQUAL(a % b, bigint("1645142448812923432790"));

	BOOST_CHECK_EQUAL(a | b, bigint("13870766920526448295931"));
	BOOST_CHECK_EQUAL(a & b, bigint("3030238090063981338664"));
	BOOST_CHECK_EQUAL(a ^ b, bigint("10840528830462466957267"));
	
	BOOST_CHECK_EQUAL(a << 12323, bigint("542102098249986749607061519571712437763348176159925492860338324812862451062748301834300358893955924214291398289528071234870770920540068679648504405244609725595877694087181711589464970281190237822720982597241526910278729627339555141260216683162260790270555133230243685750849886077706112824982691026750032543520628041236131038372219879149399021103407396042643430393658920614488185593971356133453069385220038034941207515122799293682629906643286171207187404616248845482106634034813517983977167307433765472818329577229997488747283616703641670611646595745395370901211760583322742551698842006404069965544665889568049415037163875004958296653150527318156078627896922776413354643253226157671950111463028171722523799618682125882427419470653645835687232914717510049635309073479998741931868169345793531814080411950808012294094340807061215739615875519165711679347067984620223092939036577497088843140252940000294361156358363818787749588152649839308413500118107947356563203815510199725033799161341970392000134999715648030480017629608091647626374880219628913980977723131468884075893837359981544421925011652307548982740440063943612498364409299086470424635304623769283135339416664233460074733049233331902898105167913256687081800109398377902926718754078556734693983301455420636113096813132563609710348261700301803739092911694035096123036099895779498212490284354319795707342482938046860829313796398477110119321329213665442334879564947599451073990727008329450990614917846436835974565998008684077951113931379786102525582720461727384409583071798178232022934935670431485044082257280523541155852702818050528065423658101261316553574648956190026536335266172018379100674341957193285253419087832219014911366940601420513949574657389227561119154528021759456973905174249758168022272862585308957333778358987166870019201989984684482014308476341838378818782337549754588039854993418476776488191590773786938064786061204721927352373080898443936399322837852811689044465419850391316420027623356815981794249928037313291371481150307532069172721557236707781423871855544200582652518706840113321231836501909957678742982063586061152429641472049631621262018869878910187876904343082368364993466567902133591598751597425646378986596134742092938876543550460094220587582927337853482696133560059265771705759894711002662609319146194680785986889972779068381535895033309000907811918125496741679347264800165694182267867495891675040647977289191006567176929691463798702864298021446380446507043140511176357021789077519718850344270493578910806708300785693330355332213769884393636817373859000275095957822801325856470420016631497234276271460245915948501356721474373149445174096951588038446372840469109880114701396678774644425155501253929196198169544135308335579775158087163371947281877775331241538215212843219683704023607786852987422032334910052983266457159231742617081565035011004501935942393265927058662228313568152120291656387413589137597436506714921532630003485036379182211753550274746317387523496304703145089007729207865077433465070151328467762611731360380125992655536690611104760987721947987651052200490474467685344315603511565148128907900886854643373305490827988832857965982489788282339573097276547608904545269820140608635061243211688508065865415564489887520878115786887330460859916782610805213428984931292958242857552508803483374776140927180323134713226342853874523978900371318863698471909861423140464604309269071265335210720089276101171746349379219156670536008796216903162551900000164124244707346775377306633500136743133402111070612007697383513998143624055526721057240426797375334222177746493729517389043488959509605784317189782088070297384587362776609016571148764168858304798093182811678055912813300404454752102341916041445631171769468296541125975611633951795548330426208740683150262272"));
	BOOST_CHECK_EQUAL(a >> 34783, 0);
	
	BOOST_CHECK_EQUAL(b, bigint("3051172512355501240361"));
	
	BOOST_CHECK_EQUAL(sqrt(b), bigint("55237419493"));

	BOOST_CHECK_EQUAL(b.can_convert_to<short>(), false);

	boost::uint64_t ee = 0xffffffff;
	bigint e = bigint(ee + 1);

	bigint f = ee;

	BOOST_CHECK_EQUAL(e, bigint("4294967296"));

	unsigned short xx = 34;
	bigint g = xx;

	BOOST_CHECK_EQUAL(bigint(L"11011101", 2), bigint("221"));
	BOOST_CHECK_EQUAL(bigint("fF", 16), bigint("255"));

	BOOST_CHECK_EQUAL(bigint("5").str(2), "101");
	BOOST_CHECK(bigint("5").wstr(2) ==  L"101"); // if we use BOOST_CHECK_EQUAL here it complains about not being able to print log value

	std::ostringstream oss;
	oss << std::dec << bigint(10) << std::hex << bigint(10) << std::oct << bigint(10);

	BOOST_CHECK_EQUAL(oss.str(), "10a12");

	// can_convert_to
	BOOST_CHECK( bigint("127").can_convert_to<char>());
	BOOST_CHECK(!bigint("128").can_convert_to<char>());
	BOOST_CHECK(!bigint("129").can_convert_to<char>());

	BOOST_CHECK( bigint("-127").can_convert_to<char>());
	BOOST_CHECK( bigint("-128").can_convert_to<char>());
	BOOST_CHECK(!bigint("-129").can_convert_to<char>());

	BOOST_CHECK( bigint("127").can_convert_to<unsigned char>());
	BOOST_CHECK( bigint("128").can_convert_to<unsigned char>());
	BOOST_CHECK( bigint("129").can_convert_to<unsigned char>());

	BOOST_CHECK( bigint("255").can_convert_to<unsigned char>());
	BOOST_CHECK(!bigint("256").can_convert_to<unsigned char>());

	BOOST_CHECK( bigint("ffffffff", 16).can_convert_to<unsigned int>());
	BOOST_CHECK(!bigint("100000000", 16).can_convert_to<unsigned int>());

	BOOST_CHECK( bigint("7fffffff", 16).can_convert_to<int>());
	BOOST_CHECK(!bigint("80000000", 16).can_convert_to<int>());
	
	BOOST_CHECK( bigint("-7fffffff", 16).can_convert_to<int>());
	BOOST_CHECK( bigint("-80000000", 16).can_convert_to<int>());
	BOOST_CHECK(!bigint("-80000001", 16).can_convert_to<int>());
	
	BOOST_CHECK( bigint("ffffffff", 16).can_convert_to<boost::uint64_t>());
	BOOST_CHECK( bigint("100000000", 16).can_convert_to<boost::uint64_t>());

	BOOST_CHECK( bigint("7fffffff", 16).can_convert_to<boost::int64_t>());
	BOOST_CHECK( bigint("80000000", 16).can_convert_to<boost::int64_t>());
	
	BOOST_CHECK( bigint("-7fffffff", 16).can_convert_to<boost::int64_t>());
	BOOST_CHECK( bigint("-80000000", 16).can_convert_to<boost::int64_t>());
	BOOST_CHECK( bigint("-80000001", 16).can_convert_to<boost::int64_t>());

	BOOST_CHECK_EQUAL(bigint("ffffffff", 16).to_number<unsigned int>(), 0xffffffff);
	BOOST_CHECK_EQUAL(bigint("7fffffff", 16).to_number<int>(), 0x7fffffff);
	BOOST_CHECK_EQUAL(bigint("-80000000", 16).to_number<int>(), -static_cast<boost::int64_t>(0x80000000));
	
	// 3 == 11
	// -3 = 1....1101
	//      0...01101
	BOOST_CHECK_EQUAL((bigint("-3") | bigint("1101", 2)).str(2), "-11");
	BOOST_CHECK_EQUAL((bigint("-3") & bigint("1101", 2)).str(2), "1101");
	BOOST_CHECK_EQUAL((bigint("-3") ^ bigint("1101", 2)).str(2), "-10000");
	
	BOOST_CHECK_EQUAL(bigint("-1") << 5, -32);
	BOOST_CHECK_EQUAL(bigint("-33") >> 3, -5); // 33 is 100001, -33 is 1....1011111, >>3 is 1...1011, which is complement for 101
}

int test_main( int argc, char* argv[] )
{
  test();

  return 0;
}
