\section{forward\_\-hds\_\-concept.hpp File Reference}
\label{forward__hds__concept_8hpp}\index{forward_hds_concept.hpp@{forward\_\-hds\_\-concept.hpp}}
Forward HDS concept definition. 



\subsection{Detailed Description}
Forward HDS concept definition. 

\begin{Desc}
\item[Definition]This concept refines the HDSConcept, and specifies additional forward category to iterate over the HDS data structure, which means counter clockwise movement around the facet and clockwise movement around the vertex. Possible forward categories are next\_\-in\_\-facet, next\_\-at\_\-source, and next\_\-at\_\-target. Once one of these categories are given all others can be accessed with the help of the opposite of a halfedge.\end{Desc}
\begin{Desc}
\item[Refinement of]\begin{itemize}
\item HDSConcept\end{itemize}
\end{Desc}
\begin{Desc}
\item[Notation]\begin{itemize}
\item HDS A type that is a model of Forward\-HDSConcept\item hds A non-modifiable instance of HDS\item h,g Halfedge descriptors, of type X::halfedge\_\-descriptor\end{itemize}
\end{Desc}
\begin{Desc}
\item[Associated types]\begin{itemize}
\item hds\_\-traits$<$HDS$>$::halfedge\_\-descriptor: must be Default\-Constructible and Copy\-Constructible, Equality\-Comparable, Assignable.\item hds\_\-traits$<$HDS$>$::traversal\_\-category: must be convertible to hds\_\-traits$<$HDS$>$::forward\_\-traversal\_\-tag.\item hds\_\-traits$<$HDS$>$::forward\_\-category: Defines the pointer type for forward iteration.\end{itemize}
\end{Desc}
\begin{Desc}
\item[Definitions]\begin{itemize}
\item {\em halfedge\/} {\em descriptor\/} is a type that contains information to access the halfedge.\item {\em traversal\/} {\em category\/} is a type that contains information about the direction of the traversal, which is forward, backward or bidirectional. For forward hds concept, it has to be convertible to hds\_\-traits$<$HDS$>$::forward\_\-traversal\_\-tag.\item {\em forward\/} {\em category\/} defines the type of the forward iteration.\end{itemize}
\end{Desc}
\begin{Desc}
\item[Valid Expressions]\begin{itemize}
\item next\_\-in\_\-facet(hds,h) : Must return a value assignable to h.\item next\_\-at\_\-source(hds,h) : Must return a value assignable to h.\item next\_\-at\_\-target(hds,h) : Must return a value assignable to h.\end{itemize}
\end{Desc}
\begin{Desc}
\item[Expression Semantics]\begin{itemize}
\item next\_\-in\_\-facet(hds,h) : returns an halfedge descriptor to next halfedge in counter clockwise order around the facet.\item next\_\-at\_\-source(hds,h) : returns an halfedge descriptor to next halfedge in clockwise order around the source vertex.\item next\_\-at\_\-target(hds,h) : returns an halfedge descriptor to next halfedge in clockwise order around the target vertex.\end{itemize}
\end{Desc}
\begin{Desc}
\item[Complexity guarantees]\begin{itemize}
\item next\_\-in\_\-facet(hds,h) : Amortized constant time\item next\_\-at\_\-source(hds,h) : Amortized constant time\item next\_\-at\_\-target(hds,h) : Amortized constant time\end{itemize}
\end{Desc}
\begin{Desc}
\item[Invariants ]\begin{itemize}
\item next\_\-in\_\-facet(hds,h) == next\_\-at\_\-source(opposite(hds,h)) == opposite(next\_\-at\_\-target(hds,h))\item next\_\-at\_\-source(hds,h) == next\_\-in\_\-facet(opposite(hds,h)) == opposite(next\_\-at\_\-target(opposite(hds,h)))\item next\_\-at\_\-target(hds,h) == opposite(next\_\-in\_\-facet(hds,h)) == opposite(next\_\-at\_\-source(opposite(hds,h)))\end{itemize}
\end{Desc}
\begin{Desc}
\item[Concept-checking class]

\begin{Code}\begin{verbatim} template <class HDS> 
 struct ForwardHDSConcept {
   typedef typename hds_traits<HDS>::halfedge_descriptor halfedge_descriptor; 
   typedef typename hds_traits<HDS>::traversal_category traversal_category;
   typedef typename hds_traits<HDS>::forward_category forward_category;
    void constraints() {
       using namespace boost;
       function_requires<HDSConcept<HDS> >();
       function_requires<ConvertibleConcept<traversal_category
                                                ,forward_traversal_tag> >();  
       const bool is_valid_storage_tag =
          is_convertible<forward_category,next_at_source_tag>::value ||
          is_convertible<forward_category,next_at_target_tag>::value ||
          is_convertible<forward_category,next_in_facet_tag>::value;
       BOOST_STATIC_ASSERT( is_valid_storage_tag ); 
       // Error message could be improved
       h = next_in_facet(hds,h);
       h = next_at_source(hds,h);
       h = next_at_target(hds,h);
       const_constraints(hds);
    }
    void const_constraints(HDS const& hds){
       h = next_in_facet(hds,h);
       h = next_at_source(hds,h);
       h = next_at_target(hds,h);
    }
    ForwardHDS hds;
    halfedge_descriptor h;
    halfedge_descriptor g;
 };
\end{verbatim}\end{Code}

 \end{Desc}
