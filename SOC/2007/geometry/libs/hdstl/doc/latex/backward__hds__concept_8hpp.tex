\section{backward\_\-hds\_\-concept.hpp File Reference}
\label{backward__hds__concept_8hpp}\index{backward_hds_concept.hpp@{backward\_\-hds\_\-concept.hpp}}
Backward HDS concept definition. 



\subsection{Detailed Description}
Backward HDS concept definition. 

\begin{Desc}
\item[Definition]This concept refines the HDSConcept, and specifies additional backward category to iterate over the HDS data structure, which means clockwise movement around the facet and counter clockwise movement around the vertex. Possible backward categories are prev\_\-in\_\-facet, prev\_\-at\_\-source, and prev\_\-at\_\-target. Once one of these categories are given all others can be accessed with the help of the opposite of a halfedge.\end{Desc}
\begin{Desc}
\item[Refinement of]\begin{itemize}
\item HDSConcept\end{itemize}
\end{Desc}
\begin{Desc}
\item[Notation]\begin{itemize}
\item HDS A type that is a model of Backward\-HDSConcept\item hds A non-modifiable instance of HDS\item h,g Halfedge descriptors, of type X::halfedge\_\-descriptor\end{itemize}
\end{Desc}
\begin{Desc}
\item[Associated types]\begin{itemize}
\item hds\_\-traits$<$HDS$>$::halfedge\_\-descriptor: must be Default\-Constructible and Copy\-Constructible, Equality\-Comparable, Assignable.\item hds\_\-traits$<$HDS$>$::traversal\_\-category: must be convertible to hds\_\-traits$<$HDS$>$::backward\_\-traversal\_\-tag.\item hds\_\-traits$<$HDS$>$::backward\_\-category: Defines the pointer type for backward iteration.\end{itemize}
\end{Desc}
\begin{Desc}
\item[Definitions]\begin{itemize}
\item {\em halfedge\/} {\em descriptor\/} is a type that contains information to access the halfedge.\item {\em traversal\/} {\em category\/} is a type that contains information about the direction of the traversal, which is forward, backward or bidirectional. For backward hds concept, it has to be convertible to hds\_\-traits$<$HDS$>$::backward\_\-traversal\_\-tag.\item {\em backward\/} {\em category\/} defines the type of the backward iteration.\end{itemize}
\end{Desc}
\begin{Desc}
\item[Valid Expressions]\begin{itemize}
\item prev\_\-in\_\-facet(hds,h) : Must return a value assignable to h.\item prev\_\-at\_\-source(hds,h) : Must return a value assignable to h.\item prev\_\-at\_\-target(hds,h) : Must return a value assignable to h.\end{itemize}
\end{Desc}
\begin{Desc}
\item[Expression Semantics]\begin{itemize}
\item prev\_\-in\_\-facet(hds,h) : returns an halfedge descriptor to next halfedge in clockwise order around the facet.\item prev\_\-at\_\-source(hds,h) : returns an halfedge descriptor to next halfedge in counter clockwise order around the source vertex.\item prev\_\-at\_\-target(hds,h) : returns an halfedge descriptor to next halfedge in counter clockwise order around the target vertex.\end{itemize}
\end{Desc}
\begin{Desc}
\item[Complexity guarantees]\begin{itemize}
\item prev\_\-in\_\-facet(hds,h) : Amortized constant time\item prev\_\-at\_\-source(hds,h) : Amortized constant time\item prev\_\-at\_\-target(hds,h) : Amortized constant time\end{itemize}
\end{Desc}
\begin{Desc}
\item[Invariants ]\begin{itemize}
\item prev\_\-in\_\-facet(hds,h) == prev\_\-at\_\-target(opposite(hds,h)) == opposite(prev\_\-at\_\-source(hds,h))\item prev\_\-at\_\-source(hds,h) == opposite(prev\_\-in\_\-facet(hds,h)) == opposite(prev\_\-at\_\-target(opposite(hds,h)))\item prev\_\-at\_\-target(hds,h) == prev\_\-in\_\-facet(opposite(hds,h)) == opposite(prev\_\-at\_\-source(opposite(hds,h)))\end{itemize}
\end{Desc}
\begin{Desc}
\item[Concept-checking class]

\begin{Code}\begin{verbatim} template <class HDS> 
 struct BackwardHDSConcept {
   typedef typename hds_traits<HDS>::halfedge_descriptor halfedge_descriptor; 
   typedef typename hds_traits<HDS>::traversal_category traversal_category;
   typedef typename hds_traits<HDS>::backward_category backward_category;
    void constraints() {
       using namespace boost;
       function_requires<HDSConcept<HDS> >();
       function_requires<ConvertibleConcept<traversal_category,
                                                backward_traversal_tag> >();  
       const bool is_valid_storage_tag =
          is_convertible<backward_category,prev_at_source_tag>::value ||
          is_convertible<backward_category,prev_at_target_tag>::value ||
          is_convertible<backward_category,prev_in_facet_tag>::value;
       BOOST_STATIC_ASSERT( is_valid_storage_tag ); 
       // Error message could be improved
       h = prev_in_facet(hds,h);
       h = prev_at_source(hds,h);
       h = prev_at_target(hds,h);
       const_constraints(hds);
    }
    void const_constraints(HDS const& hds){
       h = prev_in_facet(hds,h);
       h = prev_at_source(hds,h);
       h = prev_at_target(hds,h);
    }
    BackwardHDS hds;
    halfedge_descriptor h;
    halfedge_descriptor g;
 };
\end{verbatim}\end{Code}

 \end{Desc}
