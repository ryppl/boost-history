<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mutable_hds_concept.hpp File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>mutable_hds_concept.hpp File Reference</h1>Mutable HDS concept definition. <a href="#_details">More...</a>
<p>

<p>
<a href="mutable__hds__concept_8hpp-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Mutable HDS concept definition. 
<p>
<dl compact><dt><b>Definition</b></dt><dd>This concept is the basic Mutable HDS concept, which all the other Mutable HDS concepts refine. It contains a few requirements which are common to all the graph concepts. One should note that a model of Mutable HDS is not required to be a model of Assignable, so algorithms should pass Mutable HDS objects by reference.</dd></dl>
<dl compact><dt><b>Refinement of:</b></dt><dd><ul>
<li>HDSConcept</li></ul>
</dd></dl>
<dl compact><dt><b>Notation</b></dt><dd><ul>
<li>HDS A type that is a model of MutableHDSConcept</li><li>hds A non-modifiable instance of HDS</li><li>h1,h2 Halfedge descriptors, of type X::halfedge_descriptor</li></ul>
</dd></dl>
<dl compact><dt><b>Associated types</b></dt><dd><ul>
<li>hds_traits&lt;HDS&gt;::halfedge_descriptor: must be DefaultConstructible and CopyConstructible, EqualityComparable, Assignable.</li></ul>
</dd></dl>
<dl compact><dt><b>Definitions</b></dt><dd><em>halfedge</em> <em>descriptor</em> is a type that contains information to access the halfedge. Note that the halfedge descriptor type (accessible as a member of the hds_traits&lt;HDS&gt; type) is an opaque type. All that can be done to it is passing it to the function opposite and letting the hds use the information it contains to find the opposite halfedge. In particular, there is no guarantee that it is a pointer type.</dd></dl>
<dl compact><dt><b>Valid Expressions</b></dt><dd><ul>
<li>set_opposite(hds,h1,h2): Sets the opposite halfedge.</li><li>h = new_edge(hds,h1,h2) : Creates a new edge, with two halfedges.</li><li>delete_edge(hds,h1,h2) : Deletes the edge defined by halfedge pairs h1 and h2.</li></ul>
</dd></dl>
<dl compact><dt><b>Expression Semantics</b></dt><dd><ul>
<li>set_opposite(hds,h1,h2): Sets h1 and h2 as opposites of each other in the data structure hds.</li><li>h = new_edge(hds,h1,h2): Creates a new edge in data structure hds. Since halfedges are actually pairs, the new edge consists of two halfedges, h1 and h2, which are set as opposites of each other.</li><li>delete_edge(hds,h1,h2): Since halfedges are defined as pairs, and a single halfedge is useless, they are deleted as pairs also. Delete edge removes the opposite halfedges h1, and h2 from the data structure hds. Note that only the halfedges that form a pair by validating the opposite function can be deleted by this method.</li></ul>
</dd></dl>
<dl compact><dt><b>Complexity guarantees</b></dt><dd><ul>
<li>set_opposite(hds,h1,h2): Amortized constant time.</li><li>new_edge(hds,h1,h2): Amortized constant time.</li><li>delete_edge(hds,h1,h2): Amortized constant time.</li></ul>
</dd></dl>
<dl compact><dt><b>Invariants</b></dt><dd><ul>
<li>After set_opposite and new_edge functions, h1=opposite(h2), and h2=opposite(h1) should be true.</li><li>Before the delete_edge method, h1=opposite(h2), and h2=opposite(h1) should be true.</li></ul>
</dd></dl>
<dl compact><dt><b>Concept-checking class</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> HDS&gt; 
 <span class="keyword">struct </span>MutableHDSConcept {
   <span class="keyword">typedef</span> <span class="keyword">typename</span> hds_traits&lt;HDS&gt;::halfedge_descriptor halfedge_descriptor; 
    <span class="keywordtype">void</span> constraints() {
       <span class="keyword">using namespace </span>boost;
       function_requires&lt;HDSConcept&lt;HDS&gt; &gt;();
       set_opposite(hds,h1,h2);
       h = new_edge(hds,h1,h2);
       delete_edge(hds,h1,h2);
       const_constraints(hds);
    }
    <span class="keywordtype">void</span> const_constraints(HDS <span class="keyword">const</span>&amp; hds) {
       set_opposite(hds,h1,h2);
       h = new_edge(hds,h1,h2);
       delete_edge(hds,h1,h2);
    }
    HDS hds;
    halfedge_descriptor h1;
    halfedge_descriptor h2;
 };
</pre></div> </dd></dl>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jun 11 02:25:33 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
