<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>HDSTL: Backward HDS concept</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="backwardhds">Backward HDS concept</a></h1><h2><a class="anchor" name="refbackwardhds1">
Definition</a></h2>
This concept refines the <code>HDSConcept</code>, and specifies additional backward category to iterate over the <code>HDS</code> data structure, which means clockwise movement around the facet and counter clockwise movement around the vertex. Possible backward categories are <code>prev_in_facet</code>, <code>prev_at_source</code>, and <code>prev_at_target</code>. Once one of these categories are given all others can be accessed with the help of the <code>opposite</code> of a halfedge (see the section "Invariants" below for the algebraic relations that must hold).<h2><a class="anchor" name="refbackwardhds2">
Refinement of</a></h2>
<ul>
<li><code>HDSConcept</code></li></ul>
<h2><a class="anchor" name="refbackwardhds3">
Notation</a></h2>
<ul>
<li><code>HDS</code> A type that is a model of <code>BackwardHDSConcept</code></li><li><code>hds</code> A non-modifiable instance of <code>HDS</code></li><li><code>h</code>,<code>g</code> Halfedge descriptors, of type <code>hds_traits&lt;HDS&gt;::halfedge_descriptor</code></li></ul>
<h2><a class="anchor" name="refbackwardhds4">
Associated types</a></h2>
<ul>
<li><code>hds_traits&lt;HDS&gt;::halfedge_descriptor</code>: from <code>HDSConcept</code>.</li><li><code>hds_traits&lt;HDS&gt;::traversal_category</code>: from <code>HDSConcept</code>, with additional requirement that this type must be convertible to <code>hdstl::backward_traversal_tag</code>.</li><li><code>hds_traits&lt;HDS&gt;::backward_category</code>: defines the pointer type for backward iteration.</li></ul>
<h2><a class="anchor" name="refbackwardhds5">
Definitions</a></h2>
<ul>
<li><code>halfedge_descriptor</code> is a type that contains information to access the halfedge. (See the <code>HDS</code> concept or a full definition.)</li><li><code>traversal_category</code> is a type that contains information about the direction of the traversal, which is forward, backward or bidirectional. For this <code>BackwardHDS</code> concept, the <code>traversal_category</code> has to be convertible to the <code>hdstl::backward_traversal_tag</code> type defined in <code>&lt;boost/hdstl.hpp&gt;</code>.</li><li><code>backward_category</code> defines the primary accessor of the backward information for use by algorithms which desire the most direct access.</li></ul>
<h2><a class="anchor" name="refbackwardhds6">
Valid Expressions</a></h2>
In addition to the valid expressions of the <code>HDS</code> concept:<ul>
<li><code>prev_in_facet(hds,h)</code> must return a value assignable to h.</li><li><code>prev_at_source(hds,h)</code> must return a value assignable to h.</li><li><code>prev_at_target(hds,h)</code> must return a value assignable to h.</li></ul>
<h2><a class="anchor" name="refbackwardhds7">
Expression Semantics</a></h2>
In addition to the expression semantics of the <code>HDS</code> concept:<ul>
<li><code>prev_in_facet(hds,h)</code> returns a halfedge descriptor to the halfedge preceding <code>h</code> in the adjacent facet cycle, when facet cycles are oriented in counter-clockwise order.</li><li><code>prev_at_source(hds,h)</code> returns a halfedge descriptor to the halfedge preceding <code>h</code> around the source vertex of <code>h</code>, when halfedges are ordered around a given vertex in clockwise order.</li><li><code>prev_at_target(hds,h)</code> returns a halfedge descriptor to the halfedge preceding <code>h</code> around the target vertex of <code>h</code>, when halfedges are ordered around a given vertex in clockwise order.</li></ul>
<h2><a class="anchor" name="refbackwardhds8">
Complexity guarantees</a></h2>
<ul>
<li><code>prev_in_facet(hds,h)</code>: amortized constant time.</li><li><code>prev_at_source(hds,h)</code>: amortized constant time.</li><li><code>prev_at_target(hds,h)</code>: amortized constant time.</li></ul>
<h2><a class="anchor" name="refbackwardhds9">
Invariants</a></h2>
The backward halfedge accessors are linked via the algebraic relations:<ul>
<li><code>prev_in_facet(hds,h)</code> == <code>prev_at_target(opposite(hds,h))</code> == <code>opposite(prev_at_source(hds,h))</code></li><li><code>prev_at_source(hds,h)</code> == <code>opposite(prev_in_facet(hds,h))</code> == <code>opposite(prev_at_target(opposite(hds,h)))</code></li><li><code>prev_at_target(hds,h)</code> == <code>prev_in_facet(opposite(hds,h))</code> == <code>opposite(prev_at_source(opposite(hds,h)))</code></li></ul>
<h2><a class="anchor" name="refbackwardhds10">
Concept-checking class</a></h2>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HDS&gt; 
  <span class="keyword">struct </span>BackwardHDSConcept {
    <span class="keyword">typedef</span> <span class="keyword">typename</span> hds_traits&lt;HDS&gt;::halfedge_descriptor halfedge_descriptor; 
    <span class="keyword">typedef</span> <span class="keyword">typename</span> hds_traits&lt;HDS&gt;::traversal_category traversal_category;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> hds_traits&lt;HDS&gt;::backward_category backward_category;
     <span class="keywordtype">void</span> constraints() {
        <span class="keyword">using namespace </span>boost;
        function_requires&lt;HDSConcept&lt;HDS&gt; &gt;();
        function_requires&lt;ConvertibleConcept&lt;traversal_category,
                                         hdstl::backward_traversal_tag&gt; &gt;();  
        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_valid_storage_tag =
           is_convertible&lt;backward_category,prev_at_source_tag&gt;::value ||
           is_convertible&lt;backward_category,prev_at_target_tag&gt;::value ||
           is_convertible&lt;backward_category,prev_in_facet_tag&gt;::value;
        BOOST_STATIC_ASSERT( is_valid_storage_tag ); 
 
        const_constraints(hds);
     }
     <span class="keywordtype">void</span> const_constraints(HDS <span class="keyword">const</span>&amp; hds){
        h = prev_in_facet(hds,h);
        h = prev_at_source(hds,h);
        h = prev_at_target(hds,h);
     }
     BackwardHDS hds;
     halfedge_descriptor h;
     halfedge_descriptor g;
  };
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Tue Jun 12 02:11:13 2007 for HDSTL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
