<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>HDSTL: HDS concept definition</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="hdsconcept">HDS concept definition</a></h1><h2><a class="anchor" name="refhdsconcept1">
Definition</a></h2>
This concept is the basic <code>HDSConcept</code>, which all the other <code>HDS</code> concepts refine. It contains a few requirements which are common to all the graph concepts. One should note that a model of <code>HDSConcept</code> is not required to be a model of <code>Assignable</code>, so algorithms should pass <code>HDS</code> objects by reference.<h2><a class="anchor" name="refhdsconcept2">
Refinement of:</a></h2>
This concept is not a refinement of another concept, in particular a model <code>HDS</code> of <code>HDSConcept</code> does <em>not</em> need to be <code>DefaultConstructible</code>, <code>CopyConstructible</code>, or <code>Assignable</code>.<h2><a class="anchor" name="refhdsconcept3">
Notation</a></h2>
<ul>
<li><code>HDS</code> A type that is a model of <code>HDSConcept</code></li><li><code>hds</code> A non-modifiable instance of <code>HDS</code></li><li><code>h</code>,<code>g</code> Halfedge descriptors, of type <code>hds_traits&lt;HDS&gt;::halfedge_descriptor</code></li></ul>
<h2><a class="anchor" name="refhdsconcept4">
Associated types</a></h2>
<ul>
<li><code>hds_traits&lt;HDS&gt;::halfedge_descriptor</code>: must be <code>DefaultConstructible</code> and <code>CopyConstructible</code>, <code>EqualityComparable</code>, <code>Assignable</code>.</li></ul>
<h2><a class="anchor" name="refhdsconcept5">
Definitions</a></h2>
<code>halfedge_descriptor</code> is a type that contains information to access the halfedge. Note that the halfedge descriptor type (accessible as a member of the <code>hds_traits&lt;HDS&gt;</code> type) is an opaque type. All that can be done to it is passing it to the function opposite and letting the hds use the information it contains to find the opposite halfedge. In particular, there is no guarantee that it is a pointer type.<h2><a class="anchor" name="refhdsconcept6">
Valid Expressions</a></h2>
The following expression must be valid and obey the syntactic requirement:<ul>
<li><code>opposite(hds, h)</code> must return a value assignable to <code>h</code>.</li></ul>
<h2><a class="anchor" name="refhdsconcept7">
Expression Semantics</a></h2>
The expressions semantics are as follows:<ul>
<li><code>opposite(hds, h)</code> returns a descriptor to the halfedge opposite <code>h</code> in the data structure <code>hds</code>. Does not modify the state of either <code>hds</code> or <code>h</code>.</li></ul>
<h2><a class="anchor" name="refhdsconcept8">
Complexity guarantees</a></h2>
<ul>
<li><code>opposite(hds, h)</code>: Amortized constant time.</li></ul>
<h2><a class="anchor" name="refhdsconcept9">
Invariants</a></h2>
Every valid halfedge descriptor <code>h</code> must have a valid opposite <code>g = opposite(hds, h)</code>, <em>distinct</em> from h, such that <code>opposite(hds, g)</code> returns <code>h</code>. (Hence, <code>opposite</code> is an involution.)<h2><a class="anchor" name="refhdsconcept10">
Concept-checking class</a></h2>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HDS&gt; 
  <span class="keyword">struct </span>HDSConcept {
    <span class="keyword">typedef</span> <span class="keyword">typename</span> hds_traits&lt;HDS&gt;::halfedge_descriptor halfedge_descriptor; 
    <span class="keywordtype">void</span> constraints() {
      <span class="keyword">using namespace </span>boost;
      function_requires&lt;DefaultConstructibleConcept&lt;halfedge_descriptor&gt; &gt;();
      function_requires&lt;CopyConstructibleConcept&lt;halfedge_descriptor&gt; &gt;();
      function_requires&lt;EqualityComparableConcept&lt;halfedge_descriptor&gt; &gt;();
      function_requires&lt;AssignableConcept&lt;halfedge_descriptor&gt; &gt;();
      h = opposite(hds,h);
      const_constraints(hds);
    }
    <span class="keywordtype">void</span> const_constraints(HDS <span class="keyword">const</span>&amp; hds) {
      h = opposite(hds,h);
    }
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Thu Jun 14 00:29:34 2007 for HDSTL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
