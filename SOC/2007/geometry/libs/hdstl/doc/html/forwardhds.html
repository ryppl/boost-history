<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>HDSTL: Forward HDS concept</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="forwardhds">Forward HDS concept</a></h1><h2><a class="anchor" name="refforwardhds1">
Definition</a></h2>
This concept refines the <code>HDSConcept</code>, and specifies additional forward category to iterate over the <code>HDS</code> data structure, which means clockwise movement around the facet and counter clockwise movement around the vertex. Possible forward categories are <code>next_in_facet</code>, <code>next_at_source</code>, and <code>next_at_target</code>. Once one of these categories are given all others can be accessed with the help of the <code>opposite</code> of a halfedge (see the section "Invariants" below for the algebraic relations that must hold).<h2><a class="anchor" name="refforwardhds2">
Refinement of</a></h2>
<ul>
<li><code>HDSConcept</code></li></ul>
<h2><a class="anchor" name="refforwardhds3">
Notation</a></h2>
<ul>
<li><code>HDS</code> A type that is a model of <code>ForwardHDSConcept</code></li><li><code>hds</code> A non-modifiable instance of <code>HDS</code></li><li><code>h</code>,<code>g</code> Halfedge descriptors, of type <code>hds_traits&lt;HDS&gt;::halfedge_descriptor</code></li></ul>
<h2><a class="anchor" name="refforwardhds4">
Associated types</a></h2>
<ul>
<li><code>hds_traits&lt;HDS&gt;::halfedge_descriptor</code>: from <code>HDSConcept</code>.</li><li><code>hds_traits&lt;HDS&gt;::traversal_category</code>: from <code>HDSConcept</code>, with additional requirement that this type must be convertible to <code>hdstl::forward_traversal_tag</code>.</li><li><code>hds_traits&lt;HDS&gt;::forward_category</code>: defines the pointer type for forward iteration.</li></ul>
<h2><a class="anchor" name="refforwardhds5">
Definitions</a></h2>
<ul>
<li><code>halfedge_descriptor</code> is a type that contains information to access the halfedge. (See the <code>HDS</code> concept or a full definition.)</li><li><code>traversal_category</code> is a type that contains information about the direction of the traversal, which is forward, forward or bidirectional. For this <code>ForwardHDS</code> concept, the <code>traversal_category</code> has to be convertible to the <code>hdstl::forward_traversal_tag</code> type defined in <code>&lt;boost/hdstl.hpp&gt;</code>.</li><li><code>forward_category</code> defines the primary accessor of the forward information for use by algorithms which desire the most direct access.</li></ul>
<h2><a class="anchor" name="refforwardhds6">
Valid Expressions</a></h2>
In addition to the valid expressions of the <code>HDS</code> concept:<ul>
<li><code>next_in_facet(hds,h)</code> must return a value assignable to h.</li><li><code>next_at_source(hds,h)</code> must return a value assignable to h.</li><li><code>next_at_target(hds,h)</code> must return a value assignable to h.</li></ul>
<h2><a class="anchor" name="refforwardhds7">
Expression Semantics</a></h2>
In addition to the expression semantics of the <code>HDS</code> concept:<ul>
<li><code>next_in_facet(hds,h)</code> returns a halfedge descriptor to the halfedge succeeding <code>h</code> in the adjacent facet cycle, when facet cycles are oriented in counter-clockwise order.</li><li><code>next_at_source(hds,h)</code> returns a halfedge descriptor to the halfedge succeeding <code>h</code> around the source vertex of <code>h</code>, when halfedges are ordered around a given vertex in clockwise order.</li><li><code>next_at_target(hds,h)</code> returns a halfedge descriptor to the halfedge succeeding <code>h</code> around the target vertex of <code>h</code>, when halfedges are ordered around a given vertex in clockwise order.</li></ul>
<h2><a class="anchor" name="refforwardhds8">
Complexity guarantees</a></h2>
<ul>
<li><code>next_in_facet(hds,h)</code>: amortized constant time.</li><li><code>next_at_source(hds,h)</code>: amortized constant time.</li><li><code>next_at_target(hds,h)</code>: amortized constant time.</li></ul>
<h2><a class="anchor" name="refforwardhds9">
Invariants</a></h2>
The forward halfedge accessors are linked via the algebraic relations:<ul>
<li><code>next_in_facet(hds,h)</code> == <code>next_at_source(opposite(hds,h))</code> == <code>opposite(next_at_target(hds,h))</code></li><li><code>next_at_source(hds,h)</code> == <code>next_in_facet(opposite(hds,h))</code> == <code>opposite(next_at_target(opposite(hds,h)))</code></li><li><code>next_at_target(hds,h)</code> == <code>opposite(next_in_facet(hds,h))</code> == <code>opposite(next_at_source(opposite(hds,h)))</code></li></ul>
<h2><a class="anchor" name="refforwardhds10">
Concept-checking class</a></h2>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HDS&gt; 
  <span class="keyword">struct </span>ForwardHDSConcept {
    <span class="keyword">typedef</span> <span class="keyword">typename</span> hds_traits&lt;HDS&gt;::halfedge_descriptor halfedge_descriptor; 
    <span class="keyword">typedef</span> <span class="keyword">typename</span> hds_traits&lt;HDS&gt;::traversal_category traversal_category;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> hds_traits&lt;HDS&gt;::forward_category forward_category;
     <span class="keywordtype">void</span> constraints() {
        <span class="keyword">using namespace </span>boost;
        function_requires&lt;HDSConcept&lt;HDS&gt; &gt;();
        function_requires&lt;ConvertibleConcept&lt;traversal_category,
                                         hdstl::forward_traversal_tag&gt; &gt;();  
        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_valid_storage_tag =
           is_convertible&lt;forward_category,next_at_source_tag&gt;::value ||
           is_convertible&lt;forward_category,next_at_target_tag&gt;::value ||
           is_convertible&lt;forward_category,next_in_facet_tag&gt;::value;
        BOOST_STATIC_ASSERT( is_valid_storage_tag ); 
 
        const_constraints(hds);
     }
     <span class="keywordtype">void</span> const_constraints(HDS <span class="keyword">const</span>&amp; hds){
        h = next_in_facet(hds,h);
        h = next_at_source(hds,h);
        h = next_at_target(hds,h);
     }
     ForwardHDS hds;
     halfedge_descriptor h;
     halfedge_descriptor g;
  };
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Thu Jun 14 00:29:34 2007 for HDSTL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
