[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Degree Distributions]
 template <class Graph, class Distribution>
 void degree_distribution(const Graph &g, Distribution& dist);

 template <class Graph, class Distribution>
 void in_degree_distribution(const Graph &g, Distribution& dist);

 template <class Graph, class Distribution>
 void out_degree_distribution(const Graph &g, Distribution& dist);


 template <class Graph, class Histogram>
 void degree_histogram(const Graph &g, Histogram& dist);

 template <class Graph, class Histogram>
 void in_degree_histogram(const Graph &g, Histogram& dist);

 template <class Graph, class Histogram>
 void out_degree_histogram(const Graph &g, Histogram& dist);

The degree distribution functions compute distributions of the degrees
of vertices in a graph. A distribution is mapping of an observable property
to the number of occurences of that property. In this context, the observable
property is the degree of a vertex (or in- and out- degree), which are in
the range \[0, /max{degree(v)}/\] Where /max{degree(v)}/ is the maximum degree
of any vertex in a graph /G/. Therefore, the output distribution is mapping
of vertex degree to its number of occurences in a graph.

This histogram functions are closely related to the degree distribution functions.
However, instead of computing a mapping from vertex degree to the number of
vertices, the histogram maps vertex degree to the /set of vertices/ that exhibit
that degree. This is very useful if you want to quickly find all vertices with
degree 0, or find the vertex with the highest degree.

[heading Where Defined]
`boost/graph/degree_distribution.hpp`

[heading Parameters]
[table
    [[Type] [Parameter] [Description]]
    [
        [in] [`const Graph& g`]
        [
            The graph object for which the distribution will be computed. For
            `degree_distributions()` and `in_degree_distribution()`, `g` must
            be a model of a BidirectionalGraph. For `out_degree_distribution()`,
            `g`, must model the IncidenceGraph concept.
        ]
    ]
    [
        [out] [`Distribution& dist`]
        [
            The distribution parameter maps instances of degrees (numerically)
            to the number of vertices in the graph that exhibit that degree.

            The distribution output parameter must be a model of both [SgiSequence]
            and [SgiRandomAccessContainer] (e.g., `std::vector`). The index type of the
            distribution must be the same as `degree_size_type`. The `value_type` must
            be integral (preferably unsigned).
        ]
    ]
    [
        [out] [`Histogram& hist`]
        [
            The histogram parameter maps instances of degrees (numerically) to the
            set of vertices that exhibit that degree.

            The histogram output parameter must be a model of both [SgiSequence]
            and [SgiRandomAccessContainer] (e.g., `std::vector`). The index type of the
            distribution must be the same as `degree_size_type`. Additionally `value_type`
            must be a model of the [SgiBackInsertionSequence] (e.g., `std::vector`).
        ]
    ]
]

[h4 Complexity]
The time complexity of all these functions is /O(V)/.

The space complexity for the distributions functisons is /O(max{degree(v)})/ where
/max{degree(v)}/ is the maxmimum degree of all vertices in a graph /G/.

The space complexity for the histogram functions is /O(V + max{degree(v)})/.

[h4 Notes]
Because a graph may be a multigraph, there is no determinable upper bound on the
size of the distribution or histogram parameters. As such they are required to
be dynamically resized during the execution of the algorithm.

For the distribution parameter, we recommend `std::vector<size_t>`. This satisfies
all the requirements. For the histogram, we recommend using a `std::vector<Sequence<Vertex> >`
where `Sequence` is one of `std::list`, `std::vector`, `std::deque`, or `std::queue`. The
choice doesn't make much difference except that a `std::list` will require more allocations,
but a `std::vector` will require more space. Also, note that `std::list::size()` function is
not required to run in constant-time. The `Vertex` type must be
`graph_traits<Graph>::vertex_descriptor`.

If `dist` is the name of the output distribution after a call to `degree_distribution()`
then the maximum degree is `dist.size() - 1`. The minimum degree corresponds to the index
in `dist` with the first non-zero value.

[h4 Examples]
The first example show how to compute and print the degree distribution.

 undirected_graph<> g;
 // add vertices and edges to g

 std::vector<size_t> dist;
 degree_distribution(g, dist);
 copy(dist.begin(), dist.end(), ostream_iterator<size_t>(cout, " "));


The following example shows how to access the vertex (or vertices) with the maximum
degree by using the `degree_histogram()` algorithm. This prints the index of that
vertex.

 undirected_graph<> g;
 // add vertice and edges to g

 typedef graph_traits<undirected_graph<> >::vertex_descriptor vertex_type;
 typedef std::vector<vertex_type> vertex_vector;

 std::vector<vertex_vector> hist;
 degree_histogram(g, hist);
 cout << get_vertex_index(hist.back().back()) << "\n";

[endsect]