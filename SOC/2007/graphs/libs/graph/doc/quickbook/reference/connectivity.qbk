[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Connectivity Measures]

    template <
        typename Graph,
        typename Components,
        typename SizeType,
        typename ComponentMap,
        typename ColorMap,
        typename VertexIndexMap
    >
    std::size_t
    connectivity(
        const Graph& _graph,
        Components& _components,
        SizeType _number = 0,
        ComponentMap _component_map = ``['nothing]``,
        ColorMap _color_map = ``['nothing]``,
        VertexIndexMap _vertex_index_map = get(vertex_index, _graph));

The `connectivity()` algorithm is a wrapper around the [boost_connected_components]
algorithm that provides convenience for working with the resultant component maps.
The parameters have, with the exeption of `_components`, the same purpose and requirements
as documented in [boost_connected_components].

The `_components` parameter will result in a sequence of "components" of the graph
where each "component" is a sequence of vertices in the graph. After returning,
the size of the `_components` parameter will be the number of connected components
in the graph and each element in that sequence will contain a sequence of one or
more vertices. Each vertex is assigned to only one component. The assignment is
determined by the `_component_map`, whether passed to the algorithm or not.
If a vertex `v` is mapped to component id `i` such that `_component_map[v] == i` then
`v` will appear in the vertex sequence given by `_components[i]`.

To help illustrate the structure and contents of the `_components` parameter,
suppose, that after running [boost_connected_components], a graph is decomposed
into two components.

[figure
    images/reference/connected_components_after.png
    Figure 1. Components found after running [boost_connected_components]
]

Assume that we have stored each vertex into a vector, `v`, such that `v[i]`
denotes the ['i[super th]] vertex in the graph above. The `_component_map` used
for this decomposition associates each vertex with a component id.

    _component_map[ v[0] ] == 0;
    _component_map[ v[1] ] == 0;
    _component_map[ v[2] ] == 0;
    _component_map[ v[3] ] == 1;
    _component_map[ v[4] ] == 1;

However, the `_components` parameter associates each component with the vertices that
comprise that component. Therefore, contents of the output sequence `_components` will
be (in pseudo-C++):

    _components[0] == { v[0], v[1], v[2] };
    _components[1] == { v[0], v[1], v[2] };

This function returns the number of connected components in the graph.

There are two distinct methods for calling this function: with or without the
`_component_map` parameter. If the `_component_map` /is not/ given, then the
algorithm must first compute the connected components of `_graph`. In this case,
the user may need to supply the `_vertex_index_map` or an alternate `_color_map`.
Calling the [boost_connectivity] function in this way will not provide access
to a `_component_map` for the graph.

If the _component_map /is/ given, then the algorithm assumes that connected
components have already been assigned in the `_component_map`. In this case,
`_color_map` and `_vertex_index_map` parameters are effectively ignored. Additionally
the caller may pass the `_number` parameter to the function. If /not/ passed,
the computation is required to determine the number of components in the graph
by examining the `_component_map`. Passing `_number` as the return value of
[boost_connected_components] allows this operation to be bypassed.

[note
This hasn't been tested very will for directed graphs. In fact, testing
will probably result in the creation of `strong_connecity` which forwards the
call to `strong_connected_components`.
]

[h5 Where Defined]
`boost/graph/connectivity.hpp`

[h5 Parameters]
[table
    [[Type] [Parameter] [Description]]
    [
        [required, in] [`Graph _graph`]
        [
            The graph object for which the distribution will be computed. If
            the `_distribution` or `_in_distribution` arguments are supplied
            when calling this function then `_graph` must be a model of
            [BoostBidirectionalGraph]. If only `_out_distribution` is supplied,
            then `_graph` must be a model of [BoostIncidenceGraph].
        ]
    ]
    [
        [required, out] [`Components _components`]
        [
            The components parameter provides storage for the assignment of
            vertices to components. The `ComponentMap` parameter must be a
            model of [SgiRandomAccessContainer] whose index type must be convertible
            to the graphs `vertices_size_type`, and whose `value_type` must be
            a model of [SgiBackInsertionSequence]. In turn, the `value_type` of
            this [SgiBackInsertionSequence] must be the `vertex_descriptor` type
            of `_graph`.
        ]
    ]
    [
        [optional, in] [`SizeType _number`]
        [
            This is the number of components in the graph as returned by a
            prior call to [boost_connected_components]. The SizeType must
            be convertible to the `vertices_size_type` of `Graph`.

            *Default* /not given/
        ]
    ]
    [
        [optional, in] [`ComponentMap _component_map`]
        [
            The component map that represents the assignment of vertices to
            distinct components in the graph. The `ComponentMap` must be
            a model of [BoostReadablePropertyMap]. The `value_type` should be
            integral, preferably the same as `vertices_size_type` for the
            graph. The `key_type` must be the graph's `vertex_descriptor`.

            *Default* /not given/
        ]
    ]
    [
        [optional, in] [`ColorMap _color_map`]
        [
            This is used by the [boost_connected_components] algorithm to keep
            track of its progress through the graph. The type `ColorMap` must
            be a model of [BoostReadWritePropertyMap], it's `key_type` must be
            the `vertex_descriptor` type of `_graph` and its `value_type` must
            be a model of [BoostColorValue].

            *Default* /not given/
        ]
    ]
    [
        [optional, in] [`VertexIndexMap _vertex_index_map`]
        [
            This maps each vertex to an integer in the range \[0, `num_vertices(g)`).
            This parameter is necessary only `Graph` does not have built-in vertices
            and/or a correct ordering on them.

            *Default* `get(vertex_index, g)`
        ]
    ]
]

[h5 Return Value]
This function returns the number of connected components. When the return value of
this function is equal to `1`, then the graph is a single connected component.

[h5 Complexity]
This function has time complexity /O(V)/ and space complexity /O(V)/ (since each
vertex is assigned to a component in the _components_vector).

[h5 Examples]

[note These are going to be expanded...]

When a component map is not provided:

    typedef undirected_graph<> Graph;
    typedef graph_traits<Graph>::vertex_descriptor Vertex;
    typedef vector<Vertex> Component;
    typedef vector<Component> ComponentList;

    Graph g;
    // build a graph

    ComponentList components;
    connected_components(g, components);

    size_t c = 0;
    BOOST_FOREACH(Component comp, components) {
        cout << "component: " << c++ << " : ";
        BOOST_FOREACH(Vertex v, comp) {
            cout << get(vertex_index, g, v) << " ";
        }
        cout << "\n";
    }

If the component map /is/ available...

    // write some code to that effect.

[h5 Details]
The signature of this function may change in the future to include a new parameter, `_number`,
which indicates the number of components computed by [boost_connected_components]. This
introduces a new calling "profile" that would bypass the computation of the number of components.

[endsect]