[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Bron Kerbosch All Cliques]
[template ex_bron_kerbosch_printing_cliques[] [link
    boost_graph.reference.algorithms.subgraph.bron_kerbosch_all_cliques.examples.printing_cliques
    Printing Cliques Example]]

[heading Overview]
This algorithm finds all /cliques/ of the given graph, invoking a visitor when
each clique is found. A clique is a maximally connected subgraph meaning that
each pair of vertices in the clique are connected to each other.

For directed graphs, a /directed clique/ is similarly defined. For each pair
of vertices /u/ and /v/ in a directed clique, there are edges /(u,v)/ and /(v,u)/
that connect them.

The Bron-Kerbosch algorithm was originally developed to operate over adjacency
matrices of undirected graphs. It will, however, work equally well for directed
graphs given the previous definition at a constant increase in cost. However,
using this algorithm with an adjaceny list occurs significant overhead due to
the use of edge lookups.

The Bron-Kerbosch algorithm was originally developed for undirected graphs, but
will work for directed graphs as well (possibly at added cost).

[section [^bron_kerbosch_all_cliques()]]
    #include <boost/graph/bron_kerbosch_all_cliques.hpp>

    template <typename Graph, typename Visitor>
    void bron_kerbosch_all_cliques(const Graph& g, Visitor vis)

[heading Parameters]
[table
    [[Type] [Parameter] [Description]]
    [
        [required, in] [`const Graph& g`]
        [
            The graph for which cliques are being visited.

            *Preconditions:* The indices of vertices in the graph must be
            in the range \[0, `num_vertices(g)`).

            *Requirements:* The `Graph` type must be a model of the [AdjacencyMatrix],
            [IncidenceGraph] concept and the [VertexIndexGraph]
            concepts[footnote Any `Graph` typen that implements the `edge()`
            function will satisfy the expression requirements for the
            [AdjacencyMatrix], but may incur additional overhead due non-constant
            implementations.].
        ]
    ]
    [
        [required, in] [`Visitor vis`]
        [
            The visitor object to the algorithm.

            *Requirements:* This `Visitor` class must model the
            [CliqueVisitor] class.
        ]
    ]
]

[h5 Complexity]
This problem has a loose upper bound of ['O(2[super n])] if one considers all possible
combinations of subsets of vertices as cliques (i.e., the powerset of vertices).
The original publication, however, approximates the runtime of the algorithm as
being proportional to ['O(3.14[super n])].

Graphs that do not meet the constant-time requirements of the [AdjacencyMatrix]
concept will incur additional runtime costs during execution (usually by a small linear
factor). Examples of such graphs include the [undirected_graph],
[directed_graph], and the [adjacency_list] classes.
[endsect]


[section Examples]
[heading Printing Cliques]
Write Me!

[endsect]

[endsect]