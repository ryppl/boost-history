[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Mean Geodesic]

    template <typename Graph, typename DistanceMatrixMap, typename GeodesicMap>
    void mean_geodesic(const Graph& g, DistanceMatrixMap dm, GeodesicMap gm)

    template <typename Graph, typename DistanceMatrixMap, typename GeodesicMap, typename Measure>
    void mean_geodesic(const Graph& g,
                       DistanceMatrixMap dm,
                       GeodesicMap gm,
                       Measure m)


    template <typename Graph, typename DistanceMap>
    float vertex_mean_geodesic(const Graph& g, DistanceMap dm)

    template <typename ResultType, typename Graph, typename DistanceMap>
    ResultType vertex_mean_geodesic(const Graph& g, DistanceMap dm)

    template <typename Graph, typename DistanceMap, typename Measure>
    typename Measure::result_type
    vertex_mean_geodesic(const Graph& g, DistanceMap dm, Measure m)


    template <typename Graph, typename GeodesicMap, typename Measure>
    typename Measure::result_type
    graph_mean_geodesic(const Graph& g, GeodesicMap gm, Measure m)

    template <typename Graph, typename GeodesicMap>
    typename property_traits<GeodesicMap>::value_type
    graph_mean_geodesic(const Graph& g, GeodesicMap gm)


The /mean geodesic distance/ measure is used in large network analysis to identify
central vertices and as a measure of the /small world phenomenon/. The mean geodesic
distance of a vertex is defined as the average of geodesic distances from that
vertex every /other/ vertex in the graph. It is computed as:

[$images/eq/mean_geodesic.png]

Where /d(u,v)/ is the shortest path (geodesic distance) from /u/ to /v/. Note
that this excludes /d(u,u)/ from the average, even if /d(u,u)/ is non-zero, which
is rare for social networks. Note that if any vertex in the graph is unreachable
from any other, then the graph is unconnected, and the distance between those two
unonnected vertices is infinite. This imlplies that the closeness of every vertex
in an unconnected (and undirected) graph is also infinite. This is not necessarily
the case for directed graphs.

The mean geodesic distance is often used to quantify whether or not a graph exhibits
the so-called small-world phenomenon. If the mean geodesic distance of a graph is
small with respect to its density (the ratio of vertices to edges), then the graph
is said to exhibit the small-world phenomenon. This implies that vertices are
The mean geodesic distance of a graph is the average of the mean geodesics for
each vertex. It is computed as:

[$images/eq/graph_mean_geodesic.png]

Note that computing the measure in this fashion means that the mean geodesic distance
of the graph may lie outside the minimum and maximum mean geodesic distances of
its vertices.

Consider a social network of friends, which is represented by an undirected graph.

[figure
    images/reference/social_network.png
    *Figure 1.* A network of friends.
]

In this network, Frank has the lowest mean geodesic distance with an average of
1.375. Scott and Laurie have the second lowest distances with values of 1.5 and
1.875 respectively.

This module defines a flexible framework for computing the mean geodesic distance
of vertices in a graph for previously computed geodesics by providing thrtee generic
functions. The first function, `mean_geodesic()` computes the average distance of
each vertex in a graph from a matrix containing the distances between vertices.
This matrix can be computed as the output of an "all pairs shortest path" algorithm
(e.g., [boost_floyd_warshall_all_pairs_shortest_paths] or [boost_johnson_all_pairs_shortest_paths])
or as the result repeated [boost_breadth_first_search]s (if the graph is unweighted).

The second function, `vertex_mean_geodesic()` can be used to compute the
closeness of a single vertex. This function requires a distance map that contains
the distance from one vertex (the source) to all others in the graph. This
distance map can be computed as the result of a "shortest paths" algorithm such
as [boost_dijkstra_shortest_paths] or [boost_bellman_ford_shortest_paths]. If the
graph is unweighted, distances can be recorded from a [boost_breadth_first_search].

The third function, `graph_mean_geodesic()` computes the mean geodesic distance
for the graph by averaging the mean geodesic distances of each vertex in the geodesic
distance map. Note that this function does not compute the mean geodesic distances
of each vertex. Those values must be computed by using one of the functions above.

This framework also allows for a specialization of measures used to compute
these values. The default measures used in this framework implement the formulas
given above.

[heading Where Defined]
`boost/graph/geodesic_distance.hpp`

[heading Parameters]
[table
    [[Type] [Parameter] [Description]]
    [
        [template] [`ResultType`]
        [
            The `ResultType` template parmeter explitly specifies the the
            return type of the `closeness()` function. If not
            given, the return type is `float`.

            *Requirements:* The return type is required to model the
            [BoostNumericValue] concept.
        ]
    ]
    [
        [required, in] [`const Graph& g`]
        [
            The graph for which vertex measures are being comptued.

            *Requirements:* The `Graph` type must be a model of the
            [BoostVertexListGraph] concepts.
        ]
    ]
    [
        [required, in] [`DistanceMap dm`]
        [
            Given a vertex `v`, the `dm` parameter provides the length of the
            shortest path between a vertex `u` and `v`. The vertex `u` is the
            vertex for which the distance map was initially computed.

            *Requirements:* `DistanceMap` must be a model of [BoostReadablePropertyMap].
            The `key_type` of the distance map must be the same as the `vertex_descriptor`
            of the `Graph` parameter. The `value_type` is required to be a model of
            [BoostNumericValue].
        ]
    ]
    [
        [required, in] [`DistanceMatrixMap dm`]
        [
            Given vertices /u/ and /v/, the `dm` parameter provides the length
            of the shortest path between the two vertices.

            *Requirements:* `DistanceMatrixMap` must be a model of [BoostReadablePropertyMap].
            The `key_type` of the distance matrixc must be the same as the `vertex_descriptor`
            of the `Graph` parameter. The `value_type` must be a [BoostReadWritePropertyMap]
            whose `key_type` is also the `vertex_descriptor` of the `Graph` and
            whose `value_type` is a model of [BoostNumericValue].
        ]
    ]
    [
        [required, both] [`GeodesicMap gm`]
        [
            When used with the `mean_geodesic()` function, the `gm` parameter stores
            the computed mean geodesic distances for each vertex pair in the matrix.
            When used with the `graph_mean_geodesic()` function, the parameter provides
            the input required to compute the mean distance for the graph.

            [*Requirements - [^mean_geodesic()]:] The `GeodesicMap` type is required
            to model the [BoostReadablePropertyMap] concept.

            [*Requirements - [^graph_mean_geodesic()]:] The `GeodesicMap` type is
            required to model the [BoostWritablePropertyMap] concept.

            *Requirements:* The `key_type` of this parameter must be the
            same as the `vertex_descriptor` of the `Graph` parameter, and the
            `value_type` must be a model of the [BoostNumericValue] concept.
        ]
    ]
    [
        [optional, in] [`Measure measure`]
        [
            The 'measure' parameter is an instance of a closeness measure that
            performs the final division for this computation.

            *Requirements:* The `Measure` type must be a model of the [BoostDistanceMeasure]
            concept. The `distance_type` must be the same type as the `value_type`
            of the `DistanceMap` or `DistanceMatrixMap`. The `result_type` of the
            `Measure` must model the [BoostNumericValue] concept.
        ]
    ]
]

[heading Return]
The `vertex_mean_geodesic()` function returns the average of geodesic distances
to other vertices from a source. If the source vertex is not connected to one other
in the graph, this value is infinite.

The `graph_mean_geodesic()` function returns the mean geodesic distance for the
entire graph - a common measure of the small world property. If the graph is
unconnected, the mean geodesic distance is infinite.

[heading Complexity]
The `mean_geodesic()` function returns in ['O(n[super 2]*O(M))] where /n/ is the
number of vertices in the graph, and /M/ is the complexity of the measure. By
defualt, /M/ is constant.

The `vertex_mean_geodesic()` function returns in /O(n*O(M))/. By default /M/ is
constant.

The `graph_mean_geodesic()` function returns in /O(n*O(M))/. By default /M/ is
constant.

[heading Example]
This example shows how to compute the mean geodesic distance for each vertex
in a social network, and the mean geodesic distance for the graph as a whole.
This example includes the files

* [^examples/mean_geodesic.hpp]
* [^examples/social_network.hpp]
* [^examples/helper.hpp]

First, we define the graph and its associated types.
[social_network_types]
Here, we use the `Actor` to store an actor name with each vertex. We also need to
define a number of related property types to support property maps for the algorithms
called in the program.

Since this program will call [boost_floyd_warshall_all_pairs_shortest_paths] to
compute distances between vertices, we need a matrix to store the distances.
[distance_matrix_types]

We also need a property map that assigns weights to each edge. Since our graph is
unweighted, we can use the [boost_constant_property_map] to return a constant value
for each edge. [constant_weight_map_types]

We also need an output property map to store the mean geodesic distance of each
vertex.
[geodesic_map_types]

In the main program, we instantiate the graph and an extra `std::map` that we
use during graph construction.

[setup_social_network]

The graph is read from standard input. This process uses the `add_named_vertex()`
function, which is not part of the Boost.Graph library but defined in the file
`examples/helper.hpp`.

[build_social_network]

The next step is to compute the distance. This is done using the
[boost_floyd_warshall_all_pairs_shortest_paths] function. This could also be done
using [boost_johnson_all_pairs_shortest_paths]. This is done by first constructing
a matrix to hold the distance values, and a property map over the matrix. Additionally,
we use a [boost_constant_property_map] to return the value `1` for all edge weights.
Both the distance matrix and edge-weight maps are used as inputs to the distance
algorithm.
[compute_constant_distances]

After computing the distance, we can use the resulting distance matrix to compute
the mean geodesic distance of each vertex. This is done by constructing a container
for the distance values and a property map accessor for it. The previously computed
distance map and geodesic map are passed as inputs to `mean_geodesic()` function.
The geodesic map, once computed, is then used as an input to the `graph_mean_geodesic()`
function, which returns the mean geodesic distance of the graph.
[compute_mean_geodesics]

As a final step, we print the mean geodesic distance of the graph.
[print_graph_mean_geodesic]

If this program is given the `social_network.graph` file as input, the output
will be:

[pre
mean geodesic distance: 1.91667
]

Note that this program can be easily modified to work on directed graphs. In the
file `social_network.hpp`, simply replace `typedef undirected_graph<Actor> ...` to
`typedef directed_graph<Actor> ...`.


[endsect]