[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Eccentricity]

    template <typename Graph, typename DistanceMap>
    property_traits<DistanceMap>::value_type
    eccentricity(const Graph&g, DistanceMap dist)

This function computes the /eccentricity/ of a vertex in a graph. The eccentricity
of a vertex is defined as the maximum geodesic distance (shortest paths) to any
other vertex in the graph. It is important to note that these functions
/do not/ compute these paths or record their distances

Boost.Graph provides two shortest paths algorithms: [boost_dijkstra_shortest_paths]
and [boost_bellman_ford_shortest_paths]. Optionally, if the target graph is
an unweighted, undirected graph, shortest paths can be recorded using
[boost_breadth_first_search]. Each of these algorithms takes as an input a
vertex for which the shortest distances are being computed. The output of
each of these algorithms is a `DistanceMap`, which is (in turn) used as the
input of these functions. Note then, that these functions compute measures
of the vertex for which the `DistanceMap` was computed.

If the graph is unconnected, then the eccentricity of any vertex will be
infinite.

[heading Where Defined]
`boost/graph/distance.hpp`

[heading Parameters]

[table
    [[Type] [Parameter] [Description]]
    [
        [required, in] [`const Graph& g`]
        [
            The graph object for which the measure will be computed. The
            `Graph` type is required to be a model of [BoostVertexListGraph].
        ]
    ]
    [
        [required, in] [`vertex_descriptor v`]
        [
            The target vertex to which the geodisic distance is returned. The
            source vertex is made implicit by the `DistanceMap`.
        ]
    ]
    [
        [required, in] [`DistanceMap dist`]
        [
            The `dist` parameter provides the distances of the shortest paths
            from one source vertex to all others in the graph. The `DistanceMap`
            must be a model of [BoostReadWritePropertyMap], they `key_type` must
            be the `vertex_descriptor` of `Graph`.
        ]
    ]
    [
        [required, in] [`const T& dummy`]
        [
            An unused instance of the type returned by the `mean_geodesic_distance()`
            function. If specified, the measure will be computed as an average of
            this type. This type must essentially be numeric, as it is required to
            a) support division, b) be initialized with an integer type, and c)
            have a default of 0.
        ]
    ]
]

[h5 Return Value]
The `eccentricity()` function returns the closeness of the vertex for which
`dist` was computed.

[h5 Complexity]
The `eccentricity()` function has /O(V)/ time complexity.

[h5 Examples]
This example computes shows the construction of a simple undirected graph and
illustrates how to compute the `eccentricity()` for a vertex.

[figure
    images/reference/geodesic.png
    [*Figure 1.] A simple undirected, unweighted graph.
]

This graph can be constructed programmatically as:

    typedef undirected_graph<> Graph;
    typedef graph_traits<Graph>::vertex_descriptor Vertex;

    // Instantiate the graph and vector of vertices.
    Graph g;
    vector<Vertex> v(10);

    // Add vertices to the graph, recording their descriptors into
    // the vertex vector.
    for(size_t i = 0; i < 10; ++i) {
        v[i] = add_vertex(g);
    }

    // Connect the vertices by adding edges to the graph. This builds
    // the graph shown in Figure 1.
    add_edge(v[0], v[1], g);  add_edge(v[1], v[2], g);
    add_edge(v[1], v[3], g);  add_edge(v[2], v[4], g);
    add_edge(v[3], v[5], g);  add_edge(v[4], v[6], g);
    add_edge(v[4], v[7], g);  add_edge(v[4], v[8], g);
    add_edge(v[5], v[8], g);  add_edge(v[6], v[9], g);
    add_edge(v[7], v[9], g);  add_edge(v[8], v[9], g);

    // Initialize an exterior property for recording the distances
    // to every vertex in the graph.
    typedef exterior_property<Graph, int> DistanceProperty;
    typedef DistanceProperty::container_type DistanceContainer;
    typedef DistanceProperty::map_type DistanceMap;
    DistanceContainer distances(10);
    DistanceMap dist(make_property_map(dists));

    // Initialize the distance to-self of vertex 0 and run a breadth-first
    // search on the graph to compute the distance of the shortest path
    // from vertex 0 to all others.
    dist[v[0]] = 0;
    breadth_first_search(g, v[0],
            visitor(make_bfs_visitor(record_distances(dist, on_tree_edge())))
        );

Computing the `eccentricity()` for vertex 0 is trivial.

    cout << "eccentricity == " << eccentricity(g, dist) << end;

The output of this program is:

[pre
mean geodesic distance == 5
]


[endsect]