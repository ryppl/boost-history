[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Geodesic Distances]

    template <typename Graph, typename DistanceMap>
    typename property_traits<DistanceMap>::value_type
    geodesic_distance(const Graph& g,
                      typename graph_traits<Graph>::vertex_descriptor v,
                      DistanceMap dist)

    template <typename Graph, typename DistanceMap>
    double
    mean_geodesic_distance(const Graph& g, DistanceMap dist)

    template <typename Graph, typename DistanceMap, typename T>
    T
    mean_geodesic_distance(const Graph& g, DistanceMap dist, const T& dummy)

These functions compute values based on the /geodesic distance/ between
vertices. The /geodesic distance/ between vertices /u/ and /v/ is defined
as the shortest-length path between such vertices. It is important to note
that these functions /do not/ compute these paths or record their distances.

Boost.Graph provides two shortest paths algorithms: [boost_dijkstra_shortest_paths]
and [boost_bellman_ford_shortest_paths]. Optionally, if the target graph is
an unweighted, undirected graph, shortest paths can be recorded using
[boost_breadth_first_search]. Each of these algorithms takes as an input a
vertex for which the shortest distances are being computed. The output of
each of these shortest paths algorithms is a `DistanceMap`, which is used as the
input to the geodesic distance functions. Note then, that these functions compute
measures of the vertex for which `dist` was computed.

[note
Get rid of `geodesic_distance()`.
]

The `geodesic_distance()` function returns the length of the shortest path
between two vertices. The source vertex is that for which the `DistanceMap`
was computed and the target vertex, `v`, is supplied as a parameter. This
function is an alias for:

    dist[v];

The `mean_geodesic_distance()` functions return the (arithmatic) mean
of the geodesic distances between a vertex and all others in the graph. The
vertex for which this is computed is that for which `dist` originally
computed. The mean geodesic distance is implemeted as:

[$images/eq/mean_geodesic.png]

where ['d[sub G](u, v)] is the geodesic distance (shortest path) from /u/ to /v/.

The default (first) variant of this function computes and returns the
average as a `double`. The second variant allows the average and return
type to be computed as a user-defined type by passing a dummy instance.
This is useful if the `value_type` of `DistanceMap` is a user-defined or
otherwise non-trivial.

Note that the geodesic distance between two unconnected vertices is infinite.
This implies that the mean geodesic distance for an unconnected graph is
also infinite.

[heading Where Defined]
`boost/graph/distance.hpp`

[heading Parameters]

[table
    [[Type] [Parameter] [Description]]
    [
        [required, in] [`const Graph& g`]
        [
            The graph object for which the measure will be computed. The
            `Graph` type is required to be a model of [BoostVertexListGraph].
        ]
    ]
    [
        [required, in] [`vertex_descriptor v`]
        [
            The target vertex to which the geodisic distance is returned. The
            source vertex is made implicit by the `DistanceMap`.
        ]
    ]
    [
        [required, in] [`DistanceMap dist`]
        [
            The `dist` parameter provides the distances of the shortest paths
            from one source vertex to all others in the graph. The `DistanceMap`
            must be a model of [BoostReadWritePropertyMap], they `key_type` must
            be the `vertex_descriptor` of `Graph`.
        ]
    ]
    [
        [required, in] [`const T& dummy`]
        [
            An unused instance of the type returned by the `mean_geodesic_distance()`
            function. If specified, the measure will be computed as an average of
            this type. This type must essentially be numeric, as it is required to
            a) support division, b) be initialized with an integer type, and c)
            have a default of 0.
        ]
    ]
]

[note
The requirements on `T` indicate a particularly interesting problem because
division is basically [SgiMonoid] operation - which is probably one of the
more esoteric concepts in the STL. Curiously, the `identity_element()` operation
which is an SGI extension and apparently not part of the actual standard.

The correct implemention of `detail::sum_distances()` should take a monoid
type and use `identity_element(f)` for initializaiton and `f` for the combination.

There's also a sort of strange requirement that we need some testable notion
of infinite. So, `T` is apparently some monoidic type that also has the notion
of an infinite value.
]

[h5 Return Value]
The `geodesic_distance()` function returns the distance of the shortest
path to `v`.

The `mean_geodesic_distance()` function returns the (arithmatic) mean of
the shortest distances to all other vertices.

[h5 Complexity]
The `geodesic_distance()` function has /O(1)/ time complexity.

The `mean_geodesic_distance()` function has /O(V)/ time complexity.

[h5 Examples]
This example computes shows the construction of a simple undirected graph and
illustrates the computation of shortest distances and the use of the `geodesic_distance()`
and `mean_geodesic_distance()` functions. Consider the following graph:

[figure
    images/reference/geodesic.png
    [*Figure 1.] A simple undirected, unweighted graph.
]

This graph can be constructed programmatically as:

    typedef undirected_graph<> Graph;
    typedef graph_traits<Graph>::vertex_descriptor Vertex;

    // Instantiate the graph and vector of vertices.
    Graph g;
    vector<Vertex> v(10);

    // Add vertices to the graph, recording their descriptors into
    // the vertex vector.
    for(size_t i = 0; i < 10; ++i) {
        v[i] = add_vertex(g);
    }

    // Connect the vertices by adding edges to the graph. This builds
    // the graph shown in Figure 1.
    add_edge(v[0], v[1], g);  add_edge(v[1], v[2], g);
    add_edge(v[1], v[3], g);  add_edge(v[2], v[4], g);
    add_edge(v[3], v[5], g);  add_edge(v[4], v[6], g);
    add_edge(v[4], v[7], g);  add_edge(v[4], v[8], g);
    add_edge(v[5], v[8], g);  add_edge(v[6], v[9], g);
    add_edge(v[7], v[9], g);  add_edge(v[8], v[9], g);

    // Initialize an exterior property for recording the distances
    // to every vertex in the graph.
    typedef exterior_property<Graph, int> DistanceProperty;
    typedef DistanceProperty::container_type DistanceContainer;
    typedef DistanceProperty::map_type DistanceMap;
    DistanceContainer distances(10);
    DistanceMap dist(make_property_map(dists));

    // Initialize the distance to-self of vertex 0 and run a breadth-first
    // search on the graph to compute the distance of the shortest path
    // from vertex 0 to all others.
    dist[v[0]] = 0;
    breadth_first_search(g, v[0],
            visitor(make_bfs_visitor(record_distances(dist, on_tree_edge())))
        );

We can print the geodesic distance from vertex 0 to each of the other vertices, and
its mean geodesic distance.

    Graph::vertex_iterator i, end;
    for(tie(i, end) = vertices(g); i != end; ++i) {
        cout << "geodesic distance to v[" << get(vertex_index, g, *i) << "] == "
             <<  geodesic_distance(g, *i, dist) << endl;
    }
    cout << "mean geodesic distance == " << mean_geodesic_distance(g, dist) << end;

The output of this program is:

[pre
geodesic distance to v\[0\] == 0
geodesic distance to v\[1\] == 1
geodesic distance to v\[2\] == 2
geodesic distance to v\[3\] == 2
geodesic distance to v\[4\] == 3
geodesic distance to v\[5\] == 3
geodesic distance to v\[6\] == 4
geodesic distance to v\[7\] == 4
geodesic distance to v\[8\] == 4
geodesic distance to v\[9\] == 5
mean geodesic distance == 2.8
]

[endsect]