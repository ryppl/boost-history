
[section "Hello, World."]

Let's start at the beginning, with the eponymous "Hello world" example:

``
#include <boost/cgi.hpp>
using namespace boost::cgi;

int main()
{
  service s;
  request req(s);
  response resp; 

  resp<< content_type("text/plain")
      << "Hello, world.";

  resp.send(req.client());

  return 0;
}
``

That should be mostly self-explanatory, here is what is happening:

``
#include <boost/cgi.hpp>
using namespace boost::cgi;
``

The boost/cgi.hpp header includes the headers for CGI, SCGI and FastCGI. If you only want the CGI stuff you can `#include <boost/cgi/cgi.hpp>`, or similarly for the other protocols (scgi.hpp or fcgi.hpp).

``
service s;
request req(s);
``

The use of the `service` class here might seem cumbersome, but its value should become more apparent later on when we try and scale our program.

[note
  Still think it's ugly; I'm trying to think of the best way to remove the need for it without losing the protocol-independence of parts of the library.
]

``
response resp;
``

You aren't required to use the `response` class with this library, but it's highly recommended. [-There is a rationale for the `response` class in the design notes] [/**FIXME**/]. A `response` is independent of protocol and any request you choose to use it with - that makes it easy to reuse.

``
resp<< content_type("text/plain")
    << "Hello, world.";
``

You can stream data to a `response` just like you can with `std::cout`. In addition, you can stream things like `content_type("text/html")` and `cookie("whatever", "value")` (more on this later).

`content_type` is one of the ['header factories] provided by the library. In other words it is a function which returns a `header` object, so instead of streaming `content_type("text/plain")` to a `response` you can stream `header("Content-type", "text/plain")`. Both are equivalent, but the former is cleaner and less error prone.

The `response` class understands `header`s and keeps them separate from the rest of the response. This allows you to add headers at any point, so long as you haven't flushed/sent the response already. For instance, you could add a custom header "Running-time", stating the time it took to handle the request, just before you send the response.

``
resp.send(req.client());

return 0;
``

As already mentioned, the `response` class buffers your data, so you must send it when it is ready. It is sent to the `client` associated with a request - ie. req.client() - but you don't need to know anything else about the Client concept for now. The library also provides a convenient macro to clean up the above:

``
return_(resp, req, 0); // 'returns 0' from main.
``

[tip
  A CGI request is effectively closed when the application exits, but since FastCGI and SCGI can handle multiple requests per process you must explicitly close each one. The `return_()` macro does this properly.
]

[endsect] [/ hello_world]

