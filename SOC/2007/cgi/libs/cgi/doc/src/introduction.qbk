[/
 / Copyright (c) 2007 Darren Garvey
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:intro Introduction]

``
#include <boost/cgi/cgi.hpp>
using namespace cgi;

int main(int, char**)
{
  request req;
  reply rep;

  rep<< "Hello there, Universe. "
     << "Oh wait, no, it's you " << req.meta_form("name")
     << ", isn't it?!";
  rep.send(req);
}
``

This CGI library reasonably high-level library for web programming. Herein the controller portion of the Model-View-Controller idiom is implemented. The intricacies of dealing with the widely varying specifications of CGI, FastCGI and SCGI are abstracted into three main sub-parts:

* Accepting,

* Loading, and

* Handling

This is all described in more detail in the [link __tutorial__ tutorial].

If a program's purpose is to serve the wider world, it should be written with scalability in mind. The `cgi::srequest` (the 's' is for 'synchronous' - ie. asynchronous operations cannot be used with it) that the [link __quickstart__ quickstart] introduces is simple to use and ideal for shorter, light-use programs, such as admin scripts. However when it comes to heavily used web applications CGI has an inherent limitation: there must be a complete heavyweight process for each client.

[note
Even though a `cgi::srequest` is set up differently to asynchronous request types, the alternative `cgi::request` (or the explicit form `cgi::acgi_request`) can be used in exactly the same way as FastCGI and SCGI requests. This symmetry makes migrating code between different protocols trivial (see [link __interoperability__ interoperability] for more) and aids debugging of server configuration issues.
]

FastCGI and SCGI both remove this restriction and there is support for them - of widely varying quality and completeness (see [link __server_support__ here]) - in most HTTP servers. These protocols add an extra layer to your CGI programs, as you now must manage the request queue.

In return for the added complexity, your programs become complete servers, capable of handling arbitrary numbers of requests during each invocation (assuming they don't crash!): Database connections can be kept open between requests; ready-parsed XML files can be cached; processing of a client request can even be continued in the case of the client crashing - the reply can be cached and returned to them when they return - saving precious CPU cycles.

Parsing of request meta-data can be done at any point in the program, or not at all (eg. for a hit-counter). Reading and parsing of data is referred to as '[link __loading__ loading]' and this follows '[link __accepting__ accepting]' a request.

Fortunately, this layer can be largely isolated from the rest of your program logic and development of both can continue in parallel. The two parts share a [link __ProtocolService__ ProtocolService], such as a `cgi::fcgi_service` (similar in use to an [link __asio_io_service__ asio::io_service] for those familiar with [link __asio__ Boost.Asio]).

The [link __examples__ examples] are divided like this, to keep them concise.



[endsect]
