service
-> makes:
    an io_service object, or takes a reference from the user
    a gateway
    a request queue (std::queue, empty)
    a container for request_parsers (std::set, empty)
    a dispatcher

gateway
-> constructed with the max number of connections allowed
-> makes:
    an acceptor
    a container for connections (std::set, empty)
-> asynchronously accepts a connection
-> verifies the connection is good: if not, then try another allowed type
-> notifies the service when a connection is created

service
-> makes:
    a request_parser

request_parser
-> constructed with the connection and the service
-> makes:
    a pointer to the request currently being served
    a relevant header object (uninitialized)
    a note of the current state of the parser
-> requests the connection read into a supplied buffer supplied by the
   request_parser

connection
-> constructed with the request_parser
-> does an async_read into the buffer supplied by the parser_
-> notify the parser_ when the read is complete: call parser_.parse()

request_parser
-> parse the supplied data
-> if it's a header, interpret it, handle it if necessary and then continue
-> the return value of parse():
    true => all ok, stop reading for now
    false => error: stop reading, close connection
    indeterminite => all ok, read some more
-> eventually, the request will be ready for being handled
    it's added to the request queue
-> read the next header only, in case it relates to another request


