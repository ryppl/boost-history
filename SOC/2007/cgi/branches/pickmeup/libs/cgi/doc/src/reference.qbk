[/
 / Copyright (c) 2009 Darren Garvey (darren at omnisplat dot com)
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:reference Reference]

[xinclude quickref.xml]


[section:common__error__cgi_errors__gt_ common::error::cgi_errors >]



  template<>
  struct is_error_code_enum< ::cgi::common::error::cgi_errors >


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__error__cgi_errors__gt_.BOOST_STATIC_CONSTANT [*BOOST_STATIC_CONSTANT]]]
    []
  ]
  
]


[section:BOOST_STATIC_CONSTANT common::error::cgi_errors >::BOOST_STATIC_CONSTANT]

[indexterm2 BOOST_STATIC_CONSTANT..common::error::cgi_errors >] 

  BOOST_STATIC_CONSTANT(
      bool ,
      value  = true);



[endsect]



[endsect]

[section:error__fcgi_errors__gt_ error::fcgi_errors >]



  template<>
  struct is_error_code_enum< ::cgi::error::fcgi_errors >


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.error__fcgi_errors__gt_.BOOST_STATIC_CONSTANT [*BOOST_STATIC_CONSTANT]]]
    []
  ]
  
]


[section:BOOST_STATIC_CONSTANT error::fcgi_errors >::BOOST_STATIC_CONSTANT]

[indexterm2 BOOST_STATIC_CONSTANT..error::fcgi_errors >] 

  BOOST_STATIC_CONSTANT(
      bool ,
      value  = true);



[endsect]



[endsect]


[section:acgi__acceptor acgi::acceptor]

[indexterm1 acgi::acceptor] Typedef for common usage (ACGI). 

  typedef ::cgi::common::basic_request_acceptor< acgi_request_acceptor_service<> > acceptor;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_request_acceptor.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.next_layer_type [*next_layer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.port_number_type [*port_number_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.service_type [*service_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request_acceptor.accept [*accept]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.assign [*assign]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.async_accept [*async_accept]]]
    [Asynchronously accept one request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor [*basic_request_acceptor]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.is_open [*is_open]]]
    [Check if the acceptor is open. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.listen [*listen]]]
    [Set the acceptor to listen. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.native [*native]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.open [*open]]]
    [Open the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.protocol_service [*protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor._basic_request_acceptor [*~basic_request_acceptor]]]
    []
  ]
  
]



[endsect]



[section:acgi__request acgi::request]

[indexterm1 acgi::request] 

  typedef common::basic_request< acgi::request_service, acgi::service > request;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.acgi__request_service.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_service.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.request_service [*request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.set_service [*set_service]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.set_status [*set_status]]]
    [Set the request status. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.read_env_vars [*read_env_vars]]]
    [Read the environment variables into an internal map. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_service.id [*id]]]
    []
  ]

]



[endsect]


[section:acgi__request_impl acgi::request_impl]



  class request_impl


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.acgi__request_impl.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_impl.conn_ptr [*conn_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_impl.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_impl.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_impl.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_impl.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_impl.connection [*connection]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_impl.http_status [*http_status]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_impl.request_impl [*request_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_impl.status [*status]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_impl.stdin_parsed [*stdin_parsed]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_impl.service_ [*service_]]]
    []
  ]

  [
    [[link cgi.reference.acgi__request_impl.stdin_bytes_left_ [*stdin_bytes_left_]]]
    []
  ]

  [
    [[link cgi.reference.acgi__request_impl.stdin_data_read_ [*stdin_data_read_]]]
    []
  ]

  [
    [[link cgi.reference.acgi__request_impl.stdin_parsed_ [*stdin_parsed_]]]
    []
  ]

]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_impl.connection_ [*connection_]]]
    []
  ]

  [
    [[link cgi.reference.acgi__request_impl.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.acgi__request_impl.request_status_ [*request_status_]]]
    []
  ]

]


[section:client_type acgi::request_impl::client_type]

[indexterm2 client_type..acgi::request_impl] 

  typedef ::cgi::common::basic_client< connection_type, common::tags::acgi > client_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_client.connection_ptr [*connection_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.async_read_some [*async_read_some]]]
    [Asynchronously read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.async_write_some [*async_write_some]]]
    [Asynchronously write some data to the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.basic_client [*basic_client]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.bytes_left [*bytes_left]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.connection [*connection]]]
    [Get a shared_ptr of the connection associated with the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.read_some [*read_some]]]
    [Read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.set_connection [*set_connection]]]
    [Associate a connection with this client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.write_some [*write_some]]]
    [Write some data to the client. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.bytes_left_ [*bytes_left_]]]
    []
  ]

]

A client is for two things: 1. To hold a full-duplex connection (or separate input and output connections). 2. To hold any protocol-specific data about the request. For now, this means the internal 'request number' associated by FastCGI with each request (ie. so incoming/outgoing packets can be wrapped with data noting what request it relates to). 3. Buffering. Not sure about how far this should go yet, but probably no further than minimal buffering. 4. Share a connection. Since a multiplexing connection is shared between multiple clients, the client should be responsible for taking possesion of the connection for a period of time (so it can write a complete packet). This idea could be taken quite far into genericity by making clients aware of how busy the connection is and size its output packets accordingly... But I'm not doing that. 



[endsect]



[section:conn_ptr acgi::request_impl::conn_ptr]

[indexterm2 conn_ptr..acgi::request_impl] 

  typedef connection_type::pointer conn_ptr;




[endsect]



[section:connection acgi::request_impl::connection]

[indexterm2 connection..acgi::request_impl] 

  conn_ptr & connection();



[endsect]



[section:connection_ acgi::request_impl::connection_]

[indexterm2 connection_..acgi::request_impl] 

  conn_ptr connection_;



[endsect]



[section:connection_type acgi::request_impl::connection_type]

[indexterm2 connection_type..acgi::request_impl] 

  typedef connections::async_stdio connection_type;




[endsect]



[section:http_status acgi::request_impl::http_status]

[indexterm2 http_status..acgi::request_impl] 

  common::http::status_code & http_status();



[endsect]



[section:http_status_ acgi::request_impl::http_status_]

[indexterm2 http_status_..acgi::request_impl] 

  common::http::status_code http_status_;



[endsect]



[section:map_type acgi::request_impl::map_type]

[indexterm2 map_type..acgi::request_impl] 

  typedef ::cgi::common::map map_type;




[endsect]



[section:protocol_service_type acgi::request_impl::protocol_service_type]

[indexterm2 protocol_service_type..acgi::request_impl] 

  typedef ::cgi::acgi::service protocol_service_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 



[endsect]



[section:protocol_type acgi::request_impl::protocol_type]

[indexterm2 protocol_type..acgi::request_impl] 

  typedef protocol_service_type::protocol_type protocol_type;




[endsect]



[section:request_impl acgi::request_impl::request_impl]

[indexterm2 request_impl..acgi::request_impl] 

  request_impl();



[endsect]



[section:request_status_ acgi::request_impl::request_status_]

[indexterm2 request_status_..acgi::request_impl] 

  common::request_status request_status_;



[endsect]



[section:service_ acgi::request_impl::service_]

[indexterm2 service_..acgi::request_impl] 

  protocol_service_type * service_;



[endsect]



[section:status acgi::request_impl::status]

[indexterm2 status..acgi::request_impl] 

  common::request_status & status();



[endsect]



[section:stdin_bytes_left_ acgi::request_impl::stdin_bytes_left_]

[indexterm2 stdin_bytes_left_..acgi::request_impl] 

  std::size_t stdin_bytes_left_;



[endsect]



[section:stdin_data_read_ acgi::request_impl::stdin_data_read_]

[indexterm2 stdin_data_read_..acgi::request_impl] 

  bool stdin_data_read_;



[endsect]



[section:stdin_parsed acgi::request_impl::stdin_parsed]

[indexterm2 stdin_parsed..acgi::request_impl] 

  bool stdin_parsed();



[endsect]



[section:stdin_parsed_ acgi::request_impl::stdin_parsed_]

[indexterm2 stdin_parsed_..acgi::request_impl] 

  bool stdin_parsed_;



[endsect]



[endsect]

[section:acgi__request_service acgi::request_service]



  class request_service :
    public cgi_service_impl_base< acgi::request_impl >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.acgi__request_service.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_service.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.request_service [*request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.set_service [*set_service]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.set_status [*set_status]]]
    [Set the request status. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.read_env_vars [*read_env_vars]]]
    [Read the environment variables into an internal map. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_service.id [*id]]]
    []
  ]

]


[section:base_type acgi::request_service::base_type]


['Inherited from cgi_service_impl_base.]

[indexterm2 base_type..acgi::request_service] 

  typedef common::request_base< self_type > base_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_base__impl_base [*impl_base]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
]

This class provides generic member functions that can be used by any request type. 



[endsect]



[section:clear acgi::request_service::clear]


['Inherited from cgi_service_impl_base.]

[indexterm2 clear..acgi::request_service] 

  void clear(
      implementation_type & impl);



[endsect]



[section:client acgi::request_service::client]


['Inherited from cgi_service_impl_base.]

[indexterm2 client..acgi::request_service] Return the connection associated with the request. 

  implementation_type::client_type & client(
      implementation_type & impl);



[endsect]



[section:close acgi::request_service::close]


['Inherited from cgi_service_impl_base.]

[indexterm2 close..acgi::request_service] 

  int close(
      implementation_type & impl,
      common::http::status_code & http_s,
      int status,
      boost::system::error_code & ec);



[endsect]



[section:construct acgi::request_service::construct]

[indexterm2 construct..acgi::request_service] 

  void construct(
      implementation_type & impl);



[endsect]



[section:destroy acgi::request_service::destroy]

[indexterm2 destroy..acgi::request_service] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:get_role acgi::request_service::get_role]


['Inherited from cgi_service_impl_base.]

[indexterm2 get_role..acgi::request_service] 

  role_type get_role(
      implementation_type & impl);



[endsect]



[section:id acgi::request_service::id]

[indexterm2 id..acgi::request_service] 

  static boost::asio::detail::service_id< request_service > id;



[endsect]



[section:is_file acgi::request_service::is_file]


['Inherited from common::request_base.]

[indexterm2 is_file..acgi::request_service] Check if a given POST variable represents a file upload. 

  bool is_file(
      ImplType & impl,
      typename ImplType::string_type const & key);



[endsect]



[section:is_open acgi::request_service::is_open]


['Inherited from cgi_service_impl_base.]

[indexterm2 is_open..acgi::request_service] Return if the request is still open. 

  bool is_open(
      implementation_type & impl);


For CGI, this always returns true. However, in the case that a "Location: xxx" header is sent and the header is terminated, the request can be taken to be 'closed'. 


[endsect]


[section:load acgi::request_service::load]

[indexterm2 load..acgi::request_service] Synchronously read/parse the request meta-data. 

  boost::system::error_code ``[link cgi.reference.acgi__request_service.load.overload1 load]``(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);

  boost::system::error_code & ``[link cgi.reference.acgi__request_service.load.overload2 load]``(
      implementation_type & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);


[section:overload1 acgi::request_service::load (1 of 2 overloads)]


['Inherited from common::request_base.]

Synchronously read/parse the request meta-data. 

  boost::system::error_code load(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);



[endsect]



[section:overload2 acgi::request_service::load (2 of 2 overloads)]


['Inherited from cgi_service_impl_base.]

Synchronously read/parse the request data. 

  boost::system::error_code & load(
      implementation_type & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:load_environment acgi::request_service::load_environment]


['Inherited from common::request_base.]

[indexterm2 load_environment..acgi::request_service] Load the base_environment into the current environment. 

  void load_environment(
      ImplType & impl,
      char ** base_environment,
      bool is_command_line);


Parsed the base\_environment and add it to the current request's environment. This overwrites any environment variables with the existing key.

If `is\_command\_line` is true, then the first argument is skipped as this is the name of the program and ignored. Using it actually causes a crash on Windows (MSVC 9) anyway: I'm not exactly sure why. 


[endsect]



[section:map_type acgi::request_service::map_type]


['Inherited from cgi_service_impl_base.]

[indexterm2 map_type..acgi::request_service] 

  typedef ::cgi::common::map map_type;




[endsect]



[section:parse_cookie_vars acgi::request_service::parse_cookie_vars]


['Inherited from common::request_base.]

[indexterm2 parse_cookie_vars..acgi::request_service] Read and parse the HTTP_COOKIE meta variable. 

  boost::system::error_code parse_cookie_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_get_vars acgi::request_service::parse_get_vars]


['Inherited from common::request_base.]

[indexterm2 parse_get_vars..acgi::request_service] Read and parse the cgi GET meta variables. 

  boost::system::error_code parse_get_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_post_vars acgi::request_service::parse_post_vars]


['Inherited from cgi_service_impl_base.]

[indexterm2 parse_post_vars..acgi::request_service] Read and parse the cgi POST meta variables (greedily). 

  boost::system::error_code parse_post_vars(
      RequestImpl & impl,
      boost::system::error_code & ec);



[endsect]



[section:protocol_service_type acgi::request_service::protocol_service_type]

[indexterm2 protocol_service_type..acgi::request_service] 

  typedef acgi::service protocol_service_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 



[endsect]



[section:protocol_type acgi::request_service::protocol_type]

[indexterm2 protocol_type..acgi::request_service] 

  typedef common::tags::acgi protocol_type;




[endsect]



[section:read_env_vars acgi::request_service::read_env_vars]


['Inherited from cgi_service_impl_base.]

[indexterm2 read_env_vars..acgi::request_service] Read the environment variables into an internal map. 

  boost::system::error_code read_env_vars(
      RequestImpl & impl,
      boost::system::error_code & ec);



[endsect]


[section:read_some acgi::request_service::read_some]

[indexterm2 read_some..acgi::request_service] Read some data from the client into the supplied buffer. 

  std::size_t ``[link cgi.reference.acgi__request_service.read_some.overload1 read_some]``(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);

  std::size_t ``[link cgi.reference.acgi__request_service.read_some.overload2 read_some]``(
      ImplType & impl,
      boost::system::error_code & ec);

  std::size_t ``[link cgi.reference.acgi__request_service.read_some.overload3 read_some]``(
      implementation_type & impl,
      boost::system::error_code & ec);


[section:overload1 acgi::request_service::read_some (1 of 3 overloads)]


['Inherited from common::request_base.]

Read some data from the client into the supplied buffer. 

  std::size_t read_some(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 acgi::request_service::read_some (2 of 3 overloads)]


['Inherited from common::request_base.]

Read some data into the internal buffer. 

  std::size_t read_some(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:overload3 acgi::request_service::read_some (3 of 3 overloads)]


['Inherited from cgi_service_impl_base.]



  std::size_t read_some(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:request_id acgi::request_service::request_id]

[indexterm2 request_id..acgi::request_service] Get the request ID of a FastCGI request, or 1. 

  boost::uint16_t const & ``[link cgi.reference.acgi__request_service.request_id.overload1 request_id]``(
      ImplType & impl) const;

  int ``[link cgi.reference.acgi__request_service.request_id.overload2 request_id]``(
      implementation_type & impl);


[section:overload1 acgi::request_service::request_id (1 of 2 overloads)]


['Inherited from common::request_base.]

Get the request ID of a FastCGI request, or 1. 

  boost::uint16_t const & request_id(
      ImplType & impl) const;



[endsect]



[section:overload2 acgi::request_service::request_id (2 of 2 overloads)]


['Inherited from cgi_service_impl_base.]



  int request_id(
      implementation_type & impl);



[endsect]


[endsect]


[section:request_service acgi::request_service::request_service]

[indexterm2 request_service..acgi::request_service] 

  request_service(
      common::io_service & ios);



[endsect]



[section:self_type acgi::request_service::self_type]


['Inherited from cgi_service_impl_base.]

[indexterm2 self_type..acgi::request_service] 

  typedef cgi_service_impl_base< acgi::request_impl > self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.cgi_service_impl_base.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base__callback_functor [*callback_functor]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base__implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.self_type [*self_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base.cgi_service_impl_base [*cgi_service_impl_base]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.set_status [*set_status]]]
    [Set the request status. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.read_env_vars [*read_env_vars]]]
    [Read the environment variables into an internal map. ]
  ]
  
]



[endsect]



[section:set_service acgi::request_service::set_service]

[indexterm2 set_service..acgi::request_service] 

  void set_service(
      implementation_type & impl,
      protocol_service_type & ps);



[endsect]


[section:set_status acgi::request_service::set_status]

[indexterm2 set_status..acgi::request_service] Set the request status. 

  void ``[link cgi.reference.acgi__request_service.set_status.overload1 set_status]``(
      implementation_type & impl,
      common::request_status status);

  void ``[link cgi.reference.acgi__request_service.set_status.overload2 set_status]``(
      implementation_type & impl,
      common::http::status_code & );


[section:overload1 acgi::request_service::set_status (1 of 2 overloads)]


['Inherited from cgi_service_impl_base.]

Set the request status. 

  void set_status(
      implementation_type & impl,
      common::request_status status);



[endsect]



[section:overload2 acgi::request_service::set_status (2 of 2 overloads)]


['Inherited from cgi_service_impl_base.]

Set the http status (this does nothing for aCGI). 

  void set_status(
      implementation_type & impl,
      common::http::status_code & );



[endsect]


[endsect]


[section:shutdown_service acgi::request_service::shutdown_service]

[indexterm2 shutdown_service..acgi::request_service] 

  void shutdown_service();



[endsect]



[section:type acgi::request_service::type]

[indexterm2 type..acgi::request_service] 

  typedef request_service type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.acgi__request_service.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.acgi__request_service.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_service.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.request_service [*request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.set_service [*set_service]]]
    []
  ]
  
  [
    [[link cgi.reference.acgi__request_service.set_status [*set_status]]]
    [Set the request status. ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.acgi__request_service.read_env_vars [*read_env_vars]]]
    [Read the environment variables into an internal map. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.acgi__request_service.id [*id]]]
    []
  ]

]



[endsect]



[endsect]


[section:acgi__service acgi::service]

[indexterm1 acgi::service] 

  typedef common::basic_protocol_service< common::tags::acgi > service;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 



[endsect]


[section:cgi_request_impl cgi_request_impl]

Implementation for a standard CGI request. 

  class cgi_request_impl


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.cgi_request_impl.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_request_impl.conn_ptr [*conn_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_request_impl.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_request_impl.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_request_impl.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_request_impl.cgi_request_impl [*cgi_request_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_impl.connection [*connection]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_impl.http_status [*http_status]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_impl.status [*status]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_impl.stdin_parsed [*stdin_parsed]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_request_impl.stdin_bytes_left_ [*stdin_bytes_left_]]]
    []
  ]

  [
    [[link cgi.reference.cgi_request_impl.stdin_data_read_ [*stdin_data_read_]]]
    []
  ]

  [
    [[link cgi.reference.cgi_request_impl.stdin_parsed_ [*stdin_parsed_]]]
    []
  ]

]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_request_impl.connection_ [*connection_]]]
    []
  ]

  [
    [[link cgi.reference.cgi_request_impl.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.cgi_request_impl.request_status_ [*request_status_]]]
    []
  ]

]

Note: This isn't noncopyable since there's no real reason it can't be copied around. Since basic\_request is noncopyable, basic copying will be restricted but if someone really wants to copy the data, then they can. 

[section:cgi_request_impl cgi_request_impl::cgi_request_impl]

[indexterm2 cgi_request_impl..cgi_request_impl] 

  ``[link cgi.reference.cgi_request_impl.cgi_request_impl.overload1 cgi_request_impl]``();

  template<
      typename ProtocolService >
  ``[link cgi.reference.cgi_request_impl.cgi_request_impl.overload2 cgi_request_impl]``(
      ProtocolService & pserv);


[section:overload1 cgi_request_impl::cgi_request_impl (1 of 2 overloads)]



  cgi_request_impl();



[endsect]



[section:overload2 cgi_request_impl::cgi_request_impl (2 of 2 overloads)]

Constructor. 

  template<
      typename ProtocolService >
  cgi_request_impl(
      ProtocolService & pserv);


Since this request type is synchronous, there is no need for an io\_service, so the passed ProtocolService is just ignored. 


[endsect]


[endsect]


[section:client_type cgi_request_impl::client_type]

[indexterm2 client_type..cgi_request_impl] 

  typedef common::basic_client< connections::stdio, common::tags::cgi > client_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_client.connection_ptr [*connection_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.async_read_some [*async_read_some]]]
    [Asynchronously read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.async_write_some [*async_write_some]]]
    [Asynchronously write some data to the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.basic_client [*basic_client]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.bytes_left [*bytes_left]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.connection [*connection]]]
    [Get a shared_ptr of the connection associated with the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.read_some [*read_some]]]
    [Read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.set_connection [*set_connection]]]
    [Associate a connection with this client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.write_some [*write_some]]]
    [Write some data to the client. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.bytes_left_ [*bytes_left_]]]
    []
  ]

]

A client is for two things: 1. To hold a full-duplex connection (or separate input and output connections). 2. To hold any protocol-specific data about the request. For now, this means the internal 'request number' associated by FastCGI with each request (ie. so incoming/outgoing packets can be wrapped with data noting what request it relates to). 3. Buffering. Not sure about how far this should go yet, but probably no further than minimal buffering. 4. Share a connection. Since a multiplexing connection is shared between multiple clients, the client should be responsible for taking possesion of the connection for a period of time (so it can write a complete packet). This idea could be taken quite far into genericity by making clients aware of how busy the connection is and size its output packets accordingly... But I'm not doing that. 



[endsect]



[section:conn_ptr cgi_request_impl::conn_ptr]

[indexterm2 conn_ptr..cgi_request_impl] 

  typedef connection_type::pointer conn_ptr;




[endsect]



[section:connection cgi_request_impl::connection]

[indexterm2 connection..cgi_request_impl] 

  conn_ptr & connection();



[endsect]



[section:connection_ cgi_request_impl::connection_]

[indexterm2 connection_..cgi_request_impl] 

  conn_ptr connection_;



[endsect]



[section:connection_type cgi_request_impl::connection_type]

[indexterm2 connection_type..cgi_request_impl] 

  typedef connections::stdio connection_type;




[endsect]



[section:http_status cgi_request_impl::http_status]

[indexterm2 http_status..cgi_request_impl] 

  common::http::status_code & http_status();



[endsect]



[section:http_status_ cgi_request_impl::http_status_]

[indexterm2 http_status_..cgi_request_impl] 

  common::http::status_code http_status_;



[endsect]



[section:map_type cgi_request_impl::map_type]

[indexterm2 map_type..cgi_request_impl] 

  typedef ::cgi::common::map map_type;




[endsect]



[section:protocol_type cgi_request_impl::protocol_type]

[indexterm2 protocol_type..cgi_request_impl] 

  typedef common::tags::cgi protocol_type;




[endsect]



[section:request_status_ cgi_request_impl::request_status_]

[indexterm2 request_status_..cgi_request_impl] 

  common::request_status request_status_;



[endsect]



[section:status cgi_request_impl::status]

[indexterm2 status..cgi_request_impl] 

  common::request_status & status();



[endsect]



[section:stdin_bytes_left_ cgi_request_impl::stdin_bytes_left_]

[indexterm2 stdin_bytes_left_..cgi_request_impl] 

  std::size_t stdin_bytes_left_;



[endsect]



[section:stdin_data_read_ cgi_request_impl::stdin_data_read_]

[indexterm2 stdin_data_read_..cgi_request_impl] 

  bool stdin_data_read_;



[endsect]



[section:stdin_parsed cgi_request_impl::stdin_parsed]

[indexterm2 stdin_parsed..cgi_request_impl] 

  bool stdin_parsed();



[endsect]



[section:stdin_parsed_ cgi_request_impl::stdin_parsed_]

[indexterm2 stdin_parsed_..cgi_request_impl] 

  bool stdin_parsed_;



[endsect]



[endsect]

[section:cgi_request_service cgi_request_service]



  class cgi_request_service :
    public cgi_service_impl_base< cgi_request_impl >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.cgi_request_service.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_request_service.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_request_service.self_type [*self_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_request_service.cgi_request_service [*cgi_request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_service.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_service.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_request_service.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.set_status [*set_status]]]
    [Set the request status. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.cgi_request_service.read_env_vars [*read_env_vars]]]
    [Read the environment variables into an internal map. ]
  ]
  
]


[section:base_type cgi_request_service::base_type]


['Inherited from cgi_service_impl_base.]

[indexterm2 base_type..cgi_request_service] 

  typedef common::request_base< self_type > base_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_base__impl_base [*impl_base]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
]

This class provides generic member functions that can be used by any request type. 



[endsect]


[section:cgi_request_service cgi_request_service::cgi_request_service]

[indexterm2 cgi_request_service..cgi_request_service] 

  template<
      typename T >
  ``[link cgi.reference.cgi_request_service.cgi_request_service.overload1 cgi_request_service]``(
      T & );

  ``[link cgi.reference.cgi_request_service.cgi_request_service.overload2 cgi_request_service]``();


[section:overload1 cgi_request_service::cgi_request_service (1 of 2 overloads)]



  template<
      typename T >
  cgi_request_service(
      T & );



[endsect]



[section:overload2 cgi_request_service::cgi_request_service (2 of 2 overloads)]



  cgi_request_service();



[endsect]


[endsect]


[section:clear cgi_request_service::clear]


['Inherited from cgi_service_impl_base.]

[indexterm2 clear..cgi_request_service] 

  void clear(
      implementation_type & impl);



[endsect]



[section:client cgi_request_service::client]


['Inherited from cgi_service_impl_base.]

[indexterm2 client..cgi_request_service] Return the connection associated with the request. 

  implementation_type::client_type & client(
      implementation_type & impl);



[endsect]



[section:close cgi_request_service::close]


['Inherited from cgi_service_impl_base.]

[indexterm2 close..cgi_request_service] 

  int close(
      implementation_type & impl,
      common::http::status_code & http_s,
      int status,
      boost::system::error_code & ec);



[endsect]



[section:construct cgi_request_service::construct]

[indexterm2 construct..cgi_request_service] 

  void construct(
      implementation_type & impl);



[endsect]



[section:destroy cgi_request_service::destroy]

[indexterm2 destroy..cgi_request_service] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:get_role cgi_request_service::get_role]


['Inherited from cgi_service_impl_base.]

[indexterm2 get_role..cgi_request_service] 

  role_type get_role(
      implementation_type & impl);



[endsect]



[section:is_file cgi_request_service::is_file]


['Inherited from common::request_base.]

[indexterm2 is_file..cgi_request_service] Check if a given POST variable represents a file upload. 

  bool is_file(
      ImplType & impl,
      typename ImplType::string_type const & key);



[endsect]



[section:is_open cgi_request_service::is_open]


['Inherited from cgi_service_impl_base.]

[indexterm2 is_open..cgi_request_service] Return if the request is still open. 

  bool is_open(
      implementation_type & impl);


For CGI, this always returns true. However, in the case that a "Location: xxx" header is sent and the header is terminated, the request can be taken to be 'closed'. 


[endsect]


[section:load cgi_request_service::load]

[indexterm2 load..cgi_request_service] Synchronously read/parse the request meta-data. 

  boost::system::error_code ``[link cgi.reference.cgi_request_service.load.overload1 load]``(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);

  boost::system::error_code & ``[link cgi.reference.cgi_request_service.load.overload2 load]``(
      implementation_type & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);


[section:overload1 cgi_request_service::load (1 of 2 overloads)]


['Inherited from common::request_base.]

Synchronously read/parse the request meta-data. 

  boost::system::error_code load(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);



[endsect]



[section:overload2 cgi_request_service::load (2 of 2 overloads)]


['Inherited from cgi_service_impl_base.]

Synchronously read/parse the request data. 

  boost::system::error_code & load(
      implementation_type & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:load_environment cgi_request_service::load_environment]


['Inherited from common::request_base.]

[indexterm2 load_environment..cgi_request_service] Load the base_environment into the current environment. 

  void load_environment(
      ImplType & impl,
      char ** base_environment,
      bool is_command_line);


Parsed the base\_environment and add it to the current request's environment. This overwrites any environment variables with the existing key.

If `is\_command\_line` is true, then the first argument is skipped as this is the name of the program and ignored. Using it actually causes a crash on Windows (MSVC 9) anyway: I'm not exactly sure why. 


[endsect]



[section:map_type cgi_request_service::map_type]


['Inherited from cgi_service_impl_base.]

[indexterm2 map_type..cgi_request_service] 

  typedef ::cgi::common::map map_type;




[endsect]



[section:parse_cookie_vars cgi_request_service::parse_cookie_vars]


['Inherited from common::request_base.]

[indexterm2 parse_cookie_vars..cgi_request_service] Read and parse the HTTP_COOKIE meta variable. 

  boost::system::error_code parse_cookie_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_get_vars cgi_request_service::parse_get_vars]


['Inherited from common::request_base.]

[indexterm2 parse_get_vars..cgi_request_service] Read and parse the cgi GET meta variables. 

  boost::system::error_code parse_get_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_post_vars cgi_request_service::parse_post_vars]


['Inherited from cgi_service_impl_base.]

[indexterm2 parse_post_vars..cgi_request_service] Read and parse the cgi POST meta variables (greedily). 

  boost::system::error_code parse_post_vars(
      RequestImpl & impl,
      boost::system::error_code & ec);



[endsect]



[section:protocol_type cgi_request_service::protocol_type]

[indexterm2 protocol_type..cgi_request_service] 

  typedef common::tags::cgi protocol_type;




[endsect]



[section:read_env_vars cgi_request_service::read_env_vars]


['Inherited from cgi_service_impl_base.]

[indexterm2 read_env_vars..cgi_request_service] Read the environment variables into an internal map. 

  boost::system::error_code read_env_vars(
      RequestImpl & impl,
      boost::system::error_code & ec);



[endsect]


[section:read_some cgi_request_service::read_some]

[indexterm2 read_some..cgi_request_service] Read some data from the client into the supplied buffer. 

  std::size_t ``[link cgi.reference.cgi_request_service.read_some.overload1 read_some]``(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);

  std::size_t ``[link cgi.reference.cgi_request_service.read_some.overload2 read_some]``(
      ImplType & impl,
      boost::system::error_code & ec);

  std::size_t ``[link cgi.reference.cgi_request_service.read_some.overload3 read_some]``(
      implementation_type & impl,
      boost::system::error_code & ec);


[section:overload1 cgi_request_service::read_some (1 of 3 overloads)]


['Inherited from common::request_base.]

Read some data from the client into the supplied buffer. 

  std::size_t read_some(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 cgi_request_service::read_some (2 of 3 overloads)]


['Inherited from common::request_base.]

Read some data into the internal buffer. 

  std::size_t read_some(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:overload3 cgi_request_service::read_some (3 of 3 overloads)]


['Inherited from cgi_service_impl_base.]



  std::size_t read_some(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:request_id cgi_request_service::request_id]

[indexterm2 request_id..cgi_request_service] Get the request ID of a FastCGI request, or 1. 

  boost::uint16_t const & ``[link cgi.reference.cgi_request_service.request_id.overload1 request_id]``(
      ImplType & impl) const;

  int ``[link cgi.reference.cgi_request_service.request_id.overload2 request_id]``(
      implementation_type & impl);


[section:overload1 cgi_request_service::request_id (1 of 2 overloads)]


['Inherited from common::request_base.]

Get the request ID of a FastCGI request, or 1. 

  boost::uint16_t const & request_id(
      ImplType & impl) const;



[endsect]



[section:overload2 cgi_request_service::request_id (2 of 2 overloads)]


['Inherited from cgi_service_impl_base.]



  int request_id(
      implementation_type & impl);



[endsect]


[endsect]


[section:self_type cgi_request_service::self_type]


['Inherited from cgi_service_impl_base.]

[indexterm2 self_type..cgi_request_service] 

  typedef cgi_service_impl_base< cgi_request_impl > self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.cgi_service_impl_base.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base__callback_functor [*callback_functor]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base__implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.self_type [*self_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base.cgi_service_impl_base [*cgi_service_impl_base]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.set_status [*set_status]]]
    [Set the request status. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.read_env_vars [*read_env_vars]]]
    [Read the environment variables into an internal map. ]
  ]
  
]



[endsect]


[section:set_status cgi_request_service::set_status]

[indexterm2 set_status..cgi_request_service] Set the request status. 

  void ``[link cgi.reference.cgi_request_service.set_status.overload1 set_status]``(
      implementation_type & impl,
      common::request_status status);

  void ``[link cgi.reference.cgi_request_service.set_status.overload2 set_status]``(
      implementation_type & impl,
      common::http::status_code & );


[section:overload1 cgi_request_service::set_status (1 of 2 overloads)]


['Inherited from cgi_service_impl_base.]

Set the request status. 

  void set_status(
      implementation_type & impl,
      common::request_status status);



[endsect]



[section:overload2 cgi_request_service::set_status (2 of 2 overloads)]


['Inherited from cgi_service_impl_base.]

Set the http status (this does nothing for aCGI). 

  void set_status(
      implementation_type & impl,
      common::http::status_code & );



[endsect]


[endsect]


[endsect]

[section:cgi_service_impl_base cgi_service_impl_base]



  template<
      typename ``[link cgi.reference.RequestImplType RequestImplType]``>
  class cgi_service_impl_base :
    public common::request_base< cgi_service_impl_base< RequestImplType > >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.cgi_service_impl_base.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base__callback_functor [*callback_functor]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base__implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.self_type [*self_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base.cgi_service_impl_base [*cgi_service_impl_base]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.set_status [*set_status]]]
    [Set the request status. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.read_env_vars [*read_env_vars]]]
    [Read the environment variables into an internal map. ]
  ]
  
]


[section:base_type cgi_service_impl_base::base_type]

[indexterm2 base_type..cgi_service_impl_base] 

  typedef common::request_base< self_type > base_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_base__impl_base [*impl_base]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
]

This class provides generic member functions that can be used by any request type. 



[endsect]


[section:cgi_service_impl_base cgi_service_impl_base::cgi_service_impl_base]

[indexterm2 cgi_service_impl_base..cgi_service_impl_base] 

  template<
      typename T >
  ``[link cgi.reference.cgi_service_impl_base.cgi_service_impl_base.overload1 cgi_service_impl_base]``(
      T & );

  ``[link cgi.reference.cgi_service_impl_base.cgi_service_impl_base.overload2 cgi_service_impl_base]``();


[section:overload1 cgi_service_impl_base::cgi_service_impl_base (1 of 2 overloads)]



  template<
      typename T >
  cgi_service_impl_base(
      T & );



[endsect]



[section:overload2 cgi_service_impl_base::cgi_service_impl_base (2 of 2 overloads)]



  cgi_service_impl_base();



[endsect]


[endsect]


[section:clear cgi_service_impl_base::clear]

[indexterm2 clear..cgi_service_impl_base] 

  void clear(
      implementation_type & impl);



[endsect]



[section:client cgi_service_impl_base::client]

[indexterm2 client..cgi_service_impl_base] Return the connection associated with the request. 

  implementation_type::client_type & client(
      implementation_type & impl);



[endsect]



[section:close cgi_service_impl_base::close]

[indexterm2 close..cgi_service_impl_base] 

  int close(
      implementation_type & impl,
      common::http::status_code & http_s,
      int status,
      boost::system::error_code & ec);



[endsect]



[section:get_role cgi_service_impl_base::get_role]

[indexterm2 get_role..cgi_service_impl_base] 

  role_type get_role(
      implementation_type & impl);



[endsect]



[section:is_file cgi_service_impl_base::is_file]


['Inherited from common::request_base.]

[indexterm2 is_file..cgi_service_impl_base] Check if a given POST variable represents a file upload. 

  bool is_file(
      ImplType & impl,
      typename ImplType::string_type const & key);



[endsect]



[section:is_open cgi_service_impl_base::is_open]

[indexterm2 is_open..cgi_service_impl_base] Return if the request is still open. 

  bool is_open(
      implementation_type & impl);


For CGI, this always returns true. However, in the case that a "Location: xxx" header is sent and the header is terminated, the request can be taken to be 'closed'. 


[endsect]


[section:load cgi_service_impl_base::load]

[indexterm2 load..cgi_service_impl_base] Synchronously read/parse the request meta-data. 

  boost::system::error_code ``[link cgi.reference.cgi_service_impl_base.load.overload1 load]``(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);

  boost::system::error_code & ``[link cgi.reference.cgi_service_impl_base.load.overload2 load]``(
      implementation_type & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);


[section:overload1 cgi_service_impl_base::load (1 of 2 overloads)]


['Inherited from common::request_base.]

Synchronously read/parse the request meta-data. 

  boost::system::error_code load(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);



[endsect]



[section:overload2 cgi_service_impl_base::load (2 of 2 overloads)]

Synchronously read/parse the request data. 

  boost::system::error_code & load(
      implementation_type & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:load_environment cgi_service_impl_base::load_environment]


['Inherited from common::request_base.]

[indexterm2 load_environment..cgi_service_impl_base] Load the base_environment into the current environment. 

  void load_environment(
      ImplType & impl,
      char ** base_environment,
      bool is_command_line);


Parsed the base\_environment and add it to the current request's environment. This overwrites any environment variables with the existing key.

If `is\_command\_line` is true, then the first argument is skipped as this is the name of the program and ignored. Using it actually causes a crash on Windows (MSVC 9) anyway: I'm not exactly sure why. 


[endsect]



[section:map_type cgi_service_impl_base::map_type]

[indexterm2 map_type..cgi_service_impl_base] 

  typedef ::cgi::common::map map_type;




[endsect]



[section:parse_cookie_vars cgi_service_impl_base::parse_cookie_vars]


['Inherited from common::request_base.]

[indexterm2 parse_cookie_vars..cgi_service_impl_base] Read and parse the HTTP_COOKIE meta variable. 

  boost::system::error_code parse_cookie_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_get_vars cgi_service_impl_base::parse_get_vars]


['Inherited from common::request_base.]

[indexterm2 parse_get_vars..cgi_service_impl_base] Read and parse the cgi GET meta variables. 

  boost::system::error_code parse_get_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_post_vars cgi_service_impl_base::parse_post_vars]

[indexterm2 parse_post_vars..cgi_service_impl_base] Read and parse the cgi POST meta variables (greedily). 

  template<
      typename RequestImpl >
  boost::system::error_code parse_post_vars(
      RequestImpl & impl,
      boost::system::error_code & ec);



[endsect]



[section:protocol_type cgi_service_impl_base::protocol_type]

[indexterm2 protocol_type..cgi_service_impl_base] 

  typedef RequestImplType::protocol_type protocol_type;




[endsect]



[section:read_env_vars cgi_service_impl_base::read_env_vars]

[indexterm2 read_env_vars..cgi_service_impl_base] Read the environment variables into an internal map. 

  template<
      typename RequestImpl >
  boost::system::error_code read_env_vars(
      RequestImpl & impl,
      boost::system::error_code & ec);



[endsect]


[section:read_some cgi_service_impl_base::read_some]

[indexterm2 read_some..cgi_service_impl_base] Read some data from the client into the supplied buffer. 

  std::size_t ``[link cgi.reference.cgi_service_impl_base.read_some.overload1 read_some]``(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);

  std::size_t ``[link cgi.reference.cgi_service_impl_base.read_some.overload2 read_some]``(
      ImplType & impl,
      boost::system::error_code & ec);

  std::size_t ``[link cgi.reference.cgi_service_impl_base.read_some.overload3 read_some]``(
      implementation_type & impl,
      boost::system::error_code & ec);


[section:overload1 cgi_service_impl_base::read_some (1 of 3 overloads)]


['Inherited from common::request_base.]

Read some data from the client into the supplied buffer. 

  std::size_t read_some(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 cgi_service_impl_base::read_some (2 of 3 overloads)]


['Inherited from common::request_base.]

Read some data into the internal buffer. 

  std::size_t read_some(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:overload3 cgi_service_impl_base::read_some (3 of 3 overloads)]



  std::size_t read_some(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:request_id cgi_service_impl_base::request_id]

[indexterm2 request_id..cgi_service_impl_base] Get the request ID of a FastCGI request, or 1. 

  boost::uint16_t const & ``[link cgi.reference.cgi_service_impl_base.request_id.overload1 request_id]``(
      ImplType & impl) const;

  int ``[link cgi.reference.cgi_service_impl_base.request_id.overload2 request_id]``(
      implementation_type & impl);


[section:overload1 cgi_service_impl_base::request_id (1 of 2 overloads)]


['Inherited from common::request_base.]

Get the request ID of a FastCGI request, or 1. 

  boost::uint16_t const & request_id(
      ImplType & impl) const;



[endsect]



[section:overload2 cgi_service_impl_base::request_id (2 of 2 overloads)]



  int request_id(
      implementation_type & impl);



[endsect]


[endsect]


[section:self_type cgi_service_impl_base::self_type]

[indexterm2 self_type..cgi_service_impl_base] 

  typedef cgi_service_impl_base< RequestImplType > self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.cgi_service_impl_base.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base__callback_functor [*callback_functor]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base__implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base.self_type [*self_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base.cgi_service_impl_base [*cgi_service_impl_base]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.set_status [*set_status]]]
    [Set the request status. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base.read_env_vars [*read_env_vars]]]
    [Read the environment variables into an internal map. ]
  ]
  
]



[endsect]


[section:set_status cgi_service_impl_base::set_status]

[indexterm2 set_status..cgi_service_impl_base] Set the request status. 

  void ``[link cgi.reference.cgi_service_impl_base.set_status.overload1 set_status]``(
      implementation_type & impl,
      common::request_status status);

  void ``[link cgi.reference.cgi_service_impl_base.set_status.overload2 set_status]``(
      implementation_type & impl,
      common::http::status_code & );


[section:overload1 cgi_service_impl_base::set_status (1 of 2 overloads)]

Set the request status. 

  void set_status(
      implementation_type & impl,
      common::request_status status);



[endsect]



[section:overload2 cgi_service_impl_base::set_status (2 of 2 overloads)]

Set the http status (this does nothing for aCGI). 

  void set_status(
      implementation_type & impl,
      common::http::status_code & );



[endsect]


[endsect]


[endsect]

[section:cgi_service_impl_base__callback_functor cgi_service_impl_base::callback_functor]



  template<
      typename Service >
  struct callback_functor


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base__callback_functor.callback_functor [*callback_functor]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi_service_impl_base__callback_functor.operator() [*operator()]]]
    []
  ]
  
]


[section:callback_functor cgi_service_impl_base::callback_functor::callback_functor]

[indexterm2 callback_functor..cgi_service_impl_base::callback_functor] 

  callback_functor(
      implementation_type & impl,
      Service * service);



[endsect]



[section:operator() cgi_service_impl_base::callback_functor::operator()]

[indexterm2 operator()..cgi_service_impl_base::callback_functor] 

  std::size_t operator()(
      boost::system::error_code & ec);



[endsect]



[endsect]

[section:cgi_service_impl_base__implementation_type cgi_service_impl_base::implementation_type]



  struct implementation_type :
    common::request_base< T >::impl_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.cgi_service_impl_base__implementation_type.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi_service_impl_base__implementation_type.form_parser_type [*form_parser_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base__implementation_type.implementation_type [*implementation_type]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi_service_impl_base__implementation_type.characters_left_ [*characters_left_]]]
    []
  ]

  [
    [[link cgi.reference.cgi_service_impl_base__implementation_type.client_ [*client_]]]
    []
  ]

  [
    [[link cgi.reference.cgi_service_impl_base__implementation_type.fp_ [*fp_]]]
    []
  ]

]


[section:characters_left_ cgi_service_impl_base::implementation_type::characters_left_]

[indexterm2 characters_left_..cgi_service_impl_base::implementation_type] 

  std::size_t characters_left_;



[endsect]



[section:client_ cgi_service_impl_base::implementation_type::client_]

[indexterm2 client_..cgi_service_impl_base::implementation_type] 

  client_type client_;



[endsect]



[section:client_type cgi_service_impl_base::implementation_type::client_type]

[indexterm2 client_type..cgi_service_impl_base::implementation_type] 

  typedef RequestImplType::client_type client_type;




[endsect]



[section:form_parser_type cgi_service_impl_base::implementation_type::form_parser_type]

[indexterm2 form_parser_type..cgi_service_impl_base::implementation_type] 

  typedef detail::form_parser form_parser_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.detail__form_parser.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.detail__form_parser.callback_type [*callback_type]]]
    [The callback functor to read more data. ]
  
  ]

  [

    [[link cgi.reference.detail__form_parser__context [*context]]]
    [The context used for parsing. ]
  
  ]

  [

    [[link cgi.reference.detail__form_parser.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.detail__form_parser.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.detail__form_parser.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.detail__form_parser.buffer_string [*buffer_string]]]
    []
  ]
  
  [
    [[link cgi.reference.detail__form_parser.form_parser [*form_parser]]]
    []
  ]
  
  [
    [[link cgi.reference.detail__form_parser.move_to_start_of_first_part [*move_to_start_of_first_part]]]
    [Erase any front-cruft on the form data. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse [*parse]]]
    [Run the parser on the given `context`. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse_boundary_marker [*parse_boundary_marker]]]
    [Get the boundary marker from the CONTENT_TYPE header. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse_form_part [*parse_form_part]]]
    [Parse a single form part. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse_multipart_form [*parse_multipart_form]]]
    [Parse a multipart form. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse_url_encoded_form [*parse_url_encoded_form]]]
    [URL-encoded forms. ]
  ]
  
]

Construct this and then call `form\_parserparse` with an instance of form_parser::context (or compatible struct).

This is minimal and doesn't extract all meta-data yet, but is known to work on Windows XP with MSVC9.0 and Ubuntu linux with gcc 4.2.x and 4.3.x.

Valid Form Encodings > `application/x-www-form-urlencoded` > `multipart/form-data`

File uploads (ie. in `multipart/form-data` forms) are saved to disk. See the `BOOST\_CGI\_UPLOAD\_DIRECTORY` macro.

Should also work for HTTP POST data. 



[endsect]



[section:fp_ cgi_service_impl_base::implementation_type::fp_]

[indexterm2 fp_..cgi_service_impl_base::implementation_type] 

  boost::scoped_ptr< form_parser_type > fp_;



[endsect]



[section:implementation_type cgi_service_impl_base::implementation_type::implementation_type]

[indexterm2 implementation_type..cgi_service_impl_base::implementation_type] 

  implementation_type();



[endsect]



[endsect]

[section:common__basic_client common::basic_client]

A client. 

  template<
      typename Connection ,
      typename Protocol >
  class basic_client


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_client.connection_ptr [*connection_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.async_read_some [*async_read_some]]]
    [Asynchronously read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.async_write_some [*async_write_some]]]
    [Asynchronously write some data to the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.basic_client [*basic_client]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.bytes_left [*bytes_left]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.connection [*connection]]]
    [Get a shared_ptr of the connection associated with the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.read_some [*read_some]]]
    [Read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.set_connection [*set_connection]]]
    [Associate a connection with this client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.write_some [*write_some]]]
    [Write some data to the client. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.bytes_left_ [*bytes_left_]]]
    []
  ]

]

A client is for two things: 1. To hold a full-duplex connection (or separate input and output connections). 2. To hold any protocol-specific data about the request. For now, this means the internal 'request number' associated by FastCGI with each request (ie. so incoming/outgoing packets can be wrapped with data noting what request it relates to). 3. Buffering. Not sure about how far this should go yet, but probably no further than minimal buffering. 4. Share a connection. Since a multiplexing connection is shared between multiple clients, the client should be responsible for taking possesion of the connection for a period of time (so it can write a complete packet). This idea could be taken quite far into genericity by making clients aware of how busy the connection is and size its output packets accordingly... But I'm not doing that. 


[section:async_read_some common::basic_client::async_read_some]

[indexterm2 async_read_some..common::basic_client] Asynchronously read some data from the client. 

  template<
      typename MutableBufferSequence ,
      typename Handler >
  void async_read_some(
      const MutableBufferSequence & buf,
      Handler handler);



[endsect]



[section:async_write_some common::basic_client::async_write_some]

[indexterm2 async_write_some..common::basic_client] Asynchronously write some data to the client. 

  template<
      typename ConstBufferSequence ,
      typename Handler >
  void async_write_some(
      const ConstBufferSequence & buf,
      Handler handler);



[endsect]


[section:basic_client common::basic_client::basic_client]

[indexterm2 basic_client..common::basic_client] 

  ``[link cgi.reference.common__basic_client.basic_client.overload1 basic_client]``(
      io_service & ios);

  ``[link cgi.reference.common__basic_client.basic_client.overload2 basic_client]``();


[section:overload1 common::basic_client::basic_client (1 of 2 overloads)]



  basic_client(
      io_service & ios);



[endsect]



[section:overload2 common::basic_client::basic_client (2 of 2 overloads)]



  basic_client();



[endsect]


[endsect]


[section:bytes_left common::basic_client::bytes_left]

[indexterm2 bytes_left..common::basic_client] 

  std::size_t & bytes_left();



[endsect]



[section:bytes_left_ common::basic_client::bytes_left_]

[indexterm2 bytes_left_..common::basic_client] 

  std::size_t bytes_left_;



[endsect]



[section:close common::basic_client::close]

[indexterm2 close..common::basic_client] 

  void close();



[endsect]



[section:connection common::basic_client::connection]

[indexterm2 connection..common::basic_client] Get a shared_ptr of the connection associated with the client. 

  connection_ptr & connection();



[endsect]



[section:connection_ptr common::basic_client::connection_ptr]

[indexterm2 connection_ptr..common::basic_client] 

  typedef connection_type::pointer connection_ptr;




[endsect]



[section:connection_type common::basic_client::connection_type]

[indexterm2 connection_type..common::basic_client] 

  typedef Connection connection_type;




[endsect]



[section:is_open common::basic_client::is_open]

[indexterm2 is_open..common::basic_client] 

  bool is_open();



[endsect]



[section:protocol_type common::basic_client::protocol_type]

[indexterm2 protocol_type..common::basic_client] 

  typedef Protocol protocol_type;




[endsect]



[section:read_some common::basic_client::read_some]

[indexterm2 read_some..common::basic_client] Read some data from the client. 

  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:request_id common::basic_client::request_id]

[indexterm2 request_id..common::basic_client] 

  boost::uint16_t const & request_id() const;



[endsect]



[section:set_connection common::basic_client::set_connection]

[indexterm2 set_connection..common::basic_client] Associate a connection with this client. 

  bool set_connection(
      const typename connection_type::pointer & conn);


Note: the connection must have been created using the new operator

bool set\_connection(connection\_type* conn) { make sure there isn't already a connection associated with the client if (!connection\_) return false; connection\_.reset(conn); return true; } Associate a connection with this client Note: the connection must have been created using the new operator 


[endsect]



[section:write_some common::basic_client::write_some]

[indexterm2 write_some..common::basic_client] Write some data to the client. 

  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      const ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[endsect]

[section:common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_ common::basic_client< connections::shareable_tcp, Protocol >]

A client that uses a TCP socket that owned by it. 

  template<
      typename Protocol >
  class basic_client< connections::shareable_tcp, Protocol >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.connection_ptr [*connection_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.header_buffer_type [*header_buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.io_service_type [*io_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.role_type [*role_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.async_read_some [*async_read_some]]]
    [Asynchronously read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.async_write_some [*async_write_some]]]
    [Asynchronously write some data to the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.basic_client [*basic_client]]]
    [Construct. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.bytes_left [*bytes_left]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.connection [*connection]]]
    [Get a shared_ptr of the connection associated with the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.construct [*construct]]]
    [Construct the client by claiming a request id. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.keep_connection [*keep_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.read_some [*read_some]]]
    [Read data into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.set_connection [*set_connection]]]
    [Associate a connection with this client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.status [*status]]]
    [Set the status of the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.write_some [*write_some]]]
    [Write some data to the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_._basic_client [*~basic_client]]]
    [Destroy. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.bytes_left_ [*bytes_left_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.connection_ [*connection_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.header_ [*header_]]]
    [Buffer used to check the header of each packet. ]
  ]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.keep_connection_ [*keep_connection_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.outbuf_ [*outbuf_]]]
    [Output buffer. ]
  ]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.request_id_ [*request_id_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.role_ [*role_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.status_ [*status_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.total_sent_bytes_ [*total_sent_bytes_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.total_sent_packets_ [*total_sent_packets_]]]
    []
  ]

]


[section:async_read_some common::basic_client< connections::shareable_tcp, Protocol >::async_read_some]

[indexterm2 async_read_some..common::basic_client< connections::shareable_tcp, Protocol >] Asynchronously read some data from the client. 

  template<
      typename MutableBufferSequence ,
      typename Handler >
  void async_read_some(
      const MutableBufferSequence & buf,
      Handler handler);



[endsect]



[section:async_write_some common::basic_client< connections::shareable_tcp, Protocol >::async_write_some]

[indexterm2 async_write_some..common::basic_client< connections::shareable_tcp, Protocol >] Asynchronously write some data to the client. 

  template<
      typename ConstBufferSequence ,
      typename Handler >
  void async_write_some(
      const ConstBufferSequence & buf,
      Handler handler);



[endsect]


[section:basic_client common::basic_client< connections::shareable_tcp, Protocol >::basic_client]

[indexterm2 basic_client..common::basic_client< connections::shareable_tcp, Protocol >] Construct. 

  ``[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.basic_client.overload1 basic_client]``(
      io_service_type & ios);

  ``[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.basic_client.overload2 basic_client]``();


[section:overload1 common::basic_client< connections::shareable_tcp, Protocol >::basic_client (1 of 2 overloads)]

Construct. 

  basic_client(
      io_service_type & ios);



[endsect]



[section:overload2 common::basic_client< connections::shareable_tcp, Protocol >::basic_client (2 of 2 overloads)]

Construct. 

  basic_client();



[endsect]


[endsect]


[section:bytes_left common::basic_client< connections::shareable_tcp, Protocol >::bytes_left]

[indexterm2 bytes_left..common::basic_client< connections::shareable_tcp, Protocol >] 

  std::size_t & bytes_left();



[endsect]



[section:bytes_left_ common::basic_client< connections::shareable_tcp, Protocol >::bytes_left_]

[indexterm2 bytes_left_..common::basic_client< connections::shareable_tcp, Protocol >] 

  std::size_t bytes_left_;



[endsect]


[section:close common::basic_client< connections::shareable_tcp, Protocol >::close]

[indexterm2 close..common::basic_client< connections::shareable_tcp, Protocol >] 

  boost::system::error_code ``[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.close.overload1 close]``(
      boost::uint64_t app_status,
      boost::system::error_code & ec);

  void ``[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.close.overload2 close]``(
      boost::uint64_t app_status = 0);


[section:overload1 common::basic_client< connections::shareable_tcp, Protocol >::close (1 of 2 overloads)]



  boost::system::error_code close(
      boost::uint64_t app_status,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_client< connections::shareable_tcp, Protocol >::close (2 of 2 overloads)]



  void close(
      boost::uint64_t app_status = 0);



[endsect]


[endsect]


[section:connection common::basic_client< connections::shareable_tcp, Protocol >::connection]

[indexterm2 connection..common::basic_client< connections::shareable_tcp, Protocol >] Get a shared_ptr of the connection associated with the client. 

  connection_type::pointer & connection();



[endsect]



[section:connection_ common::basic_client< connections::shareable_tcp, Protocol >::connection_]

[indexterm2 connection_..common::basic_client< connections::shareable_tcp, Protocol >] 

  connection_ptr connection_;



[endsect]



[section:connection_ptr common::basic_client< connections::shareable_tcp, Protocol >::connection_ptr]

[indexterm2 connection_ptr..common::basic_client< connections::shareable_tcp, Protocol >] 

  typedef connection_type::pointer connection_ptr;




[endsect]



[section:connection_type common::basic_client< connections::shareable_tcp, Protocol >::connection_type]

[indexterm2 connection_type..common::basic_client< connections::shareable_tcp, Protocol >] 

  typedef connections::shareable_tcp connection_type;




[endsect]



[section:construct common::basic_client< connections::shareable_tcp, Protocol >::construct]

[indexterm2 construct..common::basic_client< connections::shareable_tcp, Protocol >] Construct the client by claiming a request id. 

  template<
      typename RequestImpl >
  boost::system::error_code construct(
      RequestImpl & req,
      boost::system::error_code & ec);


Before loading a request, it will usually not have a request id. This function reads headers (and corresponding bodies if necessary) until a BEGIN\_REQUEST record is found. The calling request then claims and serves that request. 


[endsect]



[section:header_ common::basic_client< connections::shareable_tcp, Protocol >::header_]

[indexterm2 header_..common::basic_client< connections::shareable_tcp, Protocol >] Buffer used to check the header of each packet. 

  fcgi::spec::header header_;



[endsect]



[section:header_buffer_type common::basic_client< connections::shareable_tcp, Protocol >::header_buffer_type]

[indexterm2 header_buffer_type..common::basic_client< connections::shareable_tcp, Protocol >] 

  typedef boost::array< unsigned char, fcgi::spec::header_length::value > header_buffer_type;




[endsect]



[section:io_service_type common::basic_client< connections::shareable_tcp, Protocol >::io_service_type]

[indexterm2 io_service_type..common::basic_client< connections::shareable_tcp, Protocol >] 

  typedef ::cgi::common::io_service io_service_type;




[endsect]



[section:is_open common::basic_client< connections::shareable_tcp, Protocol >::is_open]

[indexterm2 is_open..common::basic_client< connections::shareable_tcp, Protocol >] 

  bool is_open() const;



[endsect]



[section:keep_connection common::basic_client< connections::shareable_tcp, Protocol >::keep_connection]

[indexterm2 keep_connection..common::basic_client< connections::shareable_tcp, Protocol >] 

  bool keep_connection() const;



[endsect]



[section:keep_connection_ common::basic_client< connections::shareable_tcp, Protocol >::keep_connection_]

[indexterm2 keep_connection_..common::basic_client< connections::shareable_tcp, Protocol >] 

  bool keep_connection_;



[endsect]



[section:map_type common::basic_client< connections::shareable_tcp, Protocol >::map_type]

[indexterm2 map_type..common::basic_client< connections::shareable_tcp, Protocol >] 

  typedef ::cgi::common::map map_type;




[endsect]



[section:mutable_buffers_type common::basic_client< connections::shareable_tcp, Protocol >::mutable_buffers_type]

[indexterm2 mutable_buffers_type..common::basic_client< connections::shareable_tcp, Protocol >] 

  typedef boost::asio::mutable_buffers_1 mutable_buffers_type;




[endsect]



[section:outbuf_ common::basic_client< connections::shareable_tcp, Protocol >::outbuf_]

[indexterm2 outbuf_..common::basic_client< connections::shareable_tcp, Protocol >] Output buffer. 

  std::vector< boost::asio::const_buffer > outbuf_;



[endsect]



[section:protocol_type common::basic_client< connections::shareable_tcp, Protocol >::protocol_type]

[indexterm2 protocol_type..common::basic_client< connections::shareable_tcp, Protocol >] 

  typedef Protocol protocol_type;




[endsect]



[section:read_some common::basic_client< connections::shareable_tcp, Protocol >::read_some]

[indexterm2 read_some..common::basic_client< connections::shareable_tcp, Protocol >] Read data into the supplied buffer. 

  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);


Reads some data that, correctly checking and stripping FastCGI headers.

Returns the number of bytes read and sets `ec` such that `ec` evaluates to `true` iff an error occured during the read operation.

Notable errors:
* `fcgierror::data_for_another_request`

* `fcgierror::connection_locked`


These must be dealt with by user code if they choose to read through the client (reading through the request is recommended). 


[endsect]



[section:request_id common::basic_client< connections::shareable_tcp, Protocol >::request_id]

[indexterm2 request_id..common::basic_client< connections::shareable_tcp, Protocol >] 

  boost::uint16_t const & request_id() const;



[endsect]



[section:request_id_ common::basic_client< connections::shareable_tcp, Protocol >::request_id_]

[indexterm2 request_id_..common::basic_client< connections::shareable_tcp, Protocol >] 

  boost::uint16_t request_id_;



[endsect]



[section:role_ common::basic_client< connections::shareable_tcp, Protocol >::role_]

[indexterm2 role_..common::basic_client< connections::shareable_tcp, Protocol >] 

  role_type role_;



[endsect]



[section:role_type common::basic_client< connections::shareable_tcp, Protocol >::role_type]

[indexterm2 role_type..common::basic_client< connections::shareable_tcp, Protocol >] 

  typedef fcgi::spec_detail::role_types role_type;




[endsect]


[section:set_connection common::basic_client< connections::shareable_tcp, Protocol >::set_connection]

[indexterm2 set_connection..common::basic_client< connections::shareable_tcp, Protocol >] Associate a connection with this client. 

  bool ``[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.set_connection.overload1 set_connection]``(
      const connection_type::pointer & conn);

  bool ``[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.set_connection.overload2 set_connection]``(
      connection_type * conn);


[section:overload1 common::basic_client< connections::shareable_tcp, Protocol >::set_connection (1 of 2 overloads)]

Associate a connection with this client. 

  bool set_connection(
      const connection_type::pointer & conn);



[endsect]



[section:overload2 common::basic_client< connections::shareable_tcp, Protocol >::set_connection (2 of 2 overloads)]

Associate a connection with this client. 

  bool set_connection(
      connection_type * conn);


Note: the connection must have been created using the new operator 


[endsect]


[endsect]

[section:status common::basic_client< connections::shareable_tcp, Protocol >::status]

[indexterm2 status..common::basic_client< connections::shareable_tcp, Protocol >] Set the status of the client. 

  void ``[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.status.overload1 status]``(
      client_status status);

  const client_status & ``[link cgi.reference.common__basic_client_lt__connections__shareable_tcp,_Protocol__gt_.status.overload2 status]``() const;


[section:overload1 common::basic_client< connections::shareable_tcp, Protocol >::status (1 of 2 overloads)]

Set the status of the client. 

  void status(
      client_status status);



[endsect]



[section:overload2 common::basic_client< connections::shareable_tcp, Protocol >::status (2 of 2 overloads)]

Get the status of the client. 

  const client_status & status() const;



[endsect]


[endsect]


[section:status_ common::basic_client< connections::shareable_tcp, Protocol >::status_]

[indexterm2 status_..common::basic_client< connections::shareable_tcp, Protocol >] 

  client_status status_;



[endsect]



[section:total_sent_bytes_ common::basic_client< connections::shareable_tcp, Protocol >::total_sent_bytes_]

[indexterm2 total_sent_bytes_..common::basic_client< connections::shareable_tcp, Protocol >] 

  boost::uint64_t total_sent_bytes_;



[endsect]



[section:total_sent_packets_ common::basic_client< connections::shareable_tcp, Protocol >::total_sent_packets_]

[indexterm2 total_sent_packets_..common::basic_client< connections::shareable_tcp, Protocol >] 

  boost::uint64_t total_sent_packets_;



[endsect]



[section:write_some common::basic_client< connections::shareable_tcp, Protocol >::write_some]

[indexterm2 write_some..common::basic_client< connections::shareable_tcp, Protocol >] Write some data to the client. 

  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      const ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:_basic_client common::basic_client< connections::shareable_tcp, Protocol >::~basic_client]

[indexterm2 ~basic_client..common::basic_client< connections::shareable_tcp, Protocol >] Destroy. 

  ~basic_client();


Closing the connection as early as possible is good for efficiency 


[endsect]



[endsect]

[section:common__basic_connection_lt__tags__async_stdio__gt_ common::basic_connection< tags::async_stdio >]



  template<>
  class basic_connection< tags::async_stdio > :
    public common::basic_connection< tags::stdio >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.async_read_some [*async_read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.async_write_some [*async_write_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.basic_connection [*basic_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.read_some [*read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.write_some [*write_some]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.is_open_ [*is_open_]]]
    []
  ]

]


[section:async_read_some common::basic_connection< tags::async_stdio >::async_read_some]

[indexterm2 async_read_some..common::basic_connection< tags::async_stdio >] 

  template<
      typename MutableBufferSequence ,
      typename Handler >
  void async_read_some(
      const MutableBufferSequence & buf,
      Handler handler);



[endsect]



[section:async_write_some common::basic_connection< tags::async_stdio >::async_write_some]

[indexterm2 async_write_some..common::basic_connection< tags::async_stdio >] 

  template<
      typename ConstBufferSequence ,
      typename Handler >
  void async_write_some(
      const ConstBufferSequence & buf,
      Handler handler);



[endsect]



[section:basic_connection common::basic_connection< tags::async_stdio >::basic_connection]

[indexterm2 basic_connection..common::basic_connection< tags::async_stdio >] 

  basic_connection(
      common::io_service & ios);



[endsect]



[section:close common::basic_connection< tags::async_stdio >::close]

[indexterm2 close..common::basic_connection< tags::async_stdio >] 

  void close();



[endsect]


[section:create common::basic_connection< tags::async_stdio >::create]

[indexterm2 create..common::basic_connection< tags::async_stdio >] 

  static pointer ``[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.create.overload1 create]``();

  static pointer ``[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.create.overload2 create]``(
      ::cgi::common::io_service & ios);


[section:overload1 common::basic_connection< tags::async_stdio >::create (1 of 2 overloads)]


['Inherited from common::basic_connection< tags::stdio >.]



  static pointer create();



[endsect]



[section:overload2 common::basic_connection< tags::async_stdio >::create (2 of 2 overloads)]



  static pointer create(
      ::cgi::common::io_service & ios);



[endsect]


[endsect]


[section:is_open common::basic_connection< tags::async_stdio >::is_open]

[indexterm2 is_open..common::basic_connection< tags::async_stdio >] 

  bool is_open() const;



[endsect]



[section:is_open_ common::basic_connection< tags::async_stdio >::is_open_]


['Inherited from common::basic_connection< tags::stdio >.]

[indexterm2 is_open_..common::basic_connection< tags::async_stdio >] 

  bool is_open_;



[endsect]



[section:pointer common::basic_connection< tags::async_stdio >::pointer]

[indexterm2 pointer..common::basic_connection< tags::async_stdio >] 

  typedef boost::shared_ptr< type > pointer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.async_read_some [*async_read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.async_write_some [*async_write_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.basic_connection [*basic_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.read_some [*read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.write_some [*write_some]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__async_stdio__gt_.is_open_ [*is_open_]]]
    []
  ]

]



[endsect]



[section:read_some common::basic_connection< tags::async_stdio >::read_some]


['Inherited from common::basic_connection< tags::stdio >.]

[indexterm2 read_some..common::basic_connection< tags::async_stdio >] 

  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      MutableBufferSequence buf,
      boost::system::error_code & ec);



[endsect]



[section:type common::basic_connection< tags::async_stdio >::type]

[indexterm2 type..common::basic_connection< tags::async_stdio >] 

  typedef basic_connection< tags::async_stdio > type;




[endsect]



[section:write_some common::basic_connection< tags::async_stdio >::write_some]


['Inherited from common::basic_connection< tags::stdio >.]

[indexterm2 write_some..common::basic_connection< tags::async_stdio >] 

  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[endsect]

[section:common__basic_connection_lt__tags__shareable_tcp_socket__gt_ common::basic_connection< tags::shareable_tcp_socket >]



  template<>
  class basic_connection< tags::shareable_tcp_socket > :
    public connection_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt___condition_type [*basic_connection< tags::shareable_tcp_socket >::condition_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.mutex_type [*mutex_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.next_layer_type [*next_layer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.request_map_type [*request_map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.request_vector_type [*request_vector_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.scoped_lock_type [*scoped_lock_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.add_request [*add_request]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.async_read_some [*async_read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.async_write_some [*async_write_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.basic_connection [*basic_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.condition [*condition]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.get_slot [*get_slot]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.lock [*lock]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.mutex [*mutex]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.next_layer [*next_layer]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.read_some [*read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.unlock [*unlock]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.wait [*wait]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.write_some [*write_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_._basic_connection [*~basic_connection]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.deletable_request_ids_ [*deletable_request_ids_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.request_map_ [*request_map_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.requests_ [*requests_]]]
    []
  ]

]


[section:add_request common::basic_connection< tags::shareable_tcp_socket >::add_request]

[indexterm2 add_request..common::basic_connection< tags::shareable_tcp_socket >] 

  boost::system::error_code add_request(
      boost::uint16_t id,
      request_type * req,
      bool on_heap,
      boost::system::error_code & ec);



[endsect]



[section:async_read_some common::basic_connection< tags::shareable_tcp_socket >::async_read_some]

[indexterm2 async_read_some..common::basic_connection< tags::shareable_tcp_socket >] 

  template<
      typename MutableBufferSequence ,
      typename Handler >
  void async_read_some(
      MutableBufferSequence & buf,
      Handler handler);



[endsect]



[section:async_write_some common::basic_connection< tags::shareable_tcp_socket >::async_write_some]

[indexterm2 async_write_some..common::basic_connection< tags::shareable_tcp_socket >] 

  template<
      typename ConstBufferSequence ,
      typename Handler >
  void async_write_some(
      ConstBufferSequence & buf,
      Handler handler);



[endsect]



[section:basic_connection common::basic_connection< tags::shareable_tcp_socket >::basic_connection]

[indexterm2 basic_connection..common::basic_connection< tags::shareable_tcp_socket >] 

  basic_connection(
      io_service & ios);


End FastCGI stuff 


[endsect]



[section:close common::basic_connection< tags::shareable_tcp_socket >::close]

[indexterm2 close..common::basic_connection< tags::shareable_tcp_socket >] 

  void close();



[endsect]



[section:condition common::basic_connection< tags::shareable_tcp_socket >::condition]

[indexterm2 condition..common::basic_connection< tags::shareable_tcp_socket >] 

  condition_type & condition();



[endsect]



[section:create common::basic_connection< tags::shareable_tcp_socket >::create]

[indexterm2 create..common::basic_connection< tags::shareable_tcp_socket >] 

  static pointer create(
      io_service & ios);



[endsect]



[section:deletable_request_ids_ common::basic_connection< tags::shareable_tcp_socket >::deletable_request_ids_]

[indexterm2 deletable_request_ids_..common::basic_connection< tags::shareable_tcp_socket >] 

  std::set< int > deletable_request_ids_;



[endsect]



[section:get_slot common::basic_connection< tags::shareable_tcp_socket >::get_slot]

[indexterm2 get_slot..common::basic_connection< tags::shareable_tcp_socket >] 

  boost::system::error_code get_slot(
      boost::uint16_t id,
      boost::system::error_code & ec);



[endsect]



[section:is_open common::basic_connection< tags::shareable_tcp_socket >::is_open]

[indexterm2 is_open..common::basic_connection< tags::shareable_tcp_socket >] 

  bool is_open() const;



[endsect]



[section:lock common::basic_connection< tags::shareable_tcp_socket >::lock]

[indexterm2 lock..common::basic_connection< tags::shareable_tcp_socket >] 

  void lock();



[endsect]



[section:mutex common::basic_connection< tags::shareable_tcp_socket >::mutex]

[indexterm2 mutex..common::basic_connection< tags::shareable_tcp_socket >] 

  mutex_type & mutex();



[endsect]



[section:mutex_type common::basic_connection< tags::shareable_tcp_socket >::mutex_type]

[indexterm2 mutex_type..common::basic_connection< tags::shareable_tcp_socket >] 

  typedef boost::mutex mutex_type;




[endsect]



[section:next_layer common::basic_connection< tags::shareable_tcp_socket >::next_layer]

[indexterm2 next_layer..common::basic_connection< tags::shareable_tcp_socket >] 

  next_layer_type & next_layer();



[endsect]



[section:next_layer_type common::basic_connection< tags::shareable_tcp_socket >::next_layer_type]

[indexterm2 next_layer_type..common::basic_connection< tags::shareable_tcp_socket >] 

  typedef boost::asio::ip::tcp::socket next_layer_type;




[endsect]



[section:pointer common::basic_connection< tags::shareable_tcp_socket >::pointer]

[indexterm2 pointer..common::basic_connection< tags::shareable_tcp_socket >] 

  typedef boost::shared_ptr< basic_connection< tags::shareable_tcp_socket > > pointer;




[endsect]


[section:read_some common::basic_connection< tags::shareable_tcp_socket >::read_some]

[indexterm2 read_some..common::basic_connection< tags::shareable_tcp_socket >] 

  template<
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.read_some.overload1 read_some]``(
      MutableBufferSequence & buf,
      boost::system::error_code & ec);

  template<
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.read_some.overload2 read_some]``(
      MutableBufferSequence & buf);


[section:overload1 common::basic_connection< tags::shareable_tcp_socket >::read_some (1 of 2 overloads)]



  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_connection< tags::shareable_tcp_socket >::read_some (2 of 2 overloads)]



  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      MutableBufferSequence & buf);



[endsect]


[endsect]


[section:request_map_ common::basic_connection< tags::shareable_tcp_socket >::request_map_]

[indexterm2 request_map_..common::basic_connection< tags::shareable_tcp_socket >] 

  request_map_type request_map_;


FastCGI specific stuff 


[endsect]



[section:request_map_type common::basic_connection< tags::shareable_tcp_socket >::request_map_type]

[indexterm2 request_map_type..common::basic_connection< tags::shareable_tcp_socket >] 

  typedef std::map< boost::uint16_t, request_type * > request_map_type;




[endsect]



[section:request_ptr common::basic_connection< tags::shareable_tcp_socket >::request_ptr]

[indexterm2 request_ptr..common::basic_connection< tags::shareable_tcp_socket >] 

  typedef detail::protocol_traits< fcgi_ >::request_ptr request_ptr;




[endsect]



[section:request_type common::basic_connection< tags::shareable_tcp_socket >::request_type]

[indexterm2 request_type..common::basic_connection< tags::shareable_tcp_socket >] 

  typedef detail::protocol_traits< fcgi_ >::request_type request_type;



FastCGI specific stuff 


[endsect]



[section:request_vector_type common::basic_connection< tags::shareable_tcp_socket >::request_vector_type]

[indexterm2 request_vector_type..common::basic_connection< tags::shareable_tcp_socket >] 

  typedef std::vector< request_type * > request_vector_type;




[endsect]



[section:requests_ common::basic_connection< tags::shareable_tcp_socket >::requests_]

[indexterm2 requests_..common::basic_connection< tags::shareable_tcp_socket >] 

  request_vector_type requests_;



[endsect]



[section:scoped_lock_type common::basic_connection< tags::shareable_tcp_socket >::scoped_lock_type]

[indexterm2 scoped_lock_type..common::basic_connection< tags::shareable_tcp_socket >] 

  typedef boost::mutex::scoped_lock scoped_lock_type;




[endsect]



[section:unlock common::basic_connection< tags::shareable_tcp_socket >::unlock]

[indexterm2 unlock..common::basic_connection< tags::shareable_tcp_socket >] 

  void unlock();



[endsect]



[section:wait common::basic_connection< tags::shareable_tcp_socket >::wait]

[indexterm2 wait..common::basic_connection< tags::shareable_tcp_socket >] 

  void wait();



[endsect]


[section:write_some common::basic_connection< tags::shareable_tcp_socket >::write_some]

[indexterm2 write_some..common::basic_connection< tags::shareable_tcp_socket >] 

  template<
      typename ConstBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.write_some.overload1 write_some]``(
      ConstBufferSequence & buf,
      boost::system::error_code & ec);

  template<
      typename ConstBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt_.write_some.overload2 write_some]``(
      ConstBufferSequence & buf);


[section:overload1 common::basic_connection< tags::shareable_tcp_socket >::write_some (1 of 2 overloads)]



  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_connection< tags::shareable_tcp_socket >::write_some (2 of 2 overloads)]



  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      ConstBufferSequence & buf);



[endsect]


[endsect]


[section:_basic_connection common::basic_connection< tags::shareable_tcp_socket >::~basic_connection]

[indexterm2 ~basic_connection..common::basic_connection< tags::shareable_tcp_socket >] 

  ~basic_connection();



[endsect]



[endsect]

[section:common__basic_connection_lt__tags__shareable_tcp_socket__gt___condition_type common::basic_connection< tags::shareable_tcp_socket >::condition_type]



  struct basic_connection< tags::shareable_tcp_socket >::condition_type


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__shareable_tcp_socket__gt___condition_type.pointer [*pointer]]]
    []
  
  ]

]


[section:pointer common::basic_connection< tags::shareable_tcp_socket >::condition_type::pointer]

[indexterm2 pointer..common::basic_connection< tags::shareable_tcp_socket >::condition_type] 

  typedef boost::shared_ptr< boost::condition_variable > pointer;




[endsect]



[endsect]

[section:common__basic_connection_lt__tags__stderr__gt_ common::basic_connection< tags::stderr >]



  template<>
  class basic_connection< tags::stderr > :
    public connection_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.async_read_some [*async_read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.async_write_some [*async_write_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.basic_connection [*basic_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.next_layer [*next_layer]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.read_some [*read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.write_some [*write_some]]]
    []
  ]
  
]


[section:async_read_some common::basic_connection< tags::stderr >::async_read_some]

[indexterm2 async_read_some..common::basic_connection< tags::stderr >] 

  template<
      typename MutableBufferSequence ,
      typename Handler >
  void async_read_some(
      MutableBufferSequence & buf,
      Handler handler);



[endsect]



[section:async_write_some common::basic_connection< tags::stderr >::async_write_some]

[indexterm2 async_write_some..common::basic_connection< tags::stderr >] 

  template<
      typename ConstBufferSequence ,
      typename Handler >
  void async_write_some(
      ConstBufferSequence & buf,
      Handler handler);



[endsect]



[section:basic_connection common::basic_connection< tags::stderr >::basic_connection]

[indexterm2 basic_connection..common::basic_connection< tags::stderr >] 

  basic_connection(
      io_service & ios);



[endsect]



[section:close common::basic_connection< tags::stderr >::close]

[indexterm2 close..common::basic_connection< tags::stderr >] 

  void close();



[endsect]



[section:create common::basic_connection< tags::stderr >::create]

[indexterm2 create..common::basic_connection< tags::stderr >] 

  static pointer create(
      io_service & ios);



[endsect]



[section:is_open common::basic_connection< tags::stderr >::is_open]

[indexterm2 is_open..common::basic_connection< tags::stderr >] 

  bool is_open() const;



[endsect]



[section:next_layer common::basic_connection< tags::stderr >::next_layer]

[indexterm2 next_layer..common::basic_connection< tags::stderr >] 

  next_layer_type & next_layer();



[endsect]



[section:pointer common::basic_connection< tags::stderr >::pointer]

[indexterm2 pointer..common::basic_connection< tags::stderr >] 

  typedef boost::shared_ptr< type > pointer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.async_read_some [*async_read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.async_write_some [*async_write_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.basic_connection [*basic_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.next_layer [*next_layer]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.read_some [*read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.write_some [*write_some]]]
    []
  ]
  
]



[endsect]


[section:read_some common::basic_connection< tags::stderr >::read_some]

[indexterm2 read_some..common::basic_connection< tags::stderr >] 

  template<
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.read_some.overload1 read_some]``(
      MutableBufferSequence & buf,
      boost::system::error_code & ec);

  template<
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.read_some.overload2 read_some]``(
      MutableBufferSequence & buf);


[section:overload1 common::basic_connection< tags::stderr >::read_some (1 of 2 overloads)]



  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_connection< tags::stderr >::read_some (2 of 2 overloads)]



  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      MutableBufferSequence & buf);



[endsect]


[endsect]


[section:type common::basic_connection< tags::stderr >::type]

[indexterm2 type..common::basic_connection< tags::stderr >] 

  typedef basic_connection< tags::stderr > type;




[endsect]


[section:write_some common::basic_connection< tags::stderr >::write_some]

[indexterm2 write_some..common::basic_connection< tags::stderr >] 

  template<
      typename ConstBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.write_some.overload1 write_some]``(
      ConstBufferSequence & buf,
      boost::system::error_code & ec);

  template<
      typename ConstBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__stderr__gt_.write_some.overload2 write_some]``(
      ConstBufferSequence & buf);


[section:overload1 common::basic_connection< tags::stderr >::write_some (1 of 2 overloads)]



  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_connection< tags::stderr >::write_some (2 of 2 overloads)]



  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      ConstBufferSequence & buf);



[endsect]


[endsect]


[endsect]

[section:common__basic_connection_lt__tags__stdio__gt_ common::basic_connection< tags::stdio >]



  template<>
  class basic_connection< tags::stdio > :
    public connection_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.pointer [*pointer]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.basic_connection [*basic_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.read_some [*read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.write_some [*write_some]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.is_open_ [*is_open_]]]
    []
  ]

]

[section:basic_connection common::basic_connection< tags::stdio >::basic_connection]

[indexterm2 basic_connection..common::basic_connection< tags::stdio >] 

  template<
      typename T >
  ``[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.basic_connection.overload1 basic_connection]``(
      T & );

  ``[link cgi.reference.common__basic_connection_lt__tags__stdio__gt_.basic_connection.overload2 basic_connection]``();


[section:overload1 common::basic_connection< tags::stdio >::basic_connection (1 of 2 overloads)]



  template<
      typename T >
  basic_connection(
      T & );



[endsect]



[section:overload2 common::basic_connection< tags::stdio >::basic_connection (2 of 2 overloads)]



  basic_connection();



[endsect]


[endsect]


[section:close common::basic_connection< tags::stdio >::close]

[indexterm2 close..common::basic_connection< tags::stdio >] 

  void close();



[endsect]



[section:create common::basic_connection< tags::stdio >::create]

[indexterm2 create..common::basic_connection< tags::stdio >] 

  static pointer create();



[endsect]



[section:is_open common::basic_connection< tags::stdio >::is_open]

[indexterm2 is_open..common::basic_connection< tags::stdio >] 

  bool is_open() const;



[endsect]



[section:is_open_ common::basic_connection< tags::stdio >::is_open_]

[indexterm2 is_open_..common::basic_connection< tags::stdio >] 

  bool is_open_;



[endsect]



[section:pointer common::basic_connection< tags::stdio >::pointer]

[indexterm2 pointer..common::basic_connection< tags::stdio >] 

  typedef boost::shared_ptr< basic_connection< tags::stdio > > pointer;




[endsect]



[section:read_some common::basic_connection< tags::stdio >::read_some]

[indexterm2 read_some..common::basic_connection< tags::stdio >] 

  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      MutableBufferSequence buf,
      boost::system::error_code & ec);



[endsect]



[section:write_some common::basic_connection< tags::stdio >::write_some]

[indexterm2 write_some..common::basic_connection< tags::stdio >] 

  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[endsect]

[section:common__basic_connection_lt__tags__tcp_socket__gt_ common::basic_connection< tags::tcp_socket >]



  template<>
  class basic_connection< tags::tcp_socket > :
    public connection_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.next_layer_type [*next_layer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.async_read_some [*async_read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.async_write_some [*async_write_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.basic_connection [*basic_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.next_layer [*next_layer]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.read_some [*read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.write_some [*write_some]]]
    []
  ]
  
]


[section:async_read_some common::basic_connection< tags::tcp_socket >::async_read_some]

[indexterm2 async_read_some..common::basic_connection< tags::tcp_socket >] 

  template<
      typename MutableBufferSequence ,
      typename Handler >
  void async_read_some(
      MutableBufferSequence & buf,
      Handler handler);



[endsect]



[section:async_write_some common::basic_connection< tags::tcp_socket >::async_write_some]

[indexterm2 async_write_some..common::basic_connection< tags::tcp_socket >] 

  template<
      typename ConstBufferSequence ,
      typename Handler >
  void async_write_some(
      ConstBufferSequence & buf,
      Handler handler);



[endsect]



[section:basic_connection common::basic_connection< tags::tcp_socket >::basic_connection]

[indexterm2 basic_connection..common::basic_connection< tags::tcp_socket >] 

  basic_connection(
      io_service & ios);



[endsect]



[section:close common::basic_connection< tags::tcp_socket >::close]

[indexterm2 close..common::basic_connection< tags::tcp_socket >] 

  void close();



[endsect]



[section:create common::basic_connection< tags::tcp_socket >::create]

[indexterm2 create..common::basic_connection< tags::tcp_socket >] 

  static pointer create(
      io_service & ios);



[endsect]



[section:is_open common::basic_connection< tags::tcp_socket >::is_open]

[indexterm2 is_open..common::basic_connection< tags::tcp_socket >] 

  bool is_open() const;



[endsect]



[section:next_layer common::basic_connection< tags::tcp_socket >::next_layer]

[indexterm2 next_layer..common::basic_connection< tags::tcp_socket >] 

  next_layer_type & next_layer();



[endsect]



[section:next_layer_type common::basic_connection< tags::tcp_socket >::next_layer_type]

[indexterm2 next_layer_type..common::basic_connection< tags::tcp_socket >] 

  typedef boost::asio::ip::tcp::socket next_layer_type;




[endsect]



[section:pointer common::basic_connection< tags::tcp_socket >::pointer]

[indexterm2 pointer..common::basic_connection< tags::tcp_socket >] 

  typedef boost::shared_ptr< type > pointer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.next_layer_type [*next_layer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.async_read_some [*async_read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.async_write_some [*async_write_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.basic_connection [*basic_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.next_layer [*next_layer]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.read_some [*read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.write_some [*write_some]]]
    []
  ]
  
]



[endsect]


[section:read_some common::basic_connection< tags::tcp_socket >::read_some]

[indexterm2 read_some..common::basic_connection< tags::tcp_socket >] 

  template<
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.read_some.overload1 read_some]``(
      MutableBufferSequence & buf,
      boost::system::error_code & ec);

  template<
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.read_some.overload2 read_some]``(
      MutableBufferSequence & buf);


[section:overload1 common::basic_connection< tags::tcp_socket >::read_some (1 of 2 overloads)]



  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_connection< tags::tcp_socket >::read_some (2 of 2 overloads)]



  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      MutableBufferSequence & buf);



[endsect]


[endsect]


[section:type common::basic_connection< tags::tcp_socket >::type]

[indexterm2 type..common::basic_connection< tags::tcp_socket >] 

  typedef basic_connection< tags::tcp_socket > type;




[endsect]


[section:write_some common::basic_connection< tags::tcp_socket >::write_some]

[indexterm2 write_some..common::basic_connection< tags::tcp_socket >] 

  template<
      typename ConstBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.write_some.overload1 write_some]``(
      ConstBufferSequence & buf,
      boost::system::error_code & ec);

  template<
      typename ConstBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_connection_lt__tags__tcp_socket__gt_.write_some.overload2 write_some]``(
      ConstBufferSequence & buf);


[section:overload1 common::basic_connection< tags::tcp_socket >::write_some (1 of 2 overloads)]



  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_connection< tags::tcp_socket >::write_some (2 of 2 overloads)]



  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      ConstBufferSequence & buf);



[endsect]


[endsect]


[endsect]

[section:common__basic_cookie common::basic_cookie]

A `basic_cookie<>` object that can be (out-) streamed. 

  template<
      typename ``[link cgi.reference.CharT CharT]``>
  struct basic_cookie


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_cookie.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_cookie.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_cookie.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.basic_cookie [*basic_cookie]]]
    [Create a cookie. ]
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.to_string [*to_string]]]
    [Create a cookie from a const char*. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.domain [*domain]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.expires [*expires]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.http_only [*http_only]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.name [*name]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.path [*path]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.secure [*secure]]]
    [`true` iff the cookie is only used for secure connections. ]
  ]

  [
    [[link cgi.reference.common__basic_cookie.value [*value]]]
    []
  ]

]

Either set the parameters in the constructor, or set them directly. Note: If you want to set the parameters individually, remember that each parameter must NOT have a trailing semi-colon!

TODO
* Data should be URL-encoded, or maybe provide an overload for url_decode that takes an HttpCookie?

* Add from_string() ? 


[section:basic_cookie common::basic_cookie::basic_cookie]

[indexterm2 basic_cookie..common::basic_cookie] Create a cookie. 

  ``[link cgi.reference.common__basic_cookie.basic_cookie.overload1 basic_cookie]``(
      const string_type & _name,
      const string_type & _val,
      const string_type & _expires = "",
      const string_type & _path = "/",
      const string_type & _domain = "",
      bool _secure = false,
      bool HttpOnly = false);

  ``[link cgi.reference.common__basic_cookie.basic_cookie.overload2 basic_cookie]``(
      const string_type & _name);

  ``[link cgi.reference.common__basic_cookie.basic_cookie.overload3 basic_cookie]``();


[section:overload1 common::basic_cookie::basic_cookie (1 of 3 overloads)]

Create a cookie. 

  basic_cookie(
      const string_type & _name,
      const string_type & _val,
      const string_type & _expires = "",
      const string_type & _path = "/",
      const string_type & _domain = "",
      bool _secure = false,
      bool HttpOnly = false);



[endsect]



[section:overload2 common::basic_cookie::basic_cookie (2 of 3 overloads)]

Create a cookie for deleting the cookie named `_name`. 

  basic_cookie(
      const string_type & _name);



[endsect]



[section:overload3 common::basic_cookie::basic_cookie (3 of 3 overloads)]



  basic_cookie();



[endsect]


[endsect]


[section:char_type common::basic_cookie::char_type]

[indexterm2 char_type..common::basic_cookie] 

  typedef CharT char_type;




[endsect]



[section:domain common::basic_cookie::domain]

[indexterm2 domain..common::basic_cookie] 

  string_type domain;



[endsect]



[section:expires common::basic_cookie::expires]

[indexterm2 expires..common::basic_cookie] 

  string_type expires;



[endsect]



[section:http_only common::basic_cookie::http_only]

[indexterm2 http_only..common::basic_cookie] 

  bool http_only;



[endsect]



[section:name common::basic_cookie::name]

[indexterm2 name..common::basic_cookie] 

  string_type name;



[endsect]



[section:path common::basic_cookie::path]

[indexterm2 path..common::basic_cookie] 

  string_type path;



[endsect]



[section:secure common::basic_cookie::secure]

[indexterm2 secure..common::basic_cookie] `true` iff the cookie is only used for secure connections. 

  bool secure;



[endsect]



[section:self_type common::basic_cookie::self_type]

[indexterm2 self_type..common::basic_cookie] 

  typedef basic_cookie< CharT > self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_cookie.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_cookie.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_cookie.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.basic_cookie [*basic_cookie]]]
    [Create a cookie. ]
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.to_string [*to_string]]]
    [Create a cookie from a const char*. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.domain [*domain]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.expires [*expires]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.http_only [*http_only]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.name [*name]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.path [*path]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.secure [*secure]]]
    [`true` iff the cookie is only used for secure connections. ]
  ]

  [
    [[link cgi.reference.common__basic_cookie.value [*value]]]
    []
  ]

]

Either set the parameters in the constructor, or set them directly. Note: If you want to set the parameters individually, remember that each parameter must NOT have a trailing semi-colon!

TODO
* Data should be URL-encoded, or maybe provide an overload for url_decode that takes an HttpCookie?

* Add from_string() ? 




[endsect]



[section:string_type common::basic_cookie::string_type]

[indexterm2 string_type..common::basic_cookie] 

  typedef std::basic_string< CharT > string_type;




[endsect]



[section:to_string common::basic_cookie::to_string]

[indexterm2 to_string..common::basic_cookie] Create a cookie from a const char*. 

  string_type to_string() const;


Rules taken from: http://wp.netscape.com/newsref/std/cookie\_spec.html

Assumes:
* Parts of the cookie are delimited by '; '. ie. if there is no space, or multiple spaces after the semi-colon, this function won't work... Make a string out of the cookie. 



[endsect]



[section:value common::basic_cookie::value]

[indexterm2 value..common::basic_cookie] 

  string_type value;



[endsect]



[endsect]

[section:common__basic_header common::basic_header]



  template<
      typename ``[link cgi.reference.CharT CharT]``>
  struct basic_header


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_header.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_header.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_header.basic_header [*basic_header]]]
    [Construct an header from a cookie. ]
  ]
  
  [
    [[link cgi.reference.common__basic_header.operator_string_type [*operator string_type]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_header.content [*content]]]
    []
  ]

]

[section:basic_header common::basic_header::basic_header]

[indexterm2 basic_header..common::basic_header] Construct an header from a cookie. 

  ``[link cgi.reference.common__basic_header.basic_header.overload1 basic_header]``(
      const basic_cookie< char_type > & ck);

  ``[link cgi.reference.common__basic_header.basic_header.overload2 basic_header]``(
      const string_type & name,
      const string_type & val);

  ``[link cgi.reference.common__basic_header.basic_header.overload3 basic_header]``(
      const string_type & _content);

  ``[link cgi.reference.common__basic_header.basic_header.overload4 basic_header]``();


[section:overload1 common::basic_header::basic_header (1 of 4 overloads)]

Construct an header from a cookie. 

  basic_header(
      const basic_cookie< char_type > & ck);



[endsect]



[section:overload2 common::basic_header::basic_header (2 of 4 overloads)]



  basic_header(
      const string_type & name,
      const string_type & val);



[endsect]



[section:overload3 common::basic_header::basic_header (3 of 4 overloads)]



  basic_header(
      const string_type & _content);



[endsect]



[section:overload4 common::basic_header::basic_header (4 of 4 overloads)]



  basic_header();



[endsect]


[endsect]


[section:char_type common::basic_header::char_type]

[indexterm2 char_type..common::basic_header] 

  typedef CharT char_type;




[endsect]



[section:content common::basic_header::content]

[indexterm2 content..common::basic_header] 

  string_type content;



[endsect]



[section:operator_string_type common::basic_header::operator string_type]

[indexterm2 operator string_type..common::basic_header] 

  operator string_type();



[endsect]



[section:string_type common::basic_header::string_type]

[indexterm2 string_type..common::basic_header] 

  typedef std::basic_string< CharT > string_type;




[endsect]



[endsect]

[section:common__basic_protocol_service common::basic_protocol_service]

Basic Protocol Service. 

  template<
      typename Protocol ,
      typename IoServiceProvider >
  class basic_protocol_service


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 

[section:basic_protocol_service common::basic_protocol_service::basic_protocol_service]

[indexterm2 basic_protocol_service..common::basic_protocol_service] 

  ``[link cgi.reference.common__basic_protocol_service.basic_protocol_service.overload1 basic_protocol_service]``(
      boost::asio::io_service & ios);

  ``[link cgi.reference.common__basic_protocol_service.basic_protocol_service.overload2 basic_protocol_service]``(
      int pool_size_hint = 1);


[section:overload1 common::basic_protocol_service::basic_protocol_service (1 of 2 overloads)]



  basic_protocol_service(
      boost::asio::io_service & ios);



[endsect]



[section:overload2 common::basic_protocol_service::basic_protocol_service (2 of 2 overloads)]



  basic_protocol_service(
      int pool_size_hint = 1);



[endsect]


[endsect]


[section:dispatch common::basic_protocol_service::dispatch]

[indexterm2 dispatch..common::basic_protocol_service] Dispatch a handler through an available io_service. 

  template<
      typename Handler >
  void dispatch(
      Handler handler);



[endsect]



[section:io_service common::basic_protocol_service::io_service]

[indexterm2 io_service..common::basic_protocol_service] Return an available io_service from the IoServiceProvider. 

  ::cgi::common::io_service & io_service();


The order in which the underlying io\_services are returned is determined by what policy the IoServiceProvider uses. 


[endsect]



[section:ios_provider_type common::basic_protocol_service::ios_provider_type]

[indexterm2 ios_provider_type..common::basic_protocol_service] 

  typedef IoServiceProvider ios_provider_type;




[endsect]



[section:is_cgi common::basic_protocol_service::is_cgi]

[indexterm2 is_cgi..common::basic_protocol_service] 

  bool is_cgi();



[endsect]



[section:post common::basic_protocol_service::post]

[indexterm2 post..common::basic_protocol_service] Post the handler through an available io_service. 

  template<
      typename Handler >
  void post(
      Handler handler);



[endsect]



[section:protocol_type common::basic_protocol_service::protocol_type]

[indexterm2 protocol_type..common::basic_protocol_service] 

  typedef Protocol protocol_type;




[endsect]



[section:queue_type common::basic_protocol_service::queue_type]

[indexterm2 queue_type..common::basic_protocol_service] 

  typedef std::queue< request_ptr > queue_type;




[endsect]



[section:request_ptr common::basic_protocol_service::request_ptr]

[indexterm2 request_ptr..common::basic_protocol_service] 

  typedef boost::shared_ptr< request_type > request_ptr;




[endsect]



[section:request_type common::basic_protocol_service::request_type]

[indexterm2 request_type..common::basic_protocol_service] 

  typedef traits::request_type request_type;




[endsect]



[section:reset common::basic_protocol_service::reset]

[indexterm2 reset..common::basic_protocol_service] Reset all the io_services contained by this service. 

  void reset();


This deletes the request queue(s), aborts all running requests and then calls reset() on each of the io\_services held by ios\_provider\_. There is no guarantee that requests will terminate immediately. 


[endsect]



[section:run common::basic_protocol_service::run]

[indexterm2 run..common::basic_protocol_service] Run all the io_services contained by this service. 

  void run();


This is equivalent to calling run() on each of the io\_services held by ios\_provider\_ 


[endsect]



[section:set_type common::basic_protocol_service::set_type]

[indexterm2 set_type..common::basic_protocol_service] 

  typedef std::set< request_ptr > set_type;




[endsect]



[section:stop common::basic_protocol_service::stop]

[indexterm2 stop..common::basic_protocol_service] Stop all the io_services contained by this service. 

  void stop();


This is equivalent to calling stop() on each of the io\_services held by ios\_provider\_ 


[endsect]



[section:traits common::basic_protocol_service::traits]

[indexterm2 traits..common::basic_protocol_service] 

  typedef detail::protocol_traits< Protocol >::type traits;




[endsect]



[section:_basic_protocol_service common::basic_protocol_service::~basic_protocol_service]

[indexterm2 ~basic_protocol_service..common::basic_protocol_service] 

  ~basic_protocol_service();



[endsect]



[endsect]

[section:common__basic_request_acceptor common::basic_request_acceptor]

The interface class for any *cgiacceptor. 

  template<
      typename RequestAcceptorService >
  class basic_request_acceptor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_request_acceptor.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.next_layer_type [*next_layer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.port_number_type [*port_number_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.service_type [*service_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request_acceptor.accept [*accept]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.assign [*assign]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.async_accept [*async_accept]]]
    [Asynchronously accept one request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor [*basic_request_acceptor]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.is_open [*is_open]]]
    [Check if the acceptor is open. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.listen [*listen]]]
    [Set the acceptor to listen. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.native [*native]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.open [*open]]]
    [Open the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.protocol_service [*protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor._basic_request_acceptor [*~basic_request_acceptor]]]
    []
  ]
  
]

[section:accept common::basic_request_acceptor::accept]

[indexterm2 accept..common::basic_request_acceptor] 

  template<
      typename CommonGatewayRequest >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.accept.overload1 accept]``(
      CommonGatewayRequest & request,
      endpoint_type & ep,
      boost::system::error_code & ec);

  template<
      typename CommonGatewayRequest >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.accept.overload2 accept]``(
      CommonGatewayRequest & request,
      boost::system::error_code & ec);

  template<
      typename CommonGatewayRequest >
  void ``[link cgi.reference.common__basic_request_acceptor.accept.overload3 accept]``(
      CommonGatewayRequest & request);


[section:overload1 common::basic_request_acceptor::accept (1 of 3 overloads)]



  template<
      typename CommonGatewayRequest >
  boost::system::error_code accept(
      CommonGatewayRequest & request,
      endpoint_type & ep,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_request_acceptor::accept (2 of 3 overloads)]

Accept one request. 

  template<
      typename CommonGatewayRequest >
  boost::system::error_code accept(
      CommonGatewayRequest & request,
      boost::system::error_code & ec);



[endsect]



[section:overload3 common::basic_request_acceptor::accept (3 of 3 overloads)]

Accept one request. 

  template<
      typename CommonGatewayRequest >
  void accept(
      CommonGatewayRequest & request);



[endsect]


[endsect]

[section:assign common::basic_request_acceptor::assign]

[indexterm2 assign..common::basic_request_acceptor] 

  template<
      typename Protocol >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.assign.overload1 assign]``(
      Protocol protocol,
      const native_type & native_acceptor,
      boost::system::error_code & ec);

  template<
      typename Protocol >
  void ``[link cgi.reference.common__basic_request_acceptor.assign.overload2 assign]``(
      Protocol protocol,
      const native_type & native_acceptor);


[section:overload1 common::basic_request_acceptor::assign (1 of 2 overloads)]



  template<
      typename Protocol >
  boost::system::error_code assign(
      Protocol protocol,
      const native_type & native_acceptor,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_request_acceptor::assign (2 of 2 overloads)]



  template<
      typename Protocol >
  void assign(
      Protocol protocol,
      const native_type & native_acceptor);



[endsect]


[endsect]


[section:async_accept common::basic_request_acceptor::async_accept]

[indexterm2 async_accept..common::basic_request_acceptor] Asynchronously accept one request. 

  template<
      typename CommonGatewayRequest ,
      typename Handler >
  void async_accept(
      CommonGatewayRequest & request,
      Handler handler);



[endsect]


[section:basic_request_acceptor common::basic_request_acceptor::basic_request_acceptor]

[indexterm2 basic_request_acceptor..common::basic_request_acceptor] 

  template<
      typename IoServiceProvider ,
      typename InternetProtocol >
  ``[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor.overload1 basic_request_acceptor]``(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      const InternetProtocol & ip,
      const native_type & native_acceptor);

  template<
      typename IoServiceProvider ,
      typename InternetProtocol >
  ``[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor.overload2 basic_request_acceptor]``(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      const boost::asio::ip::basic_endpoint< InternetProtocol > & endpoint,
      bool reuse_addr = true);

  template<
      typename IoServiceProvider >
  ``[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor.overload3 basic_request_acceptor]``(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      port_number_type port_num = 0);


[section:overload1 common::basic_request_acceptor::basic_request_acceptor (1 of 3 overloads)]



  template<
      typename IoServiceProvider ,
      typename InternetProtocol >
  basic_request_acceptor(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      const InternetProtocol & ip,
      const native_type & native_acceptor);



[endsect]



[section:overload2 common::basic_request_acceptor::basic_request_acceptor (2 of 3 overloads)]



  template<
      typename IoServiceProvider ,
      typename InternetProtocol >
  basic_request_acceptor(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      const boost::asio::ip::basic_endpoint< InternetProtocol > & endpoint,
      bool reuse_addr = true);



[endsect]



[section:overload3 common::basic_request_acceptor::basic_request_acceptor (3 of 3 overloads)]



  template<
      typename IoServiceProvider >
  basic_request_acceptor(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      port_number_type port_num = 0);



[endsect]


[endsect]

[section:bind common::basic_request_acceptor::bind]

[indexterm2 bind..common::basic_request_acceptor] 

  template<
      typename Endpoint >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.bind.overload1 bind]``(
      Endpoint & ep,
      boost::system::error_code & ec);

  template<
      typename Endpoint >
  void ``[link cgi.reference.common__basic_request_acceptor.bind.overload2 bind]``(
      Endpoint & ep);


[section:overload1 common::basic_request_acceptor::bind (1 of 2 overloads)]



  template<
      typename Endpoint >
  boost::system::error_code bind(
      Endpoint & ep,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_request_acceptor::bind (2 of 2 overloads)]



  template<
      typename Endpoint >
  void bind(
      Endpoint & ep);



[endsect]


[endsect]


[section:cancel common::basic_request_acceptor::cancel]

[indexterm2 cancel..common::basic_request_acceptor] Cancel all asynchronous operations associated with the acceptor. 

  boost::system::error_code cancel();



[endsect]


[section:close common::basic_request_acceptor::close]

[indexterm2 close..common::basic_request_acceptor] Close the acceptor. 

  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.close.overload1 close]``(
      boost::system::error_code & ec);

  void ``[link cgi.reference.common__basic_request_acceptor.close.overload2 close]``();


[section:overload1 common::basic_request_acceptor::close (1 of 2 overloads)]

Close the acceptor. 

  boost::system::error_code close(
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_request_acceptor::close (2 of 2 overloads)]

Close the acceptor. 

  void close();



[endsect]


[endsect]


[section:endpoint_type common::basic_request_acceptor::endpoint_type]

[indexterm2 endpoint_type..common::basic_request_acceptor] 

  typedef service_type::endpoint_type endpoint_type;




[endsect]



[section:is_cgi common::basic_request_acceptor::is_cgi]

[indexterm2 is_cgi..common::basic_request_acceptor] 

  bool is_cgi();



[endsect]



[section:is_open common::basic_request_acceptor::is_open]

[indexterm2 is_open..common::basic_request_acceptor] Check if the acceptor is open. 

  bool is_open();



[endsect]


[section:listen common::basic_request_acceptor::listen]

[indexterm2 listen..common::basic_request_acceptor] Set the acceptor to listen. 

  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.listen.overload1 listen]``(
      int backlog,
      boost::system::error_code & ec);

  void ``[link cgi.reference.common__basic_request_acceptor.listen.overload2 listen]``(
      int backlog = boost::asio::socket_base::max_connections);


[section:overload1 common::basic_request_acceptor::listen (1 of 2 overloads)]

Set the acceptor to listen. 

  boost::system::error_code listen(
      int backlog,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_request_acceptor::listen (2 of 2 overloads)]

Set the acceptor to listen. 

  void listen(
      int backlog = boost::asio::socket_base::max_connections);



[endsect]


[endsect]

[section:local_endpoint common::basic_request_acceptor::local_endpoint]

[indexterm2 local_endpoint..common::basic_request_acceptor] 

  endpoint_type ``[link cgi.reference.common__basic_request_acceptor.local_endpoint.overload1 local_endpoint]``(
      boost::system::error_code & ec) const;

  endpoint_type ``[link cgi.reference.common__basic_request_acceptor.local_endpoint.overload2 local_endpoint]``();


[section:overload1 common::basic_request_acceptor::local_endpoint (1 of 2 overloads)]



  endpoint_type local_endpoint(
      boost::system::error_code & ec) const;



[endsect]



[section:overload2 common::basic_request_acceptor::local_endpoint (2 of 2 overloads)]



  endpoint_type local_endpoint();



[endsect]


[endsect]


[section:native common::basic_request_acceptor::native]

[indexterm2 native..common::basic_request_acceptor] 

  native_type native();



[endsect]



[section:native_type common::basic_request_acceptor::native_type]

[indexterm2 native_type..common::basic_request_acceptor] 

  typedef service_type::native_type native_type;




[endsect]



[section:next_layer_type common::basic_request_acceptor::next_layer_type]

[indexterm2 next_layer_type..common::basic_request_acceptor] 

  typedef service_type::implementation_type::acceptor_service_type next_layer_type;




[endsect]


[section:open common::basic_request_acceptor::open]

[indexterm2 open..common::basic_request_acceptor] Open the acceptor. 

  template<
      typename Protocol >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.open.overload1 open]``(
      const Protocol & protocol,
      boost::system::error_code & ec);

  template<
      typename Protocol >
  void ``[link cgi.reference.common__basic_request_acceptor.open.overload2 open]``(
      const Protocol & protocol);


[section:overload1 common::basic_request_acceptor::open (1 of 2 overloads)]

Open the acceptor. 

  template<
      typename Protocol >
  boost::system::error_code open(
      const Protocol & protocol,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_request_acceptor::open (2 of 2 overloads)]

Open the acceptor. 

  template<
      typename Protocol >
  void open(
      const Protocol & protocol);



[endsect]


[endsect]


[section:port_number_type common::basic_request_acceptor::port_number_type]

[indexterm2 port_number_type..common::basic_request_acceptor] 

  typedef service_type::implementation_type::port_number_type port_number_type;




[endsect]



[section:protocol_service common::basic_request_acceptor::protocol_service]

[indexterm2 protocol_service..common::basic_request_acceptor] 

  protocol_service_type & protocol_service() const;



[endsect]



[section:protocol_service_type common::basic_request_acceptor::protocol_service_type]

[indexterm2 protocol_service_type..common::basic_request_acceptor] 

  typedef service_type::service_impl_type::protocol_service_type protocol_service_type;




[endsect]



[section:protocol_type common::basic_request_acceptor::protocol_type]

[indexterm2 protocol_type..common::basic_request_acceptor] 

  typedef service_type::protocol_type protocol_type;




[endsect]



[section:service_type common::basic_request_acceptor::service_type]

[indexterm2 service_type..common::basic_request_acceptor] 

  typedef RequestAcceptorService service_type;




[endsect]



[section:_basic_request_acceptor common::basic_request_acceptor::~basic_request_acceptor]

[indexterm2 ~basic_request_acceptor..common::basic_request_acceptor] 

  ~basic_request_acceptor();



[endsect]



[endsect]

[section:common__basic_response common::basic_response]

The response class: a helper for responding to requests. 

  template<
      typename T>
  class basic_response


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_response.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.ostream_type [*ostream_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_response.async_send [*async_send]]]
    [Asynchronously send the data through the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.basic_response [*basic_response]]]
    [Construct with a particular buffer. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.charset [*charset]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.clear [*clear]]]
    [Clear the response buffer. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.clear_headers [*clear_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.content_length [*content_length]]]
    [Get the length of the body of the response (ie. not including the headers). ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.do_async_send [*do_async_send]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.end_headers [*end_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.flush [*flush]]]
    [Synchronously flush the data via the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.header_value [*header_value]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.headers [*headers]]]
    [Get the headers. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.headers_terminated [*headers_terminated]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.ostream [*ostream]]]
    [Get the ostream containing the response body. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.rdbuf [*rdbuf]]]
    [Get the buffer associated with the stream. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.resend [*resend]]]
    [Resend headers + content regardless of value of `headers_terminated_`. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.reset [*reset]]]
    [Return the response to the 'just constructed' state. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.reset_headers [*reset_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.send [*send]]]
    [Synchronously send the data via the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.set_header [*set_header]]]
    [Format and add a header given name and value, appending CRLF. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.set_status [*set_status]]]
    [Set the status code associated with the response. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.status [*status]]]
    [Get the status code associated with the response. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.str [*str]]]
    [Get the contents of the response as a string. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.unterminate_headers [*unterminate_headers]]]
    [Allow more headers to be added (WARNING: avoid using this). ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.write [*write]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response._basic_response [*~basic_response]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_response.buffer_ [*buffer_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.charset_ [*charset_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.headers_ [*headers_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.headers_terminated_ [*headers_terminated_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.ostream_ [*ostream_]]]
    []
  ]

]


[section:async_send common::basic_response::async_send]

[indexterm2 async_send..common::basic_response] Asynchronously send the data through the supplied request. 

  template<
      typename AsyncWriteStream ,
      typename Handler >
  void async_send(
      AsyncWriteStream & aws,
      Handler handler);


Note: This is quite crude at the moment and not as asynchronous as it could/should be. The data in the stream isn't cleared after this call. 


[endsect]


[section:basic_response common::basic_response::basic_response]

[indexterm2 basic_response..common::basic_response] Construct with a particular buffer. 

  ``[link cgi.reference.common__basic_response.basic_response.overload1 basic_response]``(
      ::cgi::common::streambuf * buf,
      common::http::status_code sc = common::http::ok);

  ``[link cgi.reference.common__basic_response.basic_response.overload2 basic_response]``(
      common::http::status_code sc = common::http::ok);


[section:overload1 common::basic_response::basic_response (1 of 2 overloads)]

Construct with a particular buffer. 

  basic_response(
      ::cgi::common::streambuf * buf,
      common::http::status_code sc = common::http::ok);


Takes the buffer and uses it internally, does nothing with it on destruction. 


[endsect]



[section:overload2 common::basic_response::basic_response (2 of 2 overloads)]



  basic_response(
      common::http::status_code sc = common::http::ok);



[endsect]


[endsect]


[section:buffer_ common::basic_response::buffer_]

[indexterm2 buffer_..common::basic_response] 

  boost::shared_ptr< common::streambuf > buffer_;



[endsect]



[section:char_type common::basic_response::char_type]

[indexterm2 char_type..common::basic_response] 

  typedef T char_type;




[endsect]



[section:charset common::basic_response::charset]

[indexterm2 charset..common::basic_response] 

  string_type & charset();



[endsect]



[section:charset_ common::basic_response::charset_]

[indexterm2 charset_..common::basic_response] 

  string_type charset_;



[endsect]



[section:clear common::basic_response::clear]

[indexterm2 clear..common::basic_response] Clear the response buffer. 

  void clear();



[endsect]



[section:clear_headers common::basic_response::clear_headers]

[indexterm2 clear_headers..common::basic_response] 

  void clear_headers();



[endsect]



[section:content_length common::basic_response::content_length]

[indexterm2 content_length..common::basic_response] Get the length of the body of the response (ie. not including the headers). 

  std::size_t content_length();


Get the length of the body of the response. 


[endsect]



[section:do_async_send common::basic_response::do_async_send]

[indexterm2 do_async_send..common::basic_response] 

  template<
      typename AsyncWriteStream ,
      typename Handler >
  void do_async_send(
      AsyncWriteStream & aws,
      Handler handler);



[endsect]



[section:end_headers common::basic_response::end_headers]

[indexterm2 end_headers..common::basic_response] 

  void end_headers();



[endsect]


[section:flush common::basic_response::flush]

[indexterm2 flush..common::basic_response] Synchronously flush the data via the supplied request. 

  template<
      typename SyncWriteStream >
  boost::system::error_code ``[link cgi.reference.common__basic_response.flush.overload1 flush]``(
      SyncWriteStream & sws,
      boost::system::error_code & ec);

  template<
      typename SyncWriteStream >
  void ``[link cgi.reference.common__basic_response.flush.overload2 flush]``(
      SyncWriteStream & sws);


[section:overload1 common::basic_response::flush (1 of 2 overloads)]

Synchronously flush the data via the supplied request. 

  template<
      typename SyncWriteStream >
  boost::system::error_code flush(
      SyncWriteStream & sws,
      boost::system::error_code & ec);


This call uses error\_code semantics. ie. ec is set if an error occurs. If there is no error, the buffer is cleared. 


[endsect]



[section:overload2 common::basic_response::flush (2 of 2 overloads)]

Synchronously flush the data to the supplied SyncWriteStream. 

  template<
      typename SyncWriteStream >
  void flush(
      SyncWriteStream & sws);


This call uses throwing semantics. ie. an exception will be thrown on any failure. If there is no error, the buffer is cleared. 


[endsect]


[endsect]


[section:header_value common::basic_response::header_value]

[indexterm2 header_value..common::basic_response] 

  string_type header_value(
      string_type const & name);



[endsect]



[section:headers common::basic_response::headers]

[indexterm2 headers..common::basic_response] Get the headers. 

  std::vector< string_type > & headers();


Get the ostream containing the response body. 


[endsect]



[section:headers_ common::basic_response::headers_]

[indexterm2 headers_..common::basic_response] 

  std::vector< string_type > headers_;



[endsect]



[section:headers_terminated common::basic_response::headers_terminated]

[indexterm2 headers_terminated..common::basic_response] 

  bool headers_terminated() const;



[endsect]



[section:headers_terminated_ common::basic_response::headers_terminated_]

[indexterm2 headers_terminated_..common::basic_response] 

  bool headers_terminated_;



[endsect]



[section:http_status_ common::basic_response::http_status_]

[indexterm2 http_status_..common::basic_response] 

  http::status_code http_status_;



[endsect]



[section:ostream common::basic_response::ostream]

[indexterm2 ostream..common::basic_response] Get the ostream containing the response body. 

  ostream_type & ostream();



[endsect]



[section:ostream_ common::basic_response::ostream_]

[indexterm2 ostream_..common::basic_response] 

  ostream_type ostream_;



[endsect]



[section:ostream_type common::basic_response::ostream_type]

[indexterm2 ostream_type..common::basic_response] 

  typedef std::basic_ostream< T > ostream_type;




[endsect]



[section:rdbuf common::basic_response::rdbuf]

[indexterm2 rdbuf..common::basic_response] Get the buffer associated with the stream. 

  common::streambuf * rdbuf();



[endsect]



[section:resend common::basic_response::resend]

[indexterm2 resend..common::basic_response] Resend headers + content regardless of value of `headers_terminated_`. 

  template<
      typename SyncWriteStream >
  void resend(
      SyncWriteStream & sws);



[endsect]



[section:reset common::basic_response::reset]

[indexterm2 reset..common::basic_response] Return the response to the 'just constructed' state. 

  void reset();



[endsect]



[section:reset_headers common::basic_response::reset_headers]

[indexterm2 reset_headers..common::basic_response] 

  void reset_headers();



[endsect]



[section:self_type common::basic_response::self_type]

[indexterm2 self_type..common::basic_response] 

  typedef basic_response< T > self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_response.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.ostream_type [*ostream_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_response.async_send [*async_send]]]
    [Asynchronously send the data through the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.basic_response [*basic_response]]]
    [Construct with a particular buffer. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.charset [*charset]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.clear [*clear]]]
    [Clear the response buffer. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.clear_headers [*clear_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.content_length [*content_length]]]
    [Get the length of the body of the response (ie. not including the headers). ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.do_async_send [*do_async_send]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.end_headers [*end_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.flush [*flush]]]
    [Synchronously flush the data via the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.header_value [*header_value]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.headers [*headers]]]
    [Get the headers. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.headers_terminated [*headers_terminated]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.ostream [*ostream]]]
    [Get the ostream containing the response body. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.rdbuf [*rdbuf]]]
    [Get the buffer associated with the stream. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.resend [*resend]]]
    [Resend headers + content regardless of value of `headers_terminated_`. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.reset [*reset]]]
    [Return the response to the 'just constructed' state. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.reset_headers [*reset_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.send [*send]]]
    [Synchronously send the data via the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.set_header [*set_header]]]
    [Format and add a header given name and value, appending CRLF. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.set_status [*set_status]]]
    [Set the status code associated with the response. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.status [*status]]]
    [Get the status code associated with the response. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.str [*str]]]
    [Get the contents of the response as a string. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.unterminate_headers [*unterminate_headers]]]
    [Allow more headers to be added (WARNING: avoid using this). ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.write [*write]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response._basic_response [*~basic_response]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_response.buffer_ [*buffer_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.charset_ [*charset_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.headers_ [*headers_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.headers_terminated_ [*headers_terminated_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.ostream_ [*ostream_]]]
    []
  ]

]



[endsect]


[section:send common::basic_response::send]

[indexterm2 send..common::basic_response] Synchronously send the data via the supplied request. 

  template<
      typename SyncWriteStream >
  boost::system::error_code ``[link cgi.reference.common__basic_response.send.overload1 send]``(
      SyncWriteStream & sws,
      boost::system::error_code & ec);

  template<
      typename SyncWriteStream >
  void ``[link cgi.reference.common__basic_response.send.overload2 send]``(
      SyncWriteStream & sws);


[section:overload1 common::basic_response::send (1 of 2 overloads)]

Synchronously send the data via the supplied request. 

  template<
      typename SyncWriteStream >
  boost::system::error_code send(
      SyncWriteStream & sws,
      boost::system::error_code & ec);


This call will not throw, but will set `ec` such that `ec == true` if an error occurs. Details of the error are held in the `error\_code` object. 


[endsect]



[section:overload2 common::basic_response::send (2 of 2 overloads)]

Synchronously send the data via the supplied request. 

  template<
      typename SyncWriteStream >
  void send(
      SyncWriteStream & sws);


This call uses throwing semantics. ie. an exception will be thrown on any failure. Note: The data in the stream isn't cleared after this call. 


[endsect]


[endsect]

[section:set_header common::basic_response::set_header]

[indexterm2 set_header..common::basic_response] Format and add a header given name and value, appending CRLF. 

  basic_response< char_type > & ``[link cgi.reference.common__basic_response.set_header.overload1 set_header]``(
      string_type const & name,
      string_type const & value);

  basic_response< char_type > & ``[link cgi.reference.common__basic_response.set_header.overload2 set_header]``(
      const string_type & value);


[section:overload1 common::basic_response::set_header (1 of 2 overloads)]

Format and add a header given name and value, appending CRLF. 

  basic_response< char_type > & set_header(
      string_type const & name,
      string_type const & value);



[endsect]



[section:overload2 common::basic_response::set_header (2 of 2 overloads)]

Add a header after appending the CRLF sequence. 

  basic_response< char_type > & set_header(
      const string_type & value);



[endsect]


[endsect]


[section:set_status common::basic_response::set_status]

[indexterm2 set_status..common::basic_response] Set the status code associated with the response. 

  basic_response< char_type > & set_status(
      const http::status_code & num);



[endsect]



[section:status common::basic_response::status]

[indexterm2 status..common::basic_response] Get the status code associated with the response. 

  http::status_code & status();



[endsect]



[section:str common::basic_response::str]

[indexterm2 str..common::basic_response] Get the contents of the response as a string. 

  string_type str() const;


Get the response as a string.

This copies the contents of the response into a string. Headers aren't included in the dump. 


[endsect]



[section:string_type common::basic_response::string_type]

[indexterm2 string_type..common::basic_response] 

  typedef std::basic_string< T > string_type;




[endsect]



[section:unterminate_headers common::basic_response::unterminate_headers]

[indexterm2 unterminate_headers..common::basic_response] Allow more headers to be added (WARNING: avoid using this). 

  void unterminate_headers();



[endsect]


[section:write common::basic_response::write]

[indexterm2 write..common::basic_response] 

  template<
      typename T >
  BOOST_CGI_INLINE std::size_t ``[link cgi.reference.common__basic_response.write.overload1 write]``(
      std::basic_string< T > const & str);

  template<
      typename ConstBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_response.write.overload2 write]``(
      const ConstBufferSequence & buf);

  std::size_t ``[link cgi.reference.common__basic_response.write.overload3 write]``(
      string_type const & str);

  std::size_t ``[link cgi.reference.common__basic_response.write.overload4 write]``(
      const char_type * str,
      std::size_t len);


[section:overload1 common::basic_response::write (1 of 4 overloads)]



  template<
      typename T >
  BOOST_CGI_INLINE std::size_t write(
      std::basic_string< T > const & str);



[endsect]



[section:overload2 common::basic_response::write (2 of 4 overloads)]



  template<
      typename ConstBufferSequence >
  std::size_t write(
      const ConstBufferSequence & buf);



[endsect]



[section:overload3 common::basic_response::write (3 of 4 overloads)]



  std::size_t write(
      string_type const & str);



[endsect]



[section:overload4 common::basic_response::write (4 of 4 overloads)]



  std::size_t write(
      const char_type * str,
      std::size_t len);



[endsect]


[endsect]


[section:_basic_response common::basic_response::~basic_response]

[indexterm2 ~basic_response..common::basic_response] 

  ~basic_response();



[endsect]



[endsect]

[section:common__charset_header common::charset_header]



  template<
      typename ``[link cgi.reference.CharT CharT]``>
  struct charset_header


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__charset_header.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__charset_header.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__charset_header.charset_header [*charset_header]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__charset_header.content [*content]]]
    []
  ]

]


[section:char_type common::charset_header::char_type]

[indexterm2 char_type..common::charset_header] 

  typedef CharT char_type;




[endsect]



[section:charset_header common::charset_header::charset_header]

[indexterm2 charset_header..common::charset_header] 

  charset_header(
      const string_type & _content);



[endsect]



[section:content common::charset_header::content]

[indexterm2 content..common::charset_header] 

  string_type content;



[endsect]



[section:string_type common::charset_header::string_type]

[indexterm2 string_type..common::charset_header] 

  typedef std::basic_string< CharT > string_type;




[endsect]



[endsect]


[section:common__client_status common::client_status]

[indexterm1 common::client_status] 

  enum client_status

[heading Values]
[variablelist

  [
    [none_]
    []
  ]

  [
    [constructed]
    []
  ]

  [
    [params_read]
    []
  ]

  [
    [stdin_read]
    []
  ]

  [
    [end_request_sent]
    []
  ]

  [
    [closed_]
    []
  ]

]



[endsect]



[section:common__connection__stderr common::connection::stderr]

[indexterm1 common::connection::stderr] 

  typedef basic_connection< tags::stderr > stderr;




[endsect]



[section:common__cookie_data_type common::cookie_data_type]

[indexterm1 common::cookie_data_type] 

  enum cookie_data_type

[heading Values]
[variablelist

  [
    [cookies]
    []
  ]

  [
    [cookie_data]
    []
  ]

]



[endsect]



[section:common__env_data_type common::env_data_type]

[indexterm1 common::env_data_type] Types of data sources and related enums. 

  enum env_data_type

[heading Values]
[variablelist

  [
    [env]
    []
  ]

  [
    [env_data]
    []
  ]

]


Each data source is given a unique type. This is so the accessor operators on a `basic\_request<>` are compile-time aliases to the internal data maps.

If you want to add a new data type to a request you need to: > Update this file > Update map.hpp with a new map type > Update `data\_map\_type` in the `request\_base` class > Use the `BOOST\_CGI\_DETAIL\_MAP\_ACCESS` macro in `basic\_request<>`, next to the other uses of it. 


[endsect]



[section:common__error__cgi_errors common::error::cgi_errors]

[indexterm1 common::error::cgi_errors] 

  enum cgi_errors

[heading Values]
[variablelist

  [
    [client_closed]
    []
  ]

  [
    [duplicate_request]
    []
  ]

  [
    [accepting_on_an_open_request]
    []
  ]

  [
    [invalid_socket]
    []
  ]

  [
    [invalid_form_type]
    []
  ]

  [
    [broken_pipe]
    []
  ]

  [
    [bad_read]
    []
  ]

  [
    [client_not_open]
    []
  ]

  [
    [eof]
    []
  ]

  [
    [multipart_form_boundary_not_found]
    []
  ]

  [
    [multipart_meta_data_not_terminated]
    []
  ]

  [
    [no_boundary_marker]
    []
  ]

  [
    [max_post_exceeded]
    []
  ]

]



[endsect]


[section:common__fcgi_ common::fcgi_]

FastCGI. 

  struct fcgi_



[endsect]


[section:common__form_data_type common::form_data_type]

[indexterm1 common::form_data_type] 

  enum form_data_type

[heading Values]
[variablelist

  [
    [form]
    []
  ]

  [
    [form_data]
    []
  ]

]



[endsect]


[section:common__form_part common::form_part]



  struct form_part


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__form_part.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.iter_t [*iter_t]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.meta_data_map_type [*meta_data_map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.pair_t [*pair_t]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.range_type [*range_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__form_part.form_part [*form_part]]]
    []
  ]
  
  [
    [[link cgi.reference.common__form_part.operator_eq__eq_ [*operator==]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__form_part.boundary_marker_ [*boundary_marker_]]]
    [The boundary marker that's needed. ]
  ]

  [
    [[link cgi.reference.common__form_part.buffer_ [*buffer_]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.content_disposition [*content_disposition]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.content_type [*content_type]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.filename [*filename]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.meta_data_ [*meta_data_]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.name [*name]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.path [*path]]]
    []
  ]

]


[section:boundary_marker_ common::form_part::boundary_marker_]

[indexterm2 boundary_marker_..common::form_part] The boundary marker that's needed. 

  string_type boundary_marker_;



[endsect]



[section:buffer_ common::form_part::buffer_]

[indexterm2 buffer_..common::form_part] 

  pair_t buffer_;



[endsect]



[section:buffer_type common::form_part::buffer_type]

[indexterm2 buffer_type..common::form_part] 

  typedef string_type buffer_type;




[endsect]



[section:content_disposition common::form_part::content_disposition]

[indexterm2 content_disposition..common::form_part] 

  string_type content_disposition;



[endsect]



[section:content_type common::form_part::content_type]

[indexterm2 content_type..common::form_part] 

  string_type content_type;



[endsect]



[section:filename common::form_part::filename]

[indexterm2 filename..common::form_part] 

  string_type filename;



[endsect]



[section:form_part common::form_part::form_part]

[indexterm2 form_part..common::form_part] 

  form_part();



[endsect]



[section:iter_t common::form_part::iter_t]

[indexterm2 iter_t..common::form_part] 

  typedef buffer_type::iterator iter_t;




[endsect]



[section:meta_data_ common::form_part::meta_data_]

[indexterm2 meta_data_..common::form_part] 

  meta_data_map_type meta_data_;



[endsect]



[section:meta_data_map_type common::form_part::meta_data_map_type]

[indexterm2 meta_data_map_type..common::form_part] 

  typedef std::map< string_type, pair_t > meta_data_map_type;




[endsect]



[section:name common::form_part::name]

[indexterm2 name..common::form_part] 

  string_type name;



[endsect]



[section:operator_eq__eq_ common::form_part::operator==]

[indexterm2 operator==..common::form_part] 

  bool operator==(
      form_part & other);



[endsect]



[section:pair_t common::form_part::pair_t]

[indexterm2 pair_t..common::form_part] 

  typedef std::pair< iter_t, iter_t > pair_t;




[endsect]



[section:path common::form_part::path]

[indexterm2 path..common::form_part] 

  string_type path;



[endsect]



[section:range_type common::form_part::range_type]

[indexterm2 range_type..common::form_part] 

  typedef boost::iterator_range< buffer_type::const_iterator > range_type;




[endsect]



[section:string_type common::form_part::string_type]

[indexterm2 string_type..common::form_part] 

  typedef std::string string_type;




[endsect]



[endsect]


[section:common__get_data_type common::get_data_type]

[indexterm1 common::get_data_type] 

  enum get_data_type

[heading Values]
[variablelist

  [
    [get]
    []
  ]

  [
    [get_data]
    []
  ]

]



[endsect]



[section:common__http__status_code common::http::status_code]

[indexterm1 common::http::status_code] Standard HTTP status codes. 

  enum status_code

[heading Values]
[variablelist

  [
    [continue_]
    [Informational codes. ]
  ]

  [
    [switching_protocols]
    []
  ]

  [
    [processing]
    []
  ]

  [
    [ok]
    [Success codes. ]
  ]

  [
    [created]
    []
  ]

  [
    [accepted]
    []
  ]

  [
    [non_authorative_information]
    []
  ]

  [
    [no_content]
    []
  ]

  [
    [reset_content]
    []
  ]

  [
    [partial_content]
    []
  ]

  [
    [multi_status]
    []
  ]

  [
    [multiple_choices]
    [Redirect codes. ]
  ]

  [
    [moved_permanently]
    []
  ]

  [
    [found]
    []
  ]

  [
    [see_other]
    []
  ]

  [
    [not_modified]
    []
  ]

  [
    [use_proxy]
    []
  ]

  [
    [switch_proxy]
    []
  ]

  [
    [temporary_redirect]
    []
  ]

  [
    [bad_request]
    [Domain error codes. ]
  ]

  [
    [unauthorized]
    []
  ]

  [
    [payment_required]
    []
  ]

  [
    [forbidden]
    []
  ]

  [
    [not_found]
    []
  ]

  [
    [method_not_allowed]
    []
  ]

  [
    [not_acceptable]
    []
  ]

  [
    [proxy_authentication_required]
    []
  ]

  [
    [request_timeout]
    []
  ]

  [
    [conflict]
    []
  ]

  [
    [gone]
    []
  ]

  [
    [length_required]
    []
  ]

  [
    [precondition_failed]
    []
  ]

  [
    [request_entity_too_large]
    []
  ]

  [
    [request_uri_too_long]
    []
  ]

  [
    [unsupported_media_type]
    []
  ]

  [
    [request_range_not_satisfiable]
    []
  ]

  [
    [expectation_failed]
    []
  ]

  [
    [unprocessable_entity]
    []
  ]

  [
    [locked]
    []
  ]

  [
    [failed_dependency]
    []
  ]

  [
    [unordered_collection]
    []
  ]

  [
    [upgrade_required]
    []
  ]

  [
    [retry_with]
    []
  ]

  [
    [internal_server_error]
    [Internal error codes. ]
  ]

  [
    [not_implemented]
    []
  ]

  [
    [bad_gateway]
    []
  ]

  [
    [service_unavailable]
    []
  ]

  [
    [gateway_timeout]
    []
  ]

  [
    [http_version_not_supported]
    []
  ]

  [
    [insufficient_storage]
    []
  ]

  [
    [bandwidth_limit_exceeded]
    []
  ]

]


See http://tools.ietf.org/html/rfc2616#section-10


[endsect]


[section:common__ichar_traits common::ichar_traits]



  template<
      typename CharT >
  struct ichar_traits


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__ichar_traits.compare [*compare]]]
    []
  ]
  
  [
    [[link cgi.reference.common__ichar_traits.eq [*eq]]]
    []
  ]
  
  [
    [[link cgi.reference.common__ichar_traits.find [*find]]]
    []
  ]
  
  [
    [[link cgi.reference.common__ichar_traits.lt [*lt]]]
    []
  ]
  
  [
    [[link cgi.reference.common__ichar_traits.ne [*ne]]]
    []
  ]
  
]


[section:compare common::ichar_traits::compare]

[indexterm2 compare..common::ichar_traits] 

  static int compare(
      const char * str1,
      const char * str2,
      std::size_t num);



[endsect]



[section:eq common::ichar_traits::eq]

[indexterm2 eq..common::ichar_traits] 

  static bool eq(
      char c1,
      char c2);



[endsect]



[section:find common::ichar_traits::find]

[indexterm2 find..common::ichar_traits] 

  static const char * find(
      const char * str,
      int n,
      char a);



[endsect]



[section:lt common::ichar_traits::lt]

[indexterm2 lt..common::ichar_traits] 

  static bool lt(
      char c1,
      char c2);



[endsect]



[section:ne common::ichar_traits::ne]

[indexterm2 ne..common::ichar_traits] 

  static bool ne(
      char c1,
      char c2);



[endsect]



[endsect]

[section:common__io_service_provider common::io_service_provider]

Hold a set number of io_services and return them based on the Policy. 

  template<
      typename PoolingPolicy >
  class io_service_provider


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__io_service_provider.get_io_service [*get_io_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__io_service_provider.io_service_provider [*io_service_provider]]]
    []
  ]
  
  [
    [[link cgi.reference.common__io_service_provider.reset [*reset]]]
    []
  ]
  
  [
    [[link cgi.reference.common__io_service_provider.run [*run]]]
    []
  ]
  
  [
    [[link cgi.reference.common__io_service_provider.stop [*stop]]]
    []
  ]
  
]

Contains six member functions: io\_service() - returns a reference to an io\_service stop() - stops all io\_services run() - runs all io\_services reset() - resets all io\_services

(strike) stop\_one() - stops one (running) io\_service (strike) run\_one() - runs one (not-yet-started/reset) io\_service

It can also be set up so that only required io\_services are run: each call to io\_service() can get an io\_service, call io\_service::run() on it and then return it. 


[section:get_io_service common::io_service_provider::get_io_service]

[indexterm2 get_io_service..common::io_service_provider] 

  ::cgi::common::io_service & get_io_service();



[endsect]


[section:io_service_provider common::io_service_provider::io_service_provider]

[indexterm2 io_service_provider..common::io_service_provider] 

  ``[link cgi.reference.common__io_service_provider.io_service_provider.overload1 io_service_provider]``();

  ``[link cgi.reference.common__io_service_provider.io_service_provider.overload2 io_service_provider]``(
      int );


[section:overload1 common::io_service_provider::io_service_provider (1 of 2 overloads)]



  io_service_provider();



[endsect]



[section:overload2 common::io_service_provider::io_service_provider (2 of 2 overloads)]



  io_service_provider(
      int );



[endsect]


[endsect]


[section:reset common::io_service_provider::reset]

[indexterm2 reset..common::io_service_provider] 

  void reset();



[endsect]



[section:run common::io_service_provider::run]

[indexterm2 run..common::io_service_provider] 

  void run();



[endsect]



[section:stop common::io_service_provider::stop]

[indexterm2 stop..common::io_service_provider] 

  void stop();



[endsect]



[endsect]

[section:common__is_async common::is_async]



  template<
      typename Protocol >
  struct is_async



[endsect]

[section:common__is_async_lt__tags__cgi__gt_ common::is_async< tags::cgi >]



  template<>
  struct is_async< tags::cgi >



[endsect]


[section:common__parse_options common::parse_options]

[indexterm1 common::parse_options] 

  enum parse_options

[heading Values]
[variablelist

  [
    [parse_none]
    []
  ]

  [
    [parse_env]
    []
  ]

  [
    [parse_get_only]
    []
  ]

  [
    [parse_get]
    []
  ]

  [
    [parse_post_only]
    []
  ]

  [
    [parse_post]
    []
  ]

  [
    [parse_form]
    []
  ]

  [
    [parse_cookie_only]
    []
  ]

  [
    [parse_cookie]
    []
  ]

  [
    [parse_cookies_only]
    []
  ]

  [
    [parse_cookies]
    []
  ]

  [
    [parse_all]
    []
  ]

]



[endsect]


[section:common__path_info common::path_info]



  struct path_info


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__path_info.const_iterator [*const_iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__path_info.iterator [*iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__path_info.value_type [*value_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__path_info.vector_type [*vector_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__path_info.begin [*begin]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.end [*end]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.operator[] [*operator[]]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.path_info [*path_info]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__path_info.parts [*parts]]]
    []
  ]

  [
    [[link cgi.reference.common__path_info.value [*value]]]
    []
  ]

]

[section:begin common::path_info::begin]

[indexterm2 begin..common::path_info] 

  const_iterator ``[link cgi.reference.common__path_info.begin.overload1 begin]``() const;

  iterator ``[link cgi.reference.common__path_info.begin.overload2 begin]``();


[section:overload1 common::path_info::begin (1 of 2 overloads)]



  const_iterator begin() const;



[endsect]



[section:overload2 common::path_info::begin (2 of 2 overloads)]



  iterator begin();



[endsect]


[endsect]


[section:const_iterator common::path_info::const_iterator]

[indexterm2 const_iterator..common::path_info] 

  typedef vector_type::const_iterator const_iterator;




[endsect]


[section:end common::path_info::end]

[indexterm2 end..common::path_info] 

  const_iterator ``[link cgi.reference.common__path_info.end.overload1 end]``() const;

  iterator ``[link cgi.reference.common__path_info.end.overload2 end]``();


[section:overload1 common::path_info::end (1 of 2 overloads)]



  const_iterator end() const;



[endsect]



[section:overload2 common::path_info::end (2 of 2 overloads)]



  iterator end();



[endsect]


[endsect]


[section:iterator common::path_info::iterator]

[indexterm2 iterator..common::path_info] 

  typedef vector_type::iterator iterator;




[endsect]



[section:operator[] common::path_info::operator[]]

[indexterm2 operator[]..common::path_info] 

  value_type & operator[](
      int i);



[endsect]



[section:parts common::path_info::parts]

[indexterm2 parts..common::path_info] 

  vector_type parts;



[endsect]


[section:path_info common::path_info::path_info]

[indexterm2 path_info..common::path_info] 

  ``[link cgi.reference.common__path_info.path_info.overload1 path_info]``(
      value_type const & str);

  template<
      typename S ,
      typename P ,
      typename A >
  ``[link cgi.reference.common__path_info.path_info.overload2 path_info]``(
      basic_request< S, P, A > & request);


[section:overload1 common::path_info::path_info (1 of 2 overloads)]



  path_info(
      value_type const & str);



[endsect]



[section:overload2 common::path_info::path_info (2 of 2 overloads)]



  template<
      typename S ,
      typename P ,
      typename A >
  path_info(
      basic_request< S, P, A > & request);



[endsect]


[endsect]


[section:value common::path_info::value]

[indexterm2 value..common::path_info] 

  value_type value;



[endsect]



[section:value_type common::path_info::value_type]

[indexterm2 value_type..common::path_info] 

  typedef std::string value_type;




[endsect]



[section:vector_type common::path_info::vector_type]

[indexterm2 vector_type..common::path_info] 

  typedef std::vector< value_type > vector_type;




[endsect]



[endsect]


[section:common__post_data_type common::post_data_type]

[indexterm1 common::post_data_type] 

  enum post_data_type

[heading Values]
[variablelist

  [
    [post]
    []
  ]

  [
    [post_data]
    []
  ]

]



[endsect]


[section:common__request_base common::request_base]

ABC that defines the common interface for basic_request<>s. 

  template<
      typename T>
  class request_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_base__impl_base [*impl_base]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
]

This class provides generic member functions that can be used by any request type. 


[section:is_file common::request_base::is_file]

[indexterm2 is_file..common::request_base] Check if a given POST variable represents a file upload. 

  template<
      typename ImplType >
  bool is_file(
      ImplType & impl,
      typename ImplType::string_type const & key);



[endsect]



[section:load common::request_base::load]

[indexterm2 load..common::request_base] Synchronously read/parse the request meta-data. 

  template<
      typename ImplType >
  boost::system::error_code load(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);



[endsect]



[section:load_environment common::request_base::load_environment]

[indexterm2 load_environment..common::request_base] Load the base_environment into the current environment. 

  template<
      typename ImplType >
  void load_environment(
      ImplType & impl,
      char ** base_environment,
      bool is_command_line);


Parsed the base\_environment and add it to the current request's environment. This overwrites any environment variables with the existing key.

If `is\_command\_line` is true, then the first argument is skipped as this is the name of the program and ignored. Using it actually causes a crash on Windows (MSVC 9) anyway: I'm not exactly sure why. 


[endsect]



[section:parse_cookie_vars common::request_base::parse_cookie_vars]

[indexterm2 parse_cookie_vars..common::request_base] Read and parse the HTTP_COOKIE meta variable. 

  template<
      typename ImplType >
  boost::system::error_code parse_cookie_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_get_vars common::request_base::parse_get_vars]

[indexterm2 parse_get_vars..common::request_base] Read and parse the cgi GET meta variables. 

  template<
      typename ImplType >
  boost::system::error_code parse_get_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]


[section:read_some common::request_base::read_some]

[indexterm2 read_some..common::request_base] Read some data from the client into the supplied buffer. 

  template<
      typename ImplType ,
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.common__request_base.read_some.overload1 read_some]``(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);

  template<
      typename ImplType >
  std::size_t ``[link cgi.reference.common__request_base.read_some.overload2 read_some]``(
      ImplType & impl,
      boost::system::error_code & ec);


[section:overload1 common::request_base::read_some (1 of 2 overloads)]

Read some data from the client into the supplied buffer. 

  template<
      typename ImplType ,
      typename MutableBufferSequence >
  std::size_t read_some(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::request_base::read_some (2 of 2 overloads)]

Read some data into the internal buffer. 

  template<
      typename ImplType >
  std::size_t read_some(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:request_id common::request_base::request_id]

[indexterm2 request_id..common::request_base] Get the request ID of a FastCGI request, or 1. 

  template<
      typename ImplType >
  boost::uint16_t const & request_id(
      ImplType & impl) const;



[endsect]



[endsect]

[section:common__request_base__impl_base common::request_base::impl_base]



  struct impl_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_base__impl_base.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.string_type [*string_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.var_map_type [*var_map_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base__impl_base.impl_base [*impl_base]]]
    [Construct. ]
  ]
  
  [
    [[link cgi.reference.common__request_base__impl_base.prepare [*prepare]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base__impl_base.env_parsed_ [*env_parsed_]]]
    [Whether the environment has been parsed yet. ]
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.form_parts_ [*form_parts_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.get_parsed_ [*get_parsed_]]]
    [Whether the get data has been parsed yet. ]
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.post_buffer_ [*post_buffer_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.vars_ [*vars_]]]
    []
  ]

]


[section:buffer_type common::request_base::impl_base::buffer_type]

[indexterm2 buffer_type..common::request_base::impl_base] 

  typedef string_type buffer_type;




[endsect]



[section:char_type common::request_base::impl_base::char_type]

[indexterm2 char_type..common::request_base::impl_base] 

  typedef char char_type;




[endsect]



[section:const_buffers_type common::request_base::impl_base::const_buffers_type]

[indexterm2 const_buffers_type..common::request_base::impl_base] 

  typedef boost::asio::const_buffers_1 const_buffers_type;




[endsect]



[section:env_parsed_ common::request_base::impl_base::env_parsed_]

[indexterm2 env_parsed_..common::request_base::impl_base] Whether the environment has been parsed yet. 

  bool env_parsed_;



[endsect]



[section:form_parts_ common::request_base::impl_base::form_parts_]

[indexterm2 form_parts_..common::request_base::impl_base] 

  std::vector< common::form_part > form_parts_;



[endsect]



[section:get_parsed_ common::request_base::impl_base::get_parsed_]

[indexterm2 get_parsed_..common::request_base::impl_base] Whether the get data has been parsed yet. 

  bool get_parsed_;



[endsect]



[section:impl_base common::request_base::impl_base::impl_base]

[indexterm2 impl_base..common::request_base::impl_base] Construct. 

  impl_base();



[endsect]



[section:mutable_buffers_type common::request_base::impl_base::mutable_buffers_type]

[indexterm2 mutable_buffers_type..common::request_base::impl_base] 

  typedef boost::asio::mutable_buffers_1 mutable_buffers_type;




[endsect]



[section:post_buffer_ common::request_base::impl_base::post_buffer_]

[indexterm2 post_buffer_..common::request_base::impl_base] 

  buffer_type post_buffer_;



[endsect]



[section:prepare common::request_base::impl_base::prepare]

[indexterm2 prepare..common::request_base::impl_base] 

  mutable_buffers_type prepare(
      std::size_t size);



[endsect]



[section:string_type common::request_base::impl_base::string_type]

[indexterm2 string_type..common::request_base::impl_base] 

  typedef std::basic_string< char_type > string_type;




[endsect]



[section:var_map_type common::request_base::impl_base::var_map_type]

[indexterm2 var_map_type..common::request_base::impl_base] 

  typedef boost::fusion::vector< common::env_map, common::get_map, common::post_map, common::cookie_map, common::session_map > var_map_type;



If you want to add a new data type to a request you need to: > Update this file (just below) > Update source_enums.hpp > Update map.hpp with a new map type > Use the `BOOST\_CGI\_DETAIL\_MAP\_ACCESS` macro in `basic\_request<>`, next to the other uses of it. 


[endsect]



[section:vars_ common::request_base::impl_base::vars_]

[indexterm2 vars_..common::request_base::impl_base] 

  var_map_type vars_;



[endsect]



[endsect]

[section:common__request_service common::request_service]

The generic service class for basic_request<>s. 

  template<
      typename Protocol >
  class request_service


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_service.impl_type [*impl_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_service.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_service.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_service.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_service.async_load [*async_load]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.load [*load]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.null [*null]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.request_service [*request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.set_header [*set_header]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_service.id [*id]]]
    []
  ]

]

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 


[section:async_load common::request_service::async_load]

[indexterm2 async_load..common::request_service] 

  template<
      typename Handler >
  void async_load(
      impl_type & impl,
      bool parse_stdin,
      Handler handler);



[endsect]



[section:construct common::request_service::construct]

[indexterm2 construct..common::request_service] 

  void construct(
      impl_type & impl);



[endsect]



[section:destroy common::request_service::destroy]

[indexterm2 destroy..common::request_service] 

  void destroy(
      impl_type & impl);



[endsect]



[section:id common::request_service::id]

[indexterm2 id..common::request_service] 

  static boost::asio::detail::service_id< request_service< Protocol > > id;



[endsect]



[section:impl_type common::request_service::impl_type]

[indexterm2 impl_type..common::request_service] 

  typedef service_impl_type::impl_type impl_type;




[endsect]



[section:implementation_type common::request_service::implementation_type]

[indexterm2 implementation_type..common::request_service] 

  typedef service_impl_type::implementation_type implementation_type;




[endsect]



[section:is_open common::request_service::is_open]

[indexterm2 is_open..common::request_service] 

  bool is_open(
      impl_type & impl);



[endsect]



[section:load common::request_service::load]

[indexterm2 load..common::request_service] 

  boost::system::error_code & load(
      impl_type & impl,
      bool parse_stdin,
      boost::system::error_code & ec);



[endsect]



[section:null common::request_service::null]

[indexterm2 null..common::request_service] 

  impl_type null() const;



[endsect]



[section:protocol_service_type common::request_service::protocol_service_type]

[indexterm2 protocol_service_type..common::request_service] 

  typedef common::basic_protocol_service< Protocol > protocol_service_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 



[endsect]



[section:protocol_type common::request_service::protocol_type]

[indexterm2 protocol_type..common::request_service] 

  typedef Protocol protocol_type;




[endsect]


[section:request_service common::request_service::request_service]

[indexterm2 request_service..common::request_service] 

  ``[link cgi.reference.common__request_service.request_service.overload1 request_service]``(
      protocol_service_type & ps);

  ``[link cgi.reference.common__request_service.request_service.overload2 request_service]``(
      ::cgi::common::io_service & ios);


[section:overload1 common::request_service::request_service (1 of 2 overloads)]



  request_service(
      protocol_service_type & ps);



[endsect]



[section:overload2 common::request_service::request_service (2 of 2 overloads)]



  request_service(
      ::cgi::common::io_service & ios);



[endsect]


[endsect]


[section:set_header common::request_service::set_header]

[indexterm2 set_header..common::request_service] 

  boost::system::error_code & set_header(
      impl_type & impl,
      const std::string & name,
      const std::string & value,
      boost::system::error_code & ec);



[endsect]



[section:shutdown_service common::request_service::shutdown_service]

[indexterm2 shutdown_service..common::request_service] 

  void shutdown_service();



[endsect]



[endsect]


[section:common__request_status common::request_status]

[indexterm1 common::request_status] 

  enum request_status

[heading Values]
[variablelist

  [
    [null]
    []
  ]

  [
    [unloaded]
    []
  ]

  [
    [activated]
    []
  ]

  [
    [accepted]
    []
  ]

  [
    [env_read]
    []
  ]

  [
    [loaded]
    []
  ]

  [
    [ok]
    []
  ]

  [
    [aborted]
    []
  ]

  [
    [closed]
    []
  ]

]



[endsect]


[section:common__scgi_ common::scgi_]

SCGI (note, this must be removed). 

  struct scgi_



[endsect]


[section:common__session_data_type common::session_data_type]

[indexterm1 common::session_data_type] 

  enum session_data_type

[heading Values]
[variablelist

  [
    [session]
    []
  ]

  [
    [session_data]
    []
  ]

]



[endsect]


[section:common__tags__acgi common::tags::acgi]



  struct acgi



[endsect]

[section:common__tags__async_cgi common::tags::async_cgi]



  struct async_cgi



[endsect]

[section:common__tags__async_stdio common::tags::async_stdio]



  struct async_stdio



[endsect]

[section:common__tags__cgi common::tags::cgi]



  struct cgi



[endsect]

[section:common__tags__fcgi common::tags::fcgi]



  struct fcgi



[endsect]

[section:common__tags__null common::tags::null]



  struct null



[endsect]

[section:common__tags__round_robin common::tags::round_robin]



  struct round_robin



[endsect]

[section:common__tags__scgi common::tags::scgi]



  struct scgi



[endsect]

[section:common__tags__service_pool common::tags::service_pool]



  struct service_pool



[endsect]

[section:common__tags__shareable_tcp_socket common::tags::shareable_tcp_socket]



  struct shareable_tcp_socket



[endsect]

[section:common__tags__single_service common::tags::single_service]



  struct single_service



[endsect]

[section:common__tags__stdio common::tags::stdio]



  struct stdio



[endsect]

[section:common__tags__tcp_socket common::tags::tcp_socket]



  struct tcp_socket



[endsect]

[section:connection_base connection_base]

Abstract Base Class for all connection types. 

  class connection_base


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.connection_base._connection_base [*~connection_base]]]
    []
  ]
  
]


[section:_connection_base connection_base::~connection_base]

[indexterm2 ~connection_base..connection_base] 

  ~connection_base();



[endsect]



[endsect]


[section:connections__async_stdio connections::async_stdio]

[indexterm1 connections::async_stdio] 

  typedef common::basic_connection< common::tags::async_stdio > async_stdio;




[endsect]



[section:connections__shareable_tcp connections::shareable_tcp]

[indexterm1 connections::shareable_tcp] 

  typedef common::basic_connection< common::tags::shareable_tcp_socket > shareable_tcp;




[endsect]



[section:connections__stdio connections::stdio]

[indexterm1 connections::stdio] 

  typedef common::basic_connection< common::tags::stdio > stdio;




[endsect]



[section:connections__tcp connections::tcp]

[indexterm1 connections::tcp] 

  typedef common::basic_connection< common::tags::tcp_socket > tcp;




[endsect]



[section:error__fcgi_errors error::fcgi_errors]

[indexterm1 error::fcgi_errors] 

  enum fcgi_errors

[heading Values]
[variablelist

  [
    [bad_header_type]
    []
  ]

  [
    [bad_request_id]
    [A packet arrived for a request id that doesn't exist and the packet wasn't a BEGIN_REQUEST record. ]
  ]

  [
    [couldnt_write_complete_packet]
    [When trying to write a packet, the client::write_some() call didn't. ]
  ]

  [
    [client_closed]
    []
  ]

  [
    [abort_request_record_recieved_for_invalid_request]
    []
  ]

  [
    [multiplexed_request_incoming]
    []
  ]

  [
    [duplicate_request]
    []
  ]

  [
    [accepting_on_an_open_request]
    []
  ]

  [
    [invalid_socket]
    []
  ]

  [
    [invalid_form_type]
    []
  ]

  [
    [broken_pipe]
    []
  ]

  [
    [bad_read]
    []
  ]

  [
    [bad_write]
    []
  ]

  [
    [client_not_open]
    []
  ]

  [
    [multiplexing_not_supported]
    []
  ]

  [
    [eof]
    []
  ]

]



[endsect]



[section:fcgi__acceptor fcgi::acceptor]

[indexterm1 fcgi::acceptor] Typedef for common usage (FCGI). 

  typedef ::cgi::common::basic_request_acceptor< fcgi_request_acceptor_service<> > acceptor;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_request_acceptor.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.next_layer_type [*next_layer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.port_number_type [*port_number_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.service_type [*service_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request_acceptor.accept [*accept]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.assign [*assign]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.async_accept [*async_accept]]]
    [Asynchronously accept one request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor [*basic_request_acceptor]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.is_open [*is_open]]]
    [Check if the acceptor is open. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.listen [*listen]]]
    [Set the acceptor to listen. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.native [*native]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.open [*open]]]
    [Open the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.protocol_service [*protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor._basic_request_acceptor [*~basic_request_acceptor]]]
    []
  ]
  
]



[endsect]


[section:fcgi__acceptor_service_impl fcgi::acceptor_service_impl]

The service_impl class for FCGI basic_request_acceptor<>s. 

  template<
      typename Protocol_  = ::cgi::common::fcgi_>
  class acceptor_service_impl


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type [*implementation_type]]]
    [The unique service identifier. ]
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl.accept [*accept]]]
    [Accepts one request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.acceptor_service_impl [*acceptor_service_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.assign [*assign]]]
    [Assign an existing native acceptor to a *socket* acceptor. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.async_accept [*async_accept]]]
    [Asynchronously accepts one request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.check_for_waiting_request [*check_for_waiting_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.close [*close]]]
    [Close the acceptor (not implemented yet). ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.default_init [*default_init]]]
    [Default-initialize the acceptor. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.get_protocol_service [*get_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.is_open [*is_open]]]
    [Check if the given implementation is open. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.listen [*listen]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.native [*native]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.open [*open]]]
    [Open a new *socket* acceptor implementation. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.service [*service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl.acceptor_service_ [*acceptor_service_]]]
    [The underlying socket acceptor service. ]
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl.id [*id]]]
    []
  ]

]

Note: this is near enough to being generic. It will hopefully translate directly to the fcgi\_acceptor\_service\_impl. In other words you would then have one acceptor\_service\_impl<>, so you'd use acceptor\_service\_impl<scgi> acceptor\_service\_impl\_; // and acceptor\_service\_impl<fcgi> acceptor\_service\_impl\_; // etc...

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 


[section:accept fcgi::acceptor_service_impl::accept]

[indexterm2 accept..fcgi::acceptor_service_impl] Accepts one request. 

  template<
      typename CommonGatewayRequest >
  boost::system::error_code accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      endpoint_type * endpoint,
      boost::system::error_code & ec);



[endsect]



[section:acceptor_service_ fcgi::acceptor_service_impl::acceptor_service_]

[indexterm2 acceptor_service_..fcgi::acceptor_service_impl] The underlying socket acceptor service. 

  acceptor_service_type & acceptor_service_;



[endsect]



[section:acceptor_service_impl fcgi::acceptor_service_impl::acceptor_service_impl]

[indexterm2 acceptor_service_impl..fcgi::acceptor_service_impl] 

  acceptor_service_impl(
      ::cgi::common::io_service & ios);



[endsect]



[section:acceptor_service_type fcgi::acceptor_service_impl::acceptor_service_type]

[indexterm2 acceptor_service_type..fcgi::acceptor_service_impl] 

  typedef type::implementation_type::acceptor_service_type acceptor_service_type;




[endsect]



[section:assign fcgi::acceptor_service_impl::assign]

[indexterm2 assign..fcgi::acceptor_service_impl] Assign an existing native acceptor to a *socket* acceptor. 

  boost::system::error_code assign(
      implementation_type & impl,
      const native_protocol_type & protocol,
      const native_type & native_acceptor,
      boost::system::error_code & ec);



[endsect]



[section:async_accept fcgi::acceptor_service_impl::async_accept]

[indexterm2 async_accept..fcgi::acceptor_service_impl] Asynchronously accepts one request. 

  template<
      typename Handler >
  void async_accept(
      implementation_type & impl,
      typename implementation_type::request_type & request,
      Handler handler);



[endsect]



[section:bind fcgi::acceptor_service_impl::bind]

[indexterm2 bind..fcgi::acceptor_service_impl] 

  template<
      typename Endpoint >
  boost::system::error_code bind(
      implementation_type & impl,
      const Endpoint & endpoint,
      boost::system::error_code & ec);



[endsect]



[section:check_for_waiting_request fcgi::acceptor_service_impl::check_for_waiting_request]

[indexterm2 check_for_waiting_request..fcgi::acceptor_service_impl] 

  template<
      typename CommonGatewayRequest ,
      typename Handler >
  int check_for_waiting_request(
      implementation_type & impl,
      CommonGatewayRequest & request,
      Handler handler);



[endsect]



[section:close fcgi::acceptor_service_impl::close]

[indexterm2 close..fcgi::acceptor_service_impl] Close the acceptor (not implemented yet). 

  boost::system::error_code close(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:construct fcgi::acceptor_service_impl::construct]

[indexterm2 construct..fcgi::acceptor_service_impl] 

  void construct(
      implementation_type & impl);



[endsect]



[section:default_init fcgi::acceptor_service_impl::default_init]

[indexterm2 default_init..fcgi::acceptor_service_impl] Default-initialize the acceptor. 

  boost::system::error_code default_init(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:destroy fcgi::acceptor_service_impl::destroy]

[indexterm2 destroy..fcgi::acceptor_service_impl] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:endpoint_type fcgi::acceptor_service_impl::endpoint_type]

[indexterm2 endpoint_type..fcgi::acceptor_service_impl] 

  typedef type::implementation_type::endpoint_type endpoint_type;




[endsect]



[section:get_protocol_service fcgi::acceptor_service_impl::get_protocol_service]

[indexterm2 get_protocol_service..fcgi::acceptor_service_impl] 

  protocol_service_type & get_protocol_service(
      implementation_type & impl);



[endsect]



[section:id fcgi::acceptor_service_impl::id]

[indexterm2 id..fcgi::acceptor_service_impl] 

  static boost::asio::detail::service_id< ::cgi::fcgi::acceptor_service_impl< Protocol_ > > id;



[endsect]



[section:is_cgi fcgi::acceptor_service_impl::is_cgi]

[indexterm2 is_cgi..fcgi::acceptor_service_impl] 

  bool is_cgi(
      implementation_type & impl);



[endsect]



[section:is_open fcgi::acceptor_service_impl::is_open]

[indexterm2 is_open..fcgi::acceptor_service_impl] Check if the given implementation is open. 

  bool is_open(
      implementation_type & impl);



[endsect]



[section:listen fcgi::acceptor_service_impl::listen]

[indexterm2 listen..fcgi::acceptor_service_impl] 

  boost::system::error_code listen(
      implementation_type & impl,
      int backlog,
      boost::system::error_code & ec);



[endsect]



[section:local_endpoint fcgi::acceptor_service_impl::local_endpoint]

[indexterm2 local_endpoint..fcgi::acceptor_service_impl] 

  implementation_type::endpoint_type local_endpoint(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:native fcgi::acceptor_service_impl::native]

[indexterm2 native..fcgi::acceptor_service_impl] 

  native_type native(
      implementation_type & impl);



[endsect]



[section:native_protocol_type fcgi::acceptor_service_impl::native_protocol_type]

[indexterm2 native_protocol_type..fcgi::acceptor_service_impl] 

  typedef type::implementation_type::native_protocol_type native_protocol_type;




[endsect]



[section:native_type fcgi::acceptor_service_impl::native_type]

[indexterm2 native_type..fcgi::acceptor_service_impl] 

  typedef acceptor_service_type::native_type native_type;




[endsect]



[section:open fcgi::acceptor_service_impl::open]

[indexterm2 open..fcgi::acceptor_service_impl] Open a new *socket* acceptor implementation. 

  boost::system::error_code open(
      implementation_type & impl,
      const native_protocol_type & protocol,
      boost::system::error_code & ec);



[endsect]



[section:protocol_service_type fcgi::acceptor_service_impl::protocol_service_type]

[indexterm2 protocol_service_type..fcgi::acceptor_service_impl] 

  typedef type::implementation_type::protocol_service_type protocol_service_type;




[endsect]



[section:protocol_type fcgi::acceptor_service_impl::protocol_type]

[indexterm2 protocol_type..fcgi::acceptor_service_impl] 

  typedef type::implementation_type::protocol_type protocol_type;




[endsect]



[section:service fcgi::acceptor_service_impl::service]

[indexterm2 service..fcgi::acceptor_service_impl] 

  protocol_service_type & service(
      implementation_type const & impl) const;



[endsect]



[section:set_protocol_service fcgi::acceptor_service_impl::set_protocol_service]

[indexterm2 set_protocol_service..fcgi::acceptor_service_impl] 

  void set_protocol_service(
      implementation_type & impl,
      protocol_service_type & ps);



[endsect]



[section:shutdown_service fcgi::acceptor_service_impl::shutdown_service]

[indexterm2 shutdown_service..fcgi::acceptor_service_impl] 

  void shutdown_service();



[endsect]



[section:type fcgi::acceptor_service_impl::type]

[indexterm2 type..fcgi::acceptor_service_impl] 

  typedef acceptor_service_impl< Protocol_ > type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type [*implementation_type]]]
    [The unique service identifier. ]
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl.accept [*accept]]]
    [Accepts one request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.acceptor_service_impl [*acceptor_service_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.assign [*assign]]]
    [Assign an existing native acceptor to a *socket* acceptor. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.async_accept [*async_accept]]]
    [Asynchronously accepts one request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.check_for_waiting_request [*check_for_waiting_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.close [*close]]]
    [Close the acceptor (not implemented yet). ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.default_init [*default_init]]]
    [Default-initialize the acceptor. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.get_protocol_service [*get_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.is_open [*is_open]]]
    [Check if the given implementation is open. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.listen [*listen]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.native [*native]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.open [*open]]]
    [Open a new *socket* acceptor implementation. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.service [*service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl.acceptor_service_ [*acceptor_service_]]]
    [The underlying socket acceptor service. ]
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl.id [*id]]]
    []
  ]

]

Note: this is near enough to being generic. It will hopefully translate directly to the fcgi\_acceptor\_service\_impl. In other words you would then have one acceptor\_service\_impl<>, so you'd use acceptor\_service\_impl<scgi> acceptor\_service\_impl\_; // and acceptor\_service\_impl<fcgi> acceptor\_service\_impl\_; // etc...

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 



[endsect]



[endsect]

[section:fcgi__acceptor_service_impl__implementation_type fcgi::acceptor_service_impl::implementation_type]

The unique service identifier. 

  struct implementation_type


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.port_number_type [*port_number_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.request_type [*request_type]]]
    []
  
  ]

]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.acceptor_ [*acceptor_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.endpoint_ [*endpoint_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.mutex_ [*mutex_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.port_num_ [*port_num_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.service_ [*service_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.waiting_requests_ [*waiting_requests_]]]
    []
  ]

]


[section:acceptor_ fcgi::acceptor_service_impl::implementation_type::acceptor_]

[indexterm2 acceptor_..fcgi::acceptor_service_impl::implementation_type] 

  acceptor_service_type::implementation_type acceptor_;



[endsect]



[section:acceptor_service_type fcgi::acceptor_service_impl::implementation_type::acceptor_service_type]

[indexterm2 acceptor_service_type..fcgi::acceptor_service_impl::implementation_type] 

  typedef boost::asio::socket_acceptor_service< native_protocol_type > acceptor_service_type;




[endsect]



[section:endpoint_ fcgi::acceptor_service_impl::implementation_type::endpoint_]

[indexterm2 endpoint_..fcgi::acceptor_service_impl::implementation_type] 

  endpoint_type endpoint_;



[endsect]



[section:endpoint_type fcgi::acceptor_service_impl::implementation_type::endpoint_type]

[indexterm2 endpoint_type..fcgi::acceptor_service_impl::implementation_type] 

  typedef boost::asio::ip::tcp::endpoint endpoint_type;




[endsect]



[section:mutex_ fcgi::acceptor_service_impl::implementation_type::mutex_]

[indexterm2 mutex_..fcgi::acceptor_service_impl::implementation_type] 

  boost::mutex mutex_;



[endsect]



[section:native_protocol_type fcgi::acceptor_service_impl::implementation_type::native_protocol_type]

[indexterm2 native_protocol_type..fcgi::acceptor_service_impl::implementation_type] 

  typedef boost::asio::ip::tcp native_protocol_type;




[endsect]



[section:port_num_ fcgi::acceptor_service_impl::implementation_type::port_num_]

[indexterm2 port_num_..fcgi::acceptor_service_impl::implementation_type] 

  port_number_type port_num_;



[endsect]



[section:port_number_type fcgi::acceptor_service_impl::implementation_type::port_number_type]

[indexterm2 port_number_type..fcgi::acceptor_service_impl::implementation_type] 

  typedef unsigned short port_number_type;




[endsect]



[section:protocol_service_type fcgi::acceptor_service_impl::implementation_type::protocol_service_type]

[indexterm2 protocol_service_type..fcgi::acceptor_service_impl::implementation_type] 

  typedef common::basic_protocol_service< protocol_type > protocol_service_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 



[endsect]



[section:protocol_type fcgi::acceptor_service_impl::implementation_type::protocol_type]

[indexterm2 protocol_type..fcgi::acceptor_service_impl::implementation_type] 

  typedef Protocol_ protocol_type;




[endsect]



[section:request_type fcgi::acceptor_service_impl::implementation_type::request_type]

[indexterm2 request_type..fcgi::acceptor_service_impl::implementation_type] 

  typedef fcgi::request request_type;




[endsect]



[section:service_ fcgi::acceptor_service_impl::implementation_type::service_]

[indexterm2 service_..fcgi::acceptor_service_impl::implementation_type] 

  protocol_service_type * service_;



[endsect]



[section:waiting_requests_ fcgi::acceptor_service_impl::implementation_type::waiting_requests_]

[indexterm2 waiting_requests_..fcgi::acceptor_service_impl::implementation_type] 

  std::queue< boost::shared_ptr< request_type > > waiting_requests_;



[endsect]



[endsect]


[section:fcgi__client fcgi::client]

[indexterm1 fcgi::client] 

  typedef common::basic_client< connections::shareable_tcp,::cgi::common::fcgi_ > client;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_client.connection_ptr [*connection_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.async_read_some [*async_read_some]]]
    [Asynchronously read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.async_write_some [*async_write_some]]]
    [Asynchronously write some data to the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.basic_client [*basic_client]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.bytes_left [*bytes_left]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.connection [*connection]]]
    [Get a shared_ptr of the connection associated with the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.read_some [*read_some]]]
    [Read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.set_connection [*set_connection]]]
    [Associate a connection with this client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.write_some [*write_some]]]
    [Write some data to the client. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.bytes_left_ [*bytes_left_]]]
    []
  ]

]

A client is for two things: 1. To hold a full-duplex connection (or separate input and output connections). 2. To hold any protocol-specific data about the request. For now, this means the internal 'request number' associated by FastCGI with each request (ie. so incoming/outgoing packets can be wrapped with data noting what request it relates to). 3. Buffering. Not sure about how far this should go yet, but probably no further than minimal buffering. 4. Share a connection. Since a multiplexing connection is shared between multiple clients, the client should be responsible for taking possesion of the connection for a period of time (so it can write a complete packet). This idea could be taken quite far into genericity by making clients aware of how busy the connection is and size its output packets accordingly... But I'm not doing that. 



[endsect]


[section:fcgi__fcgi_request_service fcgi::fcgi_request_service]

The IoObjectService class for a FCGI basic_request<>s. 

  class fcgi_request_service :
    public common::request_base< fcgi_request_service >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__callback_functor [*callback_functor]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type [*implementation_type]]]
    [The actual implementation date for an FCGI request. ]
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.full_type [*full_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.proc_func_t [*proc_func_t]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.async_load [*async_load]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.begin_request_helper [*begin_request_helper]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.clear [*clear]]]
    [Clear all request data (object is then safe to remove). ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.client [*client]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.close [*close]]]
    [Close the request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.fcgi_request_service [*fcgi_request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.handle_admin_request [*handle_admin_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.handle_other_request_header [*handle_other_request_header]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.params_read [*params_read]]]
    [Returns true if the request environment params have been read. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_body [*parse_body]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_header [*parse_header]]]
    [Parse the current header. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_packet [*parse_packet]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_abort_request [*process_abort_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_begin_request [*process_begin_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_params [*process_params]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_stdin [*process_stdin]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_body [*read_body]]]
    [Read the body of the current packet; do nothing with it. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_env_vars [*read_env_vars]]]
    [Read in the FastCGI (env) params. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_header [*read_header]]]
    [Read a single header, buf do nothing with it. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.set_service [*set_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.set_status [*set_status]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service._fcgi_request_service [*~fcgi_request_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_one_post_var [*parse_one_post_var]]]
    [Read and parse a single cgi POST meta variable (greedily). ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.id [*id]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.proc_funcs [*proc_funcs]]]
    []
  ]

]


[section:async_load fcgi::fcgi_request_service::async_load]

[indexterm2 async_load..fcgi::fcgi_request_service] 

  template<
      typename Handler >
  void async_load(
      implementation_type & impl,
      bool parse_stdin,
      Handler handler);



[endsect]



[section:clear fcgi::fcgi_request_service::clear]

[indexterm2 clear..fcgi::fcgi_request_service] Clear all request data (object is then safe to remove). 

  void clear(
      implementation_type & impl);



[endsect]



[section:client fcgi::fcgi_request_service::client]

[indexterm2 client..fcgi::fcgi_request_service] 

  implementation_type::client_type & client(
      implementation_type & impl);



[endsect]


[section:close fcgi::fcgi_request_service::close]

[indexterm2 close..fcgi::fcgi_request_service] Close the request. 

  int ``[link cgi.reference.fcgi__fcgi_request_service.close.overload1 close]``(
      implementation_type & impl,
      ::cgi::common::http::status_code & hsc,
      int program_status,
      boost::system::error_code & ec);

  int ``[link cgi.reference.fcgi__fcgi_request_service.close.overload2 close]``(
      implementation_type & impl,
      ::cgi::common::http::status_code & hsc,
      int program_status);


[section:overload1 fcgi::fcgi_request_service::close (1 of 2 overloads)]

Close the request. 

  int close(
      implementation_type & impl,
      ::cgi::common::http::status_code & hsc,
      int program_status,
      boost::system::error_code & ec);



[endsect]



[section:overload2 fcgi::fcgi_request_service::close (2 of 2 overloads)]

Close the request. 

  int close(
      implementation_type & impl,
      ::cgi::common::http::status_code & hsc,
      int program_status);



[endsect]


[endsect]


[section:construct fcgi::fcgi_request_service::construct]

[indexterm2 construct..fcgi::fcgi_request_service] 

  void construct(
      implementation_type & impl);



[endsect]



[section:destroy fcgi::fcgi_request_service::destroy]

[indexterm2 destroy..fcgi::fcgi_request_service] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:fcgi_request_service fcgi::fcgi_request_service::fcgi_request_service]

[indexterm2 fcgi_request_service..fcgi::fcgi_request_service] 

  fcgi_request_service(
      ::cgi::common::io_service & ios);



[endsect]



[section:full_type fcgi::fcgi_request_service::full_type]

[indexterm2 full_type..fcgi::fcgi_request_service] 

  typedef fcgi_request_service full_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__callback_functor [*callback_functor]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type [*implementation_type]]]
    [The actual implementation date for an FCGI request. ]
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.full_type [*full_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.proc_func_t [*proc_func_t]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.async_load [*async_load]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.begin_request_helper [*begin_request_helper]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.clear [*clear]]]
    [Clear all request data (object is then safe to remove). ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.client [*client]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.close [*close]]]
    [Close the request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.fcgi_request_service [*fcgi_request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.handle_admin_request [*handle_admin_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.handle_other_request_header [*handle_other_request_header]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.params_read [*params_read]]]
    [Returns true if the request environment params have been read. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_body [*parse_body]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_header [*parse_header]]]
    [Parse the current header. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_packet [*parse_packet]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_abort_request [*process_abort_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_begin_request [*process_begin_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_params [*process_params]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_stdin [*process_stdin]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_body [*read_body]]]
    [Read the body of the current packet; do nothing with it. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_env_vars [*read_env_vars]]]
    [Read in the FastCGI (env) params. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_header [*read_header]]]
    [Read a single header, buf do nothing with it. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.set_service [*set_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.set_status [*set_status]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service._fcgi_request_service [*~fcgi_request_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_one_post_var [*parse_one_post_var]]]
    [Read and parse a single cgi POST meta variable (greedily). ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.id [*id]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.proc_funcs [*proc_funcs]]]
    []
  ]

]



[endsect]



[section:get_role fcgi::fcgi_request_service::get_role]

[indexterm2 get_role..fcgi::fcgi_request_service] 

  role_type get_role(
      implementation_type & impl);



[endsect]



[section:handle_admin_request fcgi::fcgi_request_service::handle_admin_request]

[indexterm2 handle_admin_request..fcgi::fcgi_request_service] 

  void handle_admin_request(
      implementation_type & impl);



[endsect]



[section:handle_other_request_header fcgi::fcgi_request_service::handle_other_request_header]

[indexterm2 handle_other_request_header..fcgi::fcgi_request_service] 

  void handle_other_request_header(
      implementation_type & impl);



[endsect]



[section:id fcgi::fcgi_request_service::id]

[indexterm2 id..fcgi::fcgi_request_service] 

  static boost::asio::detail::service_id< fcgi_request_service > id;



[endsect]



[section:is_file fcgi::fcgi_request_service::is_file]


['Inherited from common::request_base.]

[indexterm2 is_file..fcgi::fcgi_request_service] Check if a given POST variable represents a file upload. 

  bool is_file(
      ImplType & impl,
      typename ImplType::string_type const & key);



[endsect]



[section:is_open fcgi::fcgi_request_service::is_open]

[indexterm2 is_open..fcgi::fcgi_request_service] 

  bool is_open(
      implementation_type & impl);



[endsect]


[section:load fcgi::fcgi_request_service::load]

[indexterm2 load..fcgi::fcgi_request_service] Synchronously read/parse the request meta-data. 

  boost::system::error_code ``[link cgi.reference.fcgi__fcgi_request_service.load.overload1 load]``(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);

  boost::system::error_code ``[link cgi.reference.fcgi__fcgi_request_service.load.overload2 load]``(
      implementation_type & impl,
      common::parse_options opts,
      boost::system::error_code & ec);


[section:overload1 fcgi::fcgi_request_service::load (1 of 2 overloads)]


['Inherited from common::request_base.]

Synchronously read/parse the request meta-data. 

  boost::system::error_code load(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);



[endsect]



[section:overload2 fcgi::fcgi_request_service::load (2 of 2 overloads)]

Load the request to a point where it can be usefully used. 

  boost::system::error_code load(
      implementation_type & impl,
      common::parse_options opts,
      boost::system::error_code & ec);


FastCGI: --------


* Calls client::construct() to claim a request id from the server.

* Reads, parses and handles all packets until the closing `PARAMS` packet for this request arrives from the server. 



[endsect]


[endsect]


[section:load_environment fcgi::fcgi_request_service::load_environment]


['Inherited from common::request_base.]

[indexterm2 load_environment..fcgi::fcgi_request_service] Load the base_environment into the current environment. 

  void load_environment(
      ImplType & impl,
      char ** base_environment,
      bool is_command_line);


Parsed the base\_environment and add it to the current request's environment. This overwrites any environment variables with the existing key.

If `is\_command\_line` is true, then the first argument is skipped as this is the name of the program and ignored. Using it actually causes a crash on Windows (MSVC 9) anyway: I'm not exactly sure why. 


[endsect]



[section:params_read fcgi::fcgi_request_service::params_read]

[indexterm2 params_read..fcgi::fcgi_request_service] Returns true if the request environment params have been read. 

  bool params_read(
      implementation_type & impl);


Check if the params have been read (ie. FCGI\_PARAMS packets). 


[endsect]



[section:parse_body fcgi::fcgi_request_service::parse_body]

[indexterm2 parse_body..fcgi::fcgi_request_service] 

  template<
      typename MutableBuffersType >
  boost::system::error_code parse_body(
      implementation_type & impl,
      const MutableBuffersType & buffer,
      boost::system::error_code & ec);



[endsect]



[section:parse_cookie_vars fcgi::fcgi_request_service::parse_cookie_vars]


['Inherited from common::request_base.]

[indexterm2 parse_cookie_vars..fcgi::fcgi_request_service] Read and parse the HTTP_COOKIE meta variable. 

  boost::system::error_code parse_cookie_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_get_vars fcgi::fcgi_request_service::parse_get_vars]


['Inherited from common::request_base.]

[indexterm2 parse_get_vars..fcgi::fcgi_request_service] Read and parse the cgi GET meta variables. 

  boost::system::error_code parse_get_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_header fcgi::fcgi_request_service::parse_header]

[indexterm2 parse_header..fcgi::fcgi_request_service] Parse the current header. 

  boost::tribool parse_header(
      implementation_type & impl);



[endsect]



[section:parse_one_post_var fcgi::fcgi_request_service::parse_one_post_var]

[indexterm2 parse_one_post_var..fcgi::fcgi_request_service] Read and parse a single cgi POST meta variable (greedily). 

  template<
      typename RequestImpl >
  boost::system::error_code & parse_one_post_var(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_packet fcgi::fcgi_request_service::parse_packet]

[indexterm2 parse_packet..fcgi::fcgi_request_service] 

  boost::system::error_code parse_packet(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_post_vars fcgi::fcgi_request_service::parse_post_vars]

[indexterm2 parse_post_vars..fcgi::fcgi_request_service] Read and parse the cgi POST meta variables (greedily). 

  boost::system::error_code & parse_post_vars(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:proc_func_t fcgi::fcgi_request_service::proc_func_t]

[indexterm2 proc_func_t..fcgi::fcgi_request_service] 

  typedef boost::system::error_code(full_type::* proc_func_t;




[endsect]



[section:proc_funcs fcgi::fcgi_request_service::proc_funcs]

[indexterm2 proc_funcs..fcgi::fcgi_request_service] 

  static const proc_func_t proc_funcs =
    { 0
    , &fcgi_request_service::process_begin_request
    , &fcgi_request_service::process_abort_request
    , 0
    , &fcgi_request_service::process_params
    , &fcgi_request_service::process_stdin
    , 0
    , 0
    };



[endsect]



[section:process_abort_request fcgi::fcgi_request_service::process_abort_request]

[indexterm2 process_abort_request..fcgi::fcgi_request_service] 

  boost::system::error_code process_abort_request(
      implementation_type & impl,
      boost::uint16_t id,
      const unsigned char * buf,
      boost::uint32_t ,
      boost::system::error_code & ec);



[endsect]



[section:process_begin_request fcgi::fcgi_request_service::process_begin_request]

[indexterm2 process_begin_request..fcgi::fcgi_request_service] 

  boost::system::error_code process_begin_request(
      implementation_type & impl,
      boost::uint16_t id,
      const unsigned char * buf,
      boost::uint32_t ,
      boost::system::error_code & ec);



[endsect]



[section:process_params fcgi::fcgi_request_service::process_params]

[indexterm2 process_params..fcgi::fcgi_request_service] 

  boost::system::error_code process_params(
      implementation_type & impl,
      boost::uint16_t id,
      const unsigned char * buf,
      boost::uint32_t len,
      boost::system::error_code & ec);



[endsect]



[section:process_stdin fcgi::fcgi_request_service::process_stdin]

[indexterm2 process_stdin..fcgi::fcgi_request_service] 

  boost::system::error_code process_stdin(
      implementation_type & impl,
      boost::uint16_t id,
      const unsigned char * buf,
      boost::uint32_t len,
      boost::system::error_code & ec);



[endsect]



[section:protocol_type fcgi::fcgi_request_service::protocol_type]

[indexterm2 protocol_type..fcgi::fcgi_request_service] 

  typedef self_type::implementation_type::protocol_type protocol_type;




[endsect]



[section:read_body fcgi::fcgi_request_service::read_body]

[indexterm2 read_body..fcgi::fcgi_request_service] Read the body of the current packet; do nothing with it. 

  template<
      typename MutableBuffersType >
  boost::system::error_code read_body(
      implementation_type & impl,
      const MutableBuffersType & buffer,
      boost::system::error_code & ec);



[endsect]



[section:read_env_vars fcgi::fcgi_request_service::read_env_vars]

[indexterm2 read_env_vars..fcgi::fcgi_request_service] Read in the FastCGI (env) params. 

  boost::system::error_code read_env_vars(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:read_header fcgi::fcgi_request_service::read_header]

[indexterm2 read_header..fcgi::fcgi_request_service] Read a single header, buf do nothing with it. 

  boost::system::error_code read_header(
      implementation_type & impl,
      boost::system::error_code & ec);


Read a single header, but do nothing with it. 


[endsect]


[section:read_some fcgi::fcgi_request_service::read_some]

[indexterm2 read_some..fcgi::fcgi_request_service] Read some data from the client into the supplied buffer. 

  std::size_t ``[link cgi.reference.fcgi__fcgi_request_service.read_some.overload1 read_some]``(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);

  std::size_t ``[link cgi.reference.fcgi__fcgi_request_service.read_some.overload2 read_some]``(
      ImplType & impl,
      boost::system::error_code & ec);

  template<
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.fcgi__fcgi_request_service.read_some.overload3 read_some]``(
      implementation_type & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);

  std::size_t ``[link cgi.reference.fcgi__fcgi_request_service.read_some.overload4 read_some]``(
      implementation_type & impl,
      boost::system::error_code & ec);


[section:overload1 fcgi::fcgi_request_service::read_some (1 of 4 overloads)]


['Inherited from common::request_base.]

Read some data from the client into the supplied buffer. 

  std::size_t read_some(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 fcgi::fcgi_request_service::read_some (2 of 4 overloads)]


['Inherited from common::request_base.]

Read some data into the internal buffer. 

  std::size_t read_some(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:overload3 fcgi::fcgi_request_service::read_some (3 of 4 overloads)]

Read some data from the client into the supplied buffer. 

  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      implementation_type & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);


Read some data from the client. 


[endsect]



[section:overload4 fcgi::fcgi_request_service::read_some (4 of 4 overloads)]

Read some data from the client into the internal buffer. 

  std::size_t read_some(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:request_id fcgi::fcgi_request_service::request_id]


['Inherited from common::request_base.]

[indexterm2 request_id..fcgi::fcgi_request_service] Get the request ID of a FastCGI request, or 1. 

  boost::uint16_t const & request_id(
      ImplType & impl) const;



[endsect]



[section:request_type fcgi::fcgi_request_service::request_type]

[indexterm2 request_type..fcgi::fcgi_request_service] 

  typedef self_type::implementation_type::request_type request_type;




[endsect]



[section:self_type fcgi::fcgi_request_service::self_type]

[indexterm2 self_type..fcgi::fcgi_request_service] 

  typedef fcgi_request_service self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__callback_functor [*callback_functor]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type [*implementation_type]]]
    [The actual implementation date for an FCGI request. ]
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.full_type [*full_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.proc_func_t [*proc_func_t]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.async_load [*async_load]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.begin_request_helper [*begin_request_helper]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.clear [*clear]]]
    [Clear all request data (object is then safe to remove). ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.client [*client]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.close [*close]]]
    [Close the request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.fcgi_request_service [*fcgi_request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.handle_admin_request [*handle_admin_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.handle_other_request_header [*handle_other_request_header]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.params_read [*params_read]]]
    [Returns true if the request environment params have been read. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_body [*parse_body]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_header [*parse_header]]]
    [Parse the current header. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_packet [*parse_packet]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_abort_request [*process_abort_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_begin_request [*process_begin_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_params [*process_params]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_stdin [*process_stdin]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_body [*read_body]]]
    [Read the body of the current packet; do nothing with it. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_env_vars [*read_env_vars]]]
    [Read in the FastCGI (env) params. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_header [*read_header]]]
    [Read a single header, buf do nothing with it. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.set_service [*set_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.set_status [*set_status]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service._fcgi_request_service [*~fcgi_request_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_one_post_var [*parse_one_post_var]]]
    [Read and parse a single cgi POST meta variable (greedily). ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.id [*id]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.proc_funcs [*proc_funcs]]]
    []
  ]

]



[endsect]



[section:set_service fcgi::fcgi_request_service::set_service]

[indexterm2 set_service..fcgi::fcgi_request_service] 

  void set_service(
      implementation_type & impl,
      implementation_type::protocol_service_type & ps);



[endsect]



[section:set_status fcgi::fcgi_request_service::set_status]

[indexterm2 set_status..fcgi::fcgi_request_service] 

  void set_status(
      implementation_type & impl,
      common::request_status status);



[endsect]



[section:shutdown_service fcgi::fcgi_request_service::shutdown_service]

[indexterm2 shutdown_service..fcgi::fcgi_request_service] 

  void shutdown_service();



[endsect]



[section:string_type fcgi::fcgi_request_service::string_type]

[indexterm2 string_type..fcgi::fcgi_request_service] 

  typedef self_type::implementation_type::string_type string_type;




[endsect]



[section:_fcgi_request_service fcgi::fcgi_request_service::~fcgi_request_service]

[indexterm2 ~fcgi_request_service..fcgi::fcgi_request_service] 

  ~fcgi_request_service();



[endsect]



[endsect]

[section:fcgi__fcgi_request_service__callback_functor fcgi::fcgi_request_service::callback_functor]



  template<
      typename Service >
  struct callback_functor


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__callback_functor.callback_functor [*callback_functor]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service__callback_functor.operator() [*operator()]]]
    []
  ]
  
]


[section:callback_functor fcgi::fcgi_request_service::callback_functor::callback_functor]

[indexterm2 callback_functor..fcgi::fcgi_request_service::callback_functor] 

  callback_functor(
      implementation_type & impl,
      Service * service);



[endsect]



[section:operator() fcgi::fcgi_request_service::callback_functor::operator()]

[indexterm2 operator()..fcgi::fcgi_request_service::callback_functor] 

  std::size_t operator()(
      boost::system::error_code & ec);



[endsect]



[endsect]

[section:fcgi__fcgi_request_service__implementation_type fcgi::fcgi_request_service::implementation_type]

The actual implementation date for an FCGI request. 

  struct implementation_type :
    public common::request_base< T >::impl_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.form_parser_type [*form_parser_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.header_buffer_type [*header_buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.header_type [*header_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.string_type [*string_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.var_map_type [*var_map_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.implementation_type [*implementation_type]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.prepare [*prepare]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.prepare_misc [*prepare_misc]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.all_done_ [*all_done_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.characters_left_ [*characters_left_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.client_ [*client_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.env_parsed_ [*env_parsed_]]]
    [Whether the environment has been parsed yet. ]
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.form_parts_ [*form_parts_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.fp_ [*fp_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.get_parsed_ [*get_parsed_]]]
    [Whether the get data has been parsed yet. ]
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.header_ [*header_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.header_buf_ [*header_buf_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.id_ [*id_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.param_buffer_ [*param_buffer_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.post_buffer_ [*post_buffer_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.request_role_ [*request_role_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.request_status_ [*request_status_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.service_ [*service_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.stdin_parsed_ [*stdin_parsed_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type.vars_ [*vars_]]]
    []
  ]

]


[section:all_done_ fcgi::fcgi_request_service::implementation_type::all_done_]

[indexterm2 all_done_..fcgi::fcgi_request_service::implementation_type] 

  bool all_done_;



[endsect]



[section:buffer_type fcgi::fcgi_request_service::implementation_type::buffer_type]


['Inherited from common::request_base::impl_base.]

[indexterm2 buffer_type..fcgi::fcgi_request_service::implementation_type] 

  typedef string_type buffer_type;




[endsect]



[section:char_type fcgi::fcgi_request_service::implementation_type::char_type]


['Inherited from common::request_base::impl_base.]

[indexterm2 char_type..fcgi::fcgi_request_service::implementation_type] 

  typedef char char_type;




[endsect]



[section:characters_left_ fcgi::fcgi_request_service::implementation_type::characters_left_]

[indexterm2 characters_left_..fcgi::fcgi_request_service::implementation_type] 

  std::size_t characters_left_;



[endsect]



[section:client_ fcgi::fcgi_request_service::implementation_type::client_]

[indexterm2 client_..fcgi::fcgi_request_service::implementation_type] 

  client_type client_;



[endsect]



[section:client_type fcgi::fcgi_request_service::implementation_type::client_type]

[indexterm2 client_type..fcgi::fcgi_request_service::implementation_type] 

  typedef ::cgi::fcgi::client client_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_client.connection_ptr [*connection_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.async_read_some [*async_read_some]]]
    [Asynchronously read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.async_write_some [*async_write_some]]]
    [Asynchronously write some data to the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.basic_client [*basic_client]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.bytes_left [*bytes_left]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.connection [*connection]]]
    [Get a shared_ptr of the connection associated with the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.read_some [*read_some]]]
    [Read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.set_connection [*set_connection]]]
    [Associate a connection with this client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.write_some [*write_some]]]
    [Write some data to the client. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.bytes_left_ [*bytes_left_]]]
    []
  ]

]

A client is for two things: 1. To hold a full-duplex connection (or separate input and output connections). 2. To hold any protocol-specific data about the request. For now, this means the internal 'request number' associated by FastCGI with each request (ie. so incoming/outgoing packets can be wrapped with data noting what request it relates to). 3. Buffering. Not sure about how far this should go yet, but probably no further than minimal buffering. 4. Share a connection. Since a multiplexing connection is shared between multiple clients, the client should be responsible for taking possesion of the connection for a period of time (so it can write a complete packet). This idea could be taken quite far into genericity by making clients aware of how busy the connection is and size its output packets accordingly... But I'm not doing that. 



[endsect]



[section:connection_type fcgi::fcgi_request_service::implementation_type::connection_type]

[indexterm2 connection_type..fcgi::fcgi_request_service::implementation_type] 

  typedef client_type::connection_type connection_type;




[endsect]



[section:const_buffers_type fcgi::fcgi_request_service::implementation_type::const_buffers_type]


['Inherited from common::request_base::impl_base.]

[indexterm2 const_buffers_type..fcgi::fcgi_request_service::implementation_type] 

  typedef boost::asio::const_buffers_1 const_buffers_type;




[endsect]



[section:env_parsed_ fcgi::fcgi_request_service::implementation_type::env_parsed_]


['Inherited from common::request_base::impl_base.]

[indexterm2 env_parsed_..fcgi::fcgi_request_service::implementation_type] Whether the environment has been parsed yet. 

  bool env_parsed_;



[endsect]



[section:form_parser_type fcgi::fcgi_request_service::implementation_type::form_parser_type]

[indexterm2 form_parser_type..fcgi::fcgi_request_service::implementation_type] 

  typedef detail::form_parser form_parser_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.detail__form_parser.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.detail__form_parser.callback_type [*callback_type]]]
    [The callback functor to read more data. ]
  
  ]

  [

    [[link cgi.reference.detail__form_parser__context [*context]]]
    [The context used for parsing. ]
  
  ]

  [

    [[link cgi.reference.detail__form_parser.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.detail__form_parser.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.detail__form_parser.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.detail__form_parser.buffer_string [*buffer_string]]]
    []
  ]
  
  [
    [[link cgi.reference.detail__form_parser.form_parser [*form_parser]]]
    []
  ]
  
  [
    [[link cgi.reference.detail__form_parser.move_to_start_of_first_part [*move_to_start_of_first_part]]]
    [Erase any front-cruft on the form data. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse [*parse]]]
    [Run the parser on the given `context`. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse_boundary_marker [*parse_boundary_marker]]]
    [Get the boundary marker from the CONTENT_TYPE header. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse_form_part [*parse_form_part]]]
    [Parse a single form part. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse_multipart_form [*parse_multipart_form]]]
    [Parse a multipart form. ]
  ]
  
  [
    [[link cgi.reference.detail__form_parser.parse_url_encoded_form [*parse_url_encoded_form]]]
    [URL-encoded forms. ]
  ]
  
]

Construct this and then call `form\_parserparse` with an instance of form_parser::context (or compatible struct).

This is minimal and doesn't extract all meta-data yet, but is known to work on Windows XP with MSVC9.0 and Ubuntu linux with gcc 4.2.x and 4.3.x.

Valid Form Encodings > `application/x-www-form-urlencoded` > `multipart/form-data`

File uploads (ie. in `multipart/form-data` forms) are saved to disk. See the `BOOST\_CGI\_UPLOAD\_DIRECTORY` macro.

Should also work for HTTP POST data. 



[endsect]



[section:form_parts_ fcgi::fcgi_request_service::implementation_type::form_parts_]


['Inherited from common::request_base::impl_base.]

[indexterm2 form_parts_..fcgi::fcgi_request_service::implementation_type] 

  std::vector< common::form_part > form_parts_;



[endsect]



[section:fp_ fcgi::fcgi_request_service::implementation_type::fp_]

[indexterm2 fp_..fcgi::fcgi_request_service::implementation_type] 

  boost::scoped_ptr< form_parser_type > fp_;



[endsect]



[section:get_parsed_ fcgi::fcgi_request_service::implementation_type::get_parsed_]


['Inherited from common::request_base::impl_base.]

[indexterm2 get_parsed_..fcgi::fcgi_request_service::implementation_type] Whether the get data has been parsed yet. 

  bool get_parsed_;



[endsect]



[section:header_ fcgi::fcgi_request_service::implementation_type::header_]

[indexterm2 header_..fcgi::fcgi_request_service::implementation_type] 

  header_type header_;



[endsect]



[section:header_buf_ fcgi::fcgi_request_service::implementation_type::header_buf_]

[indexterm2 header_buf_..fcgi::fcgi_request_service::implementation_type] 

  header_buffer_type header_buf_;



[endsect]



[section:header_buffer_type fcgi::fcgi_request_service::implementation_type::header_buffer_type]

[indexterm2 header_buffer_type..fcgi::fcgi_request_service::implementation_type] 

  typedef client_type::header_buffer_type header_buffer_type;




[endsect]



[section:header_type fcgi::fcgi_request_service::implementation_type::header_type]

[indexterm2 header_type..fcgi::fcgi_request_service::implementation_type] 

  typedef spec_detail::Header header_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type [*implementation_type]]]
    [The underlying type of a FastCGI header. ]
  
  ]

  [

    [[link cgi.reference.fcgi__spec_detail__Header.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__spec_detail__Header.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__Header.Header [*Header]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.body_length [*body_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.content_length [*content_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.data [*data]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.padding_length [*padding_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.reset [*reset]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.type [*type]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.version [*version]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__Header.impl [*impl]]]
    [The underlying type of a FastCGI header. ]
  ]

]



[endsect]



[section:http_status_ fcgi::fcgi_request_service::implementation_type::http_status_]

[indexterm2 http_status_..fcgi::fcgi_request_service::implementation_type] 

  ::cgi::common::http::status_code http_status_;



[endsect]



[section:id_ fcgi::fcgi_request_service::implementation_type::id_]

[indexterm2 id_..fcgi::fcgi_request_service::implementation_type] 

  boost::uint16_t id_;



[endsect]



[section:implementation_type fcgi::fcgi_request_service::implementation_type::implementation_type]

[indexterm2 implementation_type..fcgi::fcgi_request_service::implementation_type] 

  implementation_type();



[endsect]



[section:mutable_buffers_type fcgi::fcgi_request_service::implementation_type::mutable_buffers_type]


['Inherited from common::request_base::impl_base.]

[indexterm2 mutable_buffers_type..fcgi::fcgi_request_service::implementation_type] 

  typedef boost::asio::mutable_buffers_1 mutable_buffers_type;




[endsect]



[section:param_buffer_ fcgi::fcgi_request_service::implementation_type::param_buffer_]

[indexterm2 param_buffer_..fcgi::fcgi_request_service::implementation_type] 

  buffer_type param_buffer_;



[endsect]



[section:post_buffer_ fcgi::fcgi_request_service::implementation_type::post_buffer_]


['Inherited from common::request_base::impl_base.]

[indexterm2 post_buffer_..fcgi::fcgi_request_service::implementation_type] 

  buffer_type post_buffer_;



[endsect]



[section:prepare fcgi::fcgi_request_service::implementation_type::prepare]


['Inherited from common::request_base::impl_base.]

[indexterm2 prepare..fcgi::fcgi_request_service::implementation_type] 

  mutable_buffers_type prepare(
      std::size_t size);



[endsect]



[section:prepare_misc fcgi::fcgi_request_service::implementation_type::prepare_misc]

[indexterm2 prepare_misc..fcgi::fcgi_request_service::implementation_type] 

  mutable_buffers_type prepare_misc(
      std::size_t size);



[endsect]



[section:protocol_service_type fcgi::fcgi_request_service::implementation_type::protocol_service_type]

[indexterm2 protocol_service_type..fcgi::fcgi_request_service::implementation_type] 

  typedef detail::protocol_traits< protocol_type >::protocol_service_type protocol_service_type;




[endsect]



[section:protocol_type fcgi::fcgi_request_service::implementation_type::protocol_type]

[indexterm2 protocol_type..fcgi::fcgi_request_service::implementation_type] 

  typedef ::cgi::common::fcgi_ protocol_type;




[endsect]



[section:request_role_ fcgi::fcgi_request_service::implementation_type::request_role_]

[indexterm2 request_role_..fcgi::fcgi_request_service::implementation_type] 

  fcgi::spec_detail::role_types request_role_;



[endsect]



[section:request_status_ fcgi::fcgi_request_service::implementation_type::request_status_]

[indexterm2 request_status_..fcgi::fcgi_request_service::implementation_type] 

  common::request_status request_status_;



[endsect]



[section:request_type fcgi::fcgi_request_service::implementation_type::request_type]

[indexterm2 request_type..fcgi::fcgi_request_service::implementation_type] 

  typedef detail::protocol_traits< protocol_type >::request_type request_type;




[endsect]



[section:service_ fcgi::fcgi_request_service::implementation_type::service_]

[indexterm2 service_..fcgi::fcgi_request_service::implementation_type] 

  protocol_service_type * service_;



[endsect]



[section:stdin_parsed_ fcgi::fcgi_request_service::implementation_type::stdin_parsed_]

[indexterm2 stdin_parsed_..fcgi::fcgi_request_service::implementation_type] 

  bool stdin_parsed_;



[endsect]



[section:string_type fcgi::fcgi_request_service::implementation_type::string_type]


['Inherited from common::request_base::impl_base.]

[indexterm2 string_type..fcgi::fcgi_request_service::implementation_type] 

  typedef std::basic_string< char_type > string_type;




[endsect]



[section:var_map_type fcgi::fcgi_request_service::implementation_type::var_map_type]


['Inherited from common::request_base::impl_base.]

[indexterm2 var_map_type..fcgi::fcgi_request_service::implementation_type] 

  typedef boost::fusion::vector< common::env_map, common::get_map, common::post_map, common::cookie_map, common::session_map > var_map_type;



If you want to add a new data type to a request you need to: > Update this file (just below) > Update source_enums.hpp > Update map.hpp with a new map type > Use the `BOOST\_CGI\_DETAIL\_MAP\_ACCESS` macro in `basic\_request<>`, next to the other uses of it. 


[endsect]



[section:vars_ fcgi::fcgi_request_service::implementation_type::vars_]


['Inherited from common::request_base::impl_base.]

[indexterm2 vars_..fcgi::fcgi_request_service::implementation_type] 

  var_map_type vars_;



[endsect]



[endsect]


[section:fcgi__packet_type__packet_types fcgi::packet_type::packet_types]

[indexterm1 fcgi::packet_type::packet_types] 

  enum packet_types

[heading Values]
[variablelist

  [
    [get_data]
    []
  ]

  [
    [end_get_data]
    []
  ]

]



[endsect]



[section:fcgi__request fcgi::request]

[indexterm1 fcgi::request] 

  typedef common::basic_request< fcgi_request_service, service > request;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__callback_functor [*callback_functor]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service__implementation_type [*implementation_type]]]
    [The actual implementation date for an FCGI request. ]
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.full_type [*full_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.proc_func_t [*proc_func_t]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__fcgi_request_service.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.async_load [*async_load]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.begin_request_helper [*begin_request_helper]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.clear [*clear]]]
    [Clear all request data (object is then safe to remove). ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.client [*client]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.close [*close]]]
    [Close the request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.fcgi_request_service [*fcgi_request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.handle_admin_request [*handle_admin_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.handle_other_request_header [*handle_other_request_header]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.is_file [*is_file]]]
    [Check if a given POST variable represents a file upload. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.params_read [*params_read]]]
    [Returns true if the request environment params have been read. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_body [*parse_body]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_header [*parse_header]]]
    [Parse the current header. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_packet [*parse_packet]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_abort_request [*process_abort_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_begin_request [*process_begin_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_params [*process_params]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.process_stdin [*process_stdin]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_body [*read_body]]]
    [Read the body of the current packet; do nothing with it. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_env_vars [*read_env_vars]]]
    [Read in the FastCGI (env) params. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_header [*read_header]]]
    [Read a single header, buf do nothing with it. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.read_some [*read_some]]]
    [Read some data from the client into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.set_service [*set_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.set_status [*set_status]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service._fcgi_request_service [*~fcgi_request_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_one_post_var [*parse_one_post_var]]]
    [Read and parse a single cgi POST meta variable (greedily). ]
  ]
  
  [
    [[link cgi.reference.fcgi__fcgi_request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.id [*id]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__fcgi_request_service.proc_funcs [*proc_funcs]]]
    []
  ]

]



[endsect]



[section:fcgi__service fcgi::service]

[indexterm1 fcgi::service] 

  typedef ::cgi::common::basic_protocol_service< ::cgi::common::fcgi_ > service;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 



[endsect]



[section:fcgi__service_t fcgi::service_t]

[indexterm1 fcgi::service_t] 

  typedef service service_t;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 



[endsect]


[section:fcgi__spec_detail__BeginRequestBody fcgi::spec_detail::BeginRequestBody]



  class BeginRequestBody


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__BeginRequestBody.flags [*flags]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__BeginRequestBody.role [*role]]]
    []
  ]
  
]


[section:flags fcgi::spec_detail::BeginRequestBody::flags]

[indexterm2 flags..fcgi::spec_detail::BeginRequestBody] 

  unsigned char flags() const;



[endsect]



[section:role fcgi::spec_detail::BeginRequestBody::role]

[indexterm2 role..fcgi::spec_detail::BeginRequestBody] 

  int role() const;



[endsect]



[endsect]

[section:fcgi__spec_detail__BeginRequestBody__implementation_type fcgi::spec_detail::BeginRequestBody::implementation_type]

The underlying type of a BeginRequestBody sub-header. 

  struct implementation_type


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__BeginRequestBody__implementation_type.flags_ [*flags_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__BeginRequestBody__implementation_type.reserved_ [*reserved_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__BeginRequestBody__implementation_type.roleB0_ [*roleB0_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__BeginRequestBody__implementation_type.roleB1_ [*roleB1_]]]
    []
  ]

]

To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[section:flags_ fcgi::spec_detail::BeginRequestBody::implementation_type::flags_]

[indexterm2 flags_..fcgi::spec_detail::BeginRequestBody::implementation_type] 

  unsigned char flags_;



[endsect]



[section:reserved_ fcgi::spec_detail::BeginRequestBody::implementation_type::reserved_]

[indexterm2 reserved_..fcgi::spec_detail::BeginRequestBody::implementation_type] 

  unsigned char reserved_;



[endsect]



[section:roleB0_ fcgi::spec_detail::BeginRequestBody::implementation_type::roleB0_]

[indexterm2 roleB0_..fcgi::spec_detail::BeginRequestBody::implementation_type] 

  unsigned char roleB0_;



[endsect]



[section:roleB1_ fcgi::spec_detail::BeginRequestBody::implementation_type::roleB1_]

[indexterm2 roleB1_..fcgi::spec_detail::BeginRequestBody::implementation_type] 

  unsigned char roleB1_;



[endsect]



[endsect]

[section:fcgi__spec_detail__BeginRequestRecord fcgi::spec_detail::BeginRequestRecord]



  struct BeginRequestRecord


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__BeginRequestRecord.body_ [*body_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__BeginRequestRecord.header_ [*header_]]]
    []
  ]

]


[section:body_ fcgi::spec_detail::BeginRequestRecord::body_]

[indexterm2 body_..fcgi::spec_detail::BeginRequestRecord] 

  BeginRequestBody body_;



[endsect]



[section:header_ fcgi::spec_detail::BeginRequestRecord::header_]

[indexterm2 header_..fcgi::spec_detail::BeginRequestRecord] 

  Header header_;



[endsect]



[endsect]

[section:fcgi__spec_detail__EndRequestBody fcgi::spec_detail::EndRequestBody]



  class EndRequestBody


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__spec_detail__EndRequestBody.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody.EndRequestBody [*EndRequestBody]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody.data [*data]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody.reset [*reset]]]
    []
  ]
  
]

[section:EndRequestBody fcgi::spec_detail::EndRequestBody::EndRequestBody]

[indexterm2 EndRequestBody..fcgi::spec_detail::EndRequestBody] 

  ``[link cgi.reference.fcgi__spec_detail__EndRequestBody.EndRequestBody.overload1 EndRequestBody]``(
      boost::uint64_t appStatus,
      status_types procStatus);

  ``[link cgi.reference.fcgi__spec_detail__EndRequestBody.EndRequestBody.overload2 EndRequestBody]``();


[section:overload1 fcgi::spec_detail::EndRequestBody::EndRequestBody (1 of 2 overloads)]



  EndRequestBody(
      boost::uint64_t appStatus,
      status_types procStatus);



[endsect]



[section:overload2 fcgi::spec_detail::EndRequestBody::EndRequestBody (2 of 2 overloads)]



  EndRequestBody();



[endsect]


[endsect]


[section:const_buffers_type fcgi::spec_detail::EndRequestBody::const_buffers_type]

[indexterm2 const_buffers_type..fcgi::spec_detail::EndRequestBody] 

  typedef boost::asio::const_buffers_1 const_buffers_type;




[endsect]



[section:data fcgi::spec_detail::EndRequestBody::data]

[indexterm2 data..fcgi::spec_detail::EndRequestBody] 

  const_buffers_type data() const;



[endsect]



[section:reset fcgi::spec_detail::EndRequestBody::reset]

[indexterm2 reset..fcgi::spec_detail::EndRequestBody] 

  void reset(
      boost::uint64_t appStatus,
      status_types procStatus);



[endsect]



[endsect]

[section:fcgi__spec_detail__EndRequestBody__implementation_type fcgi::spec_detail::EndRequestBody::implementation_type]

The underlying type of an EndRequestBody sub-header. 

  struct implementation_type


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody__implementation_type.appStatusB0_ [*appStatusB0_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody__implementation_type.appStatusB1_ [*appStatusB1_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody__implementation_type.appStatusB2_ [*appStatusB2_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody__implementation_type.appStatusB3_ [*appStatusB3_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody__implementation_type.protocolStatus_ [*protocolStatus_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody__implementation_type.reserved_ [*reserved_]]]
    []
  ]

]

To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[section:appStatusB0_ fcgi::spec_detail::EndRequestBody::implementation_type::appStatusB0_]

[indexterm2 appStatusB0_..fcgi::spec_detail::EndRequestBody::implementation_type] 

  unsigned char appStatusB0_;



[endsect]



[section:appStatusB1_ fcgi::spec_detail::EndRequestBody::implementation_type::appStatusB1_]

[indexterm2 appStatusB1_..fcgi::spec_detail::EndRequestBody::implementation_type] 

  unsigned char appStatusB1_;



[endsect]



[section:appStatusB2_ fcgi::spec_detail::EndRequestBody::implementation_type::appStatusB2_]

[indexterm2 appStatusB2_..fcgi::spec_detail::EndRequestBody::implementation_type] 

  unsigned char appStatusB2_;



[endsect]



[section:appStatusB3_ fcgi::spec_detail::EndRequestBody::implementation_type::appStatusB3_]

[indexterm2 appStatusB3_..fcgi::spec_detail::EndRequestBody::implementation_type] 

  unsigned char appStatusB3_;



[endsect]



[section:protocolStatus_ fcgi::spec_detail::EndRequestBody::implementation_type::protocolStatus_]

[indexterm2 protocolStatus_..fcgi::spec_detail::EndRequestBody::implementation_type] 

  unsigned char protocolStatus_;



[endsect]



[section:reserved_ fcgi::spec_detail::EndRequestBody::implementation_type::reserved_]

[indexterm2 reserved_..fcgi::spec_detail::EndRequestBody::implementation_type] 

  unsigned char reserved_;



[endsect]



[endsect]

[section:fcgi__spec_detail__EndRequestRecord fcgi::spec_detail::EndRequestRecord]



  class EndRequestRecord


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestRecord.EndRequestRecord [*EndRequestRecord]]]
    []
  ]
  
]


[section:EndRequestRecord fcgi::spec_detail::EndRequestRecord::EndRequestRecord]

[indexterm2 EndRequestRecord..fcgi::spec_detail::EndRequestRecord] 

  EndRequestRecord(
      boost::uint16_t id,
      boost::uint64_t appStatus,
      status_types procStatus);



[endsect]



[endsect]

[section:fcgi__spec_detail__EndRequestRecord__implementation_type fcgi::spec_detail::EndRequestRecord::implementation_type]

The underlying type of an EndRequestRecord sub-header. 

  struct implementation_type


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestRecord__implementation_type.body_ [*body_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestRecord__implementation_type.header_ [*header_]]]
    []
  ]

]

To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[section:body_ fcgi::spec_detail::EndRequestRecord::implementation_type::body_]

[indexterm2 body_..fcgi::spec_detail::EndRequestRecord::implementation_type] 

  EndRequestBody body_;



[endsect]



[section:header_ fcgi::spec_detail::EndRequestRecord::implementation_type::header_]

[indexterm2 header_..fcgi::spec_detail::EndRequestRecord::implementation_type] 

  Header header_;



[endsect]



[endsect]

[section:fcgi__spec_detail__Header fcgi::spec_detail::Header]



  struct Header


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type [*implementation_type]]]
    [The underlying type of a FastCGI header. ]
  
  ]

  [

    [[link cgi.reference.fcgi__spec_detail__Header.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__spec_detail__Header.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__Header.Header [*Header]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.body_length [*body_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.content_length [*content_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.data [*data]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.padding_length [*padding_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.reset [*reset]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.type [*type]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.version [*version]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__Header.impl [*impl]]]
    [The underlying type of a FastCGI header. ]
  ]

]

[section:Header fcgi::spec_detail::Header::Header]

[indexterm2 Header..fcgi::spec_detail::Header] 

  ``[link cgi.reference.fcgi__spec_detail__Header.Header.overload1 Header]``(
      request_types t,
      int id,
      int len);

  ``[link cgi.reference.fcgi__spec_detail__Header.Header.overload2 Header]``();


[section:overload1 fcgi::spec_detail::Header::Header (1 of 2 overloads)]



  Header(
      request_types t,
      int id,
      int len);



[endsect]



[section:overload2 fcgi::spec_detail::Header::Header (2 of 2 overloads)]



  Header();



[endsect]


[endsect]


[section:body_length fcgi::spec_detail::Header::body_length]

[indexterm2 body_length..fcgi::spec_detail::Header] 

  int body_length() const;



[endsect]



[section:const_buffers_type fcgi::spec_detail::Header::const_buffers_type]

[indexterm2 const_buffers_type..fcgi::spec_detail::Header] 

  typedef boost::asio::const_buffers_1 const_buffers_type;




[endsect]



[section:content_length fcgi::spec_detail::Header::content_length]

[indexterm2 content_length..fcgi::spec_detail::Header] 

  boost::uint16_t content_length() const;



[endsect]


[section:data fcgi::spec_detail::Header::data]

[indexterm2 data..fcgi::spec_detail::Header] 

  const_buffers_type ``[link cgi.reference.fcgi__spec_detail__Header.data.overload1 data]``() const;

  mutable_buffers_type ``[link cgi.reference.fcgi__spec_detail__Header.data.overload2 data]``();


[section:overload1 fcgi::spec_detail::Header::data (1 of 2 overloads)]



  const_buffers_type data() const;



[endsect]



[section:overload2 fcgi::spec_detail::Header::data (2 of 2 overloads)]



  mutable_buffers_type data();



[endsect]


[endsect]


[section:impl fcgi::spec_detail::Header::impl]

[indexterm2 impl..fcgi::spec_detail::Header] The underlying type of a FastCGI header. 

  struct cgi::fcgi::spec_detail::Header::implementation_type impl;


To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[endsect]



[section:mutable_buffers_type fcgi::spec_detail::Header::mutable_buffers_type]

[indexterm2 mutable_buffers_type..fcgi::spec_detail::Header] 

  typedef boost::asio::mutable_buffers_1 mutable_buffers_type;




[endsect]



[section:padding_length fcgi::spec_detail::Header::padding_length]

[indexterm2 padding_length..fcgi::spec_detail::Header] 

  boost::uint16_t padding_length() const;



[endsect]



[section:request_id fcgi::spec_detail::Header::request_id]

[indexterm2 request_id..fcgi::spec_detail::Header] 

  boost::uint16_t request_id() const;



[endsect]



[section:reset fcgi::spec_detail::Header::reset]

[indexterm2 reset..fcgi::spec_detail::Header] 

  void reset(
      request_types t,
      int id,
      int len);



[endsect]



[section:type fcgi::spec_detail::Header::type]

[indexterm2 type..fcgi::spec_detail::Header] 

  boost::uint16_t type() const;



[endsect]



[section:version fcgi::spec_detail::Header::version]

[indexterm2 version..fcgi::spec_detail::Header] 

  boost::uint16_t version() const;



[endsect]



[endsect]

[section:fcgi__spec_detail__Header__implementation_type fcgi::spec_detail::Header::implementation_type]

The underlying type of a FastCGI header. 

  struct implementation_type


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type.contentLengthB0_ [*contentLengthB0_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type.contentLengthB1_ [*contentLengthB1_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type.paddingLength_ [*paddingLength_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type.requestIdB0_ [*requestIdB0_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type.requestIdB1_ [*requestIdB1_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type.reserved_ [*reserved_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type.type_ [*type_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type.version_ [*version_]]]
    []
  ]

]

To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[section:contentLengthB0_ fcgi::spec_detail::Header::implementation_type::contentLengthB0_]

[indexterm2 contentLengthB0_..fcgi::spec_detail::Header::implementation_type] 

  unsigned char contentLengthB0_;



[endsect]



[section:contentLengthB1_ fcgi::spec_detail::Header::implementation_type::contentLengthB1_]

[indexterm2 contentLengthB1_..fcgi::spec_detail::Header::implementation_type] 

  unsigned char contentLengthB1_;



[endsect]



[section:paddingLength_ fcgi::spec_detail::Header::implementation_type::paddingLength_]

[indexterm2 paddingLength_..fcgi::spec_detail::Header::implementation_type] 

  unsigned char paddingLength_;



[endsect]



[section:requestIdB0_ fcgi::spec_detail::Header::implementation_type::requestIdB0_]

[indexterm2 requestIdB0_..fcgi::spec_detail::Header::implementation_type] 

  unsigned char requestIdB0_;



[endsect]



[section:requestIdB1_ fcgi::spec_detail::Header::implementation_type::requestIdB1_]

[indexterm2 requestIdB1_..fcgi::spec_detail::Header::implementation_type] 

  unsigned char requestIdB1_;



[endsect]



[section:reserved_ fcgi::spec_detail::Header::implementation_type::reserved_]

[indexterm2 reserved_..fcgi::spec_detail::Header::implementation_type] 

  unsigned char reserved_;



[endsect]



[section:type_ fcgi::spec_detail::Header::implementation_type::type_]

[indexterm2 type_..fcgi::spec_detail::Header::implementation_type] 

  unsigned char type_;



[endsect]



[section:version_ fcgi::spec_detail::Header::implementation_type::version_]

[indexterm2 version_..fcgi::spec_detail::Header::implementation_type] 

  unsigned char version_;



[endsect]



[endsect]

[section:fcgi__spec_detail__UnknownTypeBody fcgi::spec_detail::UnknownTypeBody]



  class UnknownTypeBody


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__UnknownTypeBody.UnknownTypeBody [*UnknownTypeBody]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__UnknownTypeBody.reset [*reset]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__UnknownTypeBody.type [*type]]]
    []
  ]
  
]

[section:UnknownTypeBody fcgi::spec_detail::UnknownTypeBody::UnknownTypeBody]

[indexterm2 UnknownTypeBody..fcgi::spec_detail::UnknownTypeBody] 

  ``[link cgi.reference.fcgi__spec_detail__UnknownTypeBody.UnknownTypeBody.overload1 UnknownTypeBody]``(
      unsigned char t);

  ``[link cgi.reference.fcgi__spec_detail__UnknownTypeBody.UnknownTypeBody.overload2 UnknownTypeBody]``();


[section:overload1 fcgi::spec_detail::UnknownTypeBody::UnknownTypeBody (1 of 2 overloads)]



  UnknownTypeBody(
      unsigned char t);



[endsect]



[section:overload2 fcgi::spec_detail::UnknownTypeBody::UnknownTypeBody (2 of 2 overloads)]



  UnknownTypeBody();



[endsect]


[endsect]


[section:reset fcgi::spec_detail::UnknownTypeBody::reset]

[indexterm2 reset..fcgi::spec_detail::UnknownTypeBody] 

  void reset(
      unsigned char t);



[endsect]



[section:type fcgi::spec_detail::UnknownTypeBody::type]

[indexterm2 type..fcgi::spec_detail::UnknownTypeBody] 

  unsigned char type() const;



[endsect]



[endsect]

[section:fcgi__spec_detail__UnknownTypeBody__implementation_type fcgi::spec_detail::UnknownTypeBody::implementation_type]

The underlying type of an UnknownTypeBody sub-header. 

  struct implementation_type


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__UnknownTypeBody__implementation_type.reserved_ [*reserved_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__UnknownTypeBody__implementation_type.type_ [*type_]]]
    []
  ]

]

To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[section:reserved_ fcgi::spec_detail::UnknownTypeBody::implementation_type::reserved_]

[indexterm2 reserved_..fcgi::spec_detail::UnknownTypeBody::implementation_type] 

  unsigned char reserved_;



[endsect]



[section:type_ fcgi::spec_detail::UnknownTypeBody::implementation_type::type_]

[indexterm2 type_..fcgi::spec_detail::UnknownTypeBody::implementation_type] 

  unsigned char type_;



[endsect]



[endsect]

[section:fcgi__spec_detail__UnknownTypeRecord fcgi::spec_detail::UnknownTypeRecord]



  class UnknownTypeRecord


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__UnknownTypeRecord.UnknownTypeRecord [*UnknownTypeRecord]]]
    []
  ]
  
]


[section:UnknownTypeRecord fcgi::spec_detail::UnknownTypeRecord::UnknownTypeRecord]

[indexterm2 UnknownTypeRecord..fcgi::spec_detail::UnknownTypeRecord] 

  UnknownTypeRecord(
      int type);



[endsect]



[endsect]

[section:fcgi__spec_detail__UnknownTypeRecord__implementation_type fcgi::spec_detail::UnknownTypeRecord::implementation_type]

The underlying type of a UnknownTypeRecord sub-header. 

  struct implementation_type


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__UnknownTypeRecord__implementation_type.body_ [*body_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__spec_detail__UnknownTypeRecord__implementation_type.header_ [*header_]]]
    []
  ]

]

To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[section:body_ fcgi::spec_detail::UnknownTypeRecord::implementation_type::body_]

[indexterm2 body_..fcgi::spec_detail::UnknownTypeRecord::implementation_type] 

  UnknownTypeBody body_;



[endsect]



[section:header_ fcgi::spec_detail::UnknownTypeRecord::implementation_type::header_]

[indexterm2 header_..fcgi::spec_detail::UnknownTypeRecord::implementation_type] 

  Header header_;



[endsect]



[endsect]


[section:fcgi__spec_detail__request_types fcgi::spec_detail::request_types]

[indexterm1 fcgi::spec_detail::request_types] 

  enum request_types

[heading Values]
[variablelist

  [
    [BEGIN_REQUEST]
    []
  ]

  [
    [ABORT_REQUEST]
    []
  ]

  [
    [END_REQUEST]
    []
  ]

  [
    [PARAMS]
    []
  ]

  [
    [STDIN]
    []
  ]

  [
    [STDOUT]
    []
  ]

  [
    [STDERR]
    []
  ]

  [
    [DATA]
    []
  ]

  [
    [GET_VALUES]
    []
  ]

  [
    [GET_VALUES_RESULT]
    []
  ]

  [
    [UNKNOWN_TYPE]
    []
  ]

  [
    [MAXTYPE]
    []
  ]

]



[endsect]



[section:fcgi__spec_detail__role_types fcgi::spec_detail::role_types]

[indexterm1 fcgi::spec_detail::role_types] 

  enum role_types

[heading Values]
[variablelist

  [
    [RESPONDER]
    []
  ]

  [
    [AUTHORIZER]
    []
  ]

  [
    [FILTER]
    []
  ]

  [
    [ANY]
    []
  ]

]



[endsect]



[section:fcgi__spec_detail__status_types fcgi::spec_detail::status_types]

[indexterm1 fcgi::spec_detail::status_types] 

  enum status_types

[heading Values]
[variablelist

  [
    [REQUEST_COMPLETE]
    []
  ]

  [
    [CANT_MPX_CONN]
    []
  ]

  [
    [OVERLOADED]
    []
  ]

  [
    [UNKNOWN_ROLE]
    []
  ]

]



[endsect]


[section:fcgi__specification__AUX_WRAPPER_NAME fcgi::specification::AUX_WRAPPER_NAME]



  template<
      AUX_WRAPPER_PARAMS(N) >
  struct AUX_WRAPPER_NAME


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.tag [*tag]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.type [*type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.value_type [*value_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.AUX_WRAPPER_INST [*AUX_WRAPPER_INST]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.BOOST_STATIC_CONSTANT [*BOOST_STATIC_CONSTANT]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.operator_AUX_WRAPPER_VALUE_TYPE [*operator AUX_WRAPPER_VALUE_TYPE]]]
    []
  ]
  
]

[section:AUX_WRAPPER_INST fcgi::specification::AUX_WRAPPER_NAME::AUX_WRAPPER_INST]

[indexterm2 AUX_WRAPPER_INST..fcgi::specification::AUX_WRAPPER_NAME] 

  typedef ``[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.AUX_WRAPPER_INST.overload1 AUX_WRAPPER_INST]``(
      BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE,(value-1)) );

  typedef ``[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.AUX_WRAPPER_INST.overload2 AUX_WRAPPER_INST]``(
      BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE,(value+1)) );


[section:overload1 fcgi::specification::AUX_WRAPPER_NAME::AUX_WRAPPER_INST (1 of 2 overloads)]



  typedef AUX_WRAPPER_INST(
      BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE,(value-1)) );



[endsect]



[section:overload2 fcgi::specification::AUX_WRAPPER_NAME::AUX_WRAPPER_INST (2 of 2 overloads)]



  typedef AUX_WRAPPER_INST(
      BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE,(value+1)) );



[endsect]


[endsect]


[section:BOOST_STATIC_CONSTANT fcgi::specification::AUX_WRAPPER_NAME::BOOST_STATIC_CONSTANT]

[indexterm2 BOOST_STATIC_CONSTANT..fcgi::specification::AUX_WRAPPER_NAME] 

  BOOST_STATIC_CONSTANT(
      AUX_WRAPPER_VALUE_TYPE ,
      value  = N);



[endsect]



[section:operator_AUX_WRAPPER_VALUE_TYPE fcgi::specification::AUX_WRAPPER_NAME::operator AUX_WRAPPER_VALUE_TYPE]

[indexterm2 operator AUX_WRAPPER_VALUE_TYPE..fcgi::specification::AUX_WRAPPER_NAME] 

  operator AUX_WRAPPER_VALUE_TYPE() const;



[endsect]



[section:tag fcgi::specification::AUX_WRAPPER_NAME::tag]

[indexterm2 tag..fcgi::specification::AUX_WRAPPER_NAME] 

  typedef integral_c_tag tag;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__integral_c_tag.BOOST_STATIC_CONSTANT [*BOOST_STATIC_CONSTANT]]]
    []
  ]
  
]



[endsect]



[section:type fcgi::specification::AUX_WRAPPER_NAME::type]

[indexterm2 type..fcgi::specification::AUX_WRAPPER_NAME] 

  typedef AUX_WRAPPER_NAME type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.tag [*tag]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.type [*type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.value_type [*value_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.AUX_WRAPPER_INST [*AUX_WRAPPER_INST]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.BOOST_STATIC_CONSTANT [*BOOST_STATIC_CONSTANT]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__AUX_WRAPPER_NAME.operator_AUX_WRAPPER_VALUE_TYPE [*operator AUX_WRAPPER_VALUE_TYPE]]]
    []
  ]
  
]



[endsect]



[section:value_type fcgi::specification::AUX_WRAPPER_NAME::value_type]

[indexterm2 value_type..fcgi::specification::AUX_WRAPPER_NAME] 

  typedef AUX_WRAPPER_VALUE_TYPE value_type;




[endsect]



[endsect]

[section:fcgi__specification__BeginRequestBody fcgi::specification::BeginRequestBody]



  class BeginRequestBody


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__BeginRequestBody.flags [*flags]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__BeginRequestBody.role [*role]]]
    []
  ]
  
]


[section:flags fcgi::specification::BeginRequestBody::flags]

[indexterm2 flags..fcgi::specification::BeginRequestBody] 

  unsigned char flags() const;



[endsect]



[section:role fcgi::specification::BeginRequestBody::role]

[indexterm2 role..fcgi::specification::BeginRequestBody] 

  int role() const;



[endsect]



[endsect]

[section:fcgi__specification__BeginRequestBody__implementation_type fcgi::specification::BeginRequestBody::implementation_type]

The underlying type of a BeginRequestBody sub-header. 

  struct implementation_type


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__BeginRequestBody__implementation_type.flags_ [*flags_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__specification__BeginRequestBody__implementation_type.reserved_ [*reserved_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__specification__BeginRequestBody__implementation_type.roleB0_ [*roleB0_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__specification__BeginRequestBody__implementation_type.roleB1_ [*roleB1_]]]
    []
  ]

]

To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[section:flags_ fcgi::specification::BeginRequestBody::implementation_type::flags_]

[indexterm2 flags_..fcgi::specification::BeginRequestBody::implementation_type] 

  unsigned char flags_;



[endsect]



[section:reserved_ fcgi::specification::BeginRequestBody::implementation_type::reserved_]

[indexterm2 reserved_..fcgi::specification::BeginRequestBody::implementation_type] 

  unsigned char reserved_;



[endsect]



[section:roleB0_ fcgi::specification::BeginRequestBody::implementation_type::roleB0_]

[indexterm2 roleB0_..fcgi::specification::BeginRequestBody::implementation_type] 

  unsigned char roleB0_;



[endsect]



[section:roleB1_ fcgi::specification::BeginRequestBody::implementation_type::roleB1_]

[indexterm2 roleB1_..fcgi::specification::BeginRequestBody::implementation_type] 

  unsigned char roleB1_;



[endsect]



[endsect]

[section:fcgi__specification__begin_request fcgi::specification::begin_request]



  struct begin_request


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__specification__begin_request.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__specification__begin_request__body [*body]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__begin_request.begin_request [*begin_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__begin_request.flags [*flags]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__begin_request.flags [*flags]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__begin_request.role [*role]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__begin_request.role [*role]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__begin_request.impl [*impl]]]
    []
  ]

]


[section:begin_request fcgi::specification::begin_request::begin_request]

[indexterm2 begin_request..fcgi::specification::begin_request] 

  begin_request(
      buffer_type & buf);



[endsect]



[section:buffer_type fcgi::specification::begin_request::buffer_type]

[indexterm2 buffer_type..fcgi::specification::begin_request] 

  typedef boost::array< unsigned char, header_length::value > buffer_type;




[endsect]



[section:flags fcgi::specification::begin_request::flags]

[indexterm2 flags..fcgi::specification::begin_request] 

  unsigned char flags();



[endsect]



[section:flags fcgi::specification::begin_request::flags]

[indexterm2 flags..fcgi::specification::begin_request] 

  template<
      typename Array >
  static unsigned char flags(
      Array & a);



[endsect]



[section:impl fcgi::specification::begin_request::impl]

[indexterm2 impl..fcgi::specification::begin_request] 

  buffer_type impl;



[endsect]



[section:role fcgi::specification::begin_request::role]

[indexterm2 role..fcgi::specification::begin_request] 

  spec_detail::role_types role();



[endsect]



[section:role fcgi::specification::begin_request::role]

[indexterm2 role..fcgi::specification::begin_request] 

  template<
      typename Array >
  static spec_detail::role_types role(
      Array & a);



[endsect]



[endsect]

[section:fcgi__specification__begin_request__body fcgi::specification::begin_request::body]



  struct body


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__specification__begin_request__body.size [*size]]]
    []
  
  ]

]


[section:size fcgi::specification::begin_request::body::size]

[indexterm2 size..fcgi::specification::begin_request::body] 

  typedef boost::mpl::int_< 8 > size;




[endsect]



[endsect]

[section:fcgi__specification__end_request fcgi::specification::end_request]



  struct end_request :
    public fcgi::spec_detail::Header,
    fcgi::spec_detail::EndRequestBody


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__specification__end_request.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__specification__end_request.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__end_request.body_length [*body_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__end_request.content_length [*content_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__end_request.data [*data]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__end_request.end_request [*end_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__end_request.padding_length [*padding_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__end_request.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__end_request.reset [*reset]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__end_request.type [*type]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__end_request.version [*version]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__end_request.impl [*impl]]]
    [The underlying type of a FastCGI header. ]
  ]

]


[section:body_length fcgi::specification::end_request::body_length]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 body_length..fcgi::specification::end_request] 

  int body_length() const;



[endsect]



[section:const_buffers_type fcgi::specification::end_request::const_buffers_type]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 const_buffers_type..fcgi::specification::end_request] 

  typedef boost::asio::const_buffers_1 const_buffers_type;




[endsect]



[section:content_length fcgi::specification::end_request::content_length]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 content_length..fcgi::specification::end_request] 

  boost::uint16_t content_length() const;



[endsect]


[section:data fcgi::specification::end_request::data]

[indexterm2 data..fcgi::specification::end_request] 

  const_buffers_type ``[link cgi.reference.fcgi__specification__end_request.data.overload1 data]``() const;

  mutable_buffers_type ``[link cgi.reference.fcgi__specification__end_request.data.overload2 data]``();


[section:overload1 fcgi::specification::end_request::data (1 of 2 overloads)]


['Inherited from fcgi::spec_detail::Header.]



  const_buffers_type data() const;



[endsect]



[section:overload2 fcgi::specification::end_request::data (2 of 2 overloads)]


['Inherited from fcgi::spec_detail::Header.]



  mutable_buffers_type data();



[endsect]


[endsect]


[section:end_request fcgi::specification::end_request::end_request]

[indexterm2 end_request..fcgi::specification::end_request] 

  end_request(
      int request_id = 0,
      boost::uint64_t app_status = 0,
      spec_detail::status_types proc_status = spec_detail::REQUEST_COMPLETE);



[endsect]



[section:impl fcgi::specification::end_request::impl]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 impl..fcgi::specification::end_request] The underlying type of a FastCGI header. 

  struct cgi::fcgi::spec_detail::Header::implementation_type impl;


To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[endsect]



[section:mutable_buffers_type fcgi::specification::end_request::mutable_buffers_type]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 mutable_buffers_type..fcgi::specification::end_request] 

  typedef boost::asio::mutable_buffers_1 mutable_buffers_type;




[endsect]



[section:padding_length fcgi::specification::end_request::padding_length]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 padding_length..fcgi::specification::end_request] 

  boost::uint16_t padding_length() const;



[endsect]



[section:request_id fcgi::specification::end_request::request_id]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 request_id..fcgi::specification::end_request] 

  boost::uint16_t request_id() const;



[endsect]


[section:reset fcgi::specification::end_request::reset]

[indexterm2 reset..fcgi::specification::end_request] 

  void ``[link cgi.reference.fcgi__specification__end_request.reset.overload1 reset]``(
      request_types t,
      int id,
      int len);

  void ``[link cgi.reference.fcgi__specification__end_request.reset.overload2 reset]``(
      int request_id,
      boost::uint64_t app_status = 0,
      spec_detail::status_types proc_status = spec_detail::REQUEST_COMPLETE);


[section:overload1 fcgi::specification::end_request::reset (1 of 2 overloads)]


['Inherited from fcgi::spec_detail::Header.]



  void reset(
      request_types t,
      int id,
      int len);



[endsect]



[section:overload2 fcgi::specification::end_request::reset (2 of 2 overloads)]



  void reset(
      int request_id,
      boost::uint64_t app_status = 0,
      spec_detail::status_types proc_status = spec_detail::REQUEST_COMPLETE);



[endsect]


[endsect]


[section:type fcgi::specification::end_request::type]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 type..fcgi::specification::end_request] 

  boost::uint16_t type() const;



[endsect]



[section:version fcgi::specification::end_request::version]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 version..fcgi::specification::end_request] 

  boost::uint16_t version() const;



[endsect]



[endsect]


[section:fcgi__specification__end_request_body fcgi::specification::end_request_body]

[indexterm1 fcgi::specification::end_request_body] 

  typedef spec_detail::EndRequestBody end_request_body;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__spec_detail__EndRequestBody.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody.EndRequestBody [*EndRequestBody]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody.data [*data]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__EndRequestBody.reset [*reset]]]
    []
  ]
  
]



[endsect]



[section:fcgi__specification__header fcgi::specification::header]

[indexterm1 fcgi::specification::header] 

  typedef spec_detail::Header header;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__spec_detail__Header__implementation_type [*implementation_type]]]
    [The underlying type of a FastCGI header. ]
  
  ]

  [

    [[link cgi.reference.fcgi__spec_detail__Header.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__spec_detail__Header.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__Header.Header [*Header]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.body_length [*body_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.content_length [*content_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.data [*data]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.padding_length [*padding_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.reset [*reset]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.type [*type]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__spec_detail__Header.version [*version]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__spec_detail__Header.impl [*impl]]]
    [The underlying type of a FastCGI header. ]
  ]

]



[endsect]


[section:fcgi__specification__header_length fcgi::specification::header_length]



  struct header_length



[endsect]

[section:fcgi__specification__integral_c_tag fcgi::specification::integral_c_tag]



  struct integral_c_tag


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__integral_c_tag.BOOST_STATIC_CONSTANT [*BOOST_STATIC_CONSTANT]]]
    []
  ]
  
]


[section:BOOST_STATIC_CONSTANT fcgi::specification::integral_c_tag::BOOST_STATIC_CONSTANT]

[indexterm2 BOOST_STATIC_CONSTANT..fcgi::specification::integral_c_tag] 

  BOOST_STATIC_CONSTANT(
      int ,
      value  = 0);



[endsect]



[endsect]

[section:fcgi__specification__listensock_fileno fcgi::specification::listensock_fileno]



  struct listensock_fileno



[endsect]

[section:fcgi__specification__max_packet_size fcgi::specification::max_packet_size]

Define the FastCGI spec using types. 

  template<
      AUX_WRAPPER_PARAMS(N) >
  struct max_packet_size


Types are better than macros. 


[endsect]

[section:fcgi__specification__null_request_id fcgi::specification::null_request_id]



  struct null_request_id



[endsect]

[section:fcgi__specification__request_type fcgi::specification::request_type]



  struct request_type


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__request_type.to_string [*to_string]]]
    []
  ]
  
]


[section:to_string fcgi::specification::request_type::to_string]

[indexterm2 to_string..fcgi::specification::request_type] 

  template<
      typename Array >
  static std::string to_string(
      Array & a);



[endsect]



[endsect]

[section:fcgi__specification__role_type fcgi::specification::role_type]



  struct role_type


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__role_type.to_string [*to_string]]]
    []
  ]
  
]


[section:to_string fcgi::specification::role_type::to_string]

[indexterm2 to_string..fcgi::specification::role_type] 

  template<
      typename Array >
  static std::string to_string(
      Array & a);



[endsect]



[endsect]

[section:fcgi__specification__stdout_header fcgi::specification::stdout_header]



  struct stdout_header :
    public fcgi::spec_detail::Header


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__specification__stdout_header.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__specification__stdout_header.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__stdout_header.body_length [*body_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__stdout_header.content_length [*content_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__stdout_header.data [*data]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__stdout_header.padding_length [*padding_length]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__stdout_header.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__stdout_header.reset [*reset]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__stdout_header.stdout_header [*stdout_header]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__stdout_header.type [*type]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__specification__stdout_header.version [*version]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__specification__stdout_header.impl [*impl]]]
    [The underlying type of a FastCGI header. ]
  ]

]


[section:body_length fcgi::specification::stdout_header::body_length]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 body_length..fcgi::specification::stdout_header] 

  int body_length() const;



[endsect]



[section:const_buffers_type fcgi::specification::stdout_header::const_buffers_type]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 const_buffers_type..fcgi::specification::stdout_header] 

  typedef boost::asio::const_buffers_1 const_buffers_type;




[endsect]



[section:content_length fcgi::specification::stdout_header::content_length]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 content_length..fcgi::specification::stdout_header] 

  boost::uint16_t content_length() const;



[endsect]


[section:data fcgi::specification::stdout_header::data]

[indexterm2 data..fcgi::specification::stdout_header] 

  const_buffers_type ``[link cgi.reference.fcgi__specification__stdout_header.data.overload1 data]``() const;

  mutable_buffers_type ``[link cgi.reference.fcgi__specification__stdout_header.data.overload2 data]``();


[section:overload1 fcgi::specification::stdout_header::data (1 of 2 overloads)]


['Inherited from fcgi::spec_detail::Header.]



  const_buffers_type data() const;



[endsect]



[section:overload2 fcgi::specification::stdout_header::data (2 of 2 overloads)]


['Inherited from fcgi::spec_detail::Header.]



  mutable_buffers_type data();



[endsect]


[endsect]


[section:impl fcgi::specification::stdout_header::impl]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 impl..fcgi::specification::stdout_header] The underlying type of a FastCGI header. 

  struct cgi::fcgi::spec_detail::Header::implementation_type impl;


To guarantee the header is laid out exactly as we want, the structure must be a POD-type (see http://tinyurl.com/yo9eav). 


[endsect]



[section:mutable_buffers_type fcgi::specification::stdout_header::mutable_buffers_type]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 mutable_buffers_type..fcgi::specification::stdout_header] 

  typedef boost::asio::mutable_buffers_1 mutable_buffers_type;




[endsect]



[section:padding_length fcgi::specification::stdout_header::padding_length]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 padding_length..fcgi::specification::stdout_header] 

  boost::uint16_t padding_length() const;



[endsect]



[section:request_id fcgi::specification::stdout_header::request_id]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 request_id..fcgi::specification::stdout_header] 

  boost::uint16_t request_id() const;



[endsect]


[section:reset fcgi::specification::stdout_header::reset]

[indexterm2 reset..fcgi::specification::stdout_header] 

  void ``[link cgi.reference.fcgi__specification__stdout_header.reset.overload1 reset]``(
      request_types t,
      int id,
      int len);

  void ``[link cgi.reference.fcgi__specification__stdout_header.reset.overload2 reset]``(
      int request_id,
      int content_len);


[section:overload1 fcgi::specification::stdout_header::reset (1 of 2 overloads)]


['Inherited from fcgi::spec_detail::Header.]



  void reset(
      request_types t,
      int id,
      int len);



[endsect]



[section:overload2 fcgi::specification::stdout_header::reset (2 of 2 overloads)]



  void reset(
      int request_id,
      int content_len);



[endsect]


[endsect]

[section:stdout_header fcgi::specification::stdout_header::stdout_header]

[indexterm2 stdout_header..fcgi::specification::stdout_header] 

  ``[link cgi.reference.fcgi__specification__stdout_header.stdout_header.overload1 stdout_header]``(
      int request_id,
      int content_len);

  ``[link cgi.reference.fcgi__specification__stdout_header.stdout_header.overload2 stdout_header]``();


[section:overload1 fcgi::specification::stdout_header::stdout_header (1 of 2 overloads)]



  stdout_header(
      int request_id,
      int content_len);



[endsect]



[section:overload2 fcgi::specification::stdout_header::stdout_header (2 of 2 overloads)]



  stdout_header();



[endsect]


[endsect]


[section:type fcgi::specification::stdout_header::type]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 type..fcgi::specification::stdout_header] 

  boost::uint16_t type() const;



[endsect]



[section:version fcgi::specification::stdout_header::version]


['Inherited from fcgi::spec_detail::Header.]

[indexterm2 version..fcgi::specification::stdout_header] 

  boost::uint16_t version() const;



[endsect]



[endsect]

[section:fcgi_request_acceptor_service fcgi_request_acceptor_service]

The service class for FCGI basic_request_acceptor<>s. 

  template<
      typename Protocol_  = common::fcgi_>
  class fcgi_request_acceptor_service


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi_request_acceptor_service.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi_request_acceptor_service.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi_request_acceptor_service.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi_request_acceptor_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi_request_acceptor_service.service_impl_type [*service_impl_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi_request_acceptor_service.accept [*accept]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.assign [*assign]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.async_accept [*async_accept]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.default_init [*default_init]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.fcgi_request_acceptor_service [*fcgi_request_acceptor_service]]]
    [The unique service identifier. ]
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.listen [*listen]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.native [*native]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.open [*open]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.protocol_service [*protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi_request_acceptor_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi_request_acceptor_service.id [*id]]]
    []
  ]

  [
    [[link cgi.reference.fcgi_request_acceptor_service.service_impl_ [*service_impl_]]]
    []
  ]

]

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 


[section:accept fcgi_request_acceptor_service::accept]

[indexterm2 accept..fcgi_request_acceptor_service] 

  template<
      typename CommonGatewayRequest >
  boost::system::error_code accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      endpoint_type * ep,
      boost::system::error_code & ec);



[endsect]



[section:assign fcgi_request_acceptor_service::assign]

[indexterm2 assign..fcgi_request_acceptor_service] 

  template<
      typename Protocol >
  boost::system::error_code assign(
      implementation_type & impl,
      Protocol protocol,
      const native_type & native_acceptor,
      boost::system::error_code & ec);



[endsect]



[section:async_accept fcgi_request_acceptor_service::async_accept]

[indexterm2 async_accept..fcgi_request_acceptor_service] 

  template<
      typename CommonGatewayRequest ,
      typename Handler >
  void async_accept(
      implementation_type & impl,
      CommonGatewayRequest & req,
      Handler handler);



[endsect]



[section:bind fcgi_request_acceptor_service::bind]

[indexterm2 bind..fcgi_request_acceptor_service] 

  template<
      typename Endpoint >
  boost::system::error_code bind(
      implementation_type & impl,
      const Endpoint & endpoint,
      boost::system::error_code & ec);



[endsect]


[section:close fcgi_request_acceptor_service::close]

[indexterm2 close..fcgi_request_acceptor_service] 

  boost::system::error_code ``[link cgi.reference.fcgi_request_acceptor_service.close.overload1 close]``(
      implementation_type & impl,
      boost::system::error_code & ec);

  void ``[link cgi.reference.fcgi_request_acceptor_service.close.overload2 close]``(
      implementation_type & impl);


[section:overload1 fcgi_request_acceptor_service::close (1 of 2 overloads)]



  boost::system::error_code close(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:overload2 fcgi_request_acceptor_service::close (2 of 2 overloads)]



  void close(
      implementation_type & impl);



[endsect]


[endsect]


[section:construct fcgi_request_acceptor_service::construct]

[indexterm2 construct..fcgi_request_acceptor_service] 

  void construct(
      implementation_type & impl);



[endsect]



[section:default_init fcgi_request_acceptor_service::default_init]

[indexterm2 default_init..fcgi_request_acceptor_service] 

  boost::system::error_code default_init(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:destroy fcgi_request_acceptor_service::destroy]

[indexterm2 destroy..fcgi_request_acceptor_service] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:endpoint_type fcgi_request_acceptor_service::endpoint_type]

[indexterm2 endpoint_type..fcgi_request_acceptor_service] 

  typedef implementation_type::endpoint_type endpoint_type;




[endsect]



[section:fcgi_request_acceptor_service fcgi_request_acceptor_service::fcgi_request_acceptor_service]

[indexterm2 fcgi_request_acceptor_service..fcgi_request_acceptor_service] The unique service identifier. 

  fcgi_request_acceptor_service(
      common::io_service & ios);



[endsect]



[section:id fcgi_request_acceptor_service::id]

[indexterm2 id..fcgi_request_acceptor_service] 

  static boost::asio::detail::service_id< fcgi_request_acceptor_service< Protocol_ > > id;



[endsect]



[section:implementation_type fcgi_request_acceptor_service::implementation_type]

[indexterm2 implementation_type..fcgi_request_acceptor_service] 

  typedef service_impl_type::implementation_type implementation_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.port_number_type [*port_number_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.request_type [*request_type]]]
    []
  
  ]

]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.acceptor_ [*acceptor_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.endpoint_ [*endpoint_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.mutex_ [*mutex_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.port_num_ [*port_num_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.service_ [*service_]]]
    []
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type.waiting_requests_ [*waiting_requests_]]]
    []
  ]

]



[endsect]



[section:is_cgi fcgi_request_acceptor_service::is_cgi]

[indexterm2 is_cgi..fcgi_request_acceptor_service] 

  bool is_cgi(
      implementation_type & impl);



[endsect]



[section:is_open fcgi_request_acceptor_service::is_open]

[indexterm2 is_open..fcgi_request_acceptor_service] 

  bool is_open(
      implementation_type & impl);



[endsect]



[section:listen fcgi_request_acceptor_service::listen]

[indexterm2 listen..fcgi_request_acceptor_service] 

  boost::system::error_code listen(
      implementation_type & impl,
      int backlog,
      boost::system::error_code & ec);



[endsect]



[section:local_endpoint fcgi_request_acceptor_service::local_endpoint]

[indexterm2 local_endpoint..fcgi_request_acceptor_service] 

  implementation_type::endpoint_type local_endpoint(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:native fcgi_request_acceptor_service::native]

[indexterm2 native..fcgi_request_acceptor_service] 

  service_impl_type::native_type native(
      implementation_type & impl);



[endsect]



[section:native_type fcgi_request_acceptor_service::native_type]

[indexterm2 native_type..fcgi_request_acceptor_service] 

  typedef service_impl_type::native_type native_type;




[endsect]



[section:open fcgi_request_acceptor_service::open]

[indexterm2 open..fcgi_request_acceptor_service] 

  template<
      typename Protocol >
  boost::system::error_code open(
      implementation_type & impl,
      const Protocol & protocol,
      boost::system::error_code & ec);



[endsect]



[section:protocol_service fcgi_request_acceptor_service::protocol_service]

[indexterm2 protocol_service..fcgi_request_acceptor_service] 

  service_impl_type::protocol_service_type & protocol_service(
      implementation_type const & impl) const;



[endsect]



[section:protocol_type fcgi_request_acceptor_service::protocol_type]

[indexterm2 protocol_type..fcgi_request_acceptor_service] 

  typedef implementation_type::protocol_type protocol_type;




[endsect]



[section:service_impl_ fcgi_request_acceptor_service::service_impl_]

[indexterm2 service_impl_..fcgi_request_acceptor_service] 

  service_impl_type service_impl_;



[endsect]



[section:service_impl_type fcgi_request_acceptor_service::service_impl_type]

[indexterm2 service_impl_type..fcgi_request_acceptor_service] 

  typedef fcgi::acceptor_service_impl service_impl_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl__implementation_type [*implementation_type]]]
    [The unique service identifier. ]
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.fcgi__acceptor_service_impl.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl.accept [*accept]]]
    [Accepts one request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.acceptor_service_impl [*acceptor_service_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.assign [*assign]]]
    [Assign an existing native acceptor to a *socket* acceptor. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.async_accept [*async_accept]]]
    [Asynchronously accepts one request. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.check_for_waiting_request [*check_for_waiting_request]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.close [*close]]]
    [Close the acceptor (not implemented yet). ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.default_init [*default_init]]]
    [Default-initialize the acceptor. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.get_protocol_service [*get_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.is_open [*is_open]]]
    [Check if the given implementation is open. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.listen [*listen]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.native [*native]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.open [*open]]]
    [Open a new *socket* acceptor implementation. ]
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.service [*service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.fcgi__acceptor_service_impl.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl.acceptor_service_ [*acceptor_service_]]]
    [The underlying socket acceptor service. ]
  ]

  [
    [[link cgi.reference.fcgi__acceptor_service_impl.id [*id]]]
    []
  ]

]

Note: this is near enough to being generic. It will hopefully translate directly to the fcgi\_acceptor\_service\_impl. In other words you would then have one acceptor\_service\_impl<>, so you'd use acceptor\_service\_impl<scgi> acceptor\_service\_impl\_; // and acceptor\_service\_impl<fcgi> acceptor\_service\_impl\_; // etc...

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 



[endsect]



[section:set_protocol_service fcgi_request_acceptor_service::set_protocol_service]

[indexterm2 set_protocol_service..fcgi_request_acceptor_service] 

  template<
      typename T >
  void set_protocol_service(
      implementation_type & impl,
      T & ps);



[endsect]



[section:shutdown_service fcgi_request_acceptor_service::shutdown_service]

[indexterm2 shutdown_service..fcgi_request_acceptor_service] 

  void shutdown_service();



[endsect]



[endsect]

[section:request_acceptor_service request_acceptor_service]



  template<
      typename Protocol >
  class request_acceptor_service


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.request_acceptor_service.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.request_acceptor_service.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.request_acceptor_service.accept [*accept]]]
    [Accept a request. ]
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.async_accept [*async_accept]]]
    [Asynchronously accept a request. ]
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.request_acceptor_service [*request_acceptor_service]]]
    []
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.request_acceptor_service.id [*id]]]
    []
  ]

]


[section:accept request_acceptor_service::accept]

[indexterm2 accept..request_acceptor_service] Accept a request. 

  template<
      typename CommonGatewayRequest >
  boost::system::error_code & accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      boost::system::error_code & ec);


Check if there is a waiting request in the queue. If not, accept a connection, and associate it with the request. 


[endsect]



[section:async_accept request_acceptor_service::async_accept]

[indexterm2 async_accept..request_acceptor_service] Asynchronously accept a request. 

  template<
      typename CommonGatewayRequest ,
      typename Handler >
  void async_accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      Handler handler);



[endsect]



[section:construct request_acceptor_service::construct]

[indexterm2 construct..request_acceptor_service] 

  void construct(
      implementation_type & impl);



[endsect]



[section:destroy request_acceptor_service::destroy]

[indexterm2 destroy..request_acceptor_service] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:id request_acceptor_service::id]

[indexterm2 id..request_acceptor_service] 

  static boost::asio::detail::service_id< request_acceptor_service< Protocol > > id;



[endsect]



[section:implementation_type request_acceptor_service::implementation_type]

[indexterm2 implementation_type..request_acceptor_service] 

  typedef service_impl_type::impl_type implementation_type;




[endsect]



[section:protocol_type request_acceptor_service::protocol_type]

[indexterm2 protocol_type..request_acceptor_service] 

  typedef Protocol protocol_type;




[endsect]



[section:request_acceptor_service request_acceptor_service::request_acceptor_service]

[indexterm2 request_acceptor_service..request_acceptor_service] 

  request_acceptor_service(
      basic_protocol_service< protocol_type > & s);



[endsect]



[section:shutdown_service request_acceptor_service::shutdown_service]

[indexterm2 shutdown_service..request_acceptor_service] 

  void shutdown_service();



[endsect]



[endsect]

[section:role__authorizer role::authorizer]



  struct authorizer



[endsect]

[section:role__filter role::filter]



  struct filter



[endsect]

[section:role__responder role::responder]



  struct responder



[endsect]


[section:role_type role_type]

[indexterm1 role_type] 

  enum role_type

[heading Values]
[variablelist

  [
    [none]
    []
  ]

  [
    [responder]
    []
  ]

  [
    [authorizer]
    []
  ]

  [
    [filter]
    []
  ]

]



[endsect]



[section:scgi__acceptor scgi::acceptor]

[indexterm1 scgi::acceptor] Typedef for common usage (SCGI). 

  typedef basic_request_acceptor< scgi_request_acceptor_service<> > acceptor;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi_request_acceptor_service.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_acceptor_service.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_acceptor_service.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_acceptor_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_acceptor_service.service_impl_type [*service_impl_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi_request_acceptor_service.accept [*accept]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.assign [*assign]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.async_accept [*async_accept]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.listen [*listen]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.open [*open]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.scgi_request_acceptor_service [*scgi_request_acceptor_service]]]
    [The unique service identifier. ]
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi_request_acceptor_service.id [*id]]]
    []
  ]

  [
    [[link cgi.reference.scgi_request_acceptor_service.service_impl_ [*service_impl_]]]
    []
  ]

]

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 



[endsect]


[section:scgi__acceptor_service_impl scgi::acceptor_service_impl]

The service_impl class for SCGI basic_request_acceptor<>s. 

  template<
      typename Protocol_  = ::cgi::scgi_>
  class acceptor_service_impl


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type [*implementation_type]]]
    [The unique service identifier. ]
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__acceptor_service_impl.accept [*accept]]]
    [Accepts one request. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.acceptor_service_impl [*acceptor_service_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.assign [*assign]]]
    [Assign an existing native acceptor to a *socket* acceptor. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.async_accept [*async_accept]]]
    [Asynchronously accepts one request. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.close [*close]]]
    [Close the acceptor (not implemented yet). ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.get_protocol_service [*get_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.is_open [*is_open]]]
    [Check if the given implementation is open. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.listen [*listen]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.open [*open]]]
    [Open a new *socket* acceptor implementation. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__acceptor_service_impl.acceptor_service_ [*acceptor_service_]]]
    [The underlying socket acceptor service. ]
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl.id [*id]]]
    []
  ]

]

Note: this is near enough to being generic. It will hopefully translate directly to the fcgi\_acceptor\_service\_impl. In other words you would then have one acceptor\_service\_impl<>, so you'd use acceptor\_service\_impl<scgi> acceptor\_service\_impl\_; // and acceptor\_service\_impl<fcgi> acceptor\_service\_impl\_; // etc...

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 

[section:accept scgi::acceptor_service_impl::accept]

[indexterm2 accept..scgi::acceptor_service_impl] Accepts one request. 

  template<
      typename CommonGatewayRequest ,
      typename Endpoint >
  boost::system::error_code ``[link cgi.reference.scgi__acceptor_service_impl.accept.overload1 accept]``(
      implementation_type & impl,
      CommonGatewayRequest & request,
      Endpoint * endpoint,
      boost::system::error_code & ec);

  template<
      typename CommonGatewayRequest >
  boost::system::error_code ``[link cgi.reference.scgi__acceptor_service_impl.accept.overload2 accept]``(
      implementation_type & impl,
      CommonGatewayRequest & request,
      boost::system::error_code & ec);


[section:overload1 scgi::acceptor_service_impl::accept (1 of 2 overloads)]

Accepts one request. 

  template<
      typename CommonGatewayRequest ,
      typename Endpoint >
  boost::system::error_code accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      Endpoint * endpoint,
      boost::system::error_code & ec);



[endsect]



[section:overload2 scgi::acceptor_service_impl::accept (2 of 2 overloads)]

Accepts one request. 

  template<
      typename CommonGatewayRequest >
  boost::system::error_code accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:acceptor_service_ scgi::acceptor_service_impl::acceptor_service_]

[indexterm2 acceptor_service_..scgi::acceptor_service_impl] The underlying socket acceptor service. 

  acceptor_service_type & acceptor_service_;



[endsect]



[section:acceptor_service_impl scgi::acceptor_service_impl::acceptor_service_impl]

[indexterm2 acceptor_service_impl..scgi::acceptor_service_impl] 

  acceptor_service_impl(
      ::cgi::io_service & ios);



[endsect]



[section:acceptor_service_type scgi::acceptor_service_impl::acceptor_service_type]

[indexterm2 acceptor_service_type..scgi::acceptor_service_impl] 

  typedef type::implementation_type::acceptor_service_type acceptor_service_type;




[endsect]



[section:assign scgi::acceptor_service_impl::assign]

[indexterm2 assign..scgi::acceptor_service_impl] Assign an existing native acceptor to a *socket* acceptor. 

  boost::system::error_code assign(
      implementation_type & impl,
      const native_protocol_type & protocol,
      const native_type & native_acceptor,
      boost::system::error_code & ec);



[endsect]



[section:async_accept scgi::acceptor_service_impl::async_accept]

[indexterm2 async_accept..scgi::acceptor_service_impl] Asynchronously accepts one request. 

  template<
      typename CommonGatewayRequest ,
      typename Handler >
  void async_accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      Handler handler,
      boost::system::error_code & ec);



[endsect]



[section:bind scgi::acceptor_service_impl::bind]

[indexterm2 bind..scgi::acceptor_service_impl] 

  template<
      typename Endpoint >
  boost::system::error_code bind(
      implementation_type & impl,
      const Endpoint & endpoint,
      boost::system::error_code & ec);



[endsect]



[section:close scgi::acceptor_service_impl::close]

[indexterm2 close..scgi::acceptor_service_impl] Close the acceptor (not implemented yet). 

  boost::system::error_code close(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:construct scgi::acceptor_service_impl::construct]

[indexterm2 construct..scgi::acceptor_service_impl] 

  void construct(
      implementation_type & impl);



[endsect]



[section:destroy scgi::acceptor_service_impl::destroy]

[indexterm2 destroy..scgi::acceptor_service_impl] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:get_protocol_service scgi::acceptor_service_impl::get_protocol_service]

[indexterm2 get_protocol_service..scgi::acceptor_service_impl] 

  protocol_service_type & get_protocol_service(
      implementation_type & impl);



[endsect]



[section:id scgi::acceptor_service_impl::id]

[indexterm2 id..scgi::acceptor_service_impl] 

  static boost::asio::detail::service_id< acceptor_service_impl< Protocol_ > > id;



[endsect]



[section:is_open scgi::acceptor_service_impl::is_open]

[indexterm2 is_open..scgi::acceptor_service_impl] Check if the given implementation is open. 

  bool is_open(
      implementation_type & impl);



[endsect]



[section:listen scgi::acceptor_service_impl::listen]

[indexterm2 listen..scgi::acceptor_service_impl] 

  boost::system::error_code listen(
      implementation_type & impl,
      int backlog,
      boost::system::error_code & ec);



[endsect]



[section:local_endpoint scgi::acceptor_service_impl::local_endpoint]

[indexterm2 local_endpoint..scgi::acceptor_service_impl] 

  implementation_type::endpoint_type local_endpoint(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:native_protocol_type scgi::acceptor_service_impl::native_protocol_type]

[indexterm2 native_protocol_type..scgi::acceptor_service_impl] 

  typedef type::implementation_type::native_protocol_type native_protocol_type;




[endsect]



[section:native_type scgi::acceptor_service_impl::native_type]

[indexterm2 native_type..scgi::acceptor_service_impl] 

  typedef acceptor_service_type::native_type native_type;




[endsect]



[section:open scgi::acceptor_service_impl::open]

[indexterm2 open..scgi::acceptor_service_impl] Open a new *socket* acceptor implementation. 

  boost::system::error_code open(
      implementation_type & impl,
      const native_protocol_type & protocol,
      boost::system::error_code & ec);



[endsect]



[section:protocol_service_type scgi::acceptor_service_impl::protocol_service_type]

[indexterm2 protocol_service_type..scgi::acceptor_service_impl] 

  typedef type::implementation_type::protocol_service_type protocol_service_type;




[endsect]



[section:protocol_type scgi::acceptor_service_impl::protocol_type]

[indexterm2 protocol_type..scgi::acceptor_service_impl] 

  typedef type::implementation_type::protocol_type protocol_type;




[endsect]



[section:set_protocol_service scgi::acceptor_service_impl::set_protocol_service]

[indexterm2 set_protocol_service..scgi::acceptor_service_impl] 

  void set_protocol_service(
      implementation_type & impl,
      protocol_service_type & ps);



[endsect]



[section:shutdown_service scgi::acceptor_service_impl::shutdown_service]

[indexterm2 shutdown_service..scgi::acceptor_service_impl] 

  void shutdown_service();



[endsect]



[section:type scgi::acceptor_service_impl::type]

[indexterm2 type..scgi::acceptor_service_impl] 

  typedef acceptor_service_impl< Protocol_ > type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type [*implementation_type]]]
    [The unique service identifier. ]
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__acceptor_service_impl.accept [*accept]]]
    [Accepts one request. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.acceptor_service_impl [*acceptor_service_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.assign [*assign]]]
    [Assign an existing native acceptor to a *socket* acceptor. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.async_accept [*async_accept]]]
    [Asynchronously accepts one request. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.close [*close]]]
    [Close the acceptor (not implemented yet). ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.get_protocol_service [*get_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.is_open [*is_open]]]
    [Check if the given implementation is open. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.listen [*listen]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.open [*open]]]
    [Open a new *socket* acceptor implementation. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__acceptor_service_impl.acceptor_service_ [*acceptor_service_]]]
    [The underlying socket acceptor service. ]
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl.id [*id]]]
    []
  ]

]

Note: this is near enough to being generic. It will hopefully translate directly to the fcgi\_acceptor\_service\_impl. In other words you would then have one acceptor\_service\_impl<>, so you'd use acceptor\_service\_impl<scgi> acceptor\_service\_impl\_; // and acceptor\_service\_impl<fcgi> acceptor\_service\_impl\_; // etc...

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 



[endsect]



[endsect]

[section:scgi__acceptor_service_impl__implementation_type scgi::acceptor_service_impl::implementation_type]

The unique service identifier. 

  struct implementation_type


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.port_number_type [*port_number_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.request_type [*request_type]]]
    []
  
  ]

]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.acceptor_ [*acceptor_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.endpoint_ [*endpoint_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.mutex_ [*mutex_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.port_num_ [*port_num_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.service_ [*service_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.waiting_requests_ [*waiting_requests_]]]
    []
  ]

]


[section:acceptor_ scgi::acceptor_service_impl::implementation_type::acceptor_]

[indexterm2 acceptor_..scgi::acceptor_service_impl::implementation_type] 

  acceptor_service_type::implementation_type acceptor_;



[endsect]



[section:acceptor_service_type scgi::acceptor_service_impl::implementation_type::acceptor_service_type]

[indexterm2 acceptor_service_type..scgi::acceptor_service_impl::implementation_type] 

  typedef boost::asio::socket_acceptor_service< native_protocol_type > acceptor_service_type;




[endsect]



[section:endpoint_ scgi::acceptor_service_impl::implementation_type::endpoint_]

[indexterm2 endpoint_..scgi::acceptor_service_impl::implementation_type] 

  endpoint_type endpoint_;



[endsect]



[section:endpoint_type scgi::acceptor_service_impl::implementation_type::endpoint_type]

[indexterm2 endpoint_type..scgi::acceptor_service_impl::implementation_type] 

  typedef boost::asio::ip::tcp::endpoint endpoint_type;




[endsect]



[section:mutex_ scgi::acceptor_service_impl::implementation_type::mutex_]

[indexterm2 mutex_..scgi::acceptor_service_impl::implementation_type] 

  boost::mutex mutex_;



[endsect]



[section:native_protocol_type scgi::acceptor_service_impl::implementation_type::native_protocol_type]

[indexterm2 native_protocol_type..scgi::acceptor_service_impl::implementation_type] 

  typedef boost::asio::ip::tcp native_protocol_type;




[endsect]



[section:port_num_ scgi::acceptor_service_impl::implementation_type::port_num_]

[indexterm2 port_num_..scgi::acceptor_service_impl::implementation_type] 

  port_number_type port_num_;



[endsect]



[section:port_number_type scgi::acceptor_service_impl::implementation_type::port_number_type]

[indexterm2 port_number_type..scgi::acceptor_service_impl::implementation_type] 

  typedef unsigned short port_number_type;




[endsect]



[section:protocol_service_type scgi::acceptor_service_impl::implementation_type::protocol_service_type]

[indexterm2 protocol_service_type..scgi::acceptor_service_impl::implementation_type] 

  typedef basic_protocol_service< protocol_type > protocol_service_type;




[endsect]



[section:protocol_type scgi::acceptor_service_impl::implementation_type::protocol_type]

[indexterm2 protocol_type..scgi::acceptor_service_impl::implementation_type] 

  typedef Protocol_ protocol_type;




[endsect]



[section:request_type scgi::acceptor_service_impl::implementation_type::request_type]

[indexterm2 request_type..scgi::acceptor_service_impl::implementation_type] 

  typedef scgi::request request_type;




[endsect]



[section:service_ scgi::acceptor_service_impl::implementation_type::service_]

[indexterm2 service_..scgi::acceptor_service_impl::implementation_type] 

  protocol_service_type * service_;



[endsect]



[section:waiting_requests_ scgi::acceptor_service_impl::implementation_type::waiting_requests_]

[indexterm2 waiting_requests_..scgi::acceptor_service_impl::implementation_type] 

  std::queue< boost::shared_ptr< request_type > > waiting_requests_;



[endsect]



[endsect]


[section:scgi__request scgi::request]

[indexterm1 scgi::request] 

  typedef basic_request< scgi_request_service, service > request;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__scgi_request_service__implementation_type [*implementation_type]]]
    [The actual implementation date for an SCGI request. ]
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service.GET [*GET]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.POST [*POST]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.client [*client]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.close [*close]]]
    [Close the request. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.cookie [*cookie]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.env [*env]]]
    [Find the environment meta-variable matching name. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.load [*load]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.scgi_request_service [*scgi_request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service._scgi_request_service [*~scgi_request_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.parse_one_post_var [*parse_one_post_var]]]
    [Read and parse a single cgi POST meta variable (greedily). ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.var [*var]]]
    [Extract the var value from. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service.id [*id]]]
    []
  ]

]



[endsect]


[section:scgi__scgi_request_impl scgi::scgi_request_impl]

The implementation_type for scgi_request_service. 

  class scgi_request_impl


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__scgi_request_impl.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_impl.connection_ptr [*connection_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_impl.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_impl.map_type [*map_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_impl.connection [*connection]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_impl.scgi_request_impl [*scgi_request_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_impl._scgi_request_impl [*~scgi_request_impl]]]
    []
  ]
  
]


[section:client_type scgi::scgi_request_impl::client_type]

[indexterm2 client_type..scgi::scgi_request_impl] 

  typedef ::cgi::basic_client< connection_type > client_type;




[endsect]



[section:connection scgi::scgi_request_impl::connection]

[indexterm2 connection..scgi::scgi_request_impl] 

  connection_ptr connection();



[endsect]



[section:connection_ptr scgi::scgi_request_impl::connection_ptr]

[indexterm2 connection_ptr..scgi::scgi_request_impl] 

  typedef connection_type::pointer connection_ptr;




[endsect]



[section:connection_type scgi::scgi_request_impl::connection_type]

[indexterm2 connection_type..scgi::scgi_request_impl] 

  typedef tcp_connection connection_type;




[endsect]



[section:map_type scgi::scgi_request_impl::map_type]

[indexterm2 map_type..scgi::scgi_request_impl] 

  typedef cgi::map map_type;




[endsect]



[section:scgi_request_impl scgi::scgi_request_impl::scgi_request_impl]

[indexterm2 scgi_request_impl..scgi::scgi_request_impl] 

  scgi_request_impl();



[endsect]



[section:_scgi_request_impl scgi::scgi_request_impl::~scgi_request_impl]

[indexterm2 ~scgi_request_impl..scgi::scgi_request_impl] 

  ~scgi_request_impl();



[endsect]



[endsect]

[section:scgi__scgi_request_service scgi::scgi_request_service]

The IoObjectService class for a SCGI basic_request<>s. 

  class scgi_request_service


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__scgi_request_service__implementation_type [*implementation_type]]]
    [The actual implementation date for an SCGI request. ]
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service.GET [*GET]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.POST [*POST]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.client [*client]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.close [*close]]]
    [Close the request. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.cookie [*cookie]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.env [*env]]]
    [Find the environment meta-variable matching name. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.load [*load]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.scgi_request_service [*scgi_request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service._scgi_request_service [*~scgi_request_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.parse_one_post_var [*parse_one_post_var]]]
    [Read and parse a single cgi POST meta variable (greedily). ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.var [*var]]]
    [Extract the var value from. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service.id [*id]]]
    []
  ]

]

[section:GET scgi::scgi_request_service::GET]

[indexterm2 GET..scgi::scgi_request_service] 

  map_type & ``[link cgi.reference.scgi__scgi_request_service.GET.overload1 GET]``(
      implementation_type & impl);

  std::string ``[link cgi.reference.scgi__scgi_request_service.GET.overload2 GET]``(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec);


[section:overload1 scgi::scgi_request_service::GET (1 of 2 overloads)]



  map_type & GET(
      implementation_type & impl);



[endsect]



[section:overload2 scgi::scgi_request_service::GET (2 of 2 overloads)]



  std::string GET(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:POST scgi::scgi_request_service::POST]

[indexterm2 POST..scgi::scgi_request_service] 

  map_type & ``[link cgi.reference.scgi__scgi_request_service.POST.overload1 POST]``(
      implementation_type & impl);

  std::string ``[link cgi.reference.scgi__scgi_request_service.POST.overload2 POST]``(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec,
      bool greedy = true);


[section:overload1 scgi::scgi_request_service::POST (1 of 2 overloads)]



  map_type & POST(
      implementation_type & impl);



[endsect]



[section:overload2 scgi::scgi_request_service::POST (2 of 2 overloads)]

Find the post meta-variable matching name. 

  std::string POST(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec,
      bool greedy = true);



[heading Parameters]
    

[variablelist
  
[[greedy][This determines whether more data can be read to find the variable. The default is true to cause least surprise in the common case of having not parsed any of the POST data.]]

]

----------------------------------------------- Should this return a pair of iterators instead? What about url\_decoding? ----------------------------------------------- 


[endsect]


[endsect]


[section:client scgi::scgi_request_service::client]

[indexterm2 client..scgi::scgi_request_service] 

  implementation_type::client_type & client(
      implementation_type & impl);



[endsect]



[section:close scgi::scgi_request_service::close]

[indexterm2 close..scgi::scgi_request_service] Close the request. 

  int close(
      implementation_type & impl,
      http::status_code & hsc,
      int program_status);



[endsect]



[section:construct scgi::scgi_request_service::construct]

[indexterm2 construct..scgi::scgi_request_service] 

  void construct(
      implementation_type & impl);



[endsect]


[section:cookie scgi::scgi_request_service::cookie]

[indexterm2 cookie..scgi::scgi_request_service] 

  map_type & ``[link cgi.reference.scgi__scgi_request_service.cookie.overload1 cookie]``(
      implementation_type & impl);

  std::string ``[link cgi.reference.scgi__scgi_request_service.cookie.overload2 cookie]``(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec);


[section:overload1 scgi::scgi_request_service::cookie (1 of 2 overloads)]



  map_type & cookie(
      implementation_type & impl);



[endsect]



[section:overload2 scgi::scgi_request_service::cookie (2 of 2 overloads)]

Find the cookie meta-variable matching name. 

  std::string cookie(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:destroy scgi::scgi_request_service::destroy]

[indexterm2 destroy..scgi::scgi_request_service] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:env scgi::scgi_request_service::env]

[indexterm2 env..scgi::scgi_request_service] Find the environment meta-variable matching name. 

  std::string env(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec);



[endsect]



[section:get_role scgi::scgi_request_service::get_role]

[indexterm2 get_role..scgi::scgi_request_service] 

  role_type get_role(
      implementation_type & impl);



[endsect]



[section:id scgi::scgi_request_service::id]

[indexterm2 id..scgi::scgi_request_service] 

  static boost::asio::detail::service_id< scgi_request_service > id;



[endsect]



[section:is_open scgi::scgi_request_service::is_open]

[indexterm2 is_open..scgi::scgi_request_service] 

  bool is_open(
      implementation_type & impl);



[endsect]



[section:load scgi::scgi_request_service::load]

[indexterm2 load..scgi::scgi_request_service] 

  boost::system::error_code & load(
      implementation_type & impl,
      bool parse_stdin,
      boost::system::error_code & ec);



[endsect]



[section:map_type scgi::scgi_request_service::map_type]

[indexterm2 map_type..scgi::scgi_request_service] 

  typedef type::implementation_type::map_type map_type;




[endsect]



[section:parse_cookie_vars scgi::scgi_request_service::parse_cookie_vars]

[indexterm2 parse_cookie_vars..scgi::scgi_request_service] Read and parse the HTTP_COOKIE meta variable. 

  template<
      typename RequestImpl >
  boost::system::error_code & parse_cookie_vars(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_get_vars scgi::scgi_request_service::parse_get_vars]

[indexterm2 parse_get_vars..scgi::scgi_request_service] Read and parse the cgi GET meta variables. 

  boost::system::error_code & parse_get_vars(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_one_post_var scgi::scgi_request_service::parse_one_post_var]

[indexterm2 parse_one_post_var..scgi::scgi_request_service] Read and parse a single cgi POST meta variable (greedily). 

  template<
      typename RequestImpl >
  boost::system::error_code & parse_one_post_var(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_post_vars scgi::scgi_request_service::parse_post_vars]

[indexterm2 parse_post_vars..scgi::scgi_request_service] Read and parse the cgi POST meta variables (greedily). 

  template<
      typename RequestImpl >
  boost::system::error_code & parse_post_vars(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:protocol_type scgi::scgi_request_service::protocol_type]

[indexterm2 protocol_type..scgi::scgi_request_service] 

  typedef type::implementation_type::protocol_type protocol_type;




[endsect]



[section:scgi_request_service scgi::scgi_request_service::scgi_request_service]

[indexterm2 scgi_request_service..scgi::scgi_request_service] 

  scgi_request_service(
      ::cgi::io_service & ios);



[endsect]



[section:shutdown_service scgi::scgi_request_service::shutdown_service]

[indexterm2 shutdown_service..scgi::scgi_request_service] 

  void shutdown_service();



[endsect]



[section:type scgi::scgi_request_service::type]

[indexterm2 type..scgi::scgi_request_service] 

  typedef scgi_request_service type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__scgi_request_service__implementation_type [*implementation_type]]]
    [The actual implementation date for an SCGI request. ]
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service.GET [*GET]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.POST [*POST]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.client [*client]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.close [*close]]]
    [Close the request. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.cookie [*cookie]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.env [*env]]]
    [Find the environment meta-variable matching name. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.load [*load]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.scgi_request_service [*scgi_request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service._scgi_request_service [*~scgi_request_service]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.parse_one_post_var [*parse_one_post_var]]]
    [Read and parse a single cgi POST meta variable (greedily). ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.scgi__scgi_request_service.var [*var]]]
    [Extract the var value from. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service.id [*id]]]
    []
  ]

]



[endsect]



[section:var scgi::scgi_request_service::var]

[indexterm2 var..scgi::scgi_request_service] Extract the var value from. 

  std::string var(
      map_type & _data,
      const std::string & _name,
      boost::system::error_code & ec);



[endsect]



[section:_scgi_request_service scgi::scgi_request_service::~scgi_request_service]

[indexterm2 ~scgi_request_service..scgi::scgi_request_service] 

  ~scgi_request_service();



[endsect]



[endsect]

[section:scgi__scgi_request_service__implementation_type scgi::scgi_request_service::implementation_type]

The actual implementation date for an SCGI request. 

  struct implementation_type


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__scgi_request_service__implementation_type.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service__implementation_type.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service__implementation_type.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__scgi_request_service__implementation_type.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.implementation_type [*implementation_type]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.all_done_ [*all_done_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.client_ [*client_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.cookie_vars_ [*cookie_vars_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.env_vars_ [*env_vars_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.get_vars_ [*get_vars_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.null_str_ [*null_str_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.post_vars_ [*post_vars_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.request_status_ [*request_status_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__scgi_request_service__implementation_type.stdin_parsed_ [*stdin_parsed_]]]
    []
  ]

]


[section:all_done_ scgi::scgi_request_service::implementation_type::all_done_]

[indexterm2 all_done_..scgi::scgi_request_service::implementation_type] 

  bool all_done_;



[endsect]



[section:client_ scgi::scgi_request_service::implementation_type::client_]

[indexterm2 client_..scgi::scgi_request_service::implementation_type] 

  client_type client_;



[endsect]



[section:client_type scgi::scgi_request_service::implementation_type::client_type]

[indexterm2 client_type..scgi::scgi_request_service::implementation_type] 

  typedef basic_client< connection_type, protocol_type > client_type;




[endsect]



[section:connection_type scgi::scgi_request_service::implementation_type::connection_type]

[indexterm2 connection_type..scgi::scgi_request_service::implementation_type] 

  typedef tcp_connection connection_type;




[endsect]



[section:cookie_vars_ scgi::scgi_request_service::implementation_type::cookie_vars_]

[indexterm2 cookie_vars_..scgi::scgi_request_service::implementation_type] 

  map_type cookie_vars_;



[endsect]



[section:env_vars_ scgi::scgi_request_service::implementation_type::env_vars_]

[indexterm2 env_vars_..scgi::scgi_request_service::implementation_type] 

  map_type env_vars_;



[endsect]



[section:get_vars_ scgi::scgi_request_service::implementation_type::get_vars_]

[indexterm2 get_vars_..scgi::scgi_request_service::implementation_type] 

  map_type get_vars_;



[endsect]



[section:http_status_ scgi::scgi_request_service::implementation_type::http_status_]

[indexterm2 http_status_..scgi::scgi_request_service::implementation_type] 

  http::status_code http_status_;



[endsect]



[section:implementation_type scgi::scgi_request_service::implementation_type::implementation_type]

[indexterm2 implementation_type..scgi::scgi_request_service::implementation_type] 

  implementation_type();



[endsect]



[section:map_type scgi::scgi_request_service::implementation_type::map_type]

[indexterm2 map_type..scgi::scgi_request_service::implementation_type] 

  typedef ::cgi::map map_type;




[endsect]



[section:null_str_ scgi::scgi_request_service::implementation_type::null_str_]

[indexterm2 null_str_..scgi::scgi_request_service::implementation_type] 

  std::string null_str_;



[endsect]



[section:post_vars_ scgi::scgi_request_service::implementation_type::post_vars_]

[indexterm2 post_vars_..scgi::scgi_request_service::implementation_type] 

  map_type post_vars_;



[endsect]



[section:protocol_type scgi::scgi_request_service::implementation_type::protocol_type]

[indexterm2 protocol_type..scgi::scgi_request_service::implementation_type] 

  typedef ::cgi::scgi_ protocol_type;




[endsect]



[section:request_status_ scgi::scgi_request_service::implementation_type::request_status_]

[indexterm2 request_status_..scgi::scgi_request_service::implementation_type] 

  status_type request_status_;



[endsect]



[section:stdin_parsed_ scgi::scgi_request_service::implementation_type::stdin_parsed_]

[indexterm2 stdin_parsed_..scgi::scgi_request_service::implementation_type] 

  bool stdin_parsed_;



[endsect]



[endsect]


[section:scgi__service scgi::service]

[indexterm1 scgi::service] 

  typedef basic_protocol_service< ::cgi::scgi_ > service;




[endsect]


[section:scgi_request_acceptor_service scgi_request_acceptor_service]

The service class for SCGI basic_request_acceptor<>s. 

  template<
      typename Protocol_  = scgi_>
  class scgi_request_acceptor_service


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi_request_acceptor_service.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_acceptor_service.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_acceptor_service.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_acceptor_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_acceptor_service.service_impl_type [*service_impl_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi_request_acceptor_service.accept [*accept]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.assign [*assign]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.async_accept [*async_accept]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.listen [*listen]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.open [*open]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.scgi_request_acceptor_service [*scgi_request_acceptor_service]]]
    [The unique service identifier. ]
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_acceptor_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi_request_acceptor_service.id [*id]]]
    []
  ]

  [
    [[link cgi.reference.scgi_request_acceptor_service.service_impl_ [*service_impl_]]]
    []
  ]

]

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 

[section:accept scgi_request_acceptor_service::accept]

[indexterm2 accept..scgi_request_acceptor_service] 

  template<
      typename CommonGatewayRequest ,
      typename Endpoint >
  boost::system::error_code ``[link cgi.reference.scgi_request_acceptor_service.accept.overload1 accept]``(
      implementation_type & impl,
      CommonGatewayRequest & request,
      Endpoint * ep,
      boost::system::error_code & ec);

  template<
      typename CommonGatewayRequest >
  boost::system::error_code ``[link cgi.reference.scgi_request_acceptor_service.accept.overload2 accept]``(
      implementation_type & impl,
      CommonGatewayRequest & request,
      boost::system::error_code & ec);


[section:overload1 scgi_request_acceptor_service::accept (1 of 2 overloads)]



  template<
      typename CommonGatewayRequest ,
      typename Endpoint >
  boost::system::error_code accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      Endpoint * ep,
      boost::system::error_code & ec);



[endsect]



[section:overload2 scgi_request_acceptor_service::accept (2 of 2 overloads)]



  template<
      typename CommonGatewayRequest >
  boost::system::error_code accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:assign scgi_request_acceptor_service::assign]

[indexterm2 assign..scgi_request_acceptor_service] 

  template<
      typename Protocol >
  boost::system::error_code assign(
      implementation_type & impl,
      Protocol protocol,
      const native_type & native_acceptor,
      boost::system::error_code & ec);



[endsect]



[section:async_accept scgi_request_acceptor_service::async_accept]

[indexterm2 async_accept..scgi_request_acceptor_service] 

  template<
      typename Handler >
  void async_accept(
      implementation_type & impl,
      Handler handler);



[endsect]



[section:bind scgi_request_acceptor_service::bind]

[indexterm2 bind..scgi_request_acceptor_service] 

  template<
      typename Endpoint >
  boost::system::error_code bind(
      implementation_type & impl,
      const Endpoint & endpoint,
      boost::system::error_code & ec);



[endsect]


[section:close scgi_request_acceptor_service::close]

[indexterm2 close..scgi_request_acceptor_service] 

  boost::system::error_code ``[link cgi.reference.scgi_request_acceptor_service.close.overload1 close]``(
      implementation_type & impl,
      boost::system::error_code & ec);

  void ``[link cgi.reference.scgi_request_acceptor_service.close.overload2 close]``(
      implementation_type & impl);


[section:overload1 scgi_request_acceptor_service::close (1 of 2 overloads)]



  boost::system::error_code close(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:overload2 scgi_request_acceptor_service::close (2 of 2 overloads)]



  void close(
      implementation_type & impl);



[endsect]


[endsect]


[section:construct scgi_request_acceptor_service::construct]

[indexterm2 construct..scgi_request_acceptor_service] 

  void construct(
      implementation_type & impl);



[endsect]



[section:destroy scgi_request_acceptor_service::destroy]

[indexterm2 destroy..scgi_request_acceptor_service] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:endpoint_type scgi_request_acceptor_service::endpoint_type]

[indexterm2 endpoint_type..scgi_request_acceptor_service] 

  typedef implementation_type::endpoint_type endpoint_type;




[endsect]



[section:id scgi_request_acceptor_service::id]

[indexterm2 id..scgi_request_acceptor_service] 

  static boost::asio::detail::service_id< scgi_request_acceptor_service< Protocol_ > > id;



[endsect]



[section:implementation_type scgi_request_acceptor_service::implementation_type]

[indexterm2 implementation_type..scgi_request_acceptor_service] 

  typedef service_impl_type::implementation_type implementation_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.port_number_type [*port_number_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.request_type [*request_type]]]
    []
  
  ]

]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.acceptor_ [*acceptor_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.endpoint_ [*endpoint_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.mutex_ [*mutex_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.port_num_ [*port_num_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.service_ [*service_]]]
    []
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type.waiting_requests_ [*waiting_requests_]]]
    []
  ]

]



[endsect]



[section:is_open scgi_request_acceptor_service::is_open]

[indexterm2 is_open..scgi_request_acceptor_service] 

  bool is_open(
      implementation_type & impl);



[endsect]



[section:listen scgi_request_acceptor_service::listen]

[indexterm2 listen..scgi_request_acceptor_service] 

  boost::system::error_code listen(
      implementation_type & impl,
      int backlog,
      boost::system::error_code & ec);



[endsect]



[section:local_endpoint scgi_request_acceptor_service::local_endpoint]

[indexterm2 local_endpoint..scgi_request_acceptor_service] 

  implementation_type::endpoint_type local_endpoint(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:native_type scgi_request_acceptor_service::native_type]

[indexterm2 native_type..scgi_request_acceptor_service] 

  typedef service_impl_type::native_type native_type;




[endsect]



[section:open scgi_request_acceptor_service::open]

[indexterm2 open..scgi_request_acceptor_service] 

  template<
      typename Protocol >
  boost::system::error_code open(
      implementation_type & impl,
      const Protocol & protocol,
      boost::system::error_code & ec);



[endsect]



[section:protocol_type scgi_request_acceptor_service::protocol_type]

[indexterm2 protocol_type..scgi_request_acceptor_service] 

  typedef implementation_type::protocol_type protocol_type;




[endsect]



[section:scgi_request_acceptor_service scgi_request_acceptor_service::scgi_request_acceptor_service]

[indexterm2 scgi_request_acceptor_service..scgi_request_acceptor_service] The unique service identifier. 

  scgi_request_acceptor_service(
      ::cgi::io_service & ios);



[endsect]



[section:service_impl_ scgi_request_acceptor_service::service_impl_]

[indexterm2 service_impl_..scgi_request_acceptor_service] 

  service_impl_type service_impl_;



[endsect]



[section:service_impl_type scgi_request_acceptor_service::service_impl_type]

[indexterm2 service_impl_type..scgi_request_acceptor_service] 

  typedef scgi::acceptor_service_impl service_impl_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.acceptor_service_type [*acceptor_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl__implementation_type [*implementation_type]]]
    [The unique service identifier. ]
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.native_protocol_type [*native_protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi__acceptor_service_impl.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__acceptor_service_impl.accept [*accept]]]
    [Accepts one request. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.acceptor_service_impl [*acceptor_service_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.assign [*assign]]]
    [Assign an existing native acceptor to a *socket* acceptor. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.async_accept [*async_accept]]]
    [Asynchronously accepts one request. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.close [*close]]]
    [Close the acceptor (not implemented yet). ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.get_protocol_service [*get_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.is_open [*is_open]]]
    [Check if the given implementation is open. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.listen [*listen]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.open [*open]]]
    [Open a new *socket* acceptor implementation. ]
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi__acceptor_service_impl.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi__acceptor_service_impl.acceptor_service_ [*acceptor_service_]]]
    [The underlying socket acceptor service. ]
  ]

  [
    [[link cgi.reference.scgi__acceptor_service_impl.id [*id]]]
    []
  ]

]

Note: this is near enough to being generic. It will hopefully translate directly to the fcgi\_acceptor\_service\_impl. In other words you would then have one acceptor\_service\_impl<>, so you'd use acceptor\_service\_impl<scgi> acceptor\_service\_impl\_; // and acceptor\_service\_impl<fcgi> acceptor\_service\_impl\_; // etc...

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 



[endsect]



[section:set_protocol_service scgi_request_acceptor_service::set_protocol_service]

[indexterm2 set_protocol_service..scgi_request_acceptor_service] 

  template<
      typename T >
  void set_protocol_service(
      implementation_type & impl,
      T & ps);



[endsect]



[section:shutdown_service scgi_request_acceptor_service::shutdown_service]

[indexterm2 shutdown_service..scgi_request_acceptor_service] 

  void shutdown_service();



[endsect]



[endsect]

[section:scgi_request_service_impl scgi_request_service_impl]



  class scgi_request_service_impl


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.scgi_request_service_impl.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_service_impl.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.scgi_request_service_impl.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi_request_service_impl.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.cookie [*cookie]]]
    [Find the cookie meta-variable matching name. ]
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.get_role [*get_role]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.load [*load]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.meta_cookie [*meta_cookie]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.meta_env [*meta_env]]]
    [Find the environment meta-variable matching name. ]
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.meta_get [*meta_get]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.meta_post [*meta_post]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.read_some [*read_some]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.scgi_request_service_impl [*scgi_request_service_impl]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.write_some [*write_some]]]
    []
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl._scgi_request_service_impl [*~scgi_request_service_impl]]]
    []
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi_request_service_impl.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.parse_one_post_var [*parse_one_post_var]]]
    [Read and parse a single cgi POST meta variable (greedily). ]
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables (greedily). ]
  ]
  
  [
    [[link cgi.reference.scgi_request_service_impl.var [*var]]]
    [Extract the var value from. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.scgi_request_service_impl.id [*id]]]
    []
  ]

]


[section:construct scgi_request_service_impl::construct]

[indexterm2 construct..scgi_request_service_impl] 

  void construct(
      implementation_type & impl);



[endsect]



[section:cookie scgi_request_service_impl::cookie]

[indexterm2 cookie..scgi_request_service_impl] Find the cookie meta-variable matching name. 

  std::string cookie(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec);



[endsect]



[section:destroy scgi_request_service_impl::destroy]

[indexterm2 destroy..scgi_request_service_impl] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:get_role scgi_request_service_impl::get_role]

[indexterm2 get_role..scgi_request_service_impl] 

  role_type get_role(
      implementation_type & impl);



[endsect]



[section:id scgi_request_service_impl::id]

[indexterm2 id..scgi_request_service_impl] 

  static boost::asio::detail::service_id< scgi_service_impl > id;



[endsect]



[section:implementation_type scgi_request_service_impl::implementation_type]

[indexterm2 implementation_type..scgi_request_service_impl] 

  typedef scgi_request_impl implementation_type;




[endsect]



[section:load scgi_request_service_impl::load]

[indexterm2 load..scgi_request_service_impl] 

  boost::system::error_code & load(
      implementation_type & impl,
      bool parse_stdin,
      boost::system::error_code & ec);



[endsect]



[section:map_type scgi_request_service_impl::map_type]

[indexterm2 map_type..scgi_request_service_impl] 

  typedef cgi::map map_type;




[endsect]



[section:meta_cookie scgi_request_service_impl::meta_cookie]

[indexterm2 meta_cookie..scgi_request_service_impl] 

  map_type & meta_cookie(
      implementation_type & impl);



[endsect]



[section:meta_env scgi_request_service_impl::meta_env]

[indexterm2 meta_env..scgi_request_service_impl] Find the environment meta-variable matching name. 

  std::string meta_env(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec);



[endsect]


[section:meta_get scgi_request_service_impl::meta_get]

[indexterm2 meta_get..scgi_request_service_impl] 

  map_type & ``[link cgi.reference.scgi_request_service_impl.meta_get.overload1 meta_get]``(
      implementation_type & impl);

  std::string ``[link cgi.reference.scgi_request_service_impl.meta_get.overload2 meta_get]``(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec);


[section:overload1 scgi_request_service_impl::meta_get (1 of 2 overloads)]



  map_type & meta_get(
      implementation_type & impl);



[endsect]



[section:overload2 scgi_request_service_impl::meta_get (2 of 2 overloads)]



  std::string meta_get(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:meta_post scgi_request_service_impl::meta_post]

[indexterm2 meta_post..scgi_request_service_impl] 

  map_type & ``[link cgi.reference.scgi_request_service_impl.meta_post.overload1 meta_post]``(
      implementation_type & impl);

  std::string ``[link cgi.reference.scgi_request_service_impl.meta_post.overload2 meta_post]``(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec,
      bool greedy = true);


[section:overload1 scgi_request_service_impl::meta_post (1 of 2 overloads)]



  map_type & meta_post(
      implementation_type & impl);



[endsect]



[section:overload2 scgi_request_service_impl::meta_post (2 of 2 overloads)]

Find the post meta-variable matching name. 

  std::string meta_post(
      implementation_type & impl,
      const std::string & name,
      boost::system::error_code & ec,
      bool greedy = true);



[heading Parameters]
    

[variablelist
  
[[greedy][This determines whether more data can be read to find the variable. The default is true to cause least surprise in the common case of having not parsed any of the POST data.]]

]

----------------------------------------------- Should this return a pair of iterators instead? What about url\_decoding? ----------------------------------------------- 


[endsect]


[endsect]


[section:parse_cookie_vars scgi_request_service_impl::parse_cookie_vars]

[indexterm2 parse_cookie_vars..scgi_request_service_impl] Read and parse the HTTP_COOKIE meta variable. 

  template<
      typename RequestImpl >
  boost::system::error_code & parse_cookie_vars(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_get_vars scgi_request_service_impl::parse_get_vars]

[indexterm2 parse_get_vars..scgi_request_service_impl] Read and parse the cgi GET meta variables. 

  boost::system::error_code & parse_get_vars(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_one_post_var scgi_request_service_impl::parse_one_post_var]

[indexterm2 parse_one_post_var..scgi_request_service_impl] Read and parse a single cgi POST meta variable (greedily). 

  template<
      typename RequestImpl >
  boost::system::error_code & parse_one_post_var(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_post_vars scgi_request_service_impl::parse_post_vars]

[indexterm2 parse_post_vars..scgi_request_service_impl] Read and parse the cgi POST meta variables (greedily). 

  template<
      typename RequestImpl >
  boost::system::error_code & parse_post_vars(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]



[section:protocol_type scgi_request_service_impl::protocol_type]

[indexterm2 protocol_type..scgi_request_service_impl] 

  typedef tags::scgi protocol_type;




[endsect]



[section:read_some scgi_request_service_impl::read_some]

[indexterm2 read_some..scgi_request_service_impl] 

  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      implementation_type & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:scgi_request_service_impl scgi_request_service_impl::scgi_request_service_impl]

[indexterm2 scgi_request_service_impl..scgi_request_service_impl] 

  scgi_request_service_impl(
      cgi::io_service & ios);



[endsect]



[section:var scgi_request_service_impl::var]

[indexterm2 var..scgi_request_service_impl] Extract the var value from. 

  std::string var(
      map_type & meta_data,
      const std::string & name,
      boost::system::error_code & ec);



[endsect]



[section:write_some scgi_request_service_impl::write_some]

[indexterm2 write_some..scgi_request_service_impl] 

  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      implementation_type & impl,
      const ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:_scgi_request_service_impl scgi_request_service_impl::~scgi_request_service_impl]

[indexterm2 ~scgi_request_service_impl..scgi_request_service_impl] 

  ~scgi_request_service_impl();



[endsect]



[endsect]

[endsect]